{"chunk_id": "data\\raw\\notes\\notes-1335.txt::chunk0000", "source": "data\\raw\\notes\\notes-1335.txt", "text": "Announcements\n\n1. HW6 out\n    - You have multiple view and observer examples on Canvas\n      modules, lab, and on course website.\n\nTopics\n- Strategies\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStrategies are function objects that at runtime decide how to\nimplement a feature (e.g. how to DO something)?\n\ninterface Strategy {\n    ... // the one function you want to implement\n}\n\n\n\n\n\n\n\n\n\n\nDecorators are classes that\n    - have the same type as what they decorate\n    - have as a field the object they decorate\n    - apply some change in behavior to some existing object\n\ne.g.\n\nclass Decorator implements IBase {\n    IBase base;\n\n    public Decorator(IBase base) {\n        ....\n    }\n} // preferred because not dependent on implementation\n\nOR\n\nclass Decorator extends Base {\n    Base base; //or a more general type if applicable", "topics": ["mvc", "strategy", "observer", "decorator"]}
{"chunk_id": "data\\raw\\notes\\notes-1335.txt::chunk0001", "source": "data\\raw\\notes\\notes-1335.txt", "text": "\n\n    public Decorator(Base base) {\n        ...\n    }\n} // might be necessary, but dependent on the implementation\n\n\n\n\n\n\n\n\n\n\n\n\ninterface Beverage {\n    Size size();\n    double price();\n}\n\nenum Size { SMALL, MED, LARGE };\n\nclass Coffee implements Beverage { ... }\nclass Tea implements Beverage { ... }\n\nAdd-ons:\n- Milk\n- Cream\n- Sugar\n- Fruit\n- Syrups\n- Whipped Cream\n- Charcoal\n\nclass MilkAdded implements Beverage {\n\n    private Beverage base;\n\n    public MilkAdded(Beverage base) {\n        this.base = base;\n    }\n\n    public Size size() {\n        return this.base.size():\n    }\n\n    public double price() {\n        return 1.00 + this.base.price();\n    }\n}\n\nclass CharcoalAdded implements Beverage {\n\n    private Beverage base;\n\n    public CharcoalAdded(Beverage base) {\n        this.base = base;\n ", "topics": ["decorator"]}
{"chunk_id": "data\\raw\\notes\\notes-1335.txt::chunk0002", "source": "data\\raw\\notes\\notes-1335.txt", "text": "   }\n\n    public Size size() {\n        return this.base.size():\n    }\n\n    public double price() {\n        switch(this.base.size()) {\n            case SMALL : return this.base.price() + 15;\n            case MED: return this.base.price() + 20;\n            case LARGE: return this.base.price() + 3500;\n        }\n    }\n}\n\n\n// a tea with milk, sugar, honey\nnew HoneyAdded(new SugarAdded(new MilkAdded(new Tea())));\nnew SugarAdded(new MilkAdded(new HoneyAdded(new Tea())));\n\n// a coffee with milk\nnew MilkAdded(new Coffee());\n\nMilkAdded, HoneyAdded, SugarAdded etc. are DECORATORS\n\nDecorators are classes that are and contain what they decorate to add or change existing behavior of\nthat object.\n\n(Aside: It is common to have a builder to build a decorated object\n    because decorating an object implies ", "topics": ["decorator"]}
{"chunk_id": "data\\raw\\notes\\notes.txt::chunk0000", "source": "data\\raw\\notes\\notes.txt", "text": "Announcements\n\n1. HW6 out\n    - You have multiple view and observer examples on Canvas\n      modules, lab, and on course website.\n\nTopics\n- Strategies\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStrategies are function objects that state how a feature\nis preformed at runtime.\n\ne.g\n\ninterface Strategy {\n    //your singular function you want to decide how to do at runtime\n}\n\n\n\n\n\n\n\n\n\n\n\n\nDecorators are classes that\n    - have the same type as what they decorate\n    - have as a field the object they decorate\n    - apply some change in behavior to some existing object\n\ne.g.\n\nclass Decorator implements IBase {\n    IBase base;\n\n    public Decorator(IBase base) {\n        ....\n    }\n} // preferred because not dependent on implementation\n\nOR\n\nclass Decorator extends Base {\n    Base base; //or a more general type if applicable\n\n  ", "topics": ["mvc", "strategy", "observer", "decorator"]}
{"chunk_id": "data\\raw\\notes\\notes.txt::chunk0001", "source": "data\\raw\\notes\\notes.txt", "text": "  public Decorator(Base base) {\n        ...\n    }\n} // might be necessary, but dependent on the implementation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ninterface Beverage {\n    Size size();\n    double price();\n}\n\nenum Size { SMALL, MED, LARGE };\n\nclass Coffee implements Beverage {\n\n    private Size size;\n    private String type;\n\n    public Coffee(Size size, String type) {\n        this.size = size;\n        this.type = type;\n    }\n\n    public Size size() {\n        return size;\n    }\n\n    public double price() {\n        switch(size) {\n            case SMALL: return 5.00;\n            case MED: return 5.75;\n            case LARGE: return 6.25;\n        }\n    }\n}\n\nPossible add-ons for your drink:\n    - Milk (Whole, Almond, Oat, 2%, etc)\n    - Honey\n    - Simple Syrup (and relevant flavors like Hazelnut, Moch", "topics": ["decorator"]}
{"chunk_id": "data\\raw\\notes\\notes.txt::chunk0002", "source": "data\\raw\\notes\\notes.txt", "text": "a, Vanilla, etc.)\n    - Sweetener (but could just be different types of sweetnes levels)\n    - Iced (Less, Extra, etc) or Hot\n    - Coal Foam\n\nclass BevWithMilk implements Beverage {\n    private Beverage beverage;\n    privagte MilkType type;\n\n    public BevWithMilk(Beverage base, MilkType type) {\n        this.beverage = base;\n        this.type = type;\n    }\n\n    public Size size() {\n        return this.beverage.size();\n    }\n\n    public double price() {\n        switch(type) {\n            case WHOLE: return this.beverage.price() + 0.50;\n            case OAT: return this.beverage.price() + 1.00;\n            ...\n        }\n    }\n}\n\ninterface Sweet {\n    SweetLevel howSweet();\n}\n\nclass BevWithSweet implements Beverage, Sweet {\n    private Beverage base;\n    private SweetType type;\n\n    //ignore", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 1 Why object-oriented desig.txt::chunk0000", "source": "data\\raw\\notes\\Lecture 1 Why object-oriented desig.txt", "text": "Lecture 1: Why object-oriented design?\nSlides\nLecture Objectives\nDescribe some reasons why writing and maintaining software programs is complicated\nDescribe of some basic high-level concepts in object-oriented design, and their role in software development\nDefine and describe the SOLID principles\nDifferentiate between correct programs and ‚Äúgood‚Äù programs\n1 Software isn‚Äôt easy\nWriting software is hard. Writing good software is really hard. This might surprise us, because how computers compute is, fundamentally, very simple. As programmers, we have a solid understanding of the rules that a machine follows to execute our programs, and yet, experience shows that all significant programs have bugs‚Äîthat is, they behave in ways that are unexpected and undesirable. How can that be?\n\nWe compose com", "topics": ["command"]}
{"chunk_id": "data\\raw\\notes\\Lecture 1 Why object-oriented desig.txt::chunk0001", "source": "data\\raw\\notes\\Lecture 1 Why object-oriented desig.txt", "text": "plex systems from simple parts.\n\nThe physical world limits the size of artifacts that we can construct, but computer programs know no such limits.1 Programs are mathematical creatures, their scale and scope limited only by our imaginations. While the individual rules of computation are simple and easy to grasp, as programs get larger, simple steps interact in increasingly unpredictable ways. Human beings are capable of producing much larger programs than they are capable of understanding, and large and changing teams of human beings moreso. Thus, much of the task of engineering good software comes down to reducing and managing complexity.\n\nOf course, complexity is not the only challenge in writing software; another is that requirements evolve throughout the software development lifecycle. ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 1 Why object-oriented desig.txt::chunk0002", "source": "data\\raw\\notes\\Lecture 1 Why object-oriented desig.txt", "text": "It‚Äôs rare that a customer can, at the outset of a project, describe accurately what is wanted, and even then, releasing version one doesn‚Äôt mean that we‚Äôre finished. Requirements often change because the world our programs must interact with changes. We invent new hardware, change our laws, specify new protocols, and dream up novel features, and we need software to keep up. We want designs to be flexible, so that we can adapt them to changing requirements without making major alterations to our code.\n\n2 Object-oriented design: Basic concepts\nIn this course, we focus on a suite of techniques and technologies for dealing with complexity and increasing flexibility that are commonly known as object oriented. We will discuss concepts such as\n\ninformation hiding, the idea that components should ", "topics": ["decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 1 Why object-oriented desig.txt::chunk0003", "source": "data\\raw\\notes\\Lecture 1 Why object-oriented desig.txt", "text": "not know about other components‚Äô data representations;\ninterfaces, which mediate between client and provider, and allows each to be replaced or changed independently; and\npolymorphism, by which the same code works on different classes of objects.\nEach of these concepts promotes loose coupling, in which different parts of a program depend as little as possible on the details of other parts. This makes components easier to replace or reuse, and by limiting the ways in which components can interact, loose coupling may help reduce the complexity of the system as a whole. (Similarly, functional programming limits interactions by making all communication between components explicit and local.)\n\n3 SOLID principles\nA lot of wisdom learned through years of software development is succinctly represe", "topics": ["decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 1 Why object-oriented desig.txt::chunk0004", "source": "data\\raw\\notes\\Lecture 1 Why object-oriented desig.txt", "text": "nted by the SOLID principles. These principles give a high-level guidance of some desirable characteristics of well-designed software.\n\nSingle responsibility, meaning that each class should have a single purpose or job to do. If a single class is doing multiple tasks, perhaps it‚Äôs best to split that class into several smaller ones. (For example, separating the logic of a GUI from the presentation makes it easier to test and easier to change each separately.)\nOpen/closed, meaning that interfaces should be open to reimplementation, and that clients should not require (and possibly not even permit!) modification. (For example, code written to use the Map interface does not have to change when we decide we‚Äôd rather use a TreeMap instead of a HashMap.)\nLiskov substitution2, meaning that objects", "topics": ["gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 1 Why object-oriented desig.txt::chunk0005", "source": "data\\raw\\notes\\Lecture 1 Why object-oriented desig.txt", "text": " of subtypes may be used anywhere that the supertype can be used. (For example, if a Square is a Rectangle then a Square can be used wherever a Rectangle can be used.)\nInterface segregation, meaning that classes should offer small, specialized interfaces for different kinds of clients. (For example, a class representing the state of a document might implement different interfaces for spell-checking and printing that provide only the necessary operations for each task; this makes the relationships clearer and dependencies narrower.)\nDependency inversion, meaning that details should depend on abstractions rather than abstractions depending on details. This reduces coupling between two entities, which makes maintaining and replacing them easier. (For example, the GUI of an application should ", "topics": ["gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 1 Why object-oriented desig.txt::chunk0006", "source": "data\\raw\\notes\\Lecture 1 Why object-oriented desig.txt", "text": "only know about the interface of the business logic, rather than requiring an instance of a concrete implementation of the business logic interface.)\n4 Good software\nNow, if we want to write good software, it is important to say what makes software ‚Äúgood.‚Äù Paramount is correctness, which means that a program does what we intend it to do. We also care about efficiency, because a program that takes longer to run than we have time to wait, or needs more memory than we can afford, isn‚Äôt very useful. Often the goals of correctness and efficiency are said to be at odds: While abstraction might help us write programs that are (more) correct, it can also impede efficiency. We will see that this is sometimes the case, but we will also explore how carefully designed abstractions can facilitate effic", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 1 Why object-oriented desig.txt::chunk0007", "source": "data\\raw\\notes\\Lecture 1 Why object-oriented desig.txt", "text": "iency.\n\nBecause we have to balance these competing concerns, making software requires making choices. The most interesting problems in software development have no clear answers. This is what we mean when we talk about design. Our sense of what makes code good is as much aesthetic as it is formal or mathematical. Despite the absence of clear metrics, with experience we develop intuition that distinguishes better designs from worse. One goal of this course is for you to gain a little more experience and grow a little more intuition.\n\nThe great computer architect Fred Brooks wrote that there is ‚Äúno silver bullet‚Äù: \"There is no single development, in either technology or management technique, which by itself promises even one order-of-magnitude improvement within a decade in productivity, in ", "topics": ["gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 1 Why object-oriented desig.txt::chunk0008", "source": "data\\raw\\notes\\Lecture 1 Why object-oriented desig.txt", "text": "reliability, in simplicity.\"\n\nCertainly this is true, but object-oriented design makes a decent wooden stake.3 It offers a viable and popular methodology for mitigating complexity and change, if we do it well. If we do it poorly, we can make a terrible, incomprehensible mess. We will do our best to help you do it well, but we hope in this semester you will have the opportunity to experience both.\n\nIt is important to note that lessons in design, similar to lessons in programming, are learned often through making mistakes. You should be ready for this: often you will discover design limitations only by trying them out. While you should always strive to come up with the best design before you implement it, be aware that it in the nature of design to evolve. No design is perfect for all situat", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 1 Why object-oriented desig.txt::chunk0009", "source": "data\\raw\\notes\\Lecture 1 Why object-oriented desig.txt", "text": "ions, which means one can always pinpoint limitations in any design. The design process is about recognizing what you want, and then coming up with a design that satisfies your current and estimated future requirements, not every eventuality.\n\n5 Topics\nSome topics we will cover in this course:\n\nWhat are objects all about?\nInterface polymorphism\nData abstraction and encapsulation\nClient perspective versus implementor perspective\nObject-oriented terminology\nGeneric polymorphism\nTesting and specification\nAlgorithmic efficiency\nSoftware archaeology\nClass diagrams\nDesign patterns\n1This is not strictly true, as storage is finite, but in practice memory on general-purpose computers is not a constraint on program size.\n\n2Named after Barbara Liskov, a Turing award recipient, MIT professor, and reno", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0000", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "Lecture 2: The essence of objects\nSlidesJava and ISL source (.zip)\nObjectives of this lecture\nIn this lecture we will discuss a small, simple problem and design a solution using both functional and object-oriented design. This will allow us to compare and contrast them, and provide an insight about when to choose which design. We will also begin to see how programming languages used to implement these designs help in enforcing some of its constraints.\n\n1 Example: Formatting citations\nSuppose we want to represent two kinds of publications, in order to generate citations for them. There are two kinds of publications we want to work with:\n\nBooks, which have a title, an author, a publisher, the publisher‚Äôs location, and the year of publication.\nJournal articles, which have a title, an author, ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0001", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "and the journal‚Äôs name, volume number, issue number, and year.\nUsing Intermediate Student Language with Lambda in the style of HTDP, we can create a data definition to represent publications:\n\n;; A Publication is one of:\n;; -- (make-book String String String String Number)\n;; -- (make-article String String String Number Number Number)\n(define-struct book [title author publisher location year])\n(define-struct article [title author journal volume issue year])\n\n;; Examples:\n(define rushdie.v1\n        (make-book \"Midnight's Children\" \"Salman Rushdie\"\n                   \"Jonathan Cape\" \"London\" 1980))\n(define turing.v1\n        (make-article \"Computing machinery and intelligence\"\n                      \"A. M. Turing\" \"Mind\" 59 236 1950))\nWe would like to format citations in two styles, APA and ML", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0002", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "A. For each of these, we can design a function that takes a publication and formats it as a string. Following the design recipe, we use the template for structural decomposition of Publications:\n\n;; process-publication: Publication -> ...\n;; Template for processing Publications\n(define (process-publication: pub)\n  (cond\n    [(book? pub)\n     (... (book-title pub) ... (book-author pub) ... (book-publisher pub) ...\n          (book-location pub) ... (book-year pub) ...)]\n    [(article? pub)\n     (... (article-title pub) ... (article-author pub) ...\n          (article-journal pub) ... (article-volume pub) ...\n          (article-issue pub) ... (article-year pub) ...)]))\nThen we instantiate the template for each of the two functions that we need:\n\n;; cite-apa: Publication -> String\n;; To format ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0003", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "a publication for citation in APA style.\n(define (cite-apa pub)\n  (cond\n    [(book? pub)\n     (format \"~a (~a). ~a. ~a: ~a.\"\n             (book-author pub) (book-year pub) (book-title pub)\n             (book-location pub) (book-publisher pub))]\n    [(article? pub)\n     (format \"~a (~a). ~a. ~a, ~a(~a).\"\n             (article-author pub) (article-year pub) (article-title pub)\n             (article-journal pub) (article-volume pub) (article-issue pub))]))\n\n;; cite-mla: Publication -> String\n;; To format a publication for citation in MLA style.\n(define (cite-mla pub)\n  (cond\n    [(book? pub)\n     (format \"~a. ~a. ~a: ~a, ~a.\"\n             (book-author pub) (book-title pub) (book-location pub)\n             (book-publisher pub) (book-year pub))]\n    [(article? pub)\n     (format \"~a. \\\"~a.\\\" ~a ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0004", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "~a.~a (~a).\"\n             (article-author pub) (article-title pub) (article-journal pub)\n             (article-volume pub) (article-issue pub) (article-year pub))]))\n(The format function interpolates values into a format string, where each formatting escape ~a indicates where the next argument should be placed. ISL+ùúÜ\n‚Äôs format is documented here; the syntax of format strings is documented with Racket‚Äôs fprintf function.)\n\nNow let‚Äôs try it:\n\n> (cite-apa rushdie.v1)\n\"Salman Rushdie (1980). Midnight's Children. London: Jonathan Cape.\"\n> (cite-mla rushdie.v1)\n\"Salman Rushdie. Midnight's Children. London: Jonathan Cape, 1980.\"\n> (cite-apa turing.v1)\n\"A. M. Turing (1950). Computing machinery and intelligence. Mind, 59(236).\"\n> (cite-mla turing.v1)\n\"A. M. Turing. \\\"Computing machinery and intelli", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0005", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "gence.\\\" Mind 59.236 (1950).\"\nGreat! The code above works. But now we have a problem. Software evolves, and a first specification rarely remains unchanged through the development process. It turns out that we need to handle a third kind of publication:\n\nWeb pages, which have a title, a URL, and the date of download.\nOf course, updating our data definition to represent the new class of information is easy enough:1\n\n;; A Publication is one of:\n;; -- (make-book String String String String Number)\n;; -- (make-article String String String Number Number Number)\n;; -- (make-webpage String String String)\n(define-struct book [title author publisher location year])\n(define-struct article [title author journal volume issue year])\n(define-struct webpage [title url retrieved])\n\n;; Example:\n(define cs35", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0006", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "00.v1\n  (make-webpage \"CS3500: Object-Oriented Design\"\n                \"https://www.ccs.neu.edu/course/cs3500/\"\n                \"August 11, 2014\"))\nThat isn‚Äôt sufficient, though‚Äîwe also need to update our code. In particular, we need to find each function that decomposes a Publication and modify it to handle the new case. That is, we must add a case to cite-apa for formatting web page citations in APA style:\n\n[(webpage? pub)\n (format \"~a. Retrieved ~a, from ~a.\"\n         (webpage-title pub) (webpage-retrieved pub) (webpage-url pub))]\nWe also need to add a case to cite-mla for formatting web page citations in MLA style:\n\n[(webpage? pub)\n (format \"\\\"~a.\\\" Web. ~a <~a>.\"\n         (webpage-title pub) (webpage-retrieved pub) (webpage-url pub))]\nThe logic for formatting each class of publication", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0007", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": " is distributed between the functions for each citation style, so to handle a new kind of publication, we need to make a change in each of those functions. Our program is small, so the problem isn‚Äôt too bad in this case, but imagine how the needed changes might be scattered in a larger program. Even worse, we might be extending a library where the original source code for cite-apa and cite-mla is unavailable (or we don‚Äôt want to modify it, because we want to continue to track upstream changes). Perhaps there‚Äôs a different way to structure our code that would make this kind of extension easier.\n\n2 Turning it inside-out\nIn the example above, we defined our data first, and then wrote functions to manipulate it. This means that new classes of data require new cases in the functions. What if, i", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0008", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "nstead, we attached the logic for formatting each class of publication to the data itself. That is, we‚Äôre going to represent a publication as a value that knows how to format itself. In particular, we will represent a publication as a function that, when told which style to use, returns its own formatted citation:\n\n;; A Publication is a [CitationStyle -> String]\n;;   where\n;; CitationStyle is one of:\n;; -- \"apa\"\n;; -- \"mla\"\nWe can now write (something akin to) a template for creating Publications, which we will fill in for each class of publication that we need to represent. The idea is that a function for constructing some kind of publication takes parameters describing that publication, and returns a function representing the publication.\n\n;; create-publication: ... -> [CitationStyle -> ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0009", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "String]\n;; Template for constructing publications\n(define (create-publication args ...)\n  (lambda (style)\n    (cond\n      [(string=? style \"apa\") (... args ...)]\n      [(string=? style \"mla\") (... args ...)])))\nNote that we really have turned our code inside-out! Instead of a template for processing publications, we have a template for creating publications that know how to process themselves. Instead of each operation analyzing the shape of the publication that it‚Äôs given, each publication conditions on the operation that it is asked to perform.\n\nLet‚Äôs fill in the template for creating representations of books:\n\n;; new-book: String String String String Number -> Publication\n;; To construct a new book.\n(define (new-book title author publisher location year)\n  (lambda (style)\n    (cond\n    ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0010", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "  [(string=? style \"apa\")\n       (format \"~a (~a). ~a. ~a: ~a.\"\n               author year title location publisher)]\n      [(string=? style \"mla\")\n       (format \"~a. ~a. ~a: ~a, ~a.\"\n               author title location publisher year)])))\n\n;; Example:\n(define rushdie.v2\n        (new-book \"Midnight's Children\" \"Salman Rushdie\"\n                  \"Jonathan Cape\" \"London\" 1980))\nNow we can see how it works. The function new-book takes the same arguments that make-book took above, but instead of returning a simple structure, it returns a function that, when passed a CitationStyle, returns a citation formatted in that style. Let‚Äôs try it out:\n\n(check-expect\n (rushdie.v2 \"apa\")\n \"Salman Rushdie (1980). Midnight's Children. London: Jonathan Cape.\")\nWe can test our new implementation by comparin", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0011", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "g it again the old one (which increases our confidence that our translation is correct):\n\n(check-expect (rushdie.v2 \"apa\") (cite-apa rushdie.v1))\n(check-expect (rushdie.v2 \"mla\") (cite-mla rushdie.v1))\nWe can, of course, define a constructor function for articles as well:\n;; new-article: String String String Number Number Number -> Publication\n;; To construct a new article.\n(define (new-article title author journal volume issue year)\n  (lambda (style)\n    (cond\n      [(string=? style \"apa\")\n       (format \"~a (~a). ~a. ~a, ~a(~a).\"\n               author year title journal volume issue)]\n      [(string=? style \"mla\")\n       (format \"~a. \\\"~a.\\\" ~a ~a.~a (~a).\"\n               author title journal volume issue year)])))\n\n;; Examples:\n(define turing.v2\n        (new-article \"Computing machinery", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0012", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": " and intelligence\"\n                     \"A. M. Turing\" \"Mind\" 59 236 1950))\n\n(check-expect (turing.v2 \"apa\") (cite-apa.v1 turing))\n(check-expect (turing.v2 \"mla\") (cite-mla.v1 turing))\nAnd if we find out later that we need to handle web pages as well, we can create a new constructor function for web pages, without modifying any of our book or article code:\n\n;; new-webpage: String String String -> Publication\n;; To construct a new web page.\n(define (new-webpage title url retrieved)\n  (lambda (style)\n    (cond\n      [(string=? style \"apa\")\n       (format \"~a. Retrieved ~a, from ~a.\"\n               title retrieved url)]\n      [(string=? style \"mla\")\n       (format \"\\\"~a.\\\" Web. ~a <~a>.\"\n               title retrieved url)])))\n\n;; Examples:\n(define cs3500.v2\n        (new-webpage \"CS3500: Obje", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0013", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "ct-Oriented Design\"\n                     \"https://www.ccs.neu.edu/course/cs3500/\"\n                     \"August 11, 2014\"))\n\n(check-expect (cs3500.v2 \"apa\") (cite-apa cs3500.v1))\n(check-expect (cs3500.v2 \"mla\") (cite-mla cs3500.v1))\nTo use a Publication, whether it represents a book, an article, or a web page, we no longer need to know how the data is represented. Instead, we only need to know the interface to Publications, which in this case is the set of CitationStyles that they know how to handle. This means that even though each class of publication is defined separately, we can work with them uniformly:\n\n(map (lambda (pub) (pub \"mla\"))\n     (list rushdie turing cs3500))\n3 From structures to objects\nThe values of rushdie.v2, turing.v2, and cs3500.v2 are objects‚Äîdata encapsulated with th", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0014", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "e code that knows how to operate on it. Clients of objects‚Äîthat is, other code that uses them‚Äîinteract with objects by sending them messages. In this case, Publication objects understand two kinds of messages, \"apa\" and \"mla\", but we could imagine constructing objects that take more information in their messages, as additional arguments. The code that an object invokes in response to a message‚Äîthat is, each case in each object‚Äôs cond expression‚Äîis called a method. And the three classes of objects that we know how to construct are called, naturally, classes. To use an object, we don‚Äôt need to know its class. All we need to know is its interface‚Äîthat is, the set of messages that it understands.\n\nWe can program with objects in nearly any programming language, though some languages make it smo", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0015", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "other than others. Attempting to extend our objects above with more functionality will get increasing awkward. What if we want to receive messages with different numbers of parameters? Or what if there‚Äôs functionality that we‚Äôd like to share between different implementations? And because we‚Äôre interested in using object-oriented programming to design large systems, it would be really helpful if the language could help us find some kinds of bugs, such as when an implementation or client doesn‚Äôt conform to its supposed interface. For this reason, we are often better off doing object-oriented programming in a language designed for it, with built-in notions of classes, objects, messages, methods, and interfaces.\n\n4 Now in Java\nIn ISL+ùúÜ\n, the interface to publication objects is informal, in a c", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0016", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "omment where the compiler doesn‚Äôt see and can‚Äôt check it. In Java, on the other hand, we can express the interface as code:\n\n/**\n * Specifies operations for formatting citations from bibliographic data.\n */\npublic interface Publication {\n  /**\n   * Formats a citation in APA style.\n   *\n   * @return the formatted citation\n   */\n  String citeApa();\n\n  /**\n   * Formats a citation in MLA style.\n   *\n   * @return the formatted citation\n   */\n  String citeMla();\n}\nWe define the interface Publication, which declares a method for each of the two citation styles that we want to support. The comments beginning with /** are used by a tool called Javadoc to generate documentation; we‚Äôll see more about this later.\n\n4.1 The Book class\nNow, for each kind of publication whose bibliographic information we ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0017", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "want to represent, we define a class that implements the Publication interface. Let‚Äôs start with books:\n\n/**\n * The {@code Book} class represents bibliographic information for books.\n */\npublic class Book implements Publication {\n  private final String title, author, publisher, location;\n  private final int year;\n}\nThe implementation of the Book class declares five instance variables for the five components of the bibliographic information for a book according to our data analysis. The fields are declared private because they don‚Äôt need to be directly accessible to clients of the class. (As a rule of thumb, all instance variables should be private.) The instance variables don‚Äôt need to change once an instance is contructed; by declaring them final, we tell the Java compiler to issue a type", "topics": ["decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0018", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": " error if we attempt to assign to them, which might help us detect bugs.\n\nNext we define a constructor for the Book class, which specifies how to initialize Book objects:\n\n/** Constructs a {@code Book} object.\n *\n * @param title     the title of the book\n * @param author    the author of the book\n * @param publisher the publisher of the book\n * @param location  the location of the publisher\n * @param year      the year of publication\n */\npublic Book(String title, String author, String publisher,\n            String location, int year)\n{\n  this.title = title;\n  this.author = author;\n  this.publisher = publisher;\n  this.location = location;\n  this.year = year;\n}\nThis constructor looks like pure boilerplate‚Äîmeaningless bookkeeping that wasn‚Äôt necessary in the ISL version of the class. But as w", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0019", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "e will see later, we can create more interesting constructors that do useful things such as allocating other resources or protecting representation invariants.\n\nFinally, we implement the two methods declared in Publication:\n\npublic String citeApa() {\n  return author + \" (\" + year + \"). \" + title + \". \"\n           + location + \": \" + publisher + \".\";\n}\n\npublic String citeMla() {\n  return author + \". \" + title + \". \" + location + \": \"\n           + publisher + \", \" + year + \".\";\n}\nWe construct the formatted strings by appending the instance variables along with some additional punctuation. We may omit purpose statements on these method implementations because their purposes are the same as the those written in the Publication interface (and Javadoc knows to copy the documentation from there).", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0020", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "\n\n4.1.1 Testing the Book class\nOur work on the class isn‚Äôt done until we test it. We‚Äôll use the testing library JUnit, which offers a way to run simple assertions and report when any of them fail. We start by importing the JUnit library and defining a class to hold our test cases. We also define a variable for a book that we‚Äôll use in our tests:\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class BookTest {\n  Publication rushdie = new Book(\"Midnight's Children\", \"Salman Rushdie\",\n                                 \"Jonathan Cape\", \"London\", 1980);\n}\nNote that we declare variable rushdie to have type Publication, not Book. Either is a valid type for it, but generally uses interfaces as types is considered better style than using classes, because it reveals fewer", "topics": ["testing"]}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0021", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": " details to clients, which makes code more flexible.\n\nWe then write two assertions about the behavior of our example Book object, each in its own method. The static method assertEquals is similar to check-expect, in that it takes two arguments, first the expected value and second the expression to evaluate and check; the test succeeds when the values are ‚Äúequal‚Äù.2\n\n@Test\npublic void testCiteApa() {\n  assertEquals(\n    \"Salman Rushdie (1980). Midnight's Children. London: Jonathan Cape.\",\n    rushdie.citeApa());\n}\n\n@Test\npublic void testCiteMla() {\n  assertEquals(\n    \"Salman Rushdie. Midnight's Children. London: Jonathan Cape, 1980.\",\n    rushdie.citeMla());\n}\nEach test case method must be preceeded by the annotation @Test for JUnit to find and run it, must return void and must require no a", "topics": ["testing"]}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0022", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "rguments.\n\n4.2 The Article class\nThe implementation of Publication for articles is similar enough to Book that we include it here without further discussion.\n\n/**\n * Represents bibliographic information for journal articles.\n */\npublic class Article implements Publication {\n  private final String title, author, journal;\n  private final int volume, issue, year;\n\n  /**\n   * Constructs an article.\n   *\n   * @param title   the title of the article\n   * @param author  the author of the article\n   * @param journal the journal in which the article appears\n   * @param volume  the volume of the journal\n   * @param issue   the issue of the journal\n   * @param year    the year of the journal\n   */\n  public Article(String title, String author, String journal, int volume,\n                 int issue, in", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0023", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "t year) {\n    this.title = title;\n    this.author = author;\n    this.journal = journal;\n    this.volume = volume;\n    this.issue = issue;\n    this.year = year;\n  }\n\n  public String citeApa() {\n    return author + \" (\" + year + \"). \" + title + \". \"\n             + journal + \", \" + volume + \"(\" + issue + \").\";\n  }\n\n  public String citeMla() {\n    return author + \". \\\"\" + title + \".\\\" \" + journal + \" \"\n             + volume + \".\" + issue + \" (\" + year + \").\";\n  }\n}\nThe tests for articles are straightforward as well:\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class ArticleTest {\n  Publication turing =\n         new Article(\"Computing machinery and intelligence\",\n                     \"A. M. Turing\", \"Mind\", 59, 236, 1950);\n\n  @Test\n  public void testCiteApa() {\n ", "topics": ["testing"]}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0024", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "   assertEquals(\"A. M. Turing (1950). Computing machinery and \"\n                   + \"intelligence. Mind, 59(236).\",\n                 turing.citeApa());\n  }\n\n  @Test\n  public void testCiteMla() {\n    assertEquals(\"A. M. Turing. \\\"Computing machinery and \"\n                   + \"intelligence.\\\" Mind 59.236 (1950).\",\n                 turing.citeMla());\n  }\n}\nImplementing and testing a Website class is left as an exercise for the reader.\n\n5 Looking forward\nWe‚Äôve seen how object-oriented style lets us organize our code in a different way than functional style: Objects encapsulate both data and behaviors associated with that data. The above example illustrates this at a small scale.\n\nThe rationale for object-oriented design can be better understood by applying it to bigger examples. This allows ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0025", "source": "data\\raw\\notes\\Lecture 2 The essence of objects.txt", "text": "us to appreciate more its uses and understand why it is so popular. We will learn throughout this course how organizing our programs as cooperating objects can help us engineer software systems and components that are flexible, reusable, and maintainable.\n\n1Note that DrRacket will not allow redefining the book and article structs, so in the actual Racket source file, we use book*, etc.\n\n2Equality, in Java and in general, is a tricky concept. We will study equality and understand better what assertEquals does later in the semester.", "topics": ["decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0000", "source": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt", "text": "Lecture 3: Getting (back) into Java\nSlidesJava and ISL source (.zip)\nObjectives of the lecture\nThis and the next lecture designs a simple example from scratch, starting from a description of the problem. It creates an interface and discusses specific ways to represent data. Next it completes one specific implementation, and then adds another implementation after the first one has been tested and used. Finally it shows how abstraction can be used to minimize code replication, and how designing by interface has several advantages.\n\n1 Analysis\nWe will design a small library for computing with durations. 1. Before we start writing code, we must carefully consider the information we want to work with and what operations it needs to support.\n\nWhat do we mean by a duration? Here are some examples", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0001", "source": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt", "text": ":\n\n43.27ùúáùë†\n109\n years\n525,600 minutes\n3 days, 6 hours, 17 minutes, and 25 seconds\n1.1 Operations\nIn an object-oriented system data and operations on it are kept together. Therefore the representation of information is often related to the operations that we wish to perform on it.\n\nHere are some possible operations on durations:\n\nConvert units: 10 minutes = 600 seconds (Does this make sense?)\nFormat: 257 seconds might be printed as 4:17 or 0:04:17\nAdd: 2:45 plus 3:30 is 6:15\nSubtract: 5 hours minus 2 hours is 3 hours\nDecompose into human-friendly components: 7868 seconds might be more easily read as 2 hours, 11 minutes, and 8 seconds\nCompare durations for equality and ordering\nFor our design in this lecture, we will support conversion to seconds, one simple form of formatting, addition, and", "topics": ["decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0002", "source": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt", "text": " comparisons. The human-friendly units that we will decompose durations into include hours, minutes, and seconds.\n\n1.2 Assumptions\nBefore proceeding, it is necessary to make some assumptions about what kinds of durations we will work with, because we probably cannot represent any conceivable duration‚Äîrather, there will be some limits. Which of the above examples do we need to be able to work with? In particular:\n\nWhat resolution of time do we want to support? (That is, what is the smallest difference between two times that we can distinguish?)\nAre there bounds, lower or upper?\nDo we want to distinguish the same amounts of time when expressed in different units?\nTo keep things simple, we answer these questions as follows2. The smallest unit of time will be the second; we won‚Äôt deal with dur", "topics": ["gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0003", "source": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt", "text": "ations that are not an integer number of seconds. We disallow negative durations, since it isn‚Äôt clear what those mean. Rather than specify a maximum duration, we leave it unspecified, allowing that there will be some upper bound determined by our choice of representation. And we‚Äôd like durations to stand for pure lengths of time, regardless of what unit they are expressed in, so for example 3 minutes should be equal to 180 seconds.\n\n1.3 Interface design\nNow that we have a list of operations and have settled on some assumptions, we can design our interface Duration. It includes the following methods:\n\n/**\n * Durations, with a resolution of seconds. All durations are non-negative.\n */\npublic interface Duration extends Comparable<Duration> {\n  /**\n   * Gets the total duration in seconds.\n   ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0004", "source": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt", "text": "*\n   * @return the number of seconds (non-negative)\n   */\n  long inSeconds();\n\n  /**\n   * Formats this duration in the form {@code H:MM:SS} where the minutes and\n   * seconds are both zero-padded to two digits, but the hours are not.\n   *\n   * @return this duration formatted in hours, minutes, and seconds\n   */\n  String asHms();\n\n  /**\n   * Returns the sum of two durations.\n   *\n   * @param other the duration to add to {@code this}\n   * @return the sum of the durations\n   */\n  Duration plus(Duration other);\n}\nThings to notice:\n\nWe extend interface Comparable in order to define its comparison method compareTo on durations. In particular, extending interface Comparable<Duration> means that all Durations need to be comparable to Durations.\nThe interface and the methods each have a Javadoc com", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0005", "source": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt", "text": "ment, which is a block comment that starts with /**.3 Javadoc uses the first sentence of each Javadoc comment in the table of contents, so it should be clear and to-the-point. Think of it as a purpose statement. This interface uses three different Javadoc markup tags:\n@param paramName description is used to document method parameters, in this case other in method plus.\n@return description is used to document the value returned by each non-void method. (For simple methods, it often seems redundant.)\n{@code some-code} is used to format some-code as code.\nNotice that the plus method takes a Duration object as an argument. Thus the signature of this method does not depend on any specific implementation of the Duration interface. This is an example of how ‚ÄúDependency Inversion‚Äù is avoided (the ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0006", "source": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt", "text": "D in SOLID).\n2 Implementation\n2.1 Representation\nIn order to implement the Duration interface, we need to decide on a representation. Given that durations will have to be formatted as hours, minutes, and seconds, and that we will likely construct a duration from hours, minutes, and seconds, it seems intuitive to represent a duration using them directly4:\n\npublic final class DurationImpl implements Duration {\n  private final int hours;\n  private final int minutes;\n  private final int seconds;\n}\nThree qualifiers in this code snippet are worth explaining:\nfinal on the class means that DurationImpl cannot be extended. Inheritance can create complexities and often unwanted errors, so it is a good idea to prevent inheritance unless we anticipate that it may be useful later.\nThe fields are privat", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0007", "source": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt", "text": "e so that client code of our class cannot access them directly and can only use the official interface. This is for encapsulation, and we should make fields private by default. Note that in general we shouldn‚Äôt define getters and setters unless we have a specific need for them, and in this example we don‚Äôt.\nfinal on each field means that the field must be assigned exactly once, in the constructor, and once initialized cannot be changed. Because immutability promotes modularity,5 we should mark fields final when it makes sense in context; in particular, when a class represents a genuine value rather than something that represents a state that is transient, immutability makes sense.\n2.2 Initialization\nWe might expect a constructor that takes the decomposition as parameters to be simple, like", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0008", "source": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt", "text": " so:\n\n/**\n * Constructs a duration in terms of its length in hours, minutes, and\n * seconds.\n *\n * @param hours the number of hours\n * @param minutes the number of minutes\n * @param seconds the number of seconds\n * @throws IllegalArgumentException if any argument is negative\n */\npublic DurationImpl(int hours, int minutes, int seconds) {\n  if (hours < 0 || minutes < 0 || seconds < 0) {\n    throw new IllegalArgumentException(\"must be non-negative\");\n  }\n\n  // Insert omitted code from below //\n\n  this.hours = hours;\n  this.minutes = minutes;\n  this.seconds = seconds;\n}\nThis constructor checks that each parameter is non-negative (as it makes sense in this context), to ensure that durations are not negative (this is called an invariant). However, this is not enough. Consider the following durat", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0009", "source": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt", "text": "ions:\nDuration d1 = new DurationImpl(0, 0, 90);\nDuration d2 = new DurationImpl(0, 1, 30);\nAccording to our criteria above, it should be the case that d1.equals(d2) (once we‚Äôve overridden equals), since they represent the same amount of time. This means that we somehow need to get them in the same form if we want to compare them. How can we make that happen? We have a choice:\n\nWe could have equals look at both the minutes and seconds fields and do the right arithmetic.\nWe could have the constructor store the duration in a canonical form.\nIf we choose the former, then other methods may duplicate the work. For example, according to asHms‚Äôs contract, it formats both durations in the same canonical form, \"0:01:30\". That suggests that we can save work‚Äîand have a single point of control‚Äîif we can", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0010", "source": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt", "text": "onicalize in the constructor. (Furthermore, a real class is likely to have additional methods that require the canonicalized components.) Thus, we add code to the constructor to canonicalize the representation:\n\nif (seconds > 59) {\n  minutes += seconds / 60;\n  seconds %= 60;\n}\n\nif (minutes > 59) {\n  hours += minutes / 60;\n  minutes %= 60;\n}\nThis ensures that the seconds and minutes never exceed 59 (because if they did, we would add to the minutes or hours, respectively, instead).\n2.3 Domain-specific methods\nThe observation methods are simple:\n\n@Override\npublic long inSeconds() {\n  return 3600 * hours + 60 * minutes + seconds;\n}\n\n@Override\npublic String asHms() {\n  return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n}\nIn a Java format string, the code %d means that the next param", "topics": ["decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0011", "source": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt", "text": "eter is an int. Writing 2 between % and d means to pad the number to be at least two characters long; by default padding is done with spaces, but 02 means to zero-pad the integer to make it two characters long.\nThe operation plus is slightly more difficult. The easiest way to add two durations is to convert them both to raw seconds, add, and then convert back to hours, minutes, and seconds. The first step we can do with inSeconds(), but to convert back from seconds, we need to do a little more work. Anticipating that its use could be more general, we define a second constructor:\n\n/**\n * Constructs a duration in terms of its length in seconds.\n *\n * @param inSeconds the number of seconds (non-negative)\n * @throws IllegalArgumentException {@code inSeconds} is negative\n */\npublic DurationImpl", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0012", "source": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt", "text": "(long inSeconds) {\n  if (inSeconds < 0) {\n    throw new IllegalArgumentException(\"must be non-negative\");\n  }\n\n  this.seconds = (int) (inSeconds % 60);\n  this.minutes = (int) (inSeconds / 60 % 60);\n  this.hours = (int) (inSeconds / 3600);  // overflow...\n}\nIn each assignment above, (int) is a numeric cast that converts from type long, in this case, to type int. Because the range of long is larger, not all longs can be represented correctly as ints, and instead will overflow, producing the wrong answer. The first two casts are guaranteed not to overflow, since x % 60 is between 0 and 59, plenty small to fit in an int, for any x. However, if inSeconds is large enough6 then the resulting object won‚Äôt be right.\n\nWith the new constructor, plus is easy:\n\n@Override\npublic Duration plus(Duration t", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0013", "source": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt", "text": "hat) {\n  return new DurationImpl(this.inSeconds() + that.inSeconds());\n}\n2.4 Standard methods\nBecause Duration extends Comparable<Duration>, we need to implement the compareTo(Duration) method. We could do this by comparing the components, but it‚Äôs simpler to compare the total seconds:\n\n@Override\npublic int compareTo(Duration that) {\n  return Long.compare(this.inSeconds(), that.inSeconds());\n}\nNote that the Long class has a static method for comparing primitive, lowercase-ell long values, because primitive values cannot themselves have methods.\nAll classes should override Object.toString() with something reasonable. In this case, asHms is a fine implementation of toString:\n\n@Override\npublic String toString() {\n  return asHms();\n}\nFinally, we need to decide whether to override Object.equals", "topics": ["decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0014", "source": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt", "text": "(Object) and Object.hashCode(). (Never override one without the other‚Äîwe‚Äôll talk about this soon.) The default implementations inherited from Object use reference equality and a hash function compatible with reference equality. This most often makes sense for distinguishing stateful objects, since two objects that currently have the same state can change in the future. However, for immutable value objects like DurationImpl, if we construct two objects representing the same length of time, those values are essentially equal. Thus, it makes sense to override equals to define extensional equality, and hashCode to compute hash codes using the same values that are compared by equals. Here‚Äôs a first attempt:\n\n@Override\npublic boolean equals(Object o) {\n  // Fast path for reference equality:\n  if", "topics": ["gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0015", "source": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt", "text": " (this == o) {\n    return true;\n  }\n\n  // If o isn't the right class then it can't be equal:\n  if (! (o instanceof DurationImpl)) {\n    return false;\n  }\n\n  // The successful instanceof check means our cast will succeed:\n  DurationImpl that = (DurationImpl) o;\n\n  return this.hours == that.hours\n      && this.minutes == that.minutes\n      && this.seconds == that.seconds;\n}\n\n@Override\npublic int hashCode() {\n  return Objects.hash(hours, minutes, seconds);\n}\nThe static method Objects.hash(Object...) takes any number of arguments, each of which it hashes using that argument‚Äôs hashCode() method, and then combining the results in a reasonable way.\nHowever, if we choose to, we can do better. Because Duration is an interface, we should expect that it will be implemented more times in the future. P", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0016", "source": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt", "text": "erhaps it would be useful if the current and all future implementations of Duration could work together seamlessly, including being considered equal if they represent the same length of time. To do this, we need to rewrite the equals method to compare not only to another DurationImpl but to any Duration via its interface. We can do this in this case because inSeconds() is part of the interface and returns sufficient information to test for equality. So we create a more general equals that compares seconds:\n\n@Override\npublic boolean equals(Object that) {\n  if (this == that) {\n    return true;\n  }\n\n  if (! (that instanceof Duration)) {\n    return false;\n  }\n\n  return ((Duration) that).inSeconds() == this.inSeconds();\n}\nWe‚Äôre nearly done, but not yet. Above we wrote that equals and hashCode s", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0017", "source": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt", "text": "hould always be overridden together (or not at all), and similarly, changing one of them often requires changing the other. A proper hashCode method will return the same hash code for any two Durations that are equal according to the equals method. That means that hashCode should only use as inputs values that are part of the equals comparison, which in this case means we should hash the total seconds:\n\n@Override\npublic int hashCode() {\n  return Long.hashCode(inSeconds());\n}\n2.5 Full circle\nFinally, building the extra flexibility into DurationImpl doesn‚Äôt do us any good if future implementations of Duration don‚Äôt follow the same rules. So we document how equals and hashCode must work for all implementations of the Duration interface in the interface itself:\n\n/**\n * Durations, with a resolu", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0018", "source": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt", "text": "tion of seconds. All durations are non-negative.\n *\n * <p>Different {@code Duration} implementations should work together,\n * meaning that:\n *\n * <ul>\n *   <li>Two durations must be equal if they have the same number of seconds.</li>\n *   <li>The hash code of a duration is the result of calling\n *        {@link Long#hashCode(long)} on its length in seconds.</li>\n * </ul>\n * </p>\n */\npublic interface Duration extends Comparable<Duration> {\n  ...\n}\n1This is a potentially tricky subject, and we will simplify a lot.\n\n2Although we make some arbitrary assumptions here to simplify the illustration, in reality assumptions about resolution and range of data should be made according to requirements, stated and extrapolated.\n\n3In IntelliJ, if you press enter after the second *, it generates a Javadoc", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0019", "source": "data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt", "text": " comment template for you.\n\n4Intuitive is subjective: what if we find out later that our chosen representation wasn‚Äôt the best option after all?\n\n5Why is immutability desirable? Methods that take or return immutable types, written here and elsewhere are implicitly guaranteed not to change these types, deliberately or by accident. This makes them easier to document and use as well.\n\n6In particular, if inSeconds / 3600 > (long) Integer.MAX_VALUE.\n", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0000", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "Lecture 5: Java Safari\nJava source (.zip)Slides\n1 Objectives of the lecture\nThe objective of this lecture is to introduce additional Java structures and features that were either not taught in previous courses, or were not emphasized enough. These features would be useful going forward.\n\n2 Packages and code organization\nThere‚Äôs a lot of code in the world. Plenty of that code implements similar functionality: for example, many programs or libraries might define lists or trees or other concepts with common, repeated names. But if multiple libraries define the same names of classes or interfaces, then it becomes impossible to use those libraries together, since the names are now ambiguous. This is one scenario of a common problem, where we need a way to distinguish among distinct definitions ", "topics": ["gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0001", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "with the same name. A simple real-world analogue: there are many people who share the same first name, and the common solution is to group people together by family names.\n\n2.1 Defining packages\nJava deals with this problem via packages. A package is intended to be a logically coherent group of classes and interfaces, and we will fully qualify the name of a class with the name of its package. Package names are typically written as dot.separated.names, starting from the most general and moving rightward to more specific ‚Äúsubpackages‚Äù. For example, the built-in List interface has a fully-qualified name of java.utils.List ‚Äî the package name here is java.utils.\n\nJava also makes a one-to-one correspondence between packrage names and directory paths. For the java.utils.List example, the source c", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0002", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "ode organization looks something like\n\nTheImplementationOfJava\n+-src/\n  +-java/\n    +-utils/\n      List.java\nThe src/ directory isn‚Äôt part of the package name; it‚Äôs simply the root directory underneath which all various packages and code can be implemented.\n\nIn your own projects, as you define various packages, you‚Äôll need to ensure that your directory structure in your src/ directory matches your package structure. For example, if Assignment 123, part 1 asks you to implement your code in package cs3500.assignment123.part1, then you should ensure that your project looks something like\n\nYourProject\n+-src/\n  +-cs3500/\n    +-assignment123/\n      +- part1/\n        +- ...various Java files...\nWhenever you define code within a package, the very first line of your files must declare your package:", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0003", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "\n\npackage cs3500.assignment123.part1;\nThe package declaration must match the directory path; otherwise Java will be unable to find your classes at compile or runtime.\n\n2.2 Importing code from other packages\nWhen you want to use code from another package, you import the names into your file so that they are more convenient to use. For example, you could simply write\n\njava.utils.List<String> strs = new java.utils.ArrayList<String>();\nand always fully-qualify all the names of every type you want to use. But this is very tedious. Instead, you can write\n\nimport java.utils.*;\n\nList<String> strs = new ArrayList<String>();\nThe import line at the top ensures that you can use unqualified names for convenience, while still explaining to the compiler which fully-qualified names you mean to use. The .*", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0004", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": " suffix means ‚ÄúPlease include all the names in the package being imported.‚Äù If you only want to import a single name, you can do so explicitly:\n\nimport java.utils.List;\nimport java.utils.ArrayList;\n// etc.\nNote that imports and package declarations are intended to be counterparts of each other.\n\n2.3 The default package\nIn Fundies 2, we never dealt with packages at all. You never wrote a package ...; declaration, and never dealt with subdirectories of your src/ directory. The ‚Äúbase case‚Äù of packages is a package with no name: it‚Äôs known as the ‚Äúdefault‚Äù package. In Fundies 2, we never worried about packages, but we also never had so many class or interface definitions that we had to worry about the name collisions that packages help us avoid.\n\nIt is impossible to import classes from a defau", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0005", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "lt package...but once programs get large enough, it is considered bad practice to use the default package at all.\n\n2.4 Organizing your project directories\nYou may have noticed that IntelliJ automatically creates a src/ directory in which the source-code of your program should live. You should create a second directory, called test/, in which you place all your test classes. You can create a package organization within your test/ directory that mimics the organization within src/ ‚Äî IntelliJ is configured to treat the two directories as ‚Äúoverlapped‚Äù with each other, so that tests in one package can see source defintiions from that same package.\n\nThe reason for having two distinct directories is to ensure that code-to-be-released-to-customers is physically separated from code-that-tests-imple", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0006", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "mentations. You should ensure that you preserve this distinction in your projects.\n\n3 The static keyword?\n3.1 What is it?\nIn programming generally, static describes things that happen or are determined at compile time, and dynamic describes things that happen or are determined at run time. In object-oriented programming, and in Java in particular, static means that some member‚Äîa field, method, or nested class‚Äîis part of its class, whereas a non-static member is associated with every object of the class. Another way of saying this would be that static things are shared by all objects of the class, whereas each object gets its own unique instance of non-static things.\n\n3.2 How do we use it?\nField, class, and method members of classes can be declared static. In each case the idea of being ass", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0007", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "ociated with the classes versus its instances must be interpreted slightly differently.\n\n3.2.1 Static fields\nAn instance (non-static) field is a separate slot in each object of a class, whereas a static field has one slot for the whole class. For example, consider a class with one of each kind of field:\n\nclass Widget {\n  int widgetId;\n  static int widgetIdCounter = 3;\n}\nFor each Widget w we create, there‚Äôs a separate w.widgetId variable. Whereas there is only one Widget.widgetIdCounter variable, which we refer to as a member of the class Widget rather than a particular object w:\n\nassertEquals( 3, Widget.widgetIdCounter );\n\nWidget one = new Widget();\none.widgetId = 1;\n\nWidget two = new Widget();\ntwo.widgetId = 2;\n\nassertEquals( 1, one.widgetId );\nassertEquals( 2, two.widgetId );\nassertEqual", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0008", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "s( 3, Widget.widgetIdCounter );\n\none.widgetId = 11;\ntwo.widgetId = 12;\nWidget.widgetIdCounter = 13;\n\nassertEquals( 11, one.widgetId );\nassertEquals( 12, two.widgetId );\nassertEquals( 13, Widget.widgetIdCounter );\nIn a sense, static fields are Java‚Äôs version of global variables, and like globals, they should be used sparingly. Public, static, non-final fields warrant extra suspicion.\n\n3.2.2 Static methods\nUnlike dynamic methods, static methods do not require an instance of a class to operate on; as with static fields, the method is treated as a member of the class. For example:\n\nclass Widget {\n  public void getWidgetId() { return widgetId; }\n  int widgetId;\n\n  public static void resetWidgetIdCounter() { widgetIdCounter = 0; }\n  static int widgetIdCounter = 3;\n}\nNote that it would be a stati", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0009", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "c (compile-time) error for resetWidgetIdCounter to refer to widgetId, because widgetId is a non-static field, and static methods don‚Äôt operate on an individual instance. In order to call non-static method getWidgetId(), we need an instance of the widget class to call it on, because a non-static method can use the non-static fields of the object:\n\nassertEquals( 11, one.getWidgetId() );\nassertEquals( 12, two.getWidgetId() );\nBut static methods are called on the class rather than an instance, and thus don‚Äôt have an instance (this) to work on:\n\nassertEquals( 13, Widget.getWidgetId() );\nStatic methods are useful when they only work on data that is provided as their arguments, and do not require data stored in non-static fields. For example, the Math class has many static methods, because all of", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0010", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": " them operate only on what is provided to them as input.\n\n3.2.3 Static classes\nThe concept of static classes only applies to nested classes (i.e. classes that are defined inside another class).\n\nNested classes are useful when one has to define a class with the sole purpose of helping another class. Nesting this helper class inside the main class makes the latter more self-contained. An example could be an iterator defined over a list.\n\nWhen a nested class is static, it behaves like an ordinary class, just nested in its enclosing class‚Äôs namespace. Much like a static variable is not associated with a unique object of its containing class, a static inner class is not associated with a unique object of the outer class. Thus it may be instantiated independent of an instantiation of the outer c", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0011", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "lass.\n\nIf Nested is a static member of Outer, then we refer to it as Outer.Nested when writing code that‚Äôs outside of Outer.\n\n//Case 1: Nested is a static class inside in Outer\n//instantiating Nested\nOuter.Nested nest = new Outer.Nested(...); //appropriate arguments to constructor\n\n//Case 2: Nested is a non-static class inside Outer\n//instantiating Nested requires instantiating Outer first\nOuter outer = new Outer(...);\nOuter.Nested nest = outer.new Nested(...); //nest is \"linked\" to object outer\nFurthermore, nested classes share the same private scope with their enclosing class. Thus, Outer can see all of Outer.Nested‚Äôs private members, and Outer.Nested can see all of Outer‚Äôs private members.\n\nIn the Widget example above, rather than use a static field widgetIdCounter to generate widget ID", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0012", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "s, we can manage the counter in a factory object:\n\nclass Widget {\n  private Widget(...) { ... }\n\n  public static Factory factory() {\n    return new Factory();\n  }\n\n  public static class Factory {\n    public Factory() { ... }\n\n    public Widget create(...) {\n      ...\n      ++widgetIdCounter;\n      ...\n    }\n    private int widgetIdCounter;\n  }\n}\nIn order to create Widgets, we first must create a Widget.Factory, which instantiates its own counter. Then we can use the factory to create Widget objects numbered using that factory‚Äôs counter:\n\nWidget.Factory factObj = Widget.factory();\n\nWidget w1 = factObj.create();\nWidget w2 = factObj.create();\nAn advantage to this approach is that now we can create multiple independent factories, perhaps to work with multiple concurrent versions of some client", "topics": ["factory"]}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0013", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": " system. Of course, if we actually want only one global numbering, then we can apply the singleton pattern.\n\n3.3 When should we use static?\nUse a static field when you want on variable for the whole class rather than one per object. Sometimes a class with do this privately to cache some kind of information or to keep track of some information about its instances, but for the most part static fields are rare except for constants. A constant should be a public static final field whose contents are immutable, and its name should be in all caps.\n\nUse a static method when you want to associate some method with a class that doesn‚Äôt depend on having an instance. The most common case for static methods are static factory methods, which produce objects of a class (and don‚Äôt require that we already ", "topics": ["factory"]}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0014", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "have an object to do so). It‚Äôs also common to factor out implementation functionality into private static helper methods.\n\nUse a static class when you want a helper class that‚Äôs strongly associated with the enclosing class, especially when the helper doesn‚Äôt make sense on its own. Nesting a helper class also allows the outer class to see its private members and vice versa, which can be helpful when the two classes are tightly coupled. For example, it makes sense to nest a class implementing an iterator for a collection class inside the collection class, because the iterator probably doesn‚Äôt make sense without the collection class, and it is often useful for the iterator to be able to see into the collection objects.\n\n4 Arrays\n4.1 What are they?\nIn Java, an array of type œÑ[] (where œÑ is any", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0015", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": " Java type) is a mutable, fixed-length, constant-time‚Äìindexed sequence of values of type œÑ. Let‚Äôs unpack that, from back to front:\n\nA sequence means that we have some number of things with a defined order (unlike a set, which has no order).\nConstant-time‚Äìindexed means that we can get (or set) any element of an array identified by its index (position) in the array, and how long it takes does not depend on the position or the size of the array.1\nFixed-length means that once an array is created, its length never changes.\nMutable means that the contents of the array‚Äîthe elements‚Äîcan be changed at will. Thus, they can change in content but not in length.\n4.2 How can we use them?\nTo create a new array, use the special array form of the new operator, which comes in two main variants:\n\nA new, full", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0016", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "y initialized array new int[] {2, 4, 6, 8} contains exactly the elements listed, which also determine its length.\nA new, uninitialized array new int[64] has the given size and is filled with the default value for its element type. For numeric types like int and double the default is zero, and for object types the default is null.\nAs a special case, when used to initialize a variable as part of its declaration everything before the curly braces can be omitted:\n\nint[] intArray = {2, 4, 6, 8};\nThe main operation on arrays is indexing, for both observing and updating the array. It‚Äôs also common to find out the length of an array using its length field.\n\nassertEquals(4, intArray[1]);\nassertEquals(8, intArray[3]);\n\nintArray[3] = 17;\n\nassertEquals(17, intArray[3]);\n\nassertEquals(4, intArray.lengt", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0017", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "h);\nThe class Arrays (doc) provides a large number of static methods for working with arrays, such as searching, sorting, filling, and copying. It also provides a method for turning an array of any type T into a List (doc) of T: <T> List<T> asList(T... a).2 Ah, but what does that T... mean? It‚Äôs a special form of array. Read on...\n\n4.2.1 Varargs\nSuppose we want a method that takes an arbitrary number of strings. Of course arrays are good for this, since they represent arbitrary length sequences:\n\nvoid setPlayers(String[] newPlayers);\nHowever, passing an array is ugly and inconvenient when in the common case we don‚Äôt have an array already and want to list the elements directly in the method call:\n\nsetPlayers(new String[] {\"Crosby\", \"Stills\", \"Nash\", \"Young\"});\nInstead, Java provides a way t", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0018", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "o declare a method that takes a variable number of arguments:\n\nvoid setPlayers(String... newPlayers);\nThe ... parameter always comes last in the argument list, though there may be a number of ordinary parameters that come before it.\n\nNow when we call the method, it looks like it takes a variable number of string arguments:\n\nsetPlayers(\"Crosby\", \"Stills\", \"Nash\", \"Young\");\nWithin the method, parameter newPlayers is an array just like before:\n\nvoid setPlayers(String... newPlayers) {\n    for (String player : newPlayers) {\n        addToGame(player);\n    }\n}\nIf we already have an array ready to go, we can pass it directly:\n\nsetPlayers(someArrayOfStrings);\nWhether we pass an existing array or use the varargs method call syntax, the callee receives an array.\n\n4.2.2 Array gotchas\nAn array is repre", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0019", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "sented as a reference to a chunk of memory, and the value of the array, so far as Java is concerned, is the reference itself, not the chunk of memory. This means that re-assigning or passing an array results in aliasing, having more than one name for the same thing:\n\nint[] anotherArray = intArray;\nanotherArray[0] = -9;\nassertEquals(-9, intArray[0]);\nNot only does == for arrays compare references rather than contents, but equals(Object) does as well. This means, for example, that this JUnit test will fail:\n\nassertEquals(new int[] {3, 6}, new int[] {3, 6}); // fails!\nYes, the arrays have the same contents, but not the same physical identity. To test for equality on the contents of two arrays, use assertArrayEquals:\n\nassertArrayEquals(new int[] {3, 6}, new int[] {3, 6});\nIn order to compare a", "topics": ["testing"]}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0020", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "rrays by their values yourself, you should use the Arrays.equals(Object[], Object[]) method, which compares the elements of the arrays using their equals(Object) methods. Of course, if the contents of the arrays you are comparing are in turn arrays, those will each be compared by physical identity. If you have several layers of nested arrays and want to compare by the contents all the way down, use Arrays.deepEquals(Object[], Object[]). (Note that these methods can take Object[]s because in Java every array type is a subtype of Object[]. This design choice is actually a big problem, but we won‚Äôt get into it right now.)\n\n4.3 When should we use them?\nMainly, you will use arrays because various existing APIs require them.\n\nYou can use an array when you want a sequence of values that you can l", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0021", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "ook up and update efficiently, addressed by their positions in the sequence. However, if the length of the sequence needs to change, you probably want to use a List instead (e.g., ArrayList or LinkedList). You can simulate a variable-length array by allocating new arrays and copying the elements over as needed, and this is in fact how ArrayList works (though there are some subtleties to avoiding a large number of inefficient copies).\n\nSince Lists can do everything that arrays can, why would we ever use an array? One reason would be if you know the length that you need up front, and you want to guarantee that you can never accidentally change it. Another reason is for efficiency, since higher-level sequences such as ArrayList build on top of arrays with additional checking and indirection. ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0022", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "For example ArrayList provides the convenience of adding an arbitrary number of items to it, at the cost of some wasted space. This is usually not a concern. But if you are developing a program that must optimize its usage of memory or must be especially efficient in time (e.g. writing a device driver, writing a program for a special device with limited resources), using an array may give you greater control over usage of resources.\n\n5 Characters\n5.1 What are they?\nThe character type, char, represents single graphemes or symbols for writing text. This includes letters ('a', 'b', 'A', 'B', 'Œ±', 'Œ≤', etc.), digits ('0', '1', 'Ÿ°', 'Ÿ¢', etc.), punctuation ('.', '-', '¬´', etc.), and whitespace (' ', '\\n', '\\t', '\\v', etc.).\n\n5.2 How can we use them?\nThe Character class provides, among other thi", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0023", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "ngs, static methods for working with characters, such as tests for character categories:\n\nassertTrue(Character.isLetter('a'));\nassertTrue(Character.isLetter('Œ≤'));\nassertFalse(Character.isLetter('8'));\n\nassertFalse(Character.isLowercase('Z'));\nassertTrue(Character.isLowercase('z'));\nStrings are sequences of characters, and the Java String class provides methods for working with them as such. The method charAt(int) lets us treat a string as an (immutable) array by allowing us to look up characters by position:\n\nassertEquals('a' , \"abcde\".charAt(0));\nassertEquals('c' , \"abcde\".charAt(2));\nAdditionally, we can search for characters in strings3, and convert between strings and arrays of characters:\n\nassertEquals(0, \"abcde\".indexOf('a'));\nassertEquals(2, \"abcde\".indexOf('c'));\nassertEquals(-1, ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0024", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "\"abcde\".indexOf('f'));\n\nchar[] abc = {'a', 'b', 'c'};\nassertArrayEquals(abc, \"abc\".toCharArray());\nassertEquals(\"abc\", String.valueOf(abc));\n5.3 When should we use them?\nCharacters are really for only two things:\n\nFor processing a String character by character to query, transform, decompose, or construct it incremementally. For example, if we want to split a sentence up into individual words, then processing it character-by-character lets us find the word boundaries and whitespace in between.\nFor representing text-like values that are always exactly one character long. This is fairly rare, but one place it often shows up is representing keystrokes in GUIs, which actually doesn‚Äôt work very well. (Why?)\n6 Primitive types versus reference types\n6.1 What are they?\nJava makes a distinction betw", "topics": ["gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0025", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "een primitive types and reference (or pointer) types. Understanding this distinction will make a variety of other features and quirks of Java make sense. Let‚Äôs consider what Java variables really mean.4 In this diagram, there are six variables, each of which is represented as a box in the left column that contains the variable‚Äôs value:\n\n\n\nThe first thing to notice about the six variables is that none has a compound value, composed of multiple components‚Äîeach contains a single, simple value, which may be an immediate number, a reference to something else, or null.\n\nVariables a and b contain values of primitive (meaning ‚Äúbuilt-in‚Äù) numeric types int (four bytes) and long (eight bytes); for each of these the value is directly in the variable, with no references to anything else. The prefix 0x", "topics": ["decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0026", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": " on a number is the syntax in many programming languages, including Java, for hexadecimal integer literals; writing the numbers this way makes it clear how many bits each is represented with. Every bit in each of these types (and all primitive types) is part of the representation of the number, and there‚Äôs no room for a distinguished null bit pattern; hence, primitive types do not include null as a value.\n\nThe other four variables have reference types, of which there are two subdivisions, object types and array types. Variables c and d both have the object type Posn. (Assume a class with two int fields x and y.) Java variables cannot hold objects directly‚Äîobjects are compound data structures‚Äîso instead they must hold a reference5 to an object. Variable c contains a reference to a Posn obje", "topics": ["gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0027", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "ct, so that, for example, c.x == 3. Note that the fields of an object are a kind of variable, which means that they, too, can hold only primitives or references, not actual objects. Variable d currently does not hold a reference, so its value is null, which is a distinguished value that indicates the absence of a reference.\n\nVariables e and f have array types, which means that each hold a reference to an array (or null), not the array itself. Whereas e refers to an array of primitive int values, f refers to an array of Posn object references. Three of the four elements contain references to Posn objects, and the fourth contains null. Note that while there are only two Posn objects in the diagram, there are four Posn object references‚Äîmultiple references can point to the same object. (This ", "topics": ["gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0028", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "is aliasing as discussed in the array section above.)\n\nThe reasons why objects and arrays need to be accessed via references is that their types do not determine how much space they take up. In particular, an array type int[] does not determine the length of the array, and object type Posn could include subclasses with additional fields.\n\n6.1.1 All the primitive types\nIn total, Java has eight primitive types that can be the immediate values of variables:\n\nThese have different sizes, which means that variables have different sizes. But each one has a known size, and each is a single value rather than some combination of values.\n\n6.1.2 Boxed types\nEvery primitive type in Java has a corresponding object type: int has Integer (doc), char has Character (doc), double has Double (doc), and so on.", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0029", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": " (Only Integer and Character have names that differ in more than their capitalization from their primitive counterparts; the other six are the same except for the capitalized first letter.)\n\nIn each case, the uppercase object type is a class with a field containing the corresponding lowercase primitive type. For example, let‚Äôs compare the short primitive type with the Short object type:\n\n\n\nVariable g of type short contains a short value directly. Compare this to variable h of type Short, which contains a reference to a Short object that has a field containing its value. Variable i also has type Short, but instead of containing a reference to an object, it contains null. Note that short cannot be null but Short can, double cannot be null but Double can, and so on for the other six boxed typ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0030", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "es.\n\nVariable j contains a reference to any array of primitive short values, which are stored directly in the array. Variable k is reference to an array of Shorts, that is, an array of object references.\n\nNote that these types are boxed because each is a reference to a box (object) containing the primitive type. For the most part, you shouldn‚Äôt have to convert between primitive types and their object versions, because Java automatically inserts box and unbox operations where needed.\n\n6.2 How can we use them?\nYou have been, and for the most part you know how. But there‚Äôs one thing worth knowing about that you may not: How to perform Object operations such as equality and hashing.\n\n7 Equality: physical and logical\nEquality seems like such a simple proposition: two things are either ‚Äúthe same", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0031", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "‚Äù or they aren‚Äôt. Except of course the preceding sentence has two key terms left undefined: ‚Äúthings‚Äù and ‚Äúsameness‚Äù. Now that we have a clearer picture of the difference between reference types and value types, there are clearly two different kinds of things: things that contain an arrow, or things that don‚Äôt. We therefore have to refine our notion of sameness: For value types, there‚Äôs really only one thing to be done: compare the values themselves and see if they are equal. But for references:\n\nWe can see if the arrows point to exactly the same place. This check is what the == operator performs.\nWe can ‚Äúfollow the arrows‚Äù and recursively compare the data they refer to for sameness.\nThe first one checks ‚Äúphysical‚Äù equality (do these two things refer to the same object?) and the second one ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0032", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "checks ‚Äúlogical‚Äù equality (do these two things refer to objects that are equivalent to each other, even though they may be physically different objects?).\n\nIn Fundies 2, we called these notions ‚Äúintensional‚Äù and ‚Äúextensional‚Äù equality. They mean the same thing as ‚Äúphysical‚Äù and ‚Äúlogical‚Äù equality, except we didn‚Äôt need to know exactly how references worked in order to define them!\n\nHow can we check and define equality between objects? Java defines the boolean equals(Object other) method, on the Object class, so that any two objects can be compared. By default, this operation is defined as\n\nboolean equals(Object that) { return this == that; }\nso that the default operation is simply intensional, physical equality. However we are free to override this method on our own classes, so that instan", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0033", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "ces of our classes can support logical equality instead. In order to do this, we first decide what it means for two objects to be ‚Äúequal‚Äù to each other. Then we write the equals method accordingly.\n\nIn many cases logical equality of two objects involves checking some or all of their fields for equality. If these fields are themselves objects, we recursively check their equality using their equals methods, and so on. However logical equality can be more sophisticated than merely comparing fields for equality. Consider a Fraction class:\n\nfinal class Fraction {\n  private final int num, den; // represents the number (num/den)\n  ...\n  @Override\n  public boolean equals(Object obj) {\n    if (!(obj instanceof Fraction)) return false;\n    Fraction that = (Fraction)obj;\n\n    return this.num == that.", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0034", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "num && this.den == that.den; // Oops!\n  }\n}\n\nassertEquals(new Fraction(1, 2), new Fraction(1, 2)); // good...\nassertEquals(new Fraction(1, 2), new Fraction(2, 4)); // Fails!\nThere are multiple ways of representing the ‚Äúsame‚Äù fraction, so we need a more general equivalence:\n\n@Override\npublic boolean equals(Object obj) {\n  if (!(obj instanceof Fraction)) return false;\n  Fraction that = (Fraction)obj;\n\n  return this.num * that.den == that.num * this.den;\n}\nNow both tests above pass.\n\n7.1 Equality and autoboxing\nComparing an object to a primitive value seems like a silly thing to do: of course they can‚Äôt ever be equal, right? But in the presence of generics (see Generics below), Java will automatically box primitives into their boxed object forms. And at that point, looking for, say, an int in", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0035", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": " a List<Integer> makes a lot of sense. Accordingly, Java ensures that the equals method on box types coincides with the == operation on the primitive values: if any two values are ==, their boxed forms are equals():\n\nlong val_x1 = 7L;\nlong val_x2 = 7L;\n\nLong box_x1 = 7L;\nLong box_x2 = 7L;\n\nassertTrue(val_x1 == val_x2); // primitive equality\nassertTrue(box_x1.equals(box_x2)); // logical equality of boxes\nassertTrue(box_x1.equals(val_x1)); // logical equality with auto-boxing\nUnfortunately, the == operator will not perform the same way for box types as it does for primitives. Consider: there are a lot of 64-bit long numbers, so allocating an object for each one is exorbitantly expensive. So the following will occur:\n\nLong x1 = 7L;\nLong x2 = 7L;\n\nLong y1 = 720_233_830_121_456L;\nLong y2 = 720_", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0036", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "233_830_121_456L;\n\nassertTrue ( x1.equals(x2) ); // for small enough numbers, Java\nassertTrue ( x1 == x2 ); // will ensure physical equality of boxed values\n\nassertTrue ( y1.equals(y2) ); // but when they get large enough,\nassertFalse( y1 == y2 ); // there is no such guarantee.\nSimilar caveats apply for other primitive types. This behavior is documented, though it might be confusing at first. Stick to equals() whenever possible, to avoid this confusion.\n7.2 Equality and hashing\nEquality is intended to mean that two variables ‚Äúbehave the same‚Äù in any scenario we care about. This implies that any equality implementation had better respect the following three rules:\n\nReflexivity: x.equals(x), always. (Unless of course x is null, in which case this crashes. See the notes on null below...)\nSymm", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0037", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "etry: if x.equals(y), then y.equals(x), always.\nTransitivity: if x.equals(y) and y.equals(z), then x.equals.(z), always.\n(It should be apparent that == obeys these three rules too.)\n\nJava includes one additional scenario in which we can observe objects: we can stick them inside hash tables, in which case Java relies on the int hashCode() method. Hashcodes have to obey the following consistency rules with respect to equality:\n\nCompatibility: If x.equals(y), then x.hashCode() == y.hashCode(). Contrapositively, if x.hashCode() != y.hashCode(), then !x.equals(y).\nNon-injectivity: Just because x.hashCode() == y.hashCode() doesn‚Äôt imply that x.equals(y). Contrapositively, just because !x.equals(y) doesn‚Äôt mean that x.hashCode() != y.hashCode().\nIn other words, the point of a hashcode is to quick", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0038", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "ly decide when two objects are not equal. If that quick check can‚Äôt tell them apart, then the full equals() method is needed.\n\nAlways override hashCode when you override equals, or you‚Äôre practically guaranteed to violate these rules.\n\nAs corollary of these rules, the hashCode() method should be a function of only the same fields that are used by equals() ‚Äî or else it‚Äôs trivial to violate compatibility. (Consider an implementation of Posn whose equals() method only checked its x-coordinate, but whose hashCode() method used its y-coordinate as well.)\n\nFortunately, Java provides several static methods to make constructing hash codes simple. In particular, each of the box types provides a static hashCode method, as shown here for doubles:\n\ndouble val_x = 314.1592;\nDouble box_x = 314.1592;\n\nas", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0039", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "sertTrue(box_x.hashCode() == Double.hashCode(val_x));\nThis takes care of most individual fields or variables. Additionally, there is a utility class named Objects that includes a convenience method\n\nint hash(Object... args):\n\nfinal class Posn {\n  private final int x, y;\n  ...\n  @Override\n  public int hashCode() {\n    return Objects.hash(x, y); // boxes x and y to Integers,\n    // then gets their hashCode()s, and combines them into a single result\n  }\n}\nThe actual mathematics of good hash functions are an interesting sub-domain of algorithms; for our purposes, it‚Äôs enough to know Java has good built-in defaults that we can use as needed.\n\nOf course, if our particular equality operation is more sophisticated than simply comparing fields, then this hashing approach won‚Äôt work. In particular, ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0040", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "if we used the same approach for Fraction as we just used for Posn,\n\nassertEquals(new Fraction(1, 2).hashCode(),\n             new Fraction(2, 4).hashCode()); // Fails\nWe need a hashcode that respects our equality relation. (Try implementing this one!)\n\n8 A Nuanced View\nIn this section we review some programming practices that have been previously banned/shunned, but can be meaningful if used judiciously.\n\n8.1 null is bad\nNot entirely true. More accurately, null is a pain to deal with. null simply means ‚Äúabsence of an object‚Äù. Since there is no object, using a variable that is null to call any methods results in a NullPointerException. This is more likely to happen when null is used to signify something (instead of nothing as it is supposed to). A classic example of such usage is null to si", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0041", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "gnal the end of a linked list. An implementation using a sentinel (a last bogus object that only means the end) avoids this pitfall. Thus in many cases the use of null can be avoided.\n\nOne of the few good use cases for null is when intending to create cyclic data. Here, use null to indicate that the cycle hasn‚Äôt been formed; document well by what point the cycle should be formed, and check for it early and fail quickly if an unexpected null value appears.\n\nNuanced advice: Use null only to mean ‚Äúno object exists‚Äù and use sparingly only in this context.\n\n8.2 == is bad\nNot exactly. With our more sophisticated understanding of the distinction between value types and reference types, just remember that == compares the immediate contents of variables and so provides physical equality comparisons", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0042", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": ".\n\nNuanced advice: Use this operator sparingly, recalling how it works. For reference types, use equals in most contexts.\n\n8.3 instanceof and casts are bad\nThe instanceof operator is used to determine if a given object has a specific type. This operator is overused to determine if the object can be used to call certain methods (in general, if the object has a specific functionality). This problem can be solved by designing the code better to exploit dynamic dispatch (letting the language determine which method to call, based on which object it has at runtime).\n\ninstanceof is useful in some specific situations, such as when overriding equals.\n\nNuanced advice: When you are contemplating determining the type of an object, think about whether you can avoid that by use of dynamic dispatch. Use ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0043", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "instanceof only when you can justify that knowing the type of an object is critical to what you are doing.\n\n9 Enumerations\nAn enumeration is a finite collection of values, all of which are known statically, and can therefore be given names. Enums are most useful when the set of values is reasonably small, and when each value‚Äôs behavior is uniformly the same.\n\n9.1 Simple enumerations\nA simple enumeration looks like this:\n\nenum TrafficLight { Red, Yellow, Green }\nUnder the covers, this actually defines a class named TrafficLight, a private constructor and three static fields. In other words, it‚Äôs effectively producing the following:\n\nfinal class TrafficLight {\n  private TrafficLight() { }\n  public static final TrafficLight Red = new TrafficLight();\n  public static final TrafficLight Yellow =", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0044", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": " new TrafficLight();\n  public static final TrafficLight Green = new TrafficLight();\n}\nBecause the constructor is private and the class is final, these three final fields are the only possible non-null values of this type. As a consequence, you can check which enum value you have using the == operator:\n\nTrafficLight nextLight(TrafficLight cur) {\n  if (cur == TrafficLight.Red) {\n    return TrafficLight.Green;\n  } else if (cur == TrafficLight.Yellow) {\n    return TrafficLight.Red;\n  } else if (cur == TrafficLight.Green) {\n    return TrafficLight.Yellow;\n  } else {\n    throw new IllegalArgumentException(\"Bad traffic light\");\n  }\n}\nJava allows you to use the switch statement for enums, which would be more idiomatic than the above code.\n\n9.2 Predefined methods on enums\nLike all classes, enums co", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0045", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "me equipped with toString method. The default implementation for enums is more useful than for other objects: it displays each value exactly as its name: for example, TrafficLight.Yellow.toString() equals \"Yellow\".\n\nJava also defines an ‚Äúinverse‚Äù function from toString: the static method valueOf essentially produces enum value from its name: you can write TrafficLight.valueOf(\"Red\") to obtain TrafficLight.Red. This method is case-sensitive and not tolerant of any typos: if you try TrafficLight.valueOf(\"green\") or TrafficLight.valueOf(\"weird\"), it will throw an IllegalArgumentException.\n\nLastly, Java defines a static method values on each enum, that returns an array of the values of the enum. In our example, TrafficLight.values() would produce new TrafficLight[]{ TrafficLight.Red, TrafficLi", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0046", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "ght.Yellow, TrafficLight.Green }. This can be particularly useful in combination with a for-each loop, to process all possible values of an enum in a uniform manner.\n\n9.3 More elaborate enumerations\nSometimes we would like to associate other values with a given enumerated value. For example, we can refer to the coins in the US currency as ‚Äúpenny‚Äù, ‚Äúnickel‚Äù, ‚Äúdime‚Äù and ‚Äúquarter‚Äù. But each of them also have a numeric monetary value (1, 5, 10, 25 respectively). What if we wanted to refer to them by name, but also perform arithmetic on their numeric values?\n\nJava allows us to associate values with enums, as the code snippet below shows.\n\nenum UsCoin {\n  // Define each named value, passing an argument into the constructor\n  Penny(1), Nickel(5), Dime(10), Quarter(25);\n  // semicolon is needed to", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0047", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": " separate the declarations above\n  // from the fields and methods below\n\n  // Define some fields:\n  private final int value;\n  // Define the constructor\n  UsCoin(int value) { this.value = value; }\n\n  // Define some methods\n  public int getCentsValue() { return this.value; }\n  @Override\n  public String toString() { return String.format(\"%d¬¢\", this.value); }\n}\nWe create a placeholder to store the numeric value associated with a given enum (private final int value). We take care to make it private because we do not want the association of an enum to its numeric value to change (e.g. a dime should always remain 10 cents). We would create an enum value the same way as before: UsCoin s = UsCoin.Dime;. However this results in Java employing the constructor above to associate the numeric value 10 ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0048", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "with s. Because the constructor is strictly for internal use and never explicitly called when creating enums, we make it non-public. Since its numeric value is stored as an instance variable we can write methods that access it.\n\n10 The switch statement\nOften we wish to check if a given variable has specific values, and take action according to them. We can do this by using if/else if...else statements. Java provides a more convenient statement for this purpose: the switch statement.\n\n10.1 A simple switch statement\nWe can modify the implementation of the nextLight in the above section as follows:\n\nTrafficLight nextLight(TrafficLight cur) {\n  switch(cur) {\n    case Red: return TrafficLight.Green;\n    case Yellow: return TrafficLight.Red;\n    case Green: return TrafficLight.Yellow;\n    defaul", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0049", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "t: throw new IllegalArgumentException(\"Bad traffic light\");\n  }\n}\nThe switch statement reads better in such cases. Because it is more brief than a sequence of if/else statements, it is often easier to debug.\nA switch statement simply states that the value being examined falls into one of several mutually exclusive cases. Switch statements may only be used with enum values, primitive values (mainly chars and ints) and (as of Java 7) String values.\n\n10.2 Fallthrough behavior\nWarning: the cases of a switch statement have fallthrough behavior. The case statement determines the entry point into a switch statement, but not an exit point.\n\nIn the code below, the second case will match, and so will print \"Got here\"...\n\nvoid badSwitchExample() {\n  switch(\"Oops\") {\n    case \"Won't happen\":\n      Sys", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0050", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "tem.out.println(\"doesn't run\");\n    case \"Oops\":\n      System.out.println(\"Got here\");\n    case \"Yay\":\n      System.out.println(\"Hooray\");\n    default:\n      System.out.println(\"Huh?\");\n  }\n}\n...and then continue to print \"Hooray\" and \"Huh?\". Although each case seems to ‚Äúend‚Äù as another case begins, the code will continue executing. If we want the switch statement to end at the end of a case statement, we must explicitly do so using a break statement.\nvoid goodSwitchExample() {\n  switch(\"Oops\") {\n    case \"Won't happen\":\n      System.out.println(\"doesn't run\");\n      break;\n    case \"Oops\":\n      System.out.println(\"Got here\");\n      break;\n    case \"Yay\":\n      System.out.println(\"Hooray\");\n      break;\n    default:\n      System.out.println(\"Huh?\");\n      break;\n  }\n}\nThe code above will ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0051", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "only print \"Got here\". (The break statement is actually more general, and can be used to escape loops, if statements, etc., and essentially jump to the nearest closing brace. You cannot use break statements to escape from a method body, though; that remains an error.)\n10.3 Default cases\nEvery switch statement must come with a default: case as its final case. This case is used when none of the other cases match the given value. For strings, characters and numbers, this makes sense: after all, there are a huge number of possible values for those types! For enums, it may seem weird, but remember that enum values are objects of a given class type, and null is unfortunately a potentially legal value of that type as well.\n\n11 Exceptions\nLet us look at the constructor of the Book class from Essen", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0052", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "ce of Objects. What would happen if we used it as follows:\n\nPublication rushdie = new Book(\"Midnight's Children\", \"Salman\nRushdie\",\"Jonathan Cape\", \"London\", -1980);\nWe have attempted to create a Book object with a negative year. A negative year does not make sense in the given context. Java was not able to catch this error because -1980 is a valid number. Ideally the constructor should inform its caller ‚Äúthou shall not pass me a negative number for the year,‚Äù instead of using the number and creating an object that has an invalid year of publication. Exceptions allow us to do that.\n\nAn exception occurs when something unexpected happens, whether it be invalid input, an operation that cannot be completed (e.g. the square root of a negative number) or even something that is beyond our control", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0053", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": " (e.g. attempting to read from a file that no longer exists). Exceptions offer us a dignified way of aborting a method and sending a message to its caller that something went wrong.\n\n11.1 Writing a method with exceptions\nIn the constructor, an exception should occur if a negative number is passed as the year of publication of the book. We can change its signature to the following:\n\n/**\n * Constructs a {@code Book} object.\n *\n * @param title     the title of the book\n * @param author    the author of the book\n * @param publisher the publisher of the book\n * @param location  the location of the publisher\n * @param year      the year of publication\n * @throws IllegalArgumentException if the year is negative\n */\npublic Book(String title, String author,\n            String publisher, String loca", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0054", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "tion, int year)\n            throws IllegalArgumentException {\n  if (year < 0) {\n    throw new IllegalArgumentException(\"Year of publication \"+\n    \"cannot be a negative number\");\n  }\n  this.title = title;\n  this.author = author;\n  this.publisher = publisher;\n  this.location = location;\n  this.year = year;\n}\nJava has many kinds of exceptions. Since our problem here is an invalid argument, we use the IllegalArgumentException class.\n\nThe method signature explicitly declares that it may throw an IllegalArgumentException object. A method can throw multiple types of exceptions, declared in its signature separated by commas. The Javadoc-style comments document this possibility.\n\nBefore initializing the fields we check if the year passed to the constructor is negative and if so, we throw an except", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0055", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "ion. This involves creating an IllegalArgumentException object with a helpful message in it and throwing it.\n\nThis method now works as follows:\n\nIf the year is not negative, the constructor does not throw an exception and initializes the object, as before.\nIf the year is a negative number, the method aborts on the line throw new IllegalArgumentException(...);. It will not return anything.\nA method may throw multiple types of exceptions, and it may declare some or all of them in its method signature.\n\n11.2 Calling methods that may throw exceptions\nLet us test this constructor, specifically by passing it a negative year. Whenever a method is called that may throw one or more exceptions we can enclose it in a try-catch block as follows:\n\nPublication rushdie;\n\ntry {\n  rushdie = new Book(\"Midni", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0056", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "ght's Children\", \"Salman Rushdie\",\n  \"Jonathan Cape\", \"London\", -1980);\n}\ncatch (IllegalArgumentException e) {\n    //This will be executed only if an IllegalArgumentException is\n    //thrown by the above method call\n}\nThus we try to call such a method, and if an exception is thrown we catch it. If no exception is thrown then the catch block is ignored.\n\n11.3 Checked and unchecked exceptions\nJava has two categories of exceptions: checked and unchecked. If there is a chance that a method may throw a checked exception (either using the throw clause or by calling another method that throws it) Java mandates that the method do one of two things. Either the method must catch the exception using a try-catch block, or it must explicitly declare in its method signature using a throws clause that it", "topics": ["command"]}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0057", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": " may throw this exception to its caller. This is not mandated for unchecked exceptions. IllegalArgumentException and ArrayIndexOutofBoundsException are examples of unchecked exceptions, whereas FileNotFoundException is a checked exception.\n\nIf a method can throw an exception to its caller, it is a good idea to declare it explicitly in its signature using the throws clause irrespective of whether the exception is checked or not. This informs the client explicitly so that it may address it (e.g. by enclosing a call to this method in a try-catch block).\n\nMore information about exceptions is available in the Java documentation.\n\n12 Generics, or raw types considered harmful\n12.1 What are they?\nIn early versions of Java (prior to 1.5), programmers could not write a type that meant, ‚ÄúI represent ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0058", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "a homogeneous list of items of the same type, regardless of that type.‚Äù Programmers instead had the dubious choice of implementing the ‚Äúsame‚Äù list classes over and over again (for numbers and strings and booleans and whatever other data types they needed), or they could write a list implementation once and declare the fields inside to contain Objects ‚Äî and rely on instanceof and casting to trick the compiler into treating the data as having some particular type. This approach is quite obviously error-prone: since everything is a subtype of Object, anything could be placed into these lists whether or not they were uniform. Conversely, casting down from Object to some particular type defered any possible errors until runtime, rather than catching them at compile-time as desired.\n\n12.2 How ca", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0059", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "n we use them?\nInstead of this mess, Java 1.5 introduced generic types. Programmers can now write\n\ninterface List<T> {\n  T get(int index);\n  void set(int index, T newVal);\n  ...\n}\n\nclass LinkedList<T> implements List<T> {\n  T first;\n  List<T> rest;\n  public T get(int index) {\n    if (index == 0) return this.first;\n    else return this.rest.get(index - 1);\n  }\n  public void set(int index, T newVal) {\n    if (index == 0) this.first = newVal;\n    else this.rest.set(index - 1, newVal);\n  }\n  ...\n}\nThis interface describes homogenous lists whose elements are all of type T. The class LinkedList<T> asserts that implements this interface, regardless of the element type: it is generic enough to work for all possible types. We can also have a non-generic class that implements a generic interface for", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0060", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": " a particular type:\n\nclass IntListLength3 implements List<Integer> {\n  int first, second, third;\n  ...\n}\nJust as we can have generic interfaces and classes, we also can have generic methods. For instance, we might add a map method to our list interface:\n\ninterface List<T> {\n  ...\n  <U> List<U> map(Function<T, U> func);\n}\nThis method says it can transform the current List<T> into a new List<U>, for any type U, as long as the user provides a function transforming Ts into Us. Note that this method is generic independently from the interface: contrast the signature above with the following, broken one:\n\ninterface BrokenList<T, U> {\n  ...\n  BrokenList<U, ???> map(Function<T, U> func);\n}\nThis second interface describes ‚Äúlists with element type T that can be transformed into Us.‚Äù In other words, ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0061", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "we would have to know both the element type and the future transformed element type at the moment we created the list, which rather defeats the purpose of such a generic method. Worse, we can‚Äôt even fill in the signature completely, since we don‚Äôt know what type our U-list can turn into!\n\n12.3 Nuances\n12.3.1 Mostly leaving out the type parameters ‚Äî the ‚Äúdiamond operator‚Äù\nWriting out generic types rapidly gets unwieldy, since we have to write the type parameters twice:\n\nMap<String, Integer> myMap = new HashMap<String, Integer>();\nIn most cases, Java can infer the type parameters for us on the right-hand side of this variable declaration, so we can leave them out:\n\nMap<String, Integer> myMap = new HashMap<>();\nThis so-called ‚Äúdiamond operator‚Äù was added in Java 7, and helps enormously when t", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0062", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "he types get more intricate.\n\nNote that sometimes Java can‚Äôt figure out the type parameters for us. For example, there exists a static method <T> List<T> Arrays.asList(T... args) (see The static keyword?) and Arrays), that takes an arbitrary number of arguments and turns them into a List. There exists another static method, <T> void Collections.shuffle(List<T> list), that shuffles the elements in the given list. Trick question: what is the type T in the call Collections.shuffle(Arrays.asList())? Since there are no elements present, the compiler has nothing to use to guess the type parameter. In situations like this, we can manually specify the type argument: Collections.<Integer>(Arrays.asList()).\n\nAnother case where Java occasionally guesses wrong is when the declaration on the left-hand ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0063", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "side uses a supertype as the type parameter, but the right-hand side value uses only subtypes:\n\nList<Shape> shapes = Arrays.asList(new Circle(), new Circle());\nIn cases like these, you will need to specify the type parameter manually, because Java will not accept a List<Circle> as a List<Shape> ‚Äî see Generics and mutability below.\n\n12.3.2 Entirely leaving out the type parameters ‚Äî ‚Äúraw types‚Äù\nBecause Java prior to 1.5 did not have generic types, and because Java emphasized backwards compatibility, you could technically write\n\nList shapes = new List();\nDon‚Äôt. Ever.\n\nYou can actually configure IntelliJ to warn you about inadvertent uses of raw types, and make them be a compile-time error:6\n\nGo to File -> Settings.\nIn the Settings dialog that pops up, navigate on the left to Editor -> Inspect", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0064", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "ions.\nIn the resulting window, type ‚Äúraw‚Äù into the search bar on the right-hand side:\n\n\nSelect the two items under Java, namely ‚ÄúRaw types can be generic‚Äù and ‚ÄúRaw use of parameterized class‚Äù (highlighted blue in the screenshot above). Check the checkboxes, and then in the Severity dropdown, choose Error for each one. Click ok.\nTo make this the default for all new projects, repeat this process starting with File -> Other settings -> Settings for new projects.\n12.3.3 Wildcards\nIn some circumstances, a library method might take in a parameter with a generic type, but nevertheless not depend on that type at all. For instance, consider writing a method to print out a list of values:\n\n<DontCare> void printList(List<DontCare> list) {\n  for (DontCare value : list) {\n    System.out.println(value.t", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0065", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "oString());\n  }\n}\nHere, we‚Äôre only using methods that come from Object, so we really don‚Äôt care what the actual element type of the list is. However, we can‚Äôt say List<Object>, because then we wouldn‚Äôt be able to pass in lists of anything other than objects (again, see below). So we‚Äôre forced to mention a type parameter, but we don‚Äôt need to use it. In cases like these, Java will let us use the question-mark as a type parameter instead:\n\nvoid printList(List<?> list) {\n  for (Object value : list) {\n    System.out.println(value.toString());\n  }\n}\nQuestion marks are slightly less precise than type parameters, though. Suppose we had a method <T> List<T> copy(), that cloned the current list. Then the following two methods are different in meaning:\n\nList<?> copyAndReverse1(List<?> list) {\n  List", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0066", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "<?> dupe = list.copy();\n  dupe.reverse();\n  return dupe;\n}\n\n<T> List<T> copyAndReverse2(List<T> list) {\n  List<T> dupe = list.copy();\n  dupe.reverse();\n  return dupe;\n}\n\nList<Integer> nums = ...;\nList<Integer> broken = copyAndReverse1(nums);\nList<Integer> works  = copyAndReverse2(nums);\nThe broken case fails because we‚Äôve lost the connection between the input argument type and the output type. The final case works because the generic types are preserved through the whole snippet of code.\n\nQuestion marks seem rather esoteric, but they‚Äôre useful in the following circumstances.\n\n12.3.4 Generics and mutability\nLet‚Äôs examine a list of shapes again, and let‚Äôs sort the list by area. Surely, this sorting method would work for lists of all shapes, or lists of only circles, or lists of only squares,", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0067", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": " etc. However, the following code will not compile:\n\nvoid sortShapes(List<Shape> shapes) { ... }\n\nList<Circle> circles = ...\nsortShapes(circles);\nJava will complain that a List<Circle> is not a List<Shape>, and rightly so! Suppose we wrote the following malicious code:\n\nvoid bad(List<Shape> shapes) {\n  shapes.add(new Square(...));\n}\n\nList<Circle> circles = ...\n\nbad(circles);\nBecause of aliasing and mutation, our bad method has managed to sneak a Square into a list of only circles. If the code then tried to get the radius of that ‚Äúcircle‚Äù, it would crash, since that shape really isn‚Äôt a circle at all. In order to prevent this, Java is forced to say that treating a List<Circle> as a List<Shape> is prohibited.\n\nBut what about our sorting function? It clearly should work, and part of the reaso", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0068", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "n why is that it doesn‚Äôt construct arbitrary new shapes and mutate the list to contain them: it only rearranges things that were already in the list. So we‚Äôd like to say that the sorting method for lists of anything that‚Äôs a subtype of Shape, which we can do as follows:\n\nvoid sortShapes(List<? extends Shape> shapes) { ... }\nThis new ‚Äú? extends Shape‚Äù syntax, called a bounded generic type lets us read from the list and know that it must be a Shape, but it doesn‚Äôt let us put anything new into the list, because the actual element type of the list is just a question mark.\n\nActually attempting to write this sorting method, though, is tricky: we need to iterate over the list, but we don‚Äôt know what type the elements are. So we can use another variant of this bounded generic type, as follows:\n\n<S", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0069", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": " extends Shape> void sortShapes(List<S> shapes) {\n  for (int i = 0; i < shapes.length(); i++) {\n    S shape_i = shapes.get(i);\n    for (int j = i + 1; j < shapes.length(); j++) {\n      S shape_j = shapes.get(j);\n      if (shape_j.area() < shape_i.area()) {\n        shapes.put(i, shape_j);\n        shapes.put(j, shape_i);\n      }\n    }\n  }\n}\nThis example demonstrates a lot of nuanced type behavior. We create a type variable, S, and say that it is definitely some subtype of Shape. This permits us to call the area methods later on. Additionally, the two calls to put succeed because we know that our list contains a bunch of S values, and the only way we can get such values is by reading them from the list in the first place, so we can put those values back into the list.\n\nHowever, we cannot crea", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0070", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "te new shapes from scratch here, because writing something like new S() is meaningless: S isn‚Äôt the name of any class!\n\nIn a very real sense, this use of extends allows us to create read-only generic types. There is a dual notion to extends, that allows us to create write-only generic types. For instance, the following code will work:\n\nvoid blowBubbles(List<? super Circle> output) {\n  for (int i = 0; i < 10; i++) {\n    output.add(new Circle(i));\n  }\n}\nNow we can add a bunch of circles to a List<Circle> easily enough, but we can also add them to a List<Shape>, since Shape is indeed a supertype of Circle. We could even add circles to a List<Object>. However, we cannot read out any elements from this output list and call methods on them, because we don‚Äôt know what their actual classes are. In", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0071", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": " particular, we cannot for example call the radius method on this List<? super Circle>, because not everything in the list is guaranteed to be a Circle. We can‚Äôt even call the area method, because they might not even all be Shapes!\n\nUsing wildcards and bounded generics is definitely an advanced skill, and one that is only needed occasionally ‚Äî but when it‚Äôs useful, it‚Äôs indispensable! The primary design choice to make, from the outset, is whether you plan to read from a generic data source, or write to one, or both.\n\n13 JUnit\n13.1 Review: the tester library\nComing from Fundies 2, you already are familiar with using the tester library to write test cases: something like\n\nclass ExamplesWhatever {\n  // various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  void setupTestFixture() {\n", "topics": ["mvc", "testing"]}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0072", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "    // reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n  // old-style test method\n  boolean testSomething(Tester t) {\n    this.setupTestFixture();\n    return t.checkExpect(this.someData, 5, \"Is it five?\")\n        && t.checkConstructorException(new IllegalArgumentException(\"No tens!\"),\n                                       \"Foo\",\n                                       10)\n        && t.checkException(new RuntimeException(\"Boom\"), this.aClassThatThrows, \"explode\");\n  }\n  // new-style test method\n  void testSomething(Tester t) {\n    this.setupTestFixture();\n    t.checkExpect(this.someData, 5, \"Is it five?\");\n    t.checkConstructorException(new IllegalArgumentException(\"No tens!\"),\n                                \"Foo\",\n                            ", "topics": ["testing"]}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0073", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "    10);\n    t.checkException(new RuntimeException(\"Boom\"), this.aClassThatThrows, \"explode\");\n  }\n}\nA test class needs to accomplish several things:\n\nIt must correctly reinitialize a test fixture to ensure every test runs in a consistent environment (especially when mutation is involved);\nIt must be able to test whether some expression evaluates as expected;\nIt must be able to check for exceptions that occur in constructing objects;\nAnd it must be able to check for exceptions that occur in method invocations.\nThe tester library in Fundies 2 provided a simplified API for such activities. In this course, we‚Äôll introduce you to JUnit, the widely-used standard library for such things, and the support for it that‚Äôs built into IntelliJ. This isn‚Äôt quite a language feature‚ÄîJUnit is still a libra", "topics": ["testing"]}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "ry‚Äîbut it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; // used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; // used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  // various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    // reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT", "topics": ["testing"]}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0075", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "est() {\n    this.aClassThatThrows.explode();\n  }\n}\n13.2 Simple tests\nThe first thing to notice is the two import statements at the top; these are needed to define the assertions and annotations used by JUnit tests.\n\nSecond, JUnit does not impose any naming convention (\"ExamplesBlah\", \"testWhatever\"). Instead, we simply mark our test methods with the @Test attribute.\n\nThe analogue of t.checkExpect is simply assertEquals. Its arguments are in exactly the reversed order from the tester library‚Äôs order: first, an optional description of the test case, followed by the expected value of the test, and finally the actual value. (Technically, the first argument isn‚Äôt optional; rather, there are several overloaded assertEquals methods, of which only some include the description string.)\n\nThe assertE", "topics": ["testing"]}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0076", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "quals testing form compares its arguments using their .equals method. Keep this firmly in mind, as it is quite different from the tester library. That library provided a structural equality comparison by default, because we were using it before we‚Äôd defined how equality actually worked. Here, now that we know the distinctions between == and .equals, JUnit doesn‚Äôt impose any particular regimen on us; it‚Äôs up to us to define what we mean.\n\nAmong other things, look again at the notes about comparing arrays for equality above. Because arrays are not objects, they do not have a .equals method, so JUnit provides a customized assertArrayEquals method for comparing arrays for equality element-by-element, rather than by aliasing.\n\n13.3 Test fixtures\nWriting a test fixture is still our responsibilit", "topics": ["testing"]}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0077", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "y. However, rather than having to remember to call it manually in every test method, we simply mark the test fixture with @Before. JUnit will call it for us automatically before each @Test method.\n\n13.4 Testing for exceptions\nThe tester library had some rather ungainly mechanisms for testing exceptions: we passed in the exact exception we expect, followed by either the name of the class or the object and the name of its method, followed by the arguments to be passed in to the constructor or the method. (We couldn‚Äôt explain at the time, but checkConstructorException and checkException both accepted a varargs list of arguments...) This was particularly annoying if there was a typo in the method name, or a type error in the parameters passed in, as there was no compile-time checking to let us", "topics": ["testing"]}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0078", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": " know of our mistake.\n\nJUnit has a much simpler mechanism. We elaborate the annotation before the method with the expected exception‚Äôs class:\n\n@Test(expected = IllegalArgumentException.class)\nand then simply invoke the constructor or method as normal. The JUnit framework will wrap every test method in a try-catch statement, and check that an exception is indeed thrown and that its class exactly matches the one specified. This means we need to get the exception exactly correct, no subclassing permitted here, but we don‚Äôt have to worry about the precise error message itself, and the same technique works for exceptions thrown both by constructors and by methods. JUnit has additional mechanisms for checking exceptions, but this is the simplest and easiest to use.\n\nNote that this mechanism impl", "topics": ["decorator", "testing", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0079", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "ies that testing will stop at the first exception thrown in each test method, because throwing exceptions short-circuits evaluation (much like how a single test failure short-circuited tests in the tester library, in the old-style boolean test methods). If you want to test multiple exceptions, you must write multiple test methods: one per exception. Or, you can write your own try-catch statements, and write an assertEquals in the catch block that examines the exception object...but this is error-prone to forgetting that if the catch blok doesn‚Äôt run then the test should have failed. The common case is simply to write multiple test methods.\n\n(In hindsight, we can see why the tester library needed to be implemented the way it was: at the time, we didn‚Äôt have try-catch statements. Since the t", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0080", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "ester library was implemented entirely via methods on the Tester class, such methods would not have the ability to catch exceptions that were thrown during the evaluation of their arguments. Hence, we passed in the names of the things to be evaluated by the tester on our behalf, and internally it would use a try-catch statement to handle the exceptions. JUnit uses a different mechanism, namely method annotations, that allow it to effectively insert the try-catch statements around every method for us, leading to the cleaner API.)\n\n1When the array gets very large, this may not be entirely true due to practical memory considerations.\n\n2Note that List is an interface, and the venerable ArrayList is one class that implements it.\n\n3There‚Äôs a twist, though: some methods, such as String.indexOf(in", "topics": ["testing"]}
{"chunk_id": "data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0081", "source": "data\\raw\\notes\\Lecture 5 Java Safari.txt", "text": "t), take ‚Äúcharacters‚Äù represented as type int rather than type char, because it turns out that the Java char type doesn‚Äôt have enough bits to represent every Unicode code point. However, because chars are implicitly converted to ints, you can use a character where an integer is expected with no trouble. (In the other direction it requires a cast, which is lossy because some int values don‚Äôt fit in char)\n\n4Not just variables, because everything below applies to method parameters and results as well.\n\n5What is a reference? Most likely it‚Äôs just the memory address of the object, like a pointer in C or C++‚Äîthough there are optimizations that can make the situation less simple.\n\n6I do not know why this isn‚Äôt the default! It should be.", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0000", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "Lecture 6: The Model\nSlides\n\nOverview of lecture\nThis lecture introduces a central high-level design: the model-view-controller (MVC). MVC or one of its variants are used in a wide variety of applications, ranging from games and productivity applications to web-based applications. This lecture also walks through the design of a model for some simple games. Finally it motivates and explains the builder design pattern.\n\n1 Introduction\nSuppose you wanted to implement a graphical game. Where would you start, and how would you structure your program? A common object-oriented technique for structuring graphical programs is the model‚Äîview‚Äîcontroller pattern, which separates the program into three distinct but cooperating components,\n\nthe controller, which takes input from the user and decides wha", "topics": ["mvc", "decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0001", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "t to do,\nthe view, which knows how to display the game interface to the user,\nthe model, which represents the state of the game internally and (often) enforces its rules.\n\n\nGeneralizing this concept to other kinds of programs, the model implements the actual functionalities offered by the program. The view is the part of the program that shows results to the user. The controller takes inputs from the user and tells the model what to do and the view what to show. Take the IDE you are using to write programs as an example (IntelliJ). The view shows the source code, the project structure and the console output. The controller is the part that decides what to do when you select ‚ÄúRun‚Äù or ‚ÄúFile->Open‚Äù and tells others parts of the program to actually carry out the operations. The model is the pa", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0002", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "rt that you cannot see, but one that actually compiles, runs and debugs your program (or works with other programs that do).\n\n\n\nThe MVC design allows you to isolate the entire behavior of your program into categories: actual functionality, user display and user interaction and delegation. Practically each class you will design for the program should fall in exactly one of the model, view or controller. A badly implemented MVC design would be if a class mixes operations (e.g. a class that implements a functionality and prints the result, a class that shows a menu and implements some of its offered operations, etc.). This is illustrated in the figure above. Thus the MVC design, when used correctly, promotes cohesion.\n\n\n\nThe MVC design also mandates which components can directly use other com", "topics": ["mvc", "decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0003", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "ponents. Since the model, view and controller have separate functions, access to each other is also restricted. Typically the model and the view cannot directly access each other, and the controller communicates with both. In many programs the view cannot ask the controller for data: the controller decides when to provide data to it. This is illustrated in the figure above. In doing so, the MVC design promotes low coupling between groups of classes.\n\nAnother way to think about the merits of MVC is what each part does not do:\n\nModel:\n\nWhat it does: implements all the functionality\nWhat it does not do: does not care about which functionality is used when, how results are shown to the user\nController:\n\nWhat it does: takes user inputs, tells model what to do and view what to display\nWhat it do", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0004", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "es not do: does not care how model implements functionality, does not care how the screen is laid out to display results\nView:\n\nWhat it does: display results to user\nDoes not do: does not care how the results were produced, when to respond to user action\nMost of the code you have developed in this and previous courses thus far would belong to the model, so we can treat the model as a good starting point.\n\n2 An introductory example: Tic-tac-toe\nFor the unfamiliar, Tic-tac-toe is a two-player game played on a 3-by-3 grid, where the players alternately mark cells of the grid. A player wins by making a line of three marks, or if the grid fills with no winner then the result is a tie. For example, here a sequence of game states in which player ‚ÄúX‚Äù wins:\n\n\n\n2.1 Object-oriented analysis\nIn order ", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0005", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "to design a model for a Tic-tac-toe game, we need to consider who the client (user) of our model is. This is going to be another class likely in the controller, not the human player of the game! This client will need to perform to manipulate and query the game state. What do we need to be able to do? These operations should suffice:\n\nPlay a move as X.\nPlay a move as O.\nFind out whose turn it is.\nFind out the contents of the grid, perhaps in order to display it.\nFind out whether the game is over, and if so, who the winner is, if any.\nBecause we want the model to enforce the rules of the game, we should also consider ways in which clients should not be able to manipulate the model. The following are problematic cases during game play:\n\nAttempting to play out of turn.\nAttempting to play in a ", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0006", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "cell that already has a mark.\nAttempting to play after the game has ended.\nAttempting to play in a cell that doesn‚Äôt exist (if the interface allows that to be expressed).\nWe can address these cases using a three-step approach:\n\nPrevent the situation from ever happening, by careful design. If this is possible it means no further code needs to be written to ‚Äútake care‚Äù of this situation.\nIf prevention is not possible, detect the situation has happened and throw an exception.\nHaving completed our analysis, we can now begin to design an interface for the Tic-Tac-Toe model.\n\n2.2 Designing an interface\nWe have a number of choices for how to realize the operations above as methods in Java. Let‚Äôs start with a method or methods for playing moves.\n\n2.2.1 How to move\nIn one possible design, we could ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0007", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "provide separate methods for playing as X and playing as O:\n\n/**\n * Places an X mark in the specified cell.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if it's O's turn, if the game is\n * over, or if there is already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n */\nvoid moveAsX(int column, int row);\n\n/** ...same as above, but for O... */\nvoid moveAsO(int column, int row);\n(Note: is the Javadoc above any good? What is left unclear, that ought to be specified more carefully?)\n\nWith the above design, the model must throw an exception if its client calls moveAsX when it is O‚Äôs turn or moveAsO when it is X‚Äôs turn.\n\nAlternatively, because the model must track whose turn it is, we could ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n */\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven‚Äôt said how the", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0009", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": " column and row coordinates map onto the grid. (Are they zero- or one-based? How are they oriented?1)\n\n2.2.2 Whose turn is it?\nIn order to allow the client to find out whose turn it is, we also have several choices. One simple way is a boolean method or methods to ask if it is a particular player‚Äôs turn:\n\n/**\n * Determines whether it is player X's turn to move.\n *\n * @return whether X can play now\n */\nboolean isXsTurn();\n\n/** ...same as above, but for O... */\nboolean isOsTurn();\nEven within the above approach, we have a design choice: What should the methods do if called once the game is over? They could return false, or they could throw an exception; either way, we ought to document this choice. Which do you prefer, and why?\n\nAnother way would be to have the method return some representat", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0010", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "ion of the player whose turn it is, like so:\n\n/**\n * Returns the player whose turn is next.\n *\n * @return the next player\n * @throws IllegalStateException if the game is over\n */\n? nextPlayer();\nThere are a variety of choices we could use for the return type ?. Which of these do you prefer, and why?:\n\ntype char, with 'X' for X and 'O' for O\nclass String, with \"X\" for X and \"O\" for O\ntype boolean, with true for X and false for O\ntype boolean, with true for O and false for X\nan enumeration defined as enum Player { X, O }\nUsing type char is a poor design choice, because the char type has many other values that don‚Äôt stand for valid players. Java‚Äôs type system will not help us in preventing nextPlayer from returning meaningless values‚Äîso then what should we do if it does? More to the point, th", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0011", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "e char type is good for representing textual characters, and (ab)using it for other meanings is unstylish.\n\nUsing a String is even worse, because it has all the same drawbacks as using a char, except it has even more possibilities, including null, the empty string, and longer strings. (Important guideline you should always follow: Strings are for representing textual information, where the possible values are many or unlimited and not known ahead of time. If you find yourself using strings to represent some small set of values, or for any kind of internal API communication that is never presented to the user, you are doing it wrong.)\n\nThe boolean idea solves the main problems that we saw with char and String: there are exactly two Boolean values, and we need two values. However, boolean co", "topics": ["gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0012", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "uld be confusing, because which player is true and which false is non-obvious. In general, we should use booleans only when the value we are trying to represent is a truth value.\n\nFinally, we come to the enumeration, which declares a new class Player having exactly two values, Player.X and Player.O. This expresses very clearly what the possibilities are and what they mean. One caveat with enumerations, though: switch statements over enumerations always require a default case, even if every current possibility appears in some other case. This is because Java assumes an open world, in which more values can be added to an enumeration at a later time.\n\n2.2.3 Getting the grid\nWe want our model to enforce the rules of the game. This is not because we expect untrustworthy users to interact with i", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0013", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "t directly‚Äîall their interactions will be mediated by the view and the controller‚Äîbut because enforcing model integrity within the model class provides a good separation of concerns. The code that represents the state of the game is the right place to write the logic for how that state may evolve, and encapsulating this logic in the model will make the rest of our program simpler and less error-prone.\n\nIn order to enforce the rules and prevent client code from corrupting the state of the grid, we need to ensure that all changes to the state happen via our model class‚Äôs public methods, which will enforce the rules. Thus, we cannot merely return a reference to our internal mutable representation of the grid to the client, because then the client could change it. However, we can safely return", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0014", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": " a copy of the grid (which need not be the same type as what we use internally):\n\n/**\n * Returns a two-dimensional array representing the state of the\n * grid. The first index is the column and the second the row.\n * The resulting array is newly allocated and unconnected to the model;\n * thus, mutating it will have no effect on the model or subsequent\n * calls to {@code getGrid}.\n *\n * @return a copy of the grid\n */\nPlayer[][] getGrid();\nAlternatively, rather than return some representation of the grid, we could provide some means of querying it:\n\n/**\n * Returns the {@link Player} whose mark is in the cell at the given\n * coordinates, or {@code null} if that cell is empty.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @return a {@code Player} or {@code ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0015", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "null}\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n */\nPlayer getMarkAt(int column, int row);\n2.2.4 Finding out the results\nFinally, we need some way to find out when the game is over and who, if anyone, won. Unlike the previous operations, there isn‚Äôt much room in this design space (though there are a few sensible alternatives). We will have one method to ask whether the game is over and another to ask who has won:\n\n/**\n * Determines whether the game is over.\n *\n * @return whether the game is over\n */\nboolean isGameOver();\n\n/**\n * Returns the winner of the game, or {@code null} if the game is a\n * tie.\n *\n * @return the winner or {@code null}\n * @throws IllegalStateException if the game isn't over\n */\nPlayer getWinner();\nIn a game that does not admit ties, could thes", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0016", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "e methods be combined into one? Is that a good idea?\n\n2.3 Implementation\nTic-tac-toe is a very simple game, yet designing the interface to the model can still be an involved process. Some decisions are consequential, some not, and we might not be able to tell which is which until we start attempting to implement or even use the interface. However, whatever interface design we might choose, much of the hard work is now done, and implementing the interface is a simple matter of programming.\n\n3 A bigger example: Connect N\nAs our second example, we consider the game Connect N, which is a generalization of the game Connect Four. In Connect Four, two players take turns dropping tokens (white for one player and red for the other) into a vertical 7-by-6 grid. The first player to form a line of fou", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0017", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "r or more of their tokens, horizontally, vertically, or diagonally, wins the game. For Connect ùëÅ\n, we will allow the dimensions of the grid, the line length necessary to win, and the number of players to be configurable rather than fixed.\n\nFor example, here is a sequence of game states for two-player, 3-by-4 Connect Three in which Player W wins:\n\n\n\n3.1 Object-oriented analysis\nWe begin our design once again by considering what operations the model must provide and what exceptional conditions the operations will detect. The operations are somewhat similar to Tic-tac-toe‚Äôs operations. We need ways to:\n\nPlay a move as a particular player. (How will we represent players when the number isn‚Äôt fixed at two?)\nFind out about the configuration parameters of the game, including:\nthe dimensions of th", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0018", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "e grid,\nthe goal line length needed to win, and\nwho the players are.\nFind out about the state of the game, including:\nwhose turn it is,\nthe contents of the grid,\nwhether the game is over,\nand if so, who the winner is, if any. (Connect N, like Tic-tac-toe, allows for ties.)\nWe need to reject bad moves, including playing out of turn, playing in a non-existent column, or playing in a column that is already full to the top. Additionally, we may want to make it an error to ask for the winner before the game is over, or to ask for the next player after the game is over.\n\n3.2 Interface design\nBecause several methods will deal with players, one of the first decisions we must make is how to represent the players and their tokens. One simple way would be with integers counting up from 0. However, we", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0019", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": " will make the model slightly richer by associating a name, represented as a String, with each player. The set of players and their turn order will be represented as a String[], with most methods representing each player as an index into that array.\n\n3.2.1 How to move?\nTo take a turn, it is sufficient to select which column the current player wants to play in. However, as an extra check, we will have the move method also take the int representing the player who is moving, which the model then checks before allowing the move. Thus:\n\n/**\n * Plays a move. Given the player (whose turn it must be) and the column\n * number (zero-based from the left), attempts to add a token for that\n * player to that column. If this move ends the game then the game state\n * is updated to reflect that. Because it", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0020", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": " may be useful to the client,\n * this method returns the row number where the token lands.\n *\n * @param who    the player who is moving\n * @param where  which column to play in\n * @return the row where the token ends up\n *\n * @throws IllegalStateException if the game is over\n * @throws IllegalStateException if it isn't {@code who}'s turn\n * @throws IllegalStateException if the requested column is full\n * @throws IndexOutOfBoundsException if the requested column does not exist\n */\nint move(int who, int where);\n3.2.2 Querying the configuration\nAlthough presumably the client must specify the game configuration when instantiating the game model, it may be useful to allow the client to ask the model for this information. (Why?) Thus, we will have methods that return the width and height of the ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0021", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "grid, the goal line length, and the sequence of players:\n\nint getWidth();\n\nint getHeight();\n\nint getGoal();\n\nString[] getPlayers();\nIt‚Äôs important that getPlayers() return a copy of the array held by the model object rather than the array itself, since returning the array itself would then allow the client to modify the model‚Äôs private state.\n\n3.2.3 Querying the game state\nThe game is always in one of three different statuses:\n\nPlaying, when the game isn‚Äôt over yet,\nStalemate, when the game has ended in a tie, and\nWon, when the game has ended with a winner.\nIn order to communicate these statuses to the client, we will declare an enumeration within the game model class:\n\npublic static enum Status { Playing, Stalemate, Won }\nWe make the enumeration public so clients can see it, and static be", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0022", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "cause it‚Äôs the same for every game instance.2 Then in order to check the status, the client can use the getStatus method; as a convenience we will also define an isGameOver method:\nStatus getStatus();\n\n/**\n * Determines whether the game is over.\n *\n * @return whether the game is over\n */\nboolean isGameOver();\nWhen the game isn‚Äôt over, we can ask which player‚Äôs turn it is, and when the game has a winner, we can ask who the winner is:\n\n/**\n * Returns the winner of the game.\n *\n * <p><strong>PRECONDITION:</strong> the game is over and has a winner\n *\n * @return the winner\n * @throws IllegalStateException if {@code getStatus() != Status.Won}\n */\nint getWinner();\nFinally, we need a way for the client to observe the contents of the grid. This time we will provide a way to query the token at any ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0023", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "given cell position. Because some cells may be empty of tokens, we need some way to distinguish empty cells from player numbers. The wrapped integer type Integer includes null, so we use Integer instead of int for the result with null representing empty cells.\n\nAdditionally, we will include a convenience method3 for asking whether a particular column is full.\n\n/**\n * Gets the player whose token is at the given column and row. The\n * coordinates are zero-based and start in the lower left. Returns\n * {@code null} if there is no token in the given position.\n *\n * @param x the column coordinate ({@code 0 <= x < width})\n * @param y the row coordinate ({@code 0 <= y < height})\n * @return the player in the given position, or {@code null}\n * @throws IndexOutOfBoundsException if (x, y) is out of bo", "topics": ["decorator", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0024", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "unds\n */\nInteger getPlayerAt(int x, int y);\n\n/**\n * Determines whether the specified column is full and thus cannot be played\n * in.\n *\n * @param which the column to check\n * @return whether column {@code which} is full\n */\nboolean isColumnFull(int which);\n4 Configuring the model: the Builder pattern\nNote: for more on the Builder pattern, see Bloch, Item 2.\n\nWe designed our Connect N game to have some flexibility in its parameters, so it‚Äôs worth discussing how a client can select those parameters when instantiating the model. We could, of course offer a constructor that takes all of the parameters that are allowed to vary:\n\n/**\n * Constructs a new game model with the given parameters.\n *\n * @param width    the width of the grid (positive)\n * @param height   the height of the grid (positive", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0025", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": ")\n * @param goal     the goal line length for the game ({@code > 1})\n * @param players  the array of player names (non-null, non-empty, and\n *                 each element non-null)\n */\npublic ConnectNModel(int width, int height, int goal, String[] players);\n(Note that while we do not say which exceptions we might throw in the Javadoc, it should be clear that violating any of the method preconditions will result in an IllegalArgumentException.)\nHowever, having to provide all four parameters every time is annoying, especially if standard Connect Four is the common case. It‚Äôs easy enough to provide a second, nullary constructor that uses the default values:\n\n/**\n * Constructs a new game model for Connect Four with the default parameters.\n */\npublic ConnectNModel();\nHowever, what if want to c", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0026", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "hange only one parameter‚Äîthe width, say‚Äîwhile leaving the others at their defaults. With only the above two constructors, we must use the four-argument constructor, passing the width that we want and the default values for the other three parameters. That requires knowing the default values, and it‚Äôs tedious. Wouldn‚Äôt it be nice if there were a way to only specify how we want to differ from the defaults?\n\nOne common way to allow defaulting some of the parameters is to define constructors with different sets of parameters. Unfortunately, this can be confusing and error prone. For example, if there were a constructor that took one argument, an int, which game parameter would you expect that to be?\n\nAnother common solution is to provide setters for the configuration parameters, so that the cl", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0027", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "ient can create a game model and then configure it by modifying it. However, this creates another problem: What happens if the client tries to reconfigure a game already in progress? Of course it could detect this and throw an exception, but this solution is not satisfactory because it violates two design principles: 1) that it‚Äôs better to make bad states or operations unexpressible than to catch them later, and 2) that when we want different behaviors, we should use different classes rather than a bunch of conditionals.\n\nA better solution for handling several optional arguments is the builder pattern. When using the builder pattern, the client does not call the class‚Äôs constructor directly‚Äîin fact, we will make the constructor private, so that clients must instantiate model instances via ", "topics": ["factory"]}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0028", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "the builder. Instead, the client first creates some kind of builder object, which encapsulates the configuration parameters for the game:\n\n/**\n * Constructs a builder for configuring and then creating a game model\n * instance. Defaults to a standard game of Connect Four with players\n * named \"White\" and \"Red\".\n *\n * @return the new builder\n */\npublic static Builder builder();\nThe builder starts out with the default parameter values, and then provides several methods for changing whichever parameters we choose without saying anything about the others. In this case, that means we need a method for each of the parameters: the width, the height, the goal, and the array of players. Then, the builder provides a method build() that instantiates a game model object using the builder‚Äôs current para", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0029", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "meters. Here‚Äôs the interface:\n\npublic static final class Builder {\n  /**\n   * Sets the width of the game grid.\n   *\n   * @param width the width (positive)\n   * @return {@code this}, for method chaining\n   */\n  public Builder width(int width) { ... }\n\n  /**\n   * Sets the height of the game grid.\n   *\n   * @param height the height (positive)\n   * @return {@code this}, for method chaining\n   */\n  public Builder height(int height) { ... }\n\n  /**\n   * Sets the goal line length for the game.\n   *\n   * @param goal the goal (positive)\n   * @return {@code this}, for method chaining\n   */\n  public Builder goal(int goal) { ... }\n\n  /**\n   * Sets the players for the game. Makes a defensive copy of the\n   * player array, so the client cannot change it from under us.\n   *\n   * @param players the array o", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0030", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "f player names (non-null, non-empty,\n   *                and every element non-null)\n   * @return {@code this}, for method chaining\n   */\n  public Builder players(String... players) { ... }\n\n  /**\n   * Builds and returns the specified {@link ConnectNModel}.\n   *\n   * @return a new {@code ConnectNModel}\n   */\n  public ConnectNModel build() { ... }\n}\nThen to create our wide Connect Four instance, we can use the builder object to specify only the parameters we want:\n\nConnectNGame.builder().width(15).build()\n4.1 How to obtain a Builder?\nIn the code above, we include a public static method on the ConnectNModel class that provides a means of obtaining a Builder object. We could just expose the constructor of the Builder class directly:\n\n(new ConnectNGame.Builder())...\nbut this is less flexible a", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0031", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "nd more tightly coupled than the previous alternative. We‚Äôve now forced our clients to depend on the Builder class directly, but if our model evolves, and we eventually have multiple subclasses of Builder, our clients are forced to change code to match. The static method, on the other hand, encapsulates the call to the Builder constructor, and so insulates the client from needing to know how it works.\n\nAdditionally, we can now provide multiple such static methods, to ‚Äúpreconfigure‚Äù the Builder with some default options, or to select among multiple builder implementations. This flexibility is not needed in this simple example, but might come in handy later.\n\n4.2 Committing to the Builder pattern\nOnce we decide that a Builder makes sense, we ought to commit to it fully. That entails making t", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0032", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "he constructor(s) of the ConnectNModel class private or protected, so that clients cannot construct such a model directly, but must instead go through the Builder.\n\nWhy bother? Essentially, it boils down to a subjective decision on whether the objects we‚Äôre trying to create are heavily configurable (now or in the foreseeable future), or only mildly so. If there‚Äôs only mild configuration, then perhaps a few well-chosen public constructors will suffice. But if we can foresee that there will be lots of independently customizable parameters, then we can sidestep having to design lots of constructors, and at the same time avoid letting customers begin to depend on details that we may not want to expose later on. In short, the builder pattern lets us future-proof our class against future customi", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 6 The Model.txt::chunk0033", "source": "data\\raw\\notes\\Lecture 6 The Model.txt", "text": "zability. It may not always be necessary, but it‚Äôs often too late to introduce it afterward, so it‚Äôs worth considering early whether it may be needed eventually.\n\n1Tic-tac-toe has both rotational and reflective symmetries, which means that the orientation doesn‚Äôt actually matter so long as the UI is consistent.\n\n2Static classes and enumerations are like static fields and methods, in that they are part of the class rather than part of each object of the class.\n\n3Meaning that the client could do what this method does using the other public methods, but it‚Äôs still nice to have.", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000", "source": "data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt", "text": "Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t", "topics": ["mvc", "decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0001", "source": "data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt", "text": "o you in the starter code. You will fill in the fields and remaining method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe game grid cells are numbered by row and column starting from 0. For example, the upper left position is row 0, column 0 (or [0][0] in the 2D array returned by getBoard()), the upper middle position is row 0, column 1 ([0][1]), the lower right is [2][2].\n\n2 Testing\nWe have supplied you with some basic JUnit tests as part of the starter code. Use these to verify that your implementation is correct, and write additional tests of your own.\n\n3 Notes to Keep in Mind\nAvoid duplicating code as much as possible. Consider using non-public methods as means of creating reusable pieces of functionality.\nBe sure to use access modifiers, ", "topics": ["testing"]}
{"chunk_id": "data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0002", "source": "data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt", "text": "private and public, as well as final, appropriately.\nIn your getters, be careful to return a copy of, and not a direct reference to, any mutable internal state in your model.\nInclude JavaDoc for your classes and constructors as appropriate. You do not need to repeat JavaDoc already existing in a superclass or interface when you override a method. This is true for the course in general.", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0000", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "Lecture 8: Controllers and Mock Objects\nSlidesJava source (.zip)\nObjectives of the lecture\nThis lecture starts from a program that works correctly, but is not designed to be easily tested. Incrementally we abstract the input and output sources of this program to not only make it work with several different kinds of I/O, but also make it more suitable for automated testing. We also motivate the concepts of mocks: ‚Äústub‚Äù classes that substitute for the real classes, but help in testing. We also suggest a possible design to streamline classes that accept sequences of inputs and produce corresponding outputs.\n\nRead through the slides above first, before reading through the lecture notes below.\n\n1 Version 1: Writing a standalone program\nUp until now, we‚Äôve never actually written a program that ", "topics": ["mvc", "testing"]}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0001", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "could run on its own: we‚Äôve relied on the tester library to kick things off for us. To write a more typical program, Java relies on a particular convention to find the entry point for the program, i.e. the initial piece of code to run. We need a\n\nfunction ‚Äî because at the instant our program starts, we don‚Äôt have any objects constructed yet\nwith a well-known name ‚Äî because otherwise how would Java know what to call?\nwith a well-known signature ‚Äî or else how could Java call it correctly?\nthat returns nothing ‚Äî since no one would be listening for the return value anyway\nSince Java doesn‚Äôt have functions, per se, we‚Äôll need to use a static method instead. To make sure the name is visible, the method must be public. By convention, the method must be named main, and it must take a String[] as i", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0002", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "ts single argument. (This array contains the zero or more command line parameters that we use when running the program. We‚Äôll come back to this in a later lecture.) Since this is a method, we have to stick it in some class, but the name of that class isn‚Äôt special; instead, we‚Äôll tell Java which class to find our main method in.\n\npublic class OurMainClass {\n  public static void main(String[] args) {\n    ...\n  }\n}\nIn IntelliJ, once you‚Äôve written such a class, a green \"Play\" triangle will appear next to the class name, indicating you can run the program via this class. (Under the hood, IntelliJ is passing the name of this class as a command line parameter to Java, so that it knows which class‚Äôs main to call.)\nOur initial implementation is going to be very simple: it will read two numbers, a", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0003", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "nd print out their sum:\n\nimport java.util.Scanner;\n\npublic class SimpleCalc1 {\n  public static void main(String[] args) {\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", num1 + num2);\n  }\n}\n(A Scanner is a utility class that makes it much easier for us to read inputs from a source: instead of having to read in text and laboriously try to parse it into numbers or booleans or whatever, we can ask the Scanner to do it for us.)\n\nThe code above is simple, and it obviously works (assuming Scanners do what they‚Äôre supposed to do). So how can we test it? What sorts of inputs might a user type in when using this program, and how might they go wrong?\n\nThere are two broad categories of things to test here", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0004", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": ": is the input being obtained correctly, and is the arithmetic being performed correctly? Let‚Äôs tackle the second one, first.\n\n2 Version 2: Extracting a model\nThe first problem with the code above is that we have no programmatic control over it. The inputs come directly from the user ‚Äî they‚Äôre hardcoded to come from System.in ‚Äî and the arithmetic is performed as a subexpression whose output is sent directly to System.out. Let‚Äôs extract that expression into a helper function, which will be the beginnings of our model.\n\ninterface SimpleCalc {\n  int add(int num1, int num2);\n}\n\nclass Calculator implements SimpleCalc {\n  public int add(int num1, int num2) { return num1 + num2; }\n}\nWe can now rewrite our main method to use this class instead:\n\npublic class SimpleCalc2 {\n  public static void main", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0005", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "(String[] args) {\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", new Calculator().add(num1, num2));\n  }\n}\nThis seems strictly worse than before, since we have more code than before, and it doesn‚Äôt do anything new. However, now that we can instantiate a Calculator separately from the main method, we can write tests for it:\n\npublic class TestCalc2 {\n  @Test\n  public void testAdd() {\n    assertEquals(7, new Calculator().add(3, 4));\n    assertEquals(12, new Calculator().add(-5, 17));\n  }\n}\nWe now have automated confirmation that our arithmetic is being performed correctly ‚Äî without needing to involve a user in the testing process. This is important, because users aren‚Äôt reliable, and don‚Äôt always ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0006", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "reproduce the same behavior each time they use a program.\n3 Version 3: A very simple controller\nIf extracting a bit of code out of the main method made it easier to test, then perhaps we should keep trying to extract more code out of it. Let‚Äôs extract basically all the remaining code into a separate interface and class:\n\ninterface CalcController {\n  // Ignore the `throws` clause for now...\n  void go(SimpleCalc calc) throws IOException;\n}\n\nclass CalcController3 implements CalcController {\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main once again to use it:\npublic class SimpleCalc3", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0007", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": " {\n  public static void main(String[] args) {\n    new CalcController3().go(new Calculator());\n  }\n}\nNow our main method is about as bare-bones as it gets. And again, we‚Äôve added more code without adding any new functionality. But, now that we can instantiate the controller, we can call its go method from test cases as well as from main.\n\nExcept...as currently written, what good would that do? The go method is still hard-coded to use System.in and System.out for its inputs and outputs, so we still can‚Äôt test them. Once again, let‚Äôs abstract away details. Instead of hard-coding those two values, let‚Äôs make them be fields of the controller. According to the documentation, System.in has type InputStream, and System.out has type PrintStream. So let‚Äôs try the following:\n\nclass CalcController4 im", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0008", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "plements CalcController {\n  private final InputStream in;\n  private final PrintStream out;\n  CalcController4(InputStream in, PrintStream out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main to use it:\n\npublic class SimpleCalc4 {\n  public static void main(String[] args) {\n    new CalcController4(System.in, System.out).go(new Calculator());\n  }\n}\nNow, we have the ability to instantiate a controller using some other input and output streams, and we can test the controller itself.\n\n4 Version 4: Mocks, part 1‚Äîimitation objects for testing\nBecause", "topics": ["mvc", "testing"]}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0009", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": " we‚Äôre writing our code in terms of interfaces rather than concrete classes, we have the luxury of swapping in any convenient implementation of those interfaces for testing purposes.\n\nThe imagery of input and output streams is meant to evoke real rivers of water, which flow in only one direction. If you‚Äôre at the downstream end of a river, with water flowing towards you, that‚Äôs the analogue of an input stream. If you‚Äôre at the upstream end, such that you can pour something into the river, that‚Äôs the analogue of an output stream. Our controller needs both an input and an output: we‚Äôre going to need to create two streams. Moreover, our test will need to write into the stream that the controller will read from, and our test will need to read from the stream that the controller writes into.\n\nT", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0010", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "o construct an InputStream for our controller to read from, we‚Äôre going to construct a String containing the inputs we want to pass into the controller. We‚Äôll convert that string into an array of bytes, and then construct an input stream that reads from that byte array:\nInputStream in = new ByteArrayInputStream(\"3 4\".getBytes());\nTo construct a PrintStream for our controller to use, we‚Äôll need to create a byte array that we can eventually read from, and wrap a PrintStream around it:\nByteArrayOutputStream bytes = new ByteArrayOutputStream();\nPrintStream out = new PrintStream(bytes);\nThe PrintStream will mutate the bytes stream, and eventually we can get the bytes out of it and turn them back into a string:\n\nnew String(bytes.toByteArray())\nPutting this together, we arrive at our first test f", "topics": ["mvc", "decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0011", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "or our controller:\n\npublic class TestController4 {\n  @Test\n  public void testGo() throws Exception {\n    InputStream in = new ByteArrayInputStream(\"3 4\".getBytes());\n    ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n    PrintStream out = new PrintStream(bytes);\n    CalcController controller4 = new Controller4(in, out);\n    controller4.go(new Calculator());\n    assertEquals(\"7\", new String(bytes.toByteArray()));\n  }\n}\nThere‚Äôs an awful lot of boilerplate in there: all this messing around with byte arrays seems needlessly indirect. And it is. The problem is our types are too specific: we‚Äôve picked the wrong interfaces for in and out.\n\n5 Version 5: Fixing the types\nWe don‚Äôt really need the full power of streams for our purposes here. We just need to be able to read from the input,", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0012", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": " and append to the output. (Streams cover a much wider range of functionality, including reading and writing to files, to the network, and to many other targets.) Fortunately, Java includes two more general interfaces for this: Readable and Appendable. Because they‚Äôre more general, they‚Äôre harder to use‚Äîif we were using them directly! But we‚Äôre not: we‚Äôre using a Scanner to make reading easier. A Scanner can be built using an InputStream, as we‚Äôve been doing, or it can be built using just a Readable. And we don‚Äôt need the full power of a PrintStream, we just need to be able to print out strings, since we can use String.format to produce whatever strings we need.\n\nclass CalcController5 implements CalcController {\n  final Readable in;\n  final Appendable out;\n  CalcController5(Readable in, Ap", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0013", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "pendable out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) throws IOException {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.append(String.format(\"%d\\n\", calc.add(num1, num2)));\n  }\n}\nNote that this version of go claims that it throws IOException. Because Appendables are more general, they might include things that might fail to write properly. It so happens that using a PrintStream directly will not claim to throw exceptions, but because we‚Äôre now using the more general interface, we have to be aware of the possibility. Our main method will have to handle the possible exception:\n\npublic class SimpleCalc5 {\n  public static void main(String[] ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0014", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "args) {\n    try {\n      new CalcController5(new InputStreamReader(System.in), System.out).go(new Calculator());\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\nNow that we‚Äôve generalized our types, our tests get a lot easier. In particular, it‚Äôs easy to turn a string into a Readable, and a standard StringBuilder is Appendable1:\n\npublic class TestController5 {\n  @Test\n  public void testGo() throws IOException {\n    StringBuilder out = new StringBuilder();\n    Reader in = new StringReader(\"3 4\");\n    CalcController controller5 = new Controller5(in, out);\n    controller5.go(new Calculator());\n    assertEquals(\"7\\n\", out.toString());\n  }\n}\nMuch cleaner!\n\n6 Mocks, part 2‚Äîimitating models\nOur test above is enough to confirm that a user can input some numbers, and get back an", "topics": ["mvc", "testing"]}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0015", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": " answer. But it does not quite confirm that the controller is passing the inputs through correctly. For instance, the following controller will produce the \"right\" answer, but for the wrong reasons:\n\npublic class BadController implements CalcController {\n  ...\n  public void go(Calculator calc) throws IOException {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt() + 10;\n    num2 = scan.nextInt() - 10;\n    this.out.append(String.format(\"%d\\n\", calc.add(num2, num1)));\n  }\n}\nAs our tests are currently written, we have no way of distinguishing this bizarre controller from a better one. This particular scenario is admittedly contrived, but it‚Äôs easy to see scenarios where errors could arise: swapping inputs because we confuse", "topics": ["mvc", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0016", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "d row coordinates with column coordinates, or forgetting whether our indices were zero-based or one-based, etc. So how could we fix this?\n\nRemember that our model is an interface too! So we can mock up an alternate definition for it. Since our goal for this mock is solely to ensure that the arguments are being passed in correctly, we might not care about the actual result of our method. Here is an intriguing possibility:\n\npublic class ConfirmInputsCalculator implements Calculator {\n  final StringBuilder log;\n  public ConfirmInputsCalculator(StringBuilder log) {\n    this.log = Objects.requireNonNull(log);\n  }\n  public int add(int num1, int num2) {\n    log.append(String.format(\"num1 = %d, num2 = %d\\n\", num1, num2));\n    return 0; // WE DON'T CARE ABOUT THIS ANSWER\n  }\n}\n\n// in our tests clas", "topics": ["testing", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0017", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "s:\n@Test\npublic void testInputs() throws IOException {\n  Reader in = new StringReader(\"3 4\");\n  StringBuilder dontCareOutput = new StringBuilder();\n  CalcController controller5 = new Controller5(in, dontCareOutput);\n\n  StringBuilder log = new StringBuilder();\n  Calculator calc = new ConfirmInputsCalculator(log);\n\n  controller5.go(calc);\n  assertEquals(\"num1 = 3, num2 = 4\\n\", log.toString());\n}\nNote carefully what this test does and does not do: it does not check that the output of the model is correct! It only checks that the model has received inputs that we expect from the controller. And yet this test will distinguish the BadController implementation from the others. We‚Äôve now resolved the dangling testing problem alluded to all the way at the start of these notes.\n\nMocks aren‚Äôt just us", "topics": ["mvc", "testing", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0018", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "eful for simulating inputs and outputs ‚Äì they‚Äôre great for simulating any part of the system that isn‚Äôt the focus of a particular test. Our prior tests basically checked everything between user input and user output as a single \"black box\". But our controller really has two directions of inputs and outputs: it talks to the user through in and out, and it also talks to the model.\n\n7 An elegant idiom for testing synchronous controllers\nThe behaviors of a synchronous controller follow a script: prompt the user, wait for a response, prompt again. Testing these interactions would be quite tedious if we had to build up the expected input and output strings all in one step: how do we remember whether this output belongs with that prompt, or not? To streamline this, we‚Äôll use several features of J", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0019", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "ava‚Äîfunction objects, variadic functions, mock input and output objects‚Äîand and build up a much cleaner way to write these tests.\n\n7.1 Interactions\nFirst, let‚Äôs define a new interface:\n\n/**\n * An interaction with the user consists of some input to send the program\n * and some output to expect.  We represent it as an object that takes in two\n * StringBuilders and produces the intended effects on them\n */\ninterface Interaction {\n  void apply(StringBuilder in, StringBuilder out);\n}\nThis interface defines the signature of a function object, whose reason for being is to represent user/program interactions.\nWe can define classes for the two most common interactions: printing text to the user, or responses from the user. We show this code two different ways: first as standard Java classes, and th", "topics": ["testing"]}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0020", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "en again using Java‚Äôs new lambda syntax (see Streamlining the code further below).\n\n/**\n * Represents the printing of a sequence of lines to output\n */\nclass PrintInteraction implements Interaction {\n  String[] lines;\n  PrintInteraction(String... lines) {\n    this.lines = lines;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    for (String line : lines) {\n      out.append(line).append(\"\\n\");\n    }\n  }\n}\n/**\n * Represents a user providing the program with  an input\n */\nclass InputInteraction implements Interaction {\n  String input;\n  InputInteraction(String input) {\n    this.input = input;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    in.append(input);\n  }\n}\nFor example, the following array of Interactions represents two inputs to our Calculator and the", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0021", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "ir corresponding outputs:\n\nInteraction[] interactions = new Interaction[] {\n  new InputInteraction(\"+ 3 4\\n\"),\n  new PrintInteraction(\"7\"),\n  new InputInteraction(\"+ 5 7\\n\"),\n  new PrintInteraction(\"12\"),\n  new InputInteraction(\"q\\n\")\n};\nBut how can we use them?\n\n7.2 Scripting our controller\nSuppose we construct two initially-empty StringBuilder objects, and we feed them to each Interaction in turn:\n\nStringBuilder sb1 = new StringBuilder();\nStringBuilder sb2 = new StringBuilder();\nfor (Interaction i : interactions) {\n  i.apply(sb1, sb2);\n}\nWhat are the contents of sb1.toString() and sb2.toString()? They‚Äôre exactly the intended input and corresponding expected output from our program. If we then feed sb1.toString() to our controller, we can drive it with our intended inputs. If we give the ", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0022", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "controller another empty StringBuilder to use as output, we can compare its value to our expected one, and thereby test our controller:\nvoid testRun(Model model, Interaction... interactions) throws IOException {\n  StringBuilder fakeUserInput = new StringBuilder();\n  StringBuilder expectedOutput = new StringBuilder();\n\n  for (Interaction interaction : interactions) {\n    interaction.apply(fakeUserInput, expectedOutput);\n  }\n\n  StringReader input = new StringReader(fakeUserInput.toString());\n  StringBuilder actualOutput = new StringBuilder();\n\n  Controller controller = new Controller(model, input, actualOutput);\n  controller.run();\n\n  assertEquals(expectedOutput.toString(), actualOutput.toString());\n}\n(We pass in a model rather than a controller because we need to construct the controller in", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0023", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": " the test itself, using the given model.)\n\nThis sort of schematic function is called a test harness: it is the infrastructure by which we can run a variety of structurally-related tests without having to repeat ourselves. (In general, test harnesses can be much more complex...up to, say, being able to detect and run all our tests for us, and produce an easy-to-read report of the results. In other words, JUnit.) Now we merely need to say:\n\ntestRun(new Calculator(),\n  new InputInteraction(\"+ 3 4\\n\"),\n  new PrintInteraction(\"7\"),\n  new InputInteraction(\"+ 5 7\\n\"),\n  new PrintInteraction(\"12\"),\n  new InputInteraction(\"q\\n\"));\nBut we can do better yet!\n\n7.3 Streamlining the code further\nThe definitions for PrintInteraction and InputInteraction are clunky, full of boilerplate that would be nice ", "topics": ["testing"]}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0024", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "to eliminate. In fact, we can. Java 8 has introduced lambda expressions that make it far easier to write function objects. Java still insists that all functions must reside in objects (unlike, say, Racket, where functions and structs were distinct), but Java has introduced syntactic sugar to make it easier to write them down. 2\n\nOur first refactoring is to create a static function surrounding the calls to our constructors:\n\nstatic Interaction prints(String... lines) {\n  return new PrintInteraction(lines);\n}\nThis doesn‚Äôt save much typing; in fact, it‚Äôs now longer than our original! But our next step is to use lambda syntax, and eliminate the definition of PrintInteraction altogether:\n\nstatic Interaction prints(String... lines) {\n  return (input, output) -> {\n    for (String line : lines) {\n", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0025", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "      output.append(line).append('\\n');\n    }\n  };\n}\nThis function has the same signature as above, which means we can call it the same way. Internally, Java sees the syntax (...) -> {...} and automatically creates a new, anonymous class that implements the Interaction interface (which it determines is needed because of our return-type annotation), whose one and only method is defined as the body of code above. In other words, this lambda above is exactly the same as our original definition, except it‚Äôs anonymous.\nWe can redefine our other class, too:\n\nstatic Interaction inputs(String in) {\n  return (input, output) -> {\n    input.append(in);\n  };\n}\nAnd now we can test our controller by saying:\n\ntestRun(new Calculator(),\n        inputs(\"+ 3 4\\n\"),\n        prints(\"7\"),\n        inputs(\"+ 5 7\\", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0026", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "n\"),\n        prints(\"12\"),\n        inputs(\"q\\n\"));\nThis is about as terse and expressive as it gets!\n\nWe can define additional convenience interactions too: for example, a prompt and response:\n\nstatic Interaction prompts(String prompt, String response) {\n  return (input, output) -> {\n    output.append(prompt).append(\"\\n\");\n    input.append(response);\n  }\n}\nor a formatted output:\n\nstatic Interaction formats(String template, Object... params) {\n  return (input, output) -> {\n    output.append(String.format(template, params));\n  }\n}\nThe possibilities here can extend to whatever the scenario is that you‚Äôre testing. By defining these convenience interactions, it becomes much clearer to express your intended tests as a sequence of interactions, rather than as two giant strings with no delimiters ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0027", "source": "data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt", "text": "to guide the way. Moreover, changing the interactions automatically changes the inputs and outputs in tandem; it‚Äôs impossible for them to become inconsistent with each other.\n\n1If we cared about multiple threads and synchronization, we would use a StringBuffer here instead.\n\n2Syntactic sugar is new syntax that is not strictly necessary, in that you could accomplish exactly the same goal using other, more verbose syntax. But syntactic sugar is often ‚Äúsweeter‚Äù to use than the alternatives.", "topics": ["gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000", "source": "data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt", "text": "Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl", "topics": ["mvc", "decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001", "source": "data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt", "text": "ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0002", "source": "data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt", "text": "oves are numbered from 1. For example, to mark X in the upper left cell, the user would enter \"1 1\" at the first prompt. To mark O in the upper right cell on the second move, the user would enter \"1 3\". To quit a game in progress, the user can enter q or Q at any time.\n\nThe game state is the output of the model‚Äôs toString() method, followed by a carriage return (\\n). The move prompt is\n\n\"Enter a move for \" + model.getTurn().toString() + \":\\n\"\n\n(where model is an instance of your Tic Tac Toe Model).\n\nIf a non-integer value is entered, it should be rejected with an error message. If an invalid move is entered, namely, two valid integers, but the proposed move was deemed invalid by the model, the controller should give an error message. The message text is up to you, but should end with a car", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0003", "source": "data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt", "text": "riage return.\n\nAt the end of the game, the controller should output, in order on separate lines:\n\nA final game state\n\"Game is over!\" followed by \"X wins.\" or \"O wins.\" or \"Tie game.\" depending on the outcome\nIf the user quits, the controller should output\n\n\"Game quit! Ending game state:\\n\" + model.toString() + \"\\n\"\n\nand end the playGame() method.\n\n2 Testing\nWe have supplied you with some basic JUnit tests as part of the starter code. Use these to verify that your implementation is correct. Write additional tests of your own: Assignment 3 is a testing-heavy assignment. Some of the additional cases you should implement are listed as comments in the test class you are given. Implement those tests at the least.\n\n3 Notes to Keep in Mind\nYou will likely need a while() loop; be aware that you can", "topics": ["mvc", "testing"]}
{"chunk_id": "data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0004", "source": "data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt", "text": " use the break statement to break out of a loop prematurely (before the loop condition is false).\nYou will need to use the built-in Scanner class. See the lecture notes examples and explore the Oracle JavaDoc for this class for more information on how to use it.\nAvoid duplicating code as much as possible. Consider using non-public methods as means of creating reusable pieces of functionality.\nBe sure to use access modifiers, private and public, as well as final, appropriately.\nInclude JavaDoc for your classes and constructors as appropriate. You do not need to repeat JavaDoc already existing in a superclass or interface when you override a method. This is true for the course in general.\n4 To Turn In\nSubmit your zip containing only your src and test directories to In-class Exercise 2 on the", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0005", "source": "data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt", "text": " handin server. There is no self-evalulation for this exercise. Your grade will be determined by code style (70%) and JUnit correctness (30%); this assignment is simply for your practice. We will not be doing manual grading, but if you would like feedback on your design, and specifically your test coverage, contact a member of the course staff and we will review it.", "topics": ["mvc", "testing"]}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0000", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": "Lecture 10: The Command Design Pattern\nJava source (.zip)\nObjectives of the lecture\nThis lecture starts by working out the design of a model and controller of a new small application in detail. It streamlines code in the controller in several iterations to introduce the command design pattern.\n\n1 Context of the example program\nThis lecture uses the example of turtle graphics. Turtle graphics uses the notion of a turtle moving on a 2D plane. At any point in time, the turtle occupies a fixed position on the plane, and points in some direction. The turtle has limited mobility: it is able to turn in its place, and move only in the direction that it is pointing.\n\nTurtle graphics is used to measure and draw in various applications. Many such applications find it convenient to specify movement re", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0001", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": "lative to current position and direction (as the turtle) instead of absolute Cartesian coordinates. For example, driving directions provide navigation relative to the current position and direction (‚ÄúDrive 0.3 miles‚Äù, ‚ÄúTake left onto...‚Äù).\n\n1.1 Basic Design\nBased on the basic operations identified above for turtle model, we begin by designing an interface for the model of our program:\n\n/**\n * This interface specifies the operations on a 2D turtle\n * <p>\n * A 2D turtle is characterized by a position (x,y) and a\n * heading (where it is looking).\n * <p>\n * It can be asked to draw the path it has moved using one of\n * the commands below.\n */\npublic interface TurtleModel {\n    /**\n     * Move the turtle by the specified distance along its\n     * heading. Do not change heading\n     *\n     * @par", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": "am distance\n     */\n    void move(double distance);\n\n\n    /**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     */\n    void turn(double angleDegrees);\n\n    /**\n     * Save the current turtle state (position + heading)\n     */\n    void save();\n\n    /**\n     * Retrieve the last saved turtle state (position + heading)\n     */\n    void retrieve();\n\n    /**\n     * Get the current position of the turtle\n     *\n     * @return\n     */\n    Position2D getPosition();\n\n  /**\n   * Get the current heading of the turtle\n   *\n   * @return\n   */\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0003", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": "\n\n/**\n * This class represents a 2D position\n */\npublic final class Position2D {\n  private final double x;\n  private final double y;\n\n  /**\n   * Initialize this object to the specified position\n   */\n  public Position2D(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  /**\n   * Copy constructor\n   */\n  public Position2D(Position2D v) {\n    this(v.x, v.y);\n  }\n\n\n\n  public double getX() {\n    return x;\n  }\n\n  public double getY() {\n    return y;\n  }\n\n\n  @Override\n  public String toString() {\n    return String.format(\"(%f, %f)\", this.x, this.y);\n  }\n\n  @Override\n  public boolean equals(Object a) {\n    if (this == a) {\n      return true;\n    }\n    if (!(a instanceof Position2D)) {\n      return false;\n    }\n\n    Position2D that = (Position2D) a;\n\n    return ((Math.abs(this.x - that.x", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": ") < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n */\npublic class SimpleTurtle implements TurtleModel {\n  // the position of the turtle\n  private Position2D position;\n  // the heading of the turtle in degrees\n  private double heading;\n  // stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  /**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   */\n  public SimpleTurtle() {\n    this(new Position2D(0,", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": " 0), 0);\n  }\n  /**\n   * Initializes the turtle to the given position and heading.\n   */\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    //trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": "  }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0007", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": "istance);\nList<Line> getLines();\nIt may be tempting to simply add these methods to the TurtleModel interface and implement them in the SimpleTurtle class. However doing so has several problems:\n\nWe no longer have a turtle without the capability to draw. Clients that currently use TurtleModel and SimpleTurtle now have extra operations that is not relevant. This violates the Interface Segregation principle.\nEditing code that is in use is recipe for disaster. If we accidentally broke what was previous working, it affects client code. This violates the Open for Extension, Closed for Modification principle.\nHow do we add these operations? We extend the existing interface and then implement it by reusing the existing implementation (with inheritance).\n\n\npublic interface TracingTurtleModel extend", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": "s TurtleModel {\n  /**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   */\n  void trace(double distance);\n\n  /**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   */\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0009", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": " List<Line> getLines() {\n    return new ArrayList<>(lines);\n  }\n\n  //list of lines traced since this object was created\n  List<Line> lines;\n}\n2 Controller\nWe offer a text-based synchronous controller for our application. The application (through the controller) has the following loop:\n\nTake a one-word command from the user. This command is one of ‚Äúmove‚Äù, ‚Äúturn‚Äù, ‚Äútrace‚Äù, ‚Äúshow‚Äù and ‚Äúquit‚Äù.\nDepending on the command, take additional input (e.g. ‚Äúmove‚Äù requires a distance to move).\nCall the appropriate operation on the model, or quit (if the command is ‚Äúquit‚Äù).\nThis results in the following code:\n\npublic class SimpleController {\n  public void go() {\n    Scanner s = new Scanner(System.in);\n    TracingTurtleModel m = new SmarterTurtle();\n    while (s.hasNext()) {\n      String in = s.next();\n   ", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": "   switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0011", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": "      System.out.println(String.format(\"Unknown command %s\", in));\n          break;\n      }\n    }\n  }\n}\n3 Scaling up the controller\nImagine if we support additional text commands in the controller. Although the current set of supported commands use all available operations in the model (except save and retrieve), we can support new drawing commands at the controller level. For example, drawing a square is a sequence of 4 move and 4 turn operations on the model. Instead of letting the user draw it as a sequence of 8 text commands, we could offer it as a new text command.\n\nswitch(in) {\n...\ncase \"square\":\n    try {\n      double d = s.nextDouble();\n      m.trace(d);\n      m.turn(90);\n      m.trace(d);\n      m.turn(90);\n      m.trace(d);\n      m.turn(90);\n      m.trace(d);\n      m.turn(90);\n   ", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0012", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": " } catch (InputMismatchException ime) {\n      ...\n    }\n    break;\n}\nThe possibilities are now endless! We can support similar higher-level drawing text commands. Every such text commands adds a new case to our switch statement. The number of lines of code in each case statement depends on the complexity of the text command (e.g. the square text-command added 13 lines of code). As a result, the switch statement quickly grows in size. Moreover the go method is increasingly incohesive.\n\n4 The Command Design Pattern\nIn order to make each case statement shorter, we can put all its code into a separate helper method. Since all the helper methods operate on the model, we pass the model object to them. Also since some of the text command require additional input, we pass the additional input to e", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0013", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": "ach of them (in an attempt to make their signatures the same). The switch statement would now become:\n\nswitch(in) {\n  case \"move\":\n      double d = s.nextDouble();\n      moveHelper(d,m);\n      break;\n  case \"turn\":\n      double d = s.nextDouble();\n      traceHelper(d,m);\n      break;\n  ..\n}\nWe can now characterize each such helper method as follows: Take the model object and an additional piece of data, and execute a set of operations on the model. Note that although the operations that each helper method executes are different, all of the helper methods can be characterized this way. Since the methods differ only by name we can unify them under a single interface that has a method of the same signature: void go(TracingTurtleModel model);.\n\nDesign-wise, how can we justify the purpose of su", "topics": ["command"]}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0014", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": "ch an interface? It represents a high-level command: a set of operations that must be executed. This is an example of the command design pattern. This pattern unifies different sets of operations under one umbrella, so that they can be treated uniformly.\n\npublic interface TracingTurtleCommand {\n  void go(TracingTurtleModel m);\n}\nWe then implement this interface, once for each text command. Each implementation would take additional data during instantiation.\n\npublic class Move implements TracingTurtleCommand {\n  double d;\n\n  public Move(Double d) {\n    this.d = d;\n  }\n\n  @Override\n  public void go(TracingTurtleModel m) {\n    m.move(this.d);\n  }\n}\n\npublic class Trace implements TracingTurtleCommand {\n  double d;\n\n  public Trace(Double d) {\n    this.d = d;\n  }\n\n  @Override\n  public void go(Tr", "topics": ["command"]}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0015", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": "acingTurtleModel m) {\n    m.trace(this.d);\n  }\n\n  ...\n\n}\nNow we can change the logic of our controller to:\n\nTake a one-word command from the user.\nCreate the corresponding TracingTurtleCommand object..\nExecute the command object.\nString in = s.next();\ntry {\n  switch (in) {\n    case \"q\":\n    case \"quit\":\n      return;\n   case \"show\":\n     for (Line l : m.getLines()) {\n        System.out.println(l);\n     }\n     break;\n   case \"move\":\n      cmd = new Move(s.nextDouble());\n      break;\n   case \"trace\":\n      cmd = new Trace(s.nextDouble());\n      break;\n   case \"turn\":\n      cmd = new Turn(s.nextDouble());\n      break;\n   case \"square\":\n      cmd = new Square(s.nextDouble());\n      break;\n   default:\n      System.out.println(String.format(\"Unknown command %s\", in));\n      cmd = null;\n      bre", "topics": ["mvc", "command"]}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0016", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": "ak;\n  }\n  if (cmd != null) {\n    cmd.go(m); //execute the command\n    cmd = null;\n  }\n} catch (InputMismatchException ime) {\n  System.out.println(\"Bad length to \" + in);\n}\n4.1 Advantages of the command design pattern\nAs the above example shows, the command design pattern offers several advantages:\n\nThe command design pattern has a unifying effect, making unrelated lines of code appear as if working towards the same purpose. This increases cohesion: the controller is no longer doing 1 of 10 unrelated things, but executing commands.\nThe command design pattern promotes delegation. Details of each command are now kept in separate classes, instead of all appearing within the controller. This allows us to support new, more complicated commands such as drawing fractal objects without cluttering t", "topics": ["mvc", "command"]}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0017", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": "he controller (see the attached code for the Koch snowflake).\nThe command design pattern extends its unifying effect by allowing common operations across commands.\nFor example we can think of supporting a new text command: undo the last operation. Although our model supports this in a primitive way, the controller should be able to undo entire sequences of model operations (such as square). Although the details of undoing differ with the operation being undone, we can think of the operation itself at the ‚Äúcommand‚Äù level.\n\nWe may implement this in one of two ways:\n\nExtend the TracingTurtleCommand interface to offer an undo() operation. Each command would determine how to undo itself.\nStore a list of command objects in the controller and undo them.\nAgain, note that both of these ways use the", "topics": ["mvc", "command"]}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0018", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": " abstraction created by the command design pattern.\n\n5 Improving the controller\nAlthough we made our controller code more cohesive, the switch statement will still grow as more text commands are supported.\n\nConsider what virtually every case is doing: it takes additional input from a Scanner object, and creates a command object. We can conceptualize this operation as a method: TracingTurtleCommand create(Scanner sc).\n\nIf we have such methods for each case block, then the switch statement is simply executing the correct method depending on the entered text command. We can store all such text-command -> method in a map of function objects.\n\nMap<String, Function<Scanner, TracingTurtleCommand>> knownCommands;\n\n    knownCommands = new HashMap<>();\n    knownCommands.put(\"move\",s->new Move(s.next", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0019", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": "Double()));\n    knownCommands.put(\"turn\",s->new Turn(s.nextDouble()));\n    knownCommands.put(\"trace\", s->new Trace(s.nextDouble()));\n    knownCommands.put(\"square\", s -> new Square(s.nextDouble()));\nThen our controller logic becomes:\n\nTake a one-word command from the user.\nFind if the command exists in the map. If so, execute the corresponding function object to get the command object.\nExecute the command object.\nThe second step above becomes a map lookup, instead of a switch statement!\n\nwhile(scan.hasNext()) {\n  TracingTurtleCommand c;\n  String in = scan.next();\n  if (in.equalsIgnoreCase(\"q\") || in.equalsIgnoreCase(\"quit\"))\n    return;\n  Function<Scanner, TracingTurtleCommand> cmd =\n  knownCommands.getOrDefault(in, null);\n  if (cmd == null) {\n    throw new IllegalArgumentException();\n  } ", "topics": ["mvc", "command"]}
{"chunk_id": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0020", "source": "data\\raw\\notes\\Lecture 10 The Command Design Patte.txt", "text": "else {\n    c = cmd.apply(scan);\n    c.go(m);\n  }\n}\nAdding support for a new text command is now as easy as adding a new entry to the map! This allows us to quickly assemble a list of supported text commands for a controller. The controller‚Äôs logic does not change depend on the number and complexity of supported text commands.", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0000", "source": "data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt", "text": "Lecture 11: The Perils of Inheritance\nJava source (.zip)\nOverview of the lecture\nThis lecture compares inheritance and composition as two ways to reuse existing code. Many solutions to design problems can be loosely framed as replacing one of these ways with the other.\n\nThe IntSet interface is a simplified API for working with sets of integers‚Äîit has nearly the bare minimum of methods. Now, suppose we wanted to instrument an IntSet to find out how many times elements are added (which isn‚Äôt the same as the size). The InstrumentedIntSet interface extends IntSet with an additional operation, which lets the client find out the count of add operations.\n\nNow, suppose we wanted to implement InstrumentedIntSet based on an existing IntSet implementation that someone else wrote and maintains (IntSet", "topics": ["mvc", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0001", "source": "data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt", "text": "1, in this case‚Äîno peeking), and that we don‚Äôt want to look at or mess with. The InstrumentedIntSet1 class is our first attempt to do this by inheriting from IntSet1 and overriding the relevant methods to have them count as well. This looks good, but when we test it (see InstrumentedIntSetTest), we find that one of the tests fails.1 Why do the tests fail? You may need to look at IntSet1 to figure it out.\n\nOnce we‚Äôve figured out why they fail, we give it another go with the InstrumentedIntSet2 class, which compensates for what was going on in our first attempt. If InstrumentedIntSet2 extended IntSet1, the same IntSet implementation as before, it would pass the tests. Alas! Unbeknownst to us, the maintainer of IntSet1 decided to tweak the implementation in a (supposedly) innocuous way, and t", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0002", "source": "data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt", "text": "hat change having cancelled out our compensation, InstrumentedIntSet2 also fails one of the tests. Again, can you see why? Here‚Äôs IntSet2 in case you need it.\n\nThe next two versions show two different solutions to our problem.\n\nIn IntSet3, the author made a defensive change so that subclasses cannot interfere with how its own methods are implemented. This looks substantially the same as IntSet2 from the outside, but there are actually two substantive changes:\n\nInstead of duplicating the (admittedly tiny) code between add() and addAll(), IntSet3 factors that out into a private method that subclasses can‚Äôt touch.\nIntSet3 is properly documented for extension, which means that InstrumentedIntSet3 can now safely extend it, knowing (because it‚Äôs documented!) that overriding IntSet3‚Äôs methods won", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0003", "source": "data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt", "text": "‚Äôt screw things up.\nThe IntSet4 class takes an even more conservative approach: IntSet4 is final, which prohibits extension altogether. This is almost always the right thing to do when you write a class: unless you are designing and documenting for extension, make the class final. That way, no clients of your class can depend on implementation details leaking out via inheritance, as happened with IntSet1 and IntSet2.\n\nMaking IntSet4 final poses a problem for implementing InstrumentedIntSet4, because it can no longer use subclassing to just override some methods and silently inherit the others. So instead, InstrumentedIntSet4 takes a different tack: the delegate pattern. Instead of inheritance, it uses object composition, which means that it has a field holding the IntSet object that it wan", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0004", "source": "data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt", "text": "ts to instrument. Then InstrumentedIntSet4 forwards method calls to the delegate rather than handling them itself, adding the instrumentation functionality where needed:\n\nThe delegate pattern\n\nA disadvantage of this approach is inconvenience, since it now requires writing a stub for every method, even those that we formerly inherited unchanged. But an advantage of object composition is increased flexibility, because InstrumentedIntSet4 can take an object of any IntSet implementation in its constructor and delegate to that rather than fixing one IntSet implementation to inherit from.2 This flexibility is demonstrated by the test classes Test1Using1 through Test1Using4 at the bottom of InstrumentedIntSetTest.\n\n1InstrumentedIntSetTest uses the factory method‚Äìbased abstract testing approach th", "topics": ["factory"]}
{"chunk_id": "data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0005", "source": "data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt", "text": "at we saw early on in the course. The tests for different InstrumentedIntSet implementations are always the same, and we extend the abstract base class eight times to test our different attempts at implementing InstrumentedIntSet.\n\n2It could even change the delegate dynamically if that‚Äôs what we wanted.", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0000", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": "Lecture 12: Encapsulation and Class Invariants\nSlidesJava source (.zip)\n\n1 Model representation\nWhen we last talked about Connect ùëÅ\n, we designed an interface for our game model:\n\ninterface ConnectNModel {\n  static enum Status { Playing, Stalemate, Won, }\n\n  Status getStatus();\n  boolean isGameOver();\n  int getNextPlayer();\n  int getWinner();\n\n  Integer getPlayerAt(int x, int y);\n  boolean isColumnFull(int which);\n\n  int move(int who, int where);\n\n  int getWidth();\n  int getHeight();\n  int getGoal();\n  int getPlayers();\n}\nThe next step in implementing this interface is to consider what data we need‚Äîwhat fields‚Äîto implement it. If nothing else, clearly we need some way to represent the game grid and its tokens. Since the grid is rectangular, we want to use some kind of sequence of sequences", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0001", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": " of Integers that will let us use the positions to access the cell contents.\n\nSome of these methods return simple quantities that don‚Äôt change, so for those we can just store each in a field:\n\npublic int width;\npublic int height;\npublic int goal;\npublic int players;\nClearly we need to represent the state of the game grid, in particular which tokens are where. Since the grid is essentially a two-dimensional matrix, we can use an array of arrays or list of lists. In general this choice is arbitrary (except for the effects of locality), but in this case columns may make more sense, because we can use shorter lists to represent not-yet-full columns and grow them as necessary.\n\npublic List<List<Integer>> columns;\nFinally, we need state in order to be able to tell the client who the current play", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0002", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": "er is and who won. These fields, unlike the others, will be mutable:\n\npublic Status status;\npublic int turn;\n1.1 Reductio...\nClearly the fields listed above will work, but what if we are thinking about flexibility for the future? For example, perhaps we don‚Äôt want to commit right now to players being represented as ints, so we generalize to Object in the two places where we represented players as integers:\n\npublic Object turn;\npublic List<List<Object>> columns;\nOr perhaps we‚Äôre considering the possibility of extending Connect ùëÅ\n into a third dimension, or an arbitrary number of dimensions. If we want to represent ùëò\n-D game grids, a list-of-lists won‚Äôt do, so perhaps it‚Äôs better to defer that decision until later as well. And of course, width and height are also insufficient for ùëò\n-D, so we", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0003", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": " generalize with a map from dimension names to their sizes:\n\npublic Map<String, Integer> dimensions;\npublic Object hypercolumns;\nAt this point, we might notice that our game configuration consists of the map dimensions and two ints, goal and players. We could store those in the map as well, paving the way for adding more properties in the future without having to change the representation. So at this point, these are our fields:\n\npublic Map<String, Integer> configuration;\n\npublic Status status;\npublic Object turn;\npublic Object hypercolumns;\nNow, not having played ùëò\n-D Connect-ùëÅ\n before, I‚Äôm not sure that we won‚Äôt need more potential statuses in a game of that complexity, and for that matter, a turn may involve multiple players. But fear not! We don‚Äôt have to decide on either of those thin", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0004", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": "gs now:\n\npublic Map<String, Object> properties;\npublic Object hypercolumns;\nAt this point, we might as well go big, right? We could represent the game model now, and every potential future game idea we might imagine, with one field:\n\npublic Map<String, Object> properties;\nNow you‚Äôre programming in Python.\n\n1.2 ...Ad Absurdum\nWith this change, what have we gained and what have we lost? Certainly we‚Äôve gained a lot of flexibility, but in return we‚Äôve replaced our expression of intent, the clear meaning of the several named fields, with an amorphous mapping. We‚Äôve given up the ability to control the shape of our data.\n\nLike almost any other property of a design, increasing flexibility involves trade-offs. The design we ended up with above is clearly too flexible, but is there reason to believ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0005", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": "e that the design we started with isn‚Äôt too general as well?\n\n2 Bad freedoms\nWith increased flexibility comes additional ways to abuse that flexibility. In particular, there are a lot of things we can do with our initial representation that should likely be disallowed:\n\nThe width, height, goal, or players fields permit changes mid-game.\nThe width, height, goal, or players fields might be zero or negative.\nThe status or columns field might be null.\nThe shape of the list-of-lists in columns might not match the dimensions in width and height; columns.size() might differ from width, or it may contain a column whose size exceeds height.\nOr columns might contain Integer values that don‚Äôt stand for players.\nAnd more generally, the client can look at or change whatever it pleases.\nSome of the abov", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0006", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": "e bad things are easily prohibited using the correct language features, and others can be prohibited by careful programming.\n\n2.1 Restricting fields using the language\nThis is the easy part. For fields whose values shouldn‚Äôt be updated1, we can tell the Java compiler using the final keyword, and it will prevent the fields from changing for us:\n\npublic final int width;\npublic final int height;\npublic final int goal;\npublic final int players;\nYou might wonder, Why bother with final when I can just not change the fields? This question generalizes to any design choice that imposes a restriction on how an object can be used, and the same answer generally apply: People make mistakes. It could be you in six months when you‚Äôve forgotten how the class works, or it could be that your coworkers and s", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0007", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": "uccessors don‚Äôt know that the field isn‚Äôt supposed to be changed. Sure, you could let them know with a comment, but comments are easily missed and error messages aren‚Äôt. So just in case, arrange to get that error message by using final.\n\nAs a general rule, declare every field that you don‚Äôt intend to change as final.\n\nThe other problem that Java can solve for us directly is the last one, that clients have unrestricted freedom to access the class‚Äôs fields. We can lock clients out by specifying a more restrictive access level. Java has four, though one is implicit. Ordered from most to least restrictive:\n\n\n\nThe ordering is inclusive, in the sense that if a member is visible from some other code with one of the modifiers, then it will also be visible with the weaker modifiers (lower in the ta", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0008", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": "ble). If a field, method, constructor, or nested class, enumeration, or interface is marked private then it is visible only from within the same top-level class. (That is, nested classes are considered to be part of the same class for the purpose of access levels.) If the declaration is unmarked, it has default or package scope, which means that is visible from the entire Java package in which it lives. A protected member is additionally visible from any subclasses of the class where it‚Äôs declared, and public member is visible everywhere.\n\nTo see what this means in a bit more context, consider these four classes in two packages:\n\npackage first;\n\n    public class Base {\n        private   int privateField;\n                  int packageField;\n        protected int protectedField;\n        publ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0009", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": "ic    int publicField;\n    }\n\n    class FirstHelper { ... }\n\npackage second;\n\n    public class Derived extends Base { ... }\n\n    class SecondHelper { ... }\nFrom which classes is each member field of Base visible? Just use the table above!\n\n\n\nAs with final, the best rule of thumb for using access level modifiers is to follow the Principle of Least Privilege:\n\nEvery program and every privileged user of the system should operate using the least amount of privilege necessary to complete the job.\n\nFor fields, this means private the vast majority of the time. Exceptions are few:\n\nConstants, meaning static final fields containing immutable values, are often public.\nFields that must be accessible to subclasses can be protected (though often it‚Äôs better to give a subclass that kind of access via me", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0010", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": "thods).\nWhen multiple classes within the same package are cooperating in some close way such that it doesn‚Äôt make sense for them to communicate via interfaces, you can use the default access level.\nEvery time you make a field more accessible than it needs to be, you lose further control of what happens to it, and some ability to change that part of the representation in the future. Next, let‚Äôs explore how we can use the control that access levels give us in order to eliminate additional bad freedoms.\n\n3 Example: the Even class\nAbove we discussed the idea of bad freedoms‚Äîthat a representation might be able to do things that don‚Äôt make sense in terms of the information that it models. For example, the width field of our proposed Connect ùëÅ\n model implementation is declared with type int, whic", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0011", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": "h means that as far as Java is concerned, any int goes, even if it‚Äôs something like -8, which makes no sense as a width.\n\nSome bad possibilities are ruled out by the language we‚Äôre programming in. In Java, if we declare width to be an int then the language guarantees that it will be.2 However, Java (and most but not all other languages) gives us no way to say directly that width must be positive. But it does give us a way to control it, if we think and program carefully.\n\nConsider this class for representing even integers:\n\n/**\n * An even integer.\n */\nfinal class Even {\n  /*\n   * Constructs an {@code Even} from an even {@code int}.\n   *\n   * @param value  the {@code int} representation of the even number\n   * @throws IllegalArgumentException if {@code value} isn't even\n   */\n  public Even(", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0012", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": "int value) {\n    if (value % 2 != 0) {\n      throw IllegalArgumentException(\"value must be even\");\n    }\n\n    this.value = value;\n  }\n\n  /**\n   * Returns the even value as an {@code int}.\n   *\n   * @return the even {@code int}\n   */\n  public int getValue() {\n    return value;\n  }\n  private final int value;\n}\nThe Even class has one field, an int representing the number. Given the intended meaning of an Even class, it would be wrong for field value to contain an odd number (or from the client perspective, that the result of getValue() would be odd). Because the Java programming language doesn‚Äôt understand, much less track, evenness, it cannot directly enforce this restriction for us. Instead, the Even class enlists other rules of the language to enforce its requirements.\n\nHow do we know that", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0013", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": " field value can never be odd?\n\nThe constructor only initializes with even numbers and throws when given an odd number.\nThe value of a final field cannot change.\nTogether, these two facts are enough to establish that value is always even, because the constructor makes that so and nothing3 changes the evenness of value.\n\nLet‚Äôs consider what happens when the class is modified slightly. Like Even, EvenCounter‚Äôs value should always be even, but EvenCounter affords the client to increment the value field:\n\nfinal class EvenCounter {\n  public EvenCounter(int value) {\n    if (value % 2 != 0) {\n      throw IllegalArgumentException(\"value must be even\");\n    }\n\n    this.value = value;\n  }\n\n  public int nextValue() {\n    return value += 2;\n  }\n  private int value;\n}\nAgain we‚Äôd like ensure that value ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0014", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": "is always even, but the situation is complicated by mutation.\n\nHow do we know? Consider that\n\nthe constructor initializes value to an even number,\nthe only way to change a private field is by calling a method, and\nmethod nextValue() preserves evenness.\nThat last point is key. Does nextValue() ensure that value is even when it returns? Not at all! However, it does ensure that if value is even when nextValue() is called then value continues to be even upon the method‚Äôs return.\n\nWe can use similar reasoning to determine whether adding particular methods would allow objects of the class to violate its rules. Consider, for example, these methods:\n\npublic void reset() {\n  value = 0;\n}\nRegardless of the prior value of value, this leaves it in a correct (even) state. So adding reset is no threat.\n", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0015", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": "\npublic int scale(int factor) {\n  return value *= factor;\n}\nHere the situation is subtler, because scale does not in fact ensure that after it's called, value is even. However, if value is even to begin with then multiplying by another int will leave it even afterward.\n\npublic int halve() {\n  return value /= 2;\n}\nUnlike scale, which can only make harmless changes, division can produce oddness from evenness. Thus, halve can be called when the object is in a good state and leave it in a bad state, so we reject halve.\n\npublic int half() {\n  return value / 2;\n}\nMethod half looks strikingly similar to method halve, but half is fine and won't break our evenness abstract. Can you see why?\n\n4 What‚Äôs going on here?\nIn the preceding section, we employed a technique for reasoning about programs calle", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0016", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": "d a class invariant. A class invariant is a logical statement about the instantaneous state of an object that is ensured by the constructors and preserved by the methods. Let‚Äôs break that down:\n\nA logical statement is a claim that is true or false.\nThe instantanous state of an object is the combination of values of all its fields at some point in time.\nThe invariant is ensured by constructors in the sense that whenever a public constructor returns, the logical statment holds.\nPreserving the logical statement means that the method doesn‚Äôt introduce nonsense‚Äîinstead, we know that if given a object in a good state then it will leave the object in a good state as well.\nHere are some comments that are not class invariants:\n\n// INVARIANT: value is small\nThis doesn‚Äôt work as an invariant because ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0017", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": "it isn‚Äôt a logical statement, hinging as it does on the vague word ‚Äúsmall.‚Äù\n\n// INVARIANT: value never decreases\nThis is another statement that, true or not, it‚Äôs not of the right form to be a class invariant because it‚Äôs a temporal statement rather than a statement that applies at any single point in time.\n\n// INVARIANT: value is non-negative\nHere we have a logical statement about the instantaneous state of the object, but the statement isn‚Äôt true‚Äîthe constructor is fine being passed a negative number‚Äîso it isn‚Äôt an invariant.\n\n// INVARIANT: value an int\nTrue, but vacuous because Java‚Äôs type system takes care of this invariant for us. It‚Äôs very rarely worth listing.\n\n5 Back to Connect N\nWe can apply the class invariant technique to our implementation of the Connect N model to rule out the", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0018", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": " additional kinds of nonsense states that were method earlier, such as dimensions being negative or the columns list containing values that don‚Äôt correspond to players. We guard against these possibilities by imposing class invariants and checking that they‚Äôre respected. In the case of Connect N, we want know that the dimensions are always sensible (positive), the turn stands for a valid player, the length of the columns list equals width of the grid, the length of every column in the list doesn‚Äôt exceed height, an all the elements of the columns are non-null integers between 0 and players - 1.\n\nIn order to apply class invariant reasoning, we need to determine what invariants we have (or think we have), and then check the code to make sure that‚Äôs true.\n\n6 The class invariant reasoning prin", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0019", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": "ciple\nClass invariants enable a form of reasoning called rely-guarantee. The idea is that components rely on some things being true when they‚Äôre invoked, and they guarantee some things being true upon return (provide their reliance is satisfied). In particular,\n\nif the constructor ensures some property,\nand every method (or means by which the client can mutate the object) preserves the property,\nthen every public method, on entry, can rely on the property.\nIn this way, class invariants allow you to rule out object representations that you don‚Äôt want.\n\n7 Example: rational numbers\nSometimes we want to rule out representations because they don‚Äôt make sense in terms of the relevant domain, but another reason to restrict representations is to make other parts of our program simpler. For example", "topics": ["decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0020", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": ", we might write rational number class using a fractional representation with a numerator field and a denominator field. Unfortunately, this representation has a wrinkle, because there are many ways to write each rational number as a fraction.\n\nWe now consider three iterations of an implementation of a simple Rational interface:\n\nRationalImpl1 disallows constructing an object with zero denominator (common the next two iterations as well), but imposes no other restrictions on the values of the num and den fields and deals with the possibility of different ways to represent the same number on an ad-hoc basis, converting where necessary.\nRationalImpl2 documents the invariant that den != 0. It then takes advantage of the new invariant by introducing a private fast path for Rational constructio", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0021", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": "n where the denominator is guaranteed to be zero. It does this by removing all validation logic from the constructor to a static factory method, and then making the constructor, which now trusts its parameters, private.\nRationalImpl3 adds the invariant that the fractional representation is in least terms, or equivalently, that the greatest common divisor between den and num is 1. Least-terms fractions define a canonical represention for each rational, which means that now we can compare rationals by comparing their components without any kind of conversion. And operations that are known to preserve least terms, such as negation, are allowed to skip validation altogther when constructing a the result.\n8 Other invariants\nThe notion of an invariant should be familiar from last year. Recall fr", "topics": ["factory", "decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0022", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": "om Fundies 2 our discussion of heaps, which were binary trees that obeyed two invariants simultaneously:\n\nA structural invariant, the fullness property, that ensured the tree with ùëõ\n items was always as short as it could possibly be, which in turn ensured ùëÇ(logùëõ)\n performance. It also came in handy when we looked at clever data representations of heaps using arrays.\nA logical invariant, the heap-ordering property, that ensured the largest values were always near the root of the tree and that all subtrees were themselves heaps.\nThese invariants gave us similar rely-guarantee reasoning principles as the class invariants we discussed above, albeit based on totally different premises. Note that both of these invariants are instantaneous properties, like class invariants, but they are not prope", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0023", "source": "data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt", "text": "rties of a single isolated object (though if you squint and treat the entire heap as a ‚Äúsingle‚Äù entity, it‚Äôs pretty close). We then used these invariants to drive our algorithm design.\n\nClass invariants are similar in spirit, but a bit different in scope. They focus more on making all the methods of a single class work properly in concert, so that other parts of the program can rely on the property being true. When a single class implements an entire data type, class invariants and logical invariants become largely the same thing, but it‚Äôs rare for a data type to be implemented by just one class!\n\n1Meaning the primitive or reference value in the fields; objects referred to by references in final fields can still be mutated.\n\n2What possibilities does your favorite language let you rule out?", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0000", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "Lecture 13: GUI Basics\nMVC codestarter codesolution code\n1 Introduction to Views\nSo far we‚Äôve worked on designing models to represent the data relevant to a problem domain, in a form that encapsulates the data behind an interface that clients can use without having to know any implementation details. The model is responsible for ensuring that it can‚Äôt get stuck in a bogus or invalid state, and exposes whatever appropriate observations and operations are needed while still preserving this integrity constraint.\n\nWe‚Äôve also worked on simple synchronous controllers that allow users to interact with a model, in a form that encapsulates the user interactions and can provide feedback to users without having to redundantly ensure any integrity constraints. Moreover, controllers can be customized o", "topics": ["mvc", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0001", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "r enhanced without needing to change the model, making the model more convenient to use without making it any more complex.\n\nNow, it‚Äôs time to introduce the third part of the MVC trio: views. Views are renderings of the data in the model, and can be as simple as printing debug output to a console, as complex as fancy graphical user interfaces, or anything in between. Dealing with GUIs also brings additional challenges, and we will discuss some of them.\n\n1.1 Outline\nThis lecture starts by adding a text-based, interactive view to the program. This is closest to our earlier design for the controller, but it carves out a view cleanly. This example also illustrates the typical interactions between the model, view and controller in a simple manner.\n\nWe then progressively transition to graphical ", "topics": ["mvc", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0002", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "user interfaces. We start with poorly-designed but working code, and improve it in three stages. Initially, the code for the view will directly manipulate the model. Our first incremental improvement will decouple the view from the model so that it need not ‚Äî and in fact cannot ‚Äî do so. Our second improvement will add a new feature to the view, and add the ability to control that in the controller. Finally, our third improvement will generalize the controller to make its UI triggers more customizable.\n\nThe code for this lecture is available at the top of this page, as the MVC code link. The second link provides code for a program with an incomplete GUI. It is recommended that you complete this exercise to practice with GUIs. Finally the third link provides a solution for this GUI.\n\n2 Desig", "topics": ["mvc", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0003", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "n\nAll examples in this lecture follow a common design. The model state (interface IModel and implementation Model) consists of a single String and offers methods to get and update it. All views (coupled with controllers wherever applicable) expose functionality to interactively show this string, and to update it.\n\n3 Text-based UI\nIn the TextUI directory we show a text-based user interface. The IView interface encapsulates all the methods that a view‚Äôs client would need to call: note how they correspond roughly to the ‚Äúthings‚Äù that a controller would need to tell the view to do. The TextView class implements this interface. It transmits all messages to a PrintStream object provided to it through its constructor. Similar to the design in Lecture 8 this allows us to test the view using any su", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0004", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "itable PrintStream object.\n\nThe IController interface represents a controller: it has only method which is called to give control of the application to the controller. The TextController class implements the controller. It works with IModel, IView and Scanner objects to handle model, view and data input functionality respectively. At its heart, the controller goes through a loop that provides users with some options, takes further inputs depending on the chosen options and delegates to the model and view accordingly. Since the sequence of operations is largely fixed, this qualifies as a synchronous controller.\n\n4 Stage 1: Introduction to GUIs\nIn the BadDesignButFunctional directory, we have a poorly written implementation of a simple program that uses the same model, but a graphical user i", "topics": ["mvc", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons", "topics": ["mvc", "decorator", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0006", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "tructor of our frame, we create four components: a label to show some text, a text box to edit text, and two buttons. Adding several controls to a frame requires that we give them a layout, which describes the spatial relationships between the controls. In this example, we‚Äôre using a FlowLayout, which allows the controls to wrap around as we resize the window. (Try running the project and resizing the window to be narrower than the controls are.) Different layout managers allow adding controls in different ways. Once controls are added to the UI, the pack() method is used tell the layout manager to determine the actual positions and sizes of all the controls.\n\nIn order for the controls to do anything, however, we need to add an event handler to them. An event handler, or callback, is simpl", "topics": ["decorator", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0007", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "y a function that gets called when something interesting occurs. In our case, the clicking of different buttons should trigger a callback. In the jargon of Swing, clicking on buttons triggers their action, and so we must supply a function object that implements the ActionListener interface. (Other controls have additional events besides ‚Äúactions‚Äù.) For convenience, Swing allows us to label each button with a so-called action command, which is a String of our choosing: when the ActionListener‚Äôs callback is invoked, it will be given an ActionEvent object that knows the action command of the button that was clicked. In this way, we can use a single listener to listen to multiple buttons at once, and distinguish them by means of this command string. See the calls to setActionCommand and setAct", "topics": ["observer", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           // Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); // set its command,\n    echoButton.addActionListener(this);         // set the callback,\n    this.add(echoButton);                       // and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           // ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech", "topics": ["mvc", "observer", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0009", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "o Button\": ...\n    case \"Exit Button\": ...\n    }\n  }\n\n  ...\n}\nNote: Combining the event handlers of multiple buttons into a single function is only temporarily convenient: often, the code we want to run for one button is completely different from the code we want to run for a different button, so there‚Äôs not much benefit from merging them all. Instead, it is more common to create anonymous objects, or (even terser) lambda expressions, so that each button gets its own custom handler. We‚Äôll see other idioms of setting up listeners below.\n\n5 Stage 2: Decoupling the view from the model\nThe code above technically works, but it is very poorly designed: the view is responsible for mutating the model, which means there‚Äôs no separation of concerns between this view and any controller, and if we wan", "topics": ["mvc", "observer"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0010", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "ted to use the model with another sort of view, we‚Äôd be out of luck. In the BasicMVC directory, we start to remedy this. In particular, we want to separate out all the parts of the code that mutate the model, and isolate them within a controller.\n\nTo do this, we create a Controller class that takes in the model and the view ‚Äî at their interface types, not at their concrete class types. We revise the view so that it no longer has access to the model at all. (This is overly drastic; we merely want to ensure that the view does not have mutable access to the model. We can revisit this later.) We next add a method to the view interface, void setListener(ActionListener), which is the key indirection needed here. Instead of the view directly implementing the response to events, this method allows", "topics": ["mvc", "observer"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": " the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { // NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); // NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); // Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); // add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie", "topics": ["mvc", "observer", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0012", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "w v) {\n    this.model = m;\n    this.view = v;\n    view.setListener(this);\n    view.display();\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n      case \"Echo Button\": ...  // same code as before, but now\n      case \"Exit Button\": ...  // it's extracted out of the view\n    }\n  }\n}\nThe controller is now the only part of the system that has mutable access to the model. Because it requested that the view register itself as the listener for the buttons, the controller gets called exactly when necessary, and it can decide what mutations to perform on the model. The view doesn‚Äôt even know that it‚Äôs received a controller object: as far as it‚Äôs aware, the controller is simply a random ActionListener. (Note: It is overly simplified to have the Con", "topics": ["mvc", "observer"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0013", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "troller directly implement ActionListener ‚Äî after all, there might be many controls inside the view that could raise action events, and so having a single ActionListener isn‚Äôt a scalable approach. A better approach would be to have the Controller have one or more ActionListeners ‚Äî i.e., preferring composition over inheritance ‚Äî but we use this simplified form for now to reduce the number of classes in this example.)\n\nNote: there is a subtle difference between the setListener method we‚Äôve defined on our IView interface, and the addActionListener method present on the Swing components: our method‚Äôs name implicitly intends for only one listener at a time, but Swing components allow for multiple listeners. When we have multiple listeners, we‚Äôll sometimes say that the control broadcasts its eve", "topics": ["mvc", "observer", "decorator", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0014", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "nt to whoever‚Äôs listening, or that it publishes its event to whoever‚Äôs subscribed to it. There‚Äôs nothing limiting us from implementing this more general approach, but that generality wasn‚Äôt needed here.\n\n6 Stage 3: Enhancing the view with keyboard support\nOur next addition of functionality is shown in the KeyboardEvents directory: we want to add some keyboard-triggered behaviors. Specifically, we‚Äôll add two fancy features to our UI: the ability to toggle the color of the text from black to red and back, and the ability to temporarily show the text in all-caps. We‚Äôll switch colors every time we type the 'd' key, and we‚Äôll temporarily capitalize the text while we‚Äôre pressing and holding the 'c' key. Interestingly, only one of these two new features requires adding a new method to our view in", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0015", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "terface.\n\nFirst, we‚Äôll need to generalize our setListener method, to take in a KeyListener as well as an ActionListener. A KeyListener is analogous to a ActionListener, but as the name suggests, it listens for keyboard-related events. There are three such events: when a key is pressed, when a key is typed, and when a key is released. Pressing and holding down a key for a while will typically generate one key-pressed event, several key-typed events, and one key-released event. Just as ActionListeners accept ActionEvents, KeyListeners accept KeyEvents containing information about which key was involved. We‚Äôll use the keyTyped event to toggle the color of the text, use the keyPressed event to capitalize the text, and use the keyReleased event to un-capitalize the text.\n\nFor now, we‚Äôll simply ", "topics": ["observer"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0016", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "have our controller implement the KeyListener interface also, and pass itself along as the second argument to view.setListeners. Again, note that the view doesn‚Äôt know or care that the exact same object is being passed in as the two distinct listeners: the types ensure that it doesn‚Äôt matter. (Note: And again, this is overly simplified, and we ought to have a distinct class implement this KeyListener interface, rather than have the Controller class do everything itself.)\n\nTo implement the color changing, we‚Äôll need to add a method to our view interface to toggle the color of the text. This is intrinsically a view-specific thing, since the controller cannot know exactly how the text is displayed or which control it needs to change color. (That would leak internal implementation details of t", "topics": ["mvc", "observer"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0017", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "he view, and in any case, the controller only knows it has an IView rather than a particular view class.)\n\nTo implement the capitalization, note that we do not actually mutate the model! This is both a good thing and a necessary thing: suppose the model text contained a mixture of upper- and lower-case letters. If we mutated the model and capitalized everything, then we would not be able to undo that change later. Instead, we ask the model for its content, and inform the view that it should display a capitalized version of the that content. (This view-only change is analogous to ‚Äúzooming in‚Äù while editing a picture in Photoshop or some other image editor: the view is technically displaying only a subset of the pixels of the document, and moreover is displaying them at far more than one scr", "topics": ["mvc", "command"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0018", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "een pixel per document pixel! If ‚Äúzooming in‚Äù actually mutated the document, then we‚Äôd lose information and be unable to ‚Äúzoom out‚Äù again.)\n\n7 Aside 1: Low-level and high-level events\nWithin the KeyListener interface, there is a qualitative difference between the key-pressed and key-released events, and the key-typed event. Individual key events are incredibly, tediously low-level. Just trying to type a capital 'A' generates five events: the Shift key was pressed; the A key was pressed; the letter 'A' was typed; the A key was released; the Shift key was released. (The last two events might happen in either order, depending on which key was released first.) Notice that only one key-typed event occurred, though, and it contained exactly the text that was typed.\n\nIf we had to deduce which key", "topics": ["observer"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0019", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "s were typed, merely from the key-pressed and key-released events, we‚Äôd quickly lose track. Java (and most GUI toolkits) thankfully translate those sequences into higher-level key-typed events. And this translation has an addtional benefit: consider typing non-English text on a typical QWERTY keyboard. We clearly need to type mutliple physical keys to produce one logical character (this is sometimes known as ‚Äúchord‚Äù input, by analogy with pressing multiple keys on a piano keyboard), and this translation lets us ignore the individual key-pressed and key-released events if we only want to consider what text was typed.\n\nOn the other hand, if we want to keep track of which keys are pressed (e.g. to control a player‚Äôs motion while a key is held down), we need to resort to the lower-level events", "topics": ["gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0020", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": ".\n\nThis low-level/high-level distinction is not clearly defined, and depends on perspective. Would we consider ActionEvents to be low-level or high-level? On the one hand, they‚Äôre clearly much higher-level than individual MouseEvents, which are analogous to KeyEvents and indicate when a mouse button is pressed, released, or clicked, or when it enters or exits some area. Indeed, JButtons register themselves as MouseListeners, and translate the relevant mouse-clicked event into an ActionEvent! (They also register themselves as KeyListeners, and generate ActionEvents when the Enter key is pressed.) But at the same time, the user of our view might not care which particular buttons we happened to use to implement the view, and there might well be multiple buttons that trigger identical actions:", "topics": ["mvc", "observer"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0021", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": " from that perspective, action events are too low-level and should be implementation details hidden behind some abstraction barrier.\n\nDesigning a view and controller properly requires considering what level of detail we want to expose in the events that the view forwards to the controller. Our current designs expose far too low-level detail: ‚Äúsomething happened with the following action command‚Äù, or ‚Äúsome key was pressed/typed/released‚Äù. These events are very general, and have no specific semantics for our application. Let‚Äôs consider the different enhancements we can make, using either low-level or high-level events. We‚Äôll find that we might want to translate generic low-level events into application-specific high-level ones.\n\n8 Stage 4: Making the controller more flexible using low-level ", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0022", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "events\nMany applications run on multiple systems (e.g. Windows, Mac and Linux), and have hotkeys to perform various common actions ‚Äî but the exact hotkey differs on each platform. It would be a shame to have to recompile the code in order to support these different keys. Similarly, many applications allow the user to customize the hotkeys that control the application. Here, it‚Äôs outright impossible for users to recompile the program to customize its behavior! Our next generalization aims to alleviate this lack of flexibility.\n\nOur prior attempt hard-coded the keys in the various key event-listeners. In the KeyboardMaps directory, we generalize this so that we can reconfigure hotkeys at runtime. To accomplish this, we design a new KeyListener implementation that uses dictionaries of Runnabl", "topics": ["observer"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0023", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "es instead of switch statements in its event handlers. Specifically, our KeyboardListener will contain a Map<Integer, Runnable> dictionary for its key-pressed event handler, another such dictionary for its key-released handler, and a Map<Character, Runnable> dictionary for its key-typed handler. (These Runnables are examples of the command pattern, which we talked about several lectures ago.)\n\nThe handlers are pleasingly straightforward:\n\n// In the KeyboardListener class\n@Override\npublic void keyTyped(KeyEvent e) {\n  if (keyTypedMap.containsKey(e.getKeyChar()))\n    keyTypedMap.get(e.getKeyChar()).run();\n}\n\n// analogously for the other two events\nBecause the dictionaries are data, we can mutate them at runtime if we so choose, and therefore change which keys are mapped to which responses. (", "topics": ["observer", "command"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0024", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "For variety‚Äôs sake, we show three different syntaxes for creating Runnables: explicit classes, anonymous classes, and lambda expressions.)\n\n// In the Controller class\n  private void configureKeyBoardListener() {\n    Map<Character, Runnable> keyTypes = new HashMap<>();\n    Map<Integer, Runnable> keyPresses = new HashMap<>();\n    Map<Integer, Runnable> keyReleases = new HashMap<>();\n\n    // Uses an explicit function-object class to provide the implementation\n    keyReleases.put(KeyEvent.VK_C, new MakeOriginalCase());\n    // Uses an anonymous object to provide the implementation\n    keyPresses.put(KeyEvent.VK_C, new Runnable() {\n      public void run() {\n        String text = model.getString();\n        text = text.toUpperCase();\n        view.setEchoOutput(text);\n      }\n    });\n    // Uses la", "topics": ["mvc", "observer"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0025", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "mbda-syntax to provide the implementation\n    keyTypes.put('r', () -> { view.toggleColor(); });\n\n    KeyboardListener kbd = new KeyboardListener();\n    kbd.setKeyTypedMap(keyTypes);\n    kbd.setKeyPressedMap(keyPresses);\n    kbd.setKeyReleasedMap(keyReleases);\n\n    this.view.addKeyListener(kbd);\n  }\n(In the same manner as this KeyboardListener, our implementation also generalizes the ActionListener implementation into a dictionary that maps action commands to Runnables.)\n\nThis transformation, which converts explicit control flow (the switch statements we had earlier) into data (the keys of the Map) is a very common one in programming. We‚Äôve clearly improved things somewhat, but we‚Äôre not finished: after all, if we hard-code the keys of the Map (as we did in the calls to keyPresses.put above", "topics": ["mvc", "observer"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0026", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "), we haven‚Äôt really fixed anything, right? Fortunately, we know a way around this: by using a combination of a reader and builder, we could read in a ‚Äúuser preferences file‚Äù to figure out what keys to put in the maps, and then our code is completely agnostic to exactly which keys are needed for which handlers.\n\n9 Stage 5: Decoupling the view from the controller using high-level events\nThe previous generalization relied on the view exposing its low-level events to the controller. However, we might reasonably want to trigger the same behavior from multiple UI controls. In the GeneralCommandCallbacks directory, we take this approach: our view can toggle the color of the text either via a button, or via typing the 't' key. (This is a simplified example, but is a stand-in for typical toolbar b", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0027", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "uttons doing the same thing as hotkey shortcuts.)\n\nThe key innovation in this design is that we‚Äôve eliminated the ActionListeners and KeyListeners from the controller and also from the IView interface. Instead, we have a new addFeatures method that takes in a new interface, Features, whose methods are the various high-level features and abilities of our view. Our prior interfaces exposed low-level events saying, for instance, ‚ÄúHey, a button with this action command has been clicked; what should be done?‚Äù These new callbacks say, for example, ‚ÄúThe user has requested to make the display uppercase; what should be done?‚Äù This interface is bigger than the ActionListener interface, but it‚Äôs also much more application-specific, and it advertises exactly the responsibilities a controller has to up", "topics": ["mvc", "observer"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0028", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "hold for this view. It also successfully encapsulates the action commands that we leaked in prior designs: the view is now free to change those commands without breaking the controller at all.\n\nThis design is quite elegant, and does the best job of loosening the coupling between the view and the controller: by encapsulating the details of which physical controls do what, the view is much more abstracted away, and the logical interface that it presents to the controller is much more application-specific. Note that the Controller class and the Features interface know absolutely nothing about Swing: they don‚Äôt even import the packages! Just like our model doesn‚Äôt need to know about how it‚Äôs being displayed, so too our controller doesn‚Äôt really need to know how the views are implemented. When ", "topics": ["mvc", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0029", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "possible, aspire to interfaces like this one, but be prepared to fall back to lower-level events when necessary.\n\nNote: It might seem odd that the toggleColor method is both a callback on the Features interface and a method on the IView interface ‚Äî why can‚Äôt the view handle this internally? Indeed, it possibly could! (And in some circumstances, the view definitely should handle some events entirely internally: for instance, when implementing a text editor, the view should probably internally handle the sequence of low-level events that indicate the user has selected a stretch of text. Once the user does something with that text ‚Äî deletes it, replaces it, copies it, etc. ‚Äî the view can raise a semantically relevant high-level event with the selected content.) But consider a ‚Äúbigger‚Äù version", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0030", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": " of our current program, where we have two views that we want to keep synchronized: if either of them has toggled its color, both should toggle their colors together. The only way to ensure this synchronization is for the view to forward the event to the controller, which can in turn decide to tell both views how to update themselves.\n\nNote: Once again, in the sample code and in the snippets below, we write that the Controller implements Features directly: we use an is-a relationship. A better approach is to use a has-a relationship, and have a dedicated object that implements the Features interface instead. We omit this variant here, because there are enough other details to focus on right now!\n\n10 Aside 2: Designing a Features interface\nIn the previous section we introduced a Features in", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0031", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "terface, that hid the Swing-specific event listeners and instead exposed application-specific events. But how are we to know what sort of application-specific events we should have? It‚Äôs difficult to give a one-size-fits-all answer here, since by definition this will be rather application-specific. Instead, we can articulate some guidelines to follow:\n\nAvoid any view-specific classes in the Features interface wherever possible. Above, we said to eliminate any mention of Swing-specific events, and generalized it further so that the controller did not need to depend on the Swing library at all. We can easily come up with a plausible counterexample to this generality: suppose we were building a drawing program, and the view allows the user to choose a color to draw with. Surely the Features i", "topics": ["mvc", "observer", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0032", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "nterface should expose the java.awt.Color that the user picked? In this case, though, the model also depends on java.awt.Color, and so the view isn‚Äôt introducing any new dependencies. If the model chose a different class to represent its colors, then the Features interface ought to expose that, rather than the Swing color directly.\nTreat the methods in the Features interface as requests from the user. In particular, a view might allow a user to attempt various editing operations that the controller might prohibit, or that the model might reject as invalid. In our example above, ‚Äúrequesting an uppercase display‚Äù fits into this mindset. Additionally, brainstorming ‚Äúwhat might the user try to do?‚Äù can help articulate all the possible features a user might want from the program, which in turn ", "topics": ["mvc", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0033", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "can help design the Features methods needed.\nNot all view-specific events need to turn into Features requests. However, events that never make it to the controller are therefore intrinsically uncontrollable. In sophisticated GUIs, a single controller might need to synchronize multiple views: for instance, a split-screen text editor could have two views of the same file, whose contents should be changed in tandem. A video editor might have a timeline view at the bottom of the screen, as well as controls for the effects and a preview window, all of which must stay consistent. A spreadsheet might have a grid showing many cells of data, a textbox to edit a single cell, and a graph of multiple cells‚Äô data, again which all must stay consistent. When implementing event handlers inside a particula", "topics": ["mvc", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0034", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "r view, consider whether the change being handled might need to be synchronized with multiple views: if so, then it should be raised as a Features request. If not, then it might be entirely handled within the view. For instance, scrolling a single text file might not need to inform the controller that the file has been scrolled, and so scrolling could be handled entirely within the view. On the other hand, a diff viewer that compares two files might wnat to scroll both files in unison, and so any scroll changes would need to be raised to the controller‚Äôs attention so that it can synchronize both views.\nWhen a Features event is raised to the controller‚Äôs attention, the view probably shouldn‚Äôt mutate itself, but rather wait for the controller to tell it to do so ‚Äî this is in keeping with thi", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0035", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "nking of features as requests rather than demands. We noted this above, where toggleColor was both a method in the Features interface and also a method on the view, and the controller‚Äôs implementation of the toggleColor method turned around and called the view‚Äôs method, and we said this might seem overly roundabout. We gave one example where this was needed for synchronization of multiple views. Another might be triggering some resource-limited effect (where the resource might be tracked by the model, like in-game bonuses, or the resource might be controller-specific, like live-streaming a video of a gameplay). The view shouldn‚Äôt modify itself until the controller (and possibly model too) has confirmed that the request can go through.\nAny event that is handled entirely within the view is i", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0036", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "ntrinsically more difficult to test. We would have to synthesize the low-level UI events, which may be impractical or even impossible to do sufficiently. By decoupling the particular UI event that triggers behavior from the Features implementation that actually provides the behavior, we limit the hard-to-test code to just the ‚Äúwiring‚Äù between the event listeners and the Features object. Since all the interesting behavior is now in the Features object, and since its methods depend only on application-specific concepts and types, we can easily create a mock view that triggers Features methods without needing the actual Swing events. This allows for test cases analogous to those we saw in Lecture 8, with all the benefits they bring.\n11 Stage 6: Further enhancements using InputMaps and ActionM", "topics": ["mvc", "observer", "testing", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0037", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "aps\nOur last revision eliminated the flexibility of dynamically changing hotkeys and reverted to hard-coding the keys in the view‚Äôs implementation of its own key listener. Combining the flexibility of the KeyboardListener and its dictionaries, with the high-level events of the Features interface, is aesthetically tricky: who should control which keys do what? In some sense, it almost feels like the choice should be made not by our current controller, which is controlling a particular model and view, but rather to some hypothetical ‚Äúapplication controller‚Äù, that controls the overall application. We‚Äôve already encountered this in practice: in IntelliJ, there are both project-specific settings and application-wide settings, and different dialogs control those different features.\n\nAdditionally", "topics": ["mvc", "observer", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0038", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": ", implementing the keyboard-listening dictionaries is tedious: surely this functionality could be implemented once and for all, and we wouldn‚Äôt need to redo it in every single application?\n\nThe solution, once again, is a layer of indirection. We‚Äôve seen above that Swing components have a notion of an action command, and that we can cause code to run depending on which action was triggered. Combining several of these actions together should seem reminiscent of the KeyboardListener dictionaries we just built. In fact, Swing has a concept of an ActionMap, which is essentially just such a dictionary from action commands to actions.1 An Action in Swing has many potential subclasses; we‚Äôll focus on the AbstractAction class, which we can subclass ourselves to create new action handlers. For insta", "topics": ["observer", "decorator", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0039", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "nce, we might write\n\nAction makeOriginalCase = new AbstractAction() {\n  public void actionPerformed(ActionEvent e) {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n};\nAction makeCaps = new AbstractAction() {\n  public void actionPerformed(ActionEvent e) {\n    String text = model.getString();\n    text = text.toUpperCase();\n    view.setEchoOutput(text);\n  }\n};\nAction toggleColor = new AbstractAction() {\n  public void actionPerformed(ActionEvent e) {\n    view.toggleColor();\n  }\n};\nThis is all well and good, and now we have yet one more way of representing runnable bits of code, but how should we actually associate these actions with their keyboard triggers? First, we associate these Actions with their action commands:\n\n// Somewhere in our View class:\n\naComponent.getActi", "topics": ["mvc", "decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0040", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "onMap().put(\"restoreLowercase\", makeOriginalCase);\naComponent.getActionMap().put(\"makeCaps\", makeCaps);\naComponent.getActionMap().put(\"toggleColor\", toggleColor);\nWe then need the second piece of the indirection: an InputMap. InputMaps associate KeyStrokes with action commands. A KeyStroke describes our key-press, key-release, and key-type low-level events in a uniform manner. When a low-level key event matches something in an InputMap, the associated action command is looked up in the ActionMap and fired. So we can continue our code as follows:\n\n// Somewhere in our View class:\n\n// Use simplest constructor to describe a key-press\naComponent.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_C), \"makeCaps\");\n// Use another constructor to describe key-releases\naComponent.getInputMap().put(", "topics": ["mvc", "decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0041", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "KeyStroke.getKeyStroke(KeyEvent.VK_C, true), \"restoreLowercase\");\n// Yet another constructor lets us describe key-typed events\naComponent.getInputMap().put(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\nNote: InputMaps and ActionMaps apply only to JComponents, and not to JFrames directly. However, we can easily add a component to our frame for the sole purpose of handling key events, and we can specify that its InputMap be used whenever the frame has focus at all.\n\nThis seems like a lot of machinery to introduce, and it would be unwieldy if it weren‚Äôt so reusable. The critical design patterns here are:\n\nWe have a mechanism for translating low-level (KeyEvents) into mid-level action commands.\nWe have transformed control flow (of what code to run based on what key was pressed) into data ", "topics": ["decorator", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0042", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "(a map of KeyStrokes).\nWe have a mechanism from translating mid-level action commands into actual runnable actions.\nThe code still suffers from one problem: the Actions themselves feel like they belong in the controller (since they refer to model and view), but are referenced directly in the view (in the getActionMap().put(...) lines). We can combine these maps with our Features design, to get one final translation from mid-level action commands to high-level events:\n\n// NOTE: this class makes no mention of Actions or Controllers.\npublic class JFrameView extends JFrame implements IView {\n  KeyComponent keyComponent;\n\n  public JFrameView(String caption) {\n    super(caption);\n    ...\n    this.keyComponent = new KeyComponent();\n    this.add(keyComponent);\n  }\n\n  public void setHotKey(KeyStrok", "topics": ["mvc", "decorator", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0043", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "e key, String featureName) {\n    this.keyComponent.getInputMap().put(key, featureName);\n  }\n\n  public void addFeatures(Features features) {\n    this.keyComponent.addFeatures(features);\n  }\n}\n\n// NOTE: Neither does this class!  It only refers to Features.\nclass KeyComponent extends JPanel {\n  List<Features> featureListeners = new ArrayList<>();\n\n  // Includes this new feature listener in responding to keys\n  void addFeatures(Features f) { this.featureListeners.add(f); }\n\n  KeyComponent() {\n    // Install action command -> Feature callback associations\n    this.getActionMap().put(\"makeCaps\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.makeUppercase();\n      }\n    });\n    this.getActionMap().put(\"restoreLowe", "topics": ["observer", "decorator", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0044", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "rcase\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.restoreLowercase();\n      }\n    });\n    this.getActionMap().put(\"toggleColor\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.toggleColor();\n      }\n    });\n    ...\n  }\n}\n\n// NOTE: Only the Controller needs to know how to implement Features.\npublic class Controller implements Features {\n  private IModel model;\n  private IView view;\n\n  ...\n\n  // These are the high-level event handlers we care about:\n  @Override\n  public void toggleColor() {\n    view.toggleColor();\n  }\n\n  @Override\n  public void makeUppercase() {\n    String text = model.getString();\n    text = text.toUpperCa", "topics": ["mvc", "observer"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": "se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  // This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    // Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that", "topics": ["mvc", "observer", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0046", "source": "data\\raw\\notes\\Lecture 13 GUI Basics.txt", "text": " extends JPanel, and override its paintComponent method to draw whatever you want, just to confirm that it works.\n\nNext, enhance the IView interface so you can pass the relevant information from the model, through the controller, into the view and into your TurtlePanel class. Once you‚Äôve connected the pieces, use this information in your paintComponent implementation to draw the turtle‚Äôs trace.\n\nThe links at the top of the lecture include a ‚Äúsolution‚Äù implementation; do not to look at that until you‚Äôve tried to implement this yourself.\n\nThe IView interface contains one method for setting up an event listener. What is its signature? Does it seem like a high-level event to you, or a low-level one? If you think it‚Äôs too low-level, can you think of a better, higher-level signature to use? If y", "topics": ["mvc", "observer", "decorator", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 14 The Observer Pattern.txt::chunk0000", "source": "data\\raw\\notes\\Lecture 14 The Observer Pattern.txt", "text": "Lecture 14: The Observer Pattern\nIn the last lecture we introduced the idea of a ‚ÄúFeatures interface‚Äù that described a way to\n\nisolate the controller from the low-level Swing components inside the view, and\nsimultaneously, allow the view to have multiple UI components trigger the same logical callback on the controller.\nWe called these ‚Äúhigh-level events‚Äù, since they were application-specific events as opposed to ‚Äúlow-level‚Äù general-purpose events. This idea of defining our own application-specific events is a very common one, and generalizes the Features interface idea into something known as the Observer Patern.1\n\n1 Motivating example: buying concert tickets\nSuppose you are interested in getting tickets for a popular upcoming concert. You know that tickets will sell out quickly, and you ", "topics": ["mvc", "observer", "decorator", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 14 The Observer Pattern.txt::chunk0001", "source": "data\\raw\\notes\\Lecture 14 The Observer Pattern.txt", "text": "don‚Äôt want to miss your opportunity. So you signup for the mailing list for the ticket service, and wait for an email telling you that tickets are now available. Of course, mailing lists being what they are, you‚Äôll probably get a bunch of unwanted messages telling you about uninteresting concerts as well, so you need to read the emails to check which concert has just gone on sale.\n\nLet‚Äôs try to represent this in code.\n\n2 Setting the stage\nLet‚Äôs assume we have a class TicketSeller that handles ticket sales for lots of concerts, and a class Person to represent you or other people interested in concerts. (To keep things simple, we‚Äôll just assume each concert has a unique name that we‚Äôll represent as a String; in practice, the data here might be more interesting, but it‚Äôll obscure the pattern ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 14 The Observer Pattern.txt::chunk0002", "source": "data\\raw\\notes\\Lecture 14 The Observer Pattern.txt", "text": "we‚Äôre looking for here.)\n\nclass TicketSeller {\n  Ticket purchaseTicketFor(String concertName) { ... sell a ticket ... }\n}\n\nclass Person {\n  void tryToBuyTicketFor(String concertName) {\n    ???\n  }\n}\nIf a concert is sold out or not even available yet, then TicketSeller#purchaseTicketFor will fail, so our goal is to call that method as soon as possible, but no sooner. So in Person#tryToBuyTicketsFor, we can‚Äôt immediately call that method. Instead, we need to ‚Äúsign up for the mailing list‚Äù somehow.\n\nTo do that, let‚Äôs define an interface\n\ninterface TicketNotificationSubscriber {\n  void ticketsAvailableFor(String concertName);\n}\nThis is the analogue of the Features interface from last lecture. With Features, our controller was interested in being called back, so it registered with the view, and", "topics": ["mvc", "observer"]}
{"chunk_id": "data\\raw\\notes\\Lecture 14 The Observer Pattern.txt::chunk0003", "source": "data\\raw\\notes\\Lecture 14 The Observer Pattern.txt", "text": " the view called its methods when appropriate. Here, our TicketSeller will call the ticketsAvailableFor method on any objects that have signed up for such notifications, and our Person objects will implement that interface and sign up for the notifications.\n\nclass Person implements TicketNotificationSubscriber {\n  void tryToBuyTicketsFor(String concertName, TicketSeller seller) {\n    seller.signUpForNotifications(this);\n  }\n\n  public void ticketsAvailableFor(String concertName) {\n    // the seller will call us back when concerts become available\n  }\n}\n\nclass TicketSeller {\n  void signUpforNotifications(TicketNotificationSubscriber obs) {\n    ???\n  }\n}\nNow we just have to connect the last few pieces. The TicketSeller will need to maintain a ‚Äúmailing list‚Äù of everyone who‚Äôs signed up to be n", "topics": ["mvc", "observer"]}
{"chunk_id": "data\\raw\\notes\\Lecture 14 The Observer Pattern.txt::chunk0004", "source": "data\\raw\\notes\\Lecture 14 The Observer Pattern.txt", "text": "otified. And whenever a new concert is announced, it should broadcast that announcement to everyone who‚Äôs signed up:\n\nclass TicketSeller {\n  List<TicketNotificationSubscriber> subscriers = new ArrayList<>();\n  void signUpForNotifications(TicketNotificationSubscriber sub) {\n    this.subscribers.add(sub);\n  }\n\n  void announceNewConcert(String name) {\n    for (TicketNotificationSubscriber sub : this.subscribers) {\n      sub.ticketsAvailableFor(name);\n    }\n  }\n}\nFinally, we can complete the Person implementation. Notice that they‚Äôll get notified for all concerts, so they need to keep track of the one concert they‚Äôre interested in:\n\nclass Person implements TicketNotificationSubscriber {\n  String interestedInConcert;\n  TicketSeller seller;\n  void tryToBuyTicketsFor(String concertName, TicketSel", "topics": ["observer"]}
{"chunk_id": "data\\raw\\notes\\Lecture 14 The Observer Pattern.txt::chunk0005", "source": "data\\raw\\notes\\Lecture 14 The Observer Pattern.txt", "text": "ler seller) {\n    this.interestedInConcert = concertName;\n    this.seller = seller;\n    seller.signUpForNotifications(this);\n  }\n\n  public void ticketsAvailableFor(String concertName) {\n    if (concertName.equals(this.interestedInConcert)) {\n      // Hooray, tickets are available for the concert we're interested in\n      seller.purchaseTicketFor(concertName);\n    }\n  }\n}\nNotice the similarities to ActionListeners: the Person gets called back with the name of what event has occurred, and can choose what to do about it based on that information. Notice also the differences: the callback here is talking about concerts, which is clearly a very application-specific sort of event.\n\n3 Enhancements and subtleties\nThe names TicketSeller, signUpForNotifications, TicketNotificationSubscriber and tick", "topics": ["observer"]}
{"chunk_id": "data\\raw\\notes\\Lecture 14 The Observer Pattern.txt::chunk0006", "source": "data\\raw\\notes\\Lecture 14 The Observer Pattern.txt", "text": "etsAvailableFor are whimsical and application-specific, but they illustrate an important point: this pattern applies to high-level events just as well as to low-level events. Regardless of the name, the Observer Pattern describes this common scenario, of multiple entities that are interested in messages being sent by some common source. There can be many observers for a single message-sender, and a single observer might be interested in many message-senders.\n\nThe general names for this pattern look as follows:2\n\nclass Subject {\n  List<Observer> observers;\n  void addObserver(Observer obs) { observers.add(obs); }\n\n  // This method gets called by other methods in the Subject class as needed\n  private void notifyAllSomethingHappened() {\n    for (Observer obs : this.observers) {\n      obs.somet", "topics": ["mvc", "observer"]}
{"chunk_id": "data\\raw\\notes\\Lecture 14 The Observer Pattern.txt::chunk0007", "source": "data\\raw\\notes\\Lecture 14 The Observer Pattern.txt", "text": "hingHappened();\n    }\n  }\n}\n\ninterface Observer {\n  void somethingHappend();\n}\n\nclass SomeObserver implements Observer {\n  void somethingHappened() { ... }\n}\n\n// somewhere in the code\nsomeSubject.addObserver(someObserver);\nWe might want to enhance the Subject class to allow unsubscribing from notifications, via a removeObserver method.\nWe might want to send more information along in the somethingHappened method, including which Subject sent the notification, or what the notification is about.\nCurrently, each Person gets notified for all concerts, leading to a lot of spammy messages. We might want to enhance the addObserver method to specify what notifications we‚Äôre interested in, and allow the TicketSeller to only send the notifications we care about. In general, we might want the Subject ", "topics": ["mvc", "observer"]}
{"chunk_id": "data\\raw\\notes\\Lecture 14 The Observer Pattern.txt::chunk0008", "source": "data\\raw\\notes\\Lecture 14 The Observer Pattern.txt", "text": "class to maintain a mapping from specific topics to the observers interested in just those topics, and only somethingHappened() the observers that care about that topic. This leads to a more complex Subject implementation, but a possibly more-efficient system overall.\nOur current Observer interface has only a single method in it. But as we saw with Features, there could easily be multiple application-specific notifications we might want to send.\nThinking about the TicketSeller again, if it sends out a notification for each individual concert, then the amount of spam depends on how many concerts there are. We might instead want to group together several updates into a single batch notification (for example, configuring Piazza to notify you for each individual post, vs notifying you once eve", "topics": ["mvc", "observer"]}
{"chunk_id": "data\\raw\\notes\\Lecture 14 The Observer Pattern.txt::chunk0009", "source": "data\\raw\\notes\\Lecture 14 The Observer Pattern.txt", "text": "ry few hours with a batch of posts at once).\nThe Observer pattern is a general-purpose event handling mechanism, and hopefully it‚Äôs clear that its utility generalizes beyond just handling UI events.\n\n1It‚Äôs also known as ‚Äúpub/sub‚Äù, ‚Äúpublisher/subscriber‚Äù, ‚Äúlisteners‚Äù, or other similar terms.\n\n2The typical name for the method in Observer is notify(), but alas Java already defines a method with that name, for different purposes. It actually is a use of the Observer pattern, but with a very specific purpose, rather than the general design that we‚Äôre showing here.", "topics": ["mvc", "observer"]}
{"chunk_id": "data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000", "source": "data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt", "text": "Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java‚Äôs Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on ", "topics": ["mvc", "decorator", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001", "source": "data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt", "text": "the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha", "topics": ["mvc", "observer", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0002", "source": "data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt", "text": "t extends JPanel and overrides paintComponent that draws the game board and game status. Status includes indicating whose turn it is, and if the game is over, who won (or if it was a tie).\na class that extends MouseAdapter and overrides mouseClicked to capture a click on the game board and pass it to the controller.\nYou will also need to fill in the parts of the main method in Main.java as noted in the comments in that method.\n\n2 Testing\nTest your view by running it, inspecting the view, clicking on the game board and playing the game. No automated tests here.\n\n3 Notes to Keep in Mind\nYou will likely want to refer to the sample code on graphical programs, such as the Turtle Graphics example (see the \"solution code\" link).\nSubmit your zip containing only your src directory to In-class Exerc", "topics": ["mvc", "decorator", "adapter", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0000", "source": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt", "text": "Lecture 16: The Strategy and Decorator Patterns\nJava source (.zip)\nObjectives of the lecture\nThis lecture introduces two design patterns: strategy and decorators. Both patterns are useful to enhance existing operations and implement combinations of existing implementations of operations.\n\nThe strategy and decorator patterns are very similar idioms of using delegation to refactor aspects of a class‚Äôs behavior into separate classes, for easier enhancement or modification, and tighter cohesiveness. The strategy pattern is somewhat more intuitive to motivate with real-world examples, so we‚Äôll start there.\n\n1 The strategy pattern\nLet‚Äôs consider a straightforward game for which the technique for winning is easily, thoroughly mastered: TicTacToe. How might we play this game? Here are some ideas:\n", "topics": ["strategy", "decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0001", "source": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt", "text": "\nPlay in an open square\nPlay to an open corner\nBlock the opponent from winning\nPlace a third piece in a row to win\nAll but the first of these aren‚Äôt complete strategies. If the corners are all full, for instance, then the second approach doesn‚Äôt have any recommendation to make. So perhaps more accurately, our complete strategies might be:\n\nPlay in an open square\nPlay to an open corner, or else play in an open square\nBlock the opponent from winning if they‚Äôre about to, otherwise play to an open corner, otherwise just play to an open square\nPlace a third piece in a row to win, or else block the opponent if they‚Äôre about to win, or else play in an open corner, or else just play to an open square\nIt‚Äôs probably intuitively clear to you, as an expert human player of TicTacToe, that the final str", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002", "source": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt", "text": "ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model‚Äôs playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We‚Äôd need to know the state of the board, and also know which player we‚Äôre trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn‚Äôt care who it‚Äôs choos", "topics": ["strategy"]}
{"chunk_id": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0003", "source": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt", "text": "ing a move for; it just seeks out the first open square:\n\nclass AnyOpenSquare implements TicTacToeStrategy {\n  public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n    for (int r = 0; r < 3; r++)\n      for (int c = 0; c < 3; c++)\n        if (model.getPieceAt(r, c) == null)\n          return new Coord(r, c);\n    return null;\n  }\n}\n(Note: we are returning null at the moment to indicate the lack of an available move. This not a great idea ‚Äì might consider throwing an exception instead, to indicate that our strategy could not succeed. But see Avoiding null: Multiple strategy signatures below for a better approach still.)\n\nHow might we implement the second strategy? We could implement the entirety of the logic (choose corners or else choose random), but part of that logic has been impl", "topics": ["strategy"]}
{"chunk_id": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0004", "source": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt", "text": "emented already... Let‚Äôs implement just the new part, first:\n\nclass AnyOpenCorner implements TicTacToeStrategy {\n  public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n    if (model.getPieceAt(0, 0) == null)      return new Coord(0, 0);\n    else if (model.getPieceAt(0, 2) == null) return new Coord(0, 2);\n    else if (model.getPieceAt(2, 0) == null) return new Coord(2, 0);\n    else if (model.getPieceAt(2, 2) == null) return new Coord(2, 2);\n    else                                     ????????\n  }\n}\nHow might we fill in the question-marks? This strategy looks for an open corner, but if it can‚Äôt find one, it needs to use another approach to pick a response. Fortunately, we have such an approach already: we could reuse AnyOpenSquare!\n\nclass AnyOpenCorner implements TicTacToeStrategy", "topics": ["strategy"]}
{"chunk_id": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0005", "source": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt", "text": " {\n  public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n    if (model.getPieceAt(0, 0) == null)      return new Coord(0, 0);\n    else if (model.getPieceAt(0, 2) == null) return new Coord(0, 2);\n    else if (model.getPieceAt(2, 0) == null) return new Coord(2, 0);\n    else if (model.getPieceAt(2, 2) == null) return new Coord(2, 2);\n    else\n       return new AnyOpenSquare().chooseMove(model, forWhom);\n  }\n}\nThis resolves the question-marks, at the cost of hardcoding which fallback mechanism to choose. But we can definitely be more flexible.\n\n1.2 Strategies can be composed\nThe any-open-square strategy and the any-open-corner strategy are both functions that take in a board state and return a coordinate to move. We can easily, and generally, combine the two of them into a higher-or", "topics": ["strategy"]}
{"chunk_id": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0006", "source": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt", "text": "der strategy that first tries one and then, if it fails, tries the other:\n\nclass TryTwo implements TicTacToeStrategy {\n  TicTacToeStrategy first, second;\n  public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n    Coord ans = this.first.chooseMove(model, forWhom);\n    if (ans != null) return ans; // the first strategy succeeded\n    return this.second.chooseMove(model, forWhom);\n  }\n}\nIf we fill in the question-marks in AnyOpenCorner with return null, as we effectively did with AnyOpenSquare, then our full second strategy is simply new TryTwo(new AnyOpenCorner(), new AnyOpenSquare()). We can continue implementing the other strategy components (blocking an opponent, or going for an immediate win), and combining them with TryTwo. (These other components need the forWhom argument ‚Äîtry", "topics": ["strategy", "decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0007", "source": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt", "text": " implementing them yourself.)\n\nMore broadly, strategies can be composed in lots of different ways, analogous to mapping, and-map, or-map, or other higher-order combinations. We can generalize from TryTwo to TryMany (that takes a list of strategies); we can generalize to randomly selecting among several strategies, or more sophisticated choices among several strategies. We might possibly try a BestOfThree strategy that take in three strategies, try them all, and pick the value that at least two strategies agreed on. The possibilities here are vast.\n\n1.3 Strategies can be dynamically selected\nSuppose we wanted to build a TicTacToe game for players of varying ability, and wanted ‚Äúeasy‚Äù, ‚Äúmedium‚Äù, and ‚Äúhard‚Äù difficulty levels. We could easily mix and match compositions among the four simple st", "topics": ["strategy"]}
{"chunk_id": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0008", "source": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt", "text": "rategies above, and dynamically assign some such object at runtime:\n\nUser computerUser = ...;\nStrategy easy = new TryTwo(new PlayToWin(), new AnyOpenSquare());\nStrategy medium = new TryTwo(new PlayToWin(), new TryTwo(new DontLose(), new AnyOpenSquare()));\nStrategy hard = new TryTwo(new PlayToWin(),\n                  new TryTwo(new DontLose(),\n                    new TryTwo(new AnyOpenCorner(), new AnyOpenSquare())));\nif (difficulty == EASY)\n  computerUser.playStrategy(easy);\nelse if (difficulty == MEDIUM)\n  computerUser.playStrategy(medium);\nelse\n  computerUser.playStrategy(hard);\nRather than hardcoding the difficulty level of the game, we have refactored it out and made it easily configurable.\n\nWe can also define an AskUser strategy...and now we have something the controller can use to in", "topics": ["mvc", "strategy"]}
{"chunk_id": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0009", "source": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt", "text": "teract with a human player, in the same framework as these other strategy choices.\n\n(Note that in this scenario, the composition of strategies could be rearranged:\n\nnew TryTwo(new TryTwo(new PlayToWin(), new DontLose()),\n           new TryTwo(new PlayToCorner(), new AnyOpenSquare()));\nbehaves exactly the same as our hard strategy above, even though the component strategies are arranged in a tree instead of a list. Depending on which combinations you pick, there may easily be many ways to express the desired result.)\n\n1.4 Strategies make for easy testing\nIf we supply two strategies to our controller and say ‚Äúplay the game with two players using these respective strategies‚Äù, what could happen? If both strategies are fully automatic, then we‚Äôve built a great test harness to run through the ga", "topics": ["mvc", "strategy", "decorator", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0010", "source": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt", "text": "me automatically! Combining this with the Appendable output we‚Äôve seen in earlier lectures, and we have a straightforward means to simulate a playthrough of the game. Moreover, testing different strategies against each other lets us not only test whether they work properly, but also how well they do at playing the game.\n\n2 Avoiding null: Multiple strategy signatures\nAbove, we built four partial strategies, that worked when possible and returned null otherwise. This is a bad idea, since the user of these strategies is forced to check for nullness before using the result. But it‚Äôs a mistake of our own making: we chose a return type for our strategy that didn‚Äôt include the possibility of failure. A complete strategy in this game will always be able to choose a place to play (assuming any open", "topics": ["strategy"]}
{"chunk_id": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0011", "source": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt", "text": " places remain). But partial strategies might not always be able to do so.\n\nAccordingly, since these are now two different purpose statements (\"Find me a place!\" versus \"Try to find a place if you can\"), we might encode them as two different strategy interfaces:\n\n// An interface describing strategies whose return value cannot fail:\n// they will always return a non-null Coord, or else\n// throw an excpetion if they're called on a game that cannot have a move\ninterface InfallibleTicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom) throws IllegalStateException;\n}\n\n// An interface describing incomplete or partial strategies, that\n// might successfully choose a move and might not.\ninterface FallibleTicTacToeStrategy {\n  Optional<Coord> chooseMove(TicTacToeModel model, Piec", "topics": ["strategy"]}
{"chunk_id": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0012", "source": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt", "text": "e forWhom);\n}\nThen our partial strategies above would be better written as\n\nclass AnyOpenSquare implements FallibleTicTacToeStrategy {\n  public Optional<Coord> chooseMove(TicTacToeModel model, Piece forWhom) {\n    for (int r = 0; r < 3; r++)\n      for (int c = 0; c < 3; c++)\n        if (model.getPieceAt(r, c) == null)\n          return Optional.of(new Coord(r, c));\n    return Optional.empty();\n  }\n}\n\nclass AnyOpenCorner implements FallibleTicTacToeStrategy {\n  public Optional<Coord> chooseMove(TicTacToeModel model, Piece forWhom) {\n    if (model.getPieceAt(0, 0) == null)      return Optional.of(new Coord(0, 0));\n    else if (model.getPieceAt(0, 2) == null) return Optional.of(new Coord(0, 2));\n    else if (model.getPieceAt(2, 0) == null) return Optional.of(new Coord(2, 0));\n    else if (mode", "topics": ["strategy"]}
{"chunk_id": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0013", "source": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt", "text": "l.getPieceAt(2, 2) == null) return Optional.of(new Coord(2, 2));\n    else                                     return Optional.empty();\n  }\n}\n\nclass TryTwo implements FallibleTicTacToeStrategy {\n  FallibleTicTacToeStrategy first, second;\n  public Optional<Coord> chooseMove(TicTacToeModel model, Piece forWhom) {\n    Optional<Coord> ans = this.first.chooseMove(model, forWhom);\n    if (ans.isPresent()) return ans; // the first strategy succeeded\n    return this.second.chooseMove(model, forWhom);\n  }\n}\nUltimately, our User wants a complete strategy, not one that can fail. So we need a way to convert our fallible strategies into an infallible one:\n\nclass CompleteStrategyFromFallible implements InfallibleTicTacToeStrategy {\n  FallibleTicTacToeStrategy strategyToTry;\n  public Coord chooseMove(TicT", "topics": ["strategy"]}
{"chunk_id": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0014", "source": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt", "text": "acToeModel model, Piece forWhom) throws IllegalStateException {\n    Optional<Coord> maybeAns = this.strategyToTry.chooseMove(model, forWhom);\n    if (maybeAns.isPresent()) { return maybeAns.get(); }\n    throw new IllegalStateException(\"There are no possible moves chosen by this strategy!\");\n  }\n}\n3 The decorator pattern\nThe decorator pattern is similar to the strategy pattern in terms of how objects delegate from one to another, but the purpose is different. The canonical example of decorators is a UI widget library, such as Swing. We might have a basic JPanel class that just describes a rectangle of on-screen content. We might have a JScrollPanel class, which is a subclass of JPanel, that visually wraps around some other JPanel and adds scrollbars and the ability to scroll the view in one", "topics": ["mvc", "strategy", "decorator", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0015", "source": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt", "text": " or more directions. Or a JSplitPanel, which surrounds two panels and produces a split-screen effect. Or a JGridPanel, or others... Each of these classes obeys a fairly sophisticated interface (all the methods of the base JPanel class), and then does two things: it provides some new functionality of its own, and delegates the rest of the functionality to inner panels. Visually, each surrounding panel decorates the inner ones by adding borders, scrollbars, splitters, etc. Just as with the strategy pattern, each class is responsible for one fragment of functionality: the complete functionality comes about by composing several decorators together around some base object.\n\nUnlike strategies, where there can often be useful strategies that do not need to delegate at all; decorators are all abou", "topics": ["strategy", "decorator", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0016", "source": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt", "text": "t the delegation. Also, unlike strategies, a decorator can never be a \"partial\" function ‚Äî the underlying thing being decorated is already a complete thing, and the decoration adds more functionality on top of it, but there‚Äôs never a notion of an \"incomplete\" object.\n\n4 Strategies, Decorators and Inheritance\nWhen should you use a strategy pattern or a decorator pattern, instead of just using inheritance to customize behavior? After all, don‚Äôt subclasses specialize the behavior of their superclasses? For example, could we produce the same effect by having our User class just have an abstract method chooseMove, and then creating subclasses that define various possible implementations for that method?\n\nYes...but only sometimes. The power of the strategy and decorator patterns comes from the d", "topics": ["strategy", "decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0017", "source": "data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt", "text": "ynamism inherent in ability to delegate from one simple strategy to the next, or from one decorator to its contained content. Rather than being fixed at compile time, we can use higher-order strategies to mix-and-match strategy pieces, or decorate panels into elaborate UIs, without having to hard-code those choices in advance. Additionally, the strategy or decorator classes are appealingly tiny, self-contained, and easy to read: they have very high cohesion, because they‚Äôre built to do exactly one thing and nothing else.\n\n1It‚Äôs not perfect ‚Äî suppose two players were following this same strategy. Would the game end in a win, loss, or tie for the first player? How could you fix any problems you might encounter?", "topics": ["strategy", "decorator", "gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0000", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": "Lecture 17: The Adapter Pattern\nSlidesJava source (.zip)Exercise (.zip)\nObjectives of the lecture\nThis lecture introduces the adapter design pattern. Adapters are very commonly used to ‚Äúmash-up‚Äù many existing code bases into one application. This lecture also applies this pattern to implement a variant of the MVC design.\n\n1 A tale of two interfaces\nIt‚Äôs rare that real, significant programs are designed completely from scratch. Most real programs use libraries, often several. It‚Äôs also rare that all the libraries used by a program were designed to work together, using all the same abstractions. More often, libraries have to define some interfaces of their own. Sometimes, you need to integrate two libraries that define different interfaces for similar or even equivalent abstractions.\n\nFor ex", "topics": ["mvc", "adapter"]}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0001", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": "ample, suppose we were using two different libraries that each offered its own set interface incompatible with the other. Suppose a library for working with graphs‚Äîcall it graph‚Äîrelies on a set abstraction. So it declares set operations, which in this case work with elements of sets1:\n\n/**\n * Simple sets of integers.\n */\npublic interface IntSet1 extends Iterable<Integer> {\n  /**\n   * Adds the given value to this set.\n   */\n  void add(int value);\n\n  /**\n   * Removes the given value from this set, if present.\n   */\n  void remove(int value);\n\n  /*\n   * Determines whether a particular integer value is a member of this set.\n   */\n  boolean member(int value);\n\n  /**\n   * Returns an iterator over the elements.\n   */\n  Iterator<Integer> iterator();\n}\nThe graph library provides a class IntSet1Impl ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": "that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  /** Creates a new, empty integer set. */\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  /**\n   * Inserts the elements of {@code other} into this set.\n   */\n  void unionWith(IntSet2 other);\n\n  /**\n   * Removes the elements of {@code other} from this set.\n   */\n  void differenceFrom(IntSet2 other);\n\n  /**\n   * Checks whether this set is a superset of the {@code other} set.\n   */\n  boolean isSupersetOf(IntSet2 other);\n\n  /**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0003", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": "   */\n  List<Integer> asList();\n}\nThe prob library provides a class IntSet2Impl that implements IntSet2. For creating instances, IntSet2Impl provides two static factories, empty() and singleton(int):\n\npublic class IntSet2Impl implements IntSet2 {\n  /** Creates a new, empty integer set. */\n  public static empty() { ... }\n\n  /** Creates a new, singleton integer set with the given member. */\n  public static singleton(int member) { ... }\n\n  ...\n}\nWhat if we want to use both of these libraries from the same program, and furthermore, we want to use some sets with both. Perhaps we want to use graph‚Äôs sets, which implement IntSet1, with code that works with prob‚Äôs sets, which implement IntSet2. Can we do it? Yes, with an adapter.\n\n2 The class adapter pattern\nTo make this abstract for a moment, sup", "topics": ["adapter"]}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0004", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": "pose we have a class AdapteeImpl and we want to reuse its implementation where an object implementing interface Target is needed. AdapteeImpl and Target don‚Äôt have exactly the same methods, but they‚Äôre close enough that we can create a class AdapteeImplToTargetAdapter that implements interface Target by subclassing AdapteeImpl and implementing Targets methods in terms of the inherited methods primarily using an instance of Adaptee to do so. In UML it looks like this:\n\n\n\nIf the client wants a Target then we can use AdapteeImpl to implement it by writing AdapteeToTargetAdapter, which extends AdapteeImpl and implements Target by translating Target methods to AdapteeImpl methods. Or more concretely, some code from prob (the client) knows how to use IntSet2s, and we implement IntSet2 based on I", "topics": ["adapter"]}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": "ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic", "topics": ["decorator", "adapter"]}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0006", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": " final List<Integer> asList() {\n  List<Integer> result = new ArrayList<>();\n  for (int i : this) {\n    result.add(i);\n  }\n  return result;\n}\nThe class adapter pattern is simple to use‚Äîjust extend the adaptee and then implement the target. The resulting object, by virtue of extending the adaptee, inherits its interface for free. However, there are many things it cannot do, such as:\n\nwrapping an already-existing object, or\nwrapping objects of different types than the one for which it was intended.\nIn order to do those things and more, we can replace inheritance with delegation and gain flexibility as well.\n\n3 The object adapter pattern\nTo make this once again abstract, suppose we have an object of type Adaptee (which could be an interface or a class) and we want to use it in a context where ", "topics": ["decorator", "adapter"]}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0007", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": "an object implementing interface Target is needed. Adaptee and Target don‚Äôt have exactly the same methods, but they‚Äôre close enough that we can create a class AdapteeToTargetAdapter that implements interface Target primarily using an instance of Adaptee to do so. In UML it looks like this:\n\n\n\nIf the client wants a Target then we can use an Adaptee in its place by writing an AdapteeToTargetAdapter, which owns an Adaptee and implements Target by translating Target methods to Adaptee methods. Or more concretely, some code from graph (the client) knows create IntSet1s, and we can use an IntSet1 as that IntSet2 by writing an adapter that wraps an IntSet1 and uses it as the representation of an IntSet2.\n\nWe start the adapter by declaring that it implements IntSet1, which is what the client wants", "topics": ["decorator", "adapter"]}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0008", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": ", and has a field containing an IntSet2, which is the object to adapt:\n\npublic final class IntSet2ToIntSet1Adapter implements IntSet1 {\n  private final IntSet2 adaptee;\n}\nThere are two ways we might want to construct an IntSet2ToIntSet1Adapter. If we have an IntSet2 object already, we can adapt that object:\n\npublic IntSet2ToIntSet1Adapter(IntSet2 adaptee) {\n  this.adaptee = Objects.requireNonNull(adaptee);\n}\nWhereas sometimes we might not have an IntSet2 already and not need access to it directly, so we provide a convenience constructor that creates the adaptee for us:\n\npublic IntSet2ToIntSet1Adapter() {\n  this(IntSet2Impl.empty());\n}\nNext we need to implement the methods of IntSet1 interface in terms of IntSet2 by translating method calls to the adaptee. For example, to add an int to the ", "topics": ["adapter"]}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": "set, we use adaptee‚Äôs unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob", "topics": ["adapter"]}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0010", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": " as an IntSet1 that we can pass to graph. But what if we‚Äôd like to use the resulting object with both libraries, with no further adaptation? A two-way adapter implements two interfaces, most often being a Target as well as an Adaptee, sending requests received via either interface to the underlying adaptee object. For example, we can declare our IntSet2ToIntSet1Adapter to implement both interfaces:\n\npublic final class IntSet2ToIntSet1Adapter implements IntSet1, IntSet2 { ... }\nthe implementation from the previous section remains, and to implement IntSet2 as well, we merely need to forward those requests to the IntSet2 adaptee:\n\n@Override\npublic void unionWith(IntSet2 other) {\n  adaptee.unionWith(other);\n}\n\n@Override\npublic void differenceFrom(IntSet2 other) {\n  adaptee.differenceFrom(other", "topics": ["adapter"]}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0011", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": ");\n}\n\n@Override\npublic boolean isSupersetOf(IntSet2 other) {\n  return adaptee.isSupersetOf(other);\n}\n\n@Override\npublic List<Integer> asList() {\n  return adaptee.asList();\n}\n4 The ViewModel\n\n\nIn the Model-View-Controller architecture, the view must render the data that is maintained by the model. In such circumstances, how will the data from the model make it to the view?\n\n\n\nOne way would be for the controller to act as an intermediary for this data exchange. The controller would get the data from the model, and then supply it to the view. In this design, the view does not ‚Äúask‚Äù for the data‚Äìthe controller provides it at the appropriate time and tells the view to use it. This can be termed as a ‚Äúpush‚Äù design: the controller pushes the data to the view. One drawback of this design is that th", "topics": ["mvc", "adapter"]}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0012", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": "e controller must repeatedly pass (possibly a lot of) data from the model to the view. This can be made more efficient if the view could ‚Äúpull‚Äù the data out whenever it needed.\n\nThe ‚Äúpull‚Äù design can be as simple as having the view store a reference to the model. This design has an even bigger potential pitfall. The model interface likely offers operations that access data, and others that mutate it. By giving the view a reference to the model, we give the view the power to mutate the model directly. Such direct mutation is undesirable for several reasons: a view can circumvent checks that are implemented in the controller, a view can make changes that conflict with the workings of another view, etc. If only there was a way for the view to provide restricted access to the model: it can acc", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0013", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": "ess, but it may not mutate.\n\nWe can achieve this by creating a ViewModel class that implements a IViewModel interface. A ViewModel object would then extract data from the original model object and provide it to its client, essentially avoiding direct contact between the client and the model.\n\n\n\nA possible design would be for the IViewModel interface to contain methods that only get the data. The ViewModel class would use the actual model object to provide the data. Since the data resides in a specific, pre-existing model object, the ViewModel class is essentially an object adapter that adapts the model with the viewmodel interface.\n\n\n\nAnother design could be for the IViewModel interface to be the same as the model interface. In this case the ViewModel class would implement all the model‚Äôs ", "topics": ["mvc", "adapter"]}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0014", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": "methods, but suppress any mutating operations (for example, by throwing UnsupportedOperationException).\n\n\n\nA third design would select elements of these two designs. We create the IViewModel interface to have only accessor methods, and make our model implement both the model interface and the IViewModel interface. When we provide the model interface to the view, we provide it as a IViewModel interface. This means that the model is available to the view with a restricted IViewModel interface.\n\n5 Case study: Enumerator and Iterator, and partial adaptors\nSometimes, adaptating one interface (or class) to another interface doesn‚Äôt work quite so smoothly.\n\nIn the very first version of Java, the standard library included the following interface2:\n\ninterface Enumeration<T> {\n  boolean hasMoreEleme", "topics": ["mvc"]}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0015", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": "nts();\n  T nextElement();\n}\nThis interface was used to describe enumerating the various items in a collection. For various reasons, this interface was deprecated in favor of the following, more familiar interface:\n\ninterface Iterator<T> {\n  boolean hasNext();\n  T next();\n  void remove();\n}\nSuppose your project has to work with some ancient Java library, that includes a class that implements Enumerator, and you‚Äôd like to use it with modern Iterators. Which kind of adapter ‚Äì object or class ‚Äì would you most likely need to use?\n\nSince this Enumerator-implementing class already exists, and we can‚Äôt modify it, we‚Äôll define an object adapter to wrap the instances of that class and make them behave like an Iterator.\n\nGetting started is easy enough:\n\nclass EnumeratorIterator<T> implements Iterator", "topics": ["decorator", "adapter"]}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0016", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": "<T> {\n  Enumerator<T> source;\n  EnumeratorIterator(Enumerator<T> source) {\n    this.source = Objects.requireNonNull(source);\n  }\n\n  @Override\n  public boolean hasNext() { return this.source.hasMoreElements(); }\n\n  @Override\n  public boolean next() { return this.source.nextElement(); }\n\n  @Override\n  public void remove() { /* ??? */ }\n}\nThere is no method in Enumerator that corresponds to remove. We might think that we could implement remove by somehow collecting all the remaining elements of the source, removing the current one, and continuing to enumerate the resulting rest of the collected elements. But...recall the original motivating purpose of iterators, which is to describe an arbitrary collection of items, supplying them one at a time. There is no guarantee that the collection is fi", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0017", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": "nite, which means that our idea breaks down right at the start: ‚Äúcollect the remaining elements‚Äù is an ill-defined notion!\n\nSo we can‚Äôt actually implement this method. Yet the Iterator interface requires that we define something there. The best we can do is throw an exception, saying we give up:\n\n@Override\npublic void remove() {\n  throw new UnsupportedOperationException(\"Can't remove from this Enumeration\");\n}\nFortunately, the designers of the Iterator interface realized that not all iterators have a well-defined notion of removing items ‚Äî consider what it might mean to iterate over all positive integers, say, and try to remove one of them. Accordingly, the documentation for this method specifies that the UnsupportedOperationException may be used to indicate exactly this failure mode.3\n\n5.", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0018", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": "1 Over-promising and under-delivering\nThis is a tiny but indicative example of what might go wrong when adapting one type to another: sometimes, not everything is readily adaptable. But recall the underlying contract of interfaces: they are promises of behavior that clients of the interface should be able to rely upon in their code. Providing an object that claims to implement an interface, but in fact throws exceptions for some (or all) of the methods, is a rather stubborn and unhelpful object!\n\nThere are other settings, though, where refusing to implement behavior is a perfectly reasonable thing to do:\n\nConsider an Insta-snap-book app clone, that connects your phone and its camera to your social-media accounts via the phone‚Äôs internet connection. The camera API provides a neatly-packaged", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0019", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": " abstraction for taking pictures. But suppose your app obtains a valid (i.e. non-null) CameraManager object, and before the app can take a picture, you go to the permissions manager and disable its ability to access the camera. What should the API do?\nConsider course-management software, that maintains student homeworks and grades and other pertinent information. The application maintains multiple roles ‚Äî student, grader, professor, etc ‚Äî and all users are represented in the system as a User object, with a role field. How should the User object respond to a getGrades request if your role is insufficiently-priviledged?\nConsider a library for reading and writing image files. How should an image object respond to a getPixels request if the image file is corrupted?\nPart of the challenge as an ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0020", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": "interface designer is figuring out their potential failure modes, and documenting them as part of the possible behaviors of that interface. In the Iterator case, if the remove method were not specified as potentially throwing an exception, then it would be impossible to provide a EnumeratorIterator adapter that fulfilled the Iterator interface‚Äôs promises. If the camera API didn‚Äôt document its permission errors, then the camera API would itself be at fault.\n\nAnd, as a counterpart: the challenge of being an interface client is, if your program can‚Äôt obey the promises of that interface, then it behooves you to document why your code is not compliant, so that future maintainers of your code can figure out what might go wrong!\n\nIndeed, this design tension raises a broader language-design concer", "topics": ["adapter"]}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0021", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": "n, that touches directly on how to use this pattern specifically (or indeed, our programming language more generally) effectively. There‚Äôs something deeply unpleasant about having an interface claim to promise that a method exists, and yet have an implementation of it that fails at runtime. After all, part of the touted benefits of a statically-typed language is that ‚Äúif it typechecks, then all the operations should be legal at runtime‚Äù, since the type system ensures that no non-sensical methods can be invoked. This is the sort of invariant that we dismissed as vacuous in Lecture 12, since it was true by virtue of the language, rather than by our own reasoning efforts. Supplying methods that then throw errors weakens the effectiveness of our static type-based reasoning, though it doesn‚Äôt e", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0022", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": "liminate it entirely. Instead, if we want to ensure that our program never crashes with an unhandled exception, we must resort to higher-level invariant reasoning ‚Äî those logical assertions we talked about in Lecture 12 that the compiler can‚Äôt help us with! ‚Äî and think about the dynamic behavior of our program, as well.\n\n1We limit these to sets of int to avoid the additional complexity of generics.\n\n2Actually, the original version was defined without generics (since those were added in Java 1.5). Fortunately, this change does not affect our design problems here in any way.\n\n3As of version 8, Java supports a notion of default methods in an interface. Classes that implement these interfaces can basically skip implementing such methods, because the interface provides a default implementation.", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0023", "source": "data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt", "text": " (This gets somewhat tricky when a class implements two interfaces, both of which provide a default method with the same name and the same signature ‚Äì in such cases, the class is required to override the method explicitly, to resolve the ambiguity.) The default implementation for the remove() method in the Iterator interface simply throws exactly this exception...so you don‚Äôt even have to mention it in your code unless you truly want to support this method.", "topics": ["gui"]}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0000", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "Lecture 18: Intro to Performance\nJava source (.zip)\nObjectives of the lecture\nThis lecture takes an empirical view of the goodness of a design and implementation choice. It presents details of an experiment to profile the performance of a component in a rudimentary way, and presents its uses and limitations.\n\n1 A performance problem\nIn Assignment 2, your view‚Äôs toString() method likely had to accumulate a string in a loop. Stripped down to its essence, building the string might have looked something like this:\n\nString result = \"\";\n\nfor (...) {\n    ...\n    result += ...;\n    ...\n}\n\nreturn result;\nThat is, the most straightforward thing to do, when we need to accumulate a string, is often to build it up character-by-character via string appends. Naively, we might expect this to be quite effi", "topics": ["mvc", "decorator"]}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0001", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "cient: after all, the loop is doing a constant amount of work each iteration ‚Äî just a single string-append! ‚Äî and we surely needed to loop over every character of the input string, so this must be as efficient as it gets.\n\nUnfortunately, this analysis is too simplistic: the actual performance of this approach scales terribly. For example, here is are benchmark results for an implementation of the format method on template strings of length 1000, 2000, 3000, and 4000, with two different \"densities\" of % signs (14\n versus 150\n):\n\nAccumulating strings character by character\n\nThe lines represent running time, so longer lines are worse. As we can see, the running time of this method superlinearly‚Äîwhen the template string doubles in length, the running time more than doubles. This is an inherent", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0002", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": " feature of some computational problems, but it isn‚Äôt inherent to the task of building a string, and in fact we can do much, much better.\n\nSomehow, what seemed like a single, cheap operation isn‚Äôt. To see why we‚Äôre getting such bad performance, we need to consider what is happening under the hood. In Java (and many programming languages), a string is represented as an array of characters. The Java String class is immutable, which means that when we append two strings, it allocates a fresh, new String object to hold the result. Under the hood, this entails allocating a new array with enough space to hold the characters from both strings, and then copying the contents into it. This operation takes time proportional to the length of the resulting string. When we accumulate a string in a loop,", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0003", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": " this means that we are allocating a new string in each iteration of the loop, and the size of that new string increases each time. Overall, to accumulate a string of length ùëõ\n, character by character, this will do ùëõ\n copies, allocating new strings of length 1, 2, ‚Ä¶\n, ùëõ\n. Adding this up, we get the time ùëá(ùëõ)\n to accumulate a string of length ùëõ\n,\n\nùëá(ùëõ)=‚àëùëñ=1ùëõùëêùëñ=ùëêùëõ(ùëõ+1)2\n\nwhere ùëê\n represents some constant factor involved in each operation (since the exact time to allocate a string and copy its contents depends on details of the particular machine and environment in which we are running). Because the above expression is quadratic in ùëõ\n, this explains why our format method scales superlinearly.\n\n2 A mathematical digression\nYou likely have previously seen the formula above, stating that the sum ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0004", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "of the first ùëõ\n numbers is ùëõ(ùëõ+1)2\n. Take a moment to consider how to prove such a formula. Here is one common proof:\n\nWhen ùëõ=1\n, ‚àë1ùëñ=1=1(1+1)2=1\n. So our base case is satisfied.\nAssume inductively that the formula holds for ùëõ\n; show that it works for ùëõ+1\n:\n‚àëùëñ=1ùëõ+1ùëñ=(‚àëùëñ=1ùëõùëñ)+(ùëõ+1)by induction=ùëõ(ùëõ+1)2+(ùëõ+1)=ùëõ(ùëõ+1)2+2(ùëõ+1)2=(ùëõ+2)(ùëõ+1)2\n\nThis proof is straightforward, fairly simple...and utterly unenlightening: how did we guess the appropriate formula in the first place? Moreover, suppose we needed to solve a related problem (such as ‚àëùëõùëñ=1ùëñ2\n, or higher powers) ‚Äî nothing about this proof is reusable.\n\nAnother common proof, due to Carl Friedrich Gauss, goes as follows: pair off the first and last numbers of the range, the second and next-to-last numbers, etc:\n\n123‚ãÆfloor(ùëõ/2)ùëõùëõ‚àí1ùëõ‚àí2‚ãÆceil(ùëõ/2)\n\n", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0005", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "Each row sums to ùëõ+1\n, and there are ùëõ2\n rows. Therefore the total sum is ùëõ(ùëõ+1)2\n as desired. This proof is a bit better: you don‚Äôt have to know the formula in advance in order to derive it, but you need some insight to see that arranging the numbers in this manner will be helpful.\n\nHere is an alternate proof, based on a technique called \"telescoping\". Consider the well-known fact\n\n(ùëõ+1)2=ùëõ2+2ùëõ+1\n\nNow comes an odd observation ‚Äî the following formula is also true:\n\n(ùëõ)2=(ùëõ‚àí1)2+2(ùëõ‚àí1)+1\n\nWhy bother with this? Because we can continue in this manner all the way down:\n\n(ùëõ+1)2(ùëõ‚àí0)2(ùëõ‚àí1)212=(ùëõ‚àí0)2+2(ùëõ‚àí0)+1=(ùëõ‚àí1)2+2(ùëõ‚àí1)+1=(ùëõ‚àí2)2+2(ùëõ‚àí2)+1‚ãÆ=(ùëõ‚àíùëõ)2+2(ùëõ‚àíùëõ)+1\n\nNow we can apply something like Gauss‚Äôs technique, and sum all these equations together. But notice: most of the terms cancel each other out,", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0006", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": " because they appear on both sides of the equals signs. We are left with\n\n(ùëõ+1)2=2((ùëõ‚àí0)+(ùëõ‚àí1)+‚ãØ+(ùëõ‚àíùëõ))+(1+1+‚ãØ+1)\n\nOr in other words,\n\n(ùëõ+1)2=2(‚àëùëñ=1ùëõùëñ)+(ùëõ+1)\n\nWith just a little bit of algebra, we obtain the desired formula...without knowing in advance what the formula should be.\n\nBetter yet, we can generalize this technique:\n\n(ùëõ+1)3(ùëõ‚àí0)3(ùëõ‚àí1)313=(ùëõ‚àí0)3+3(ùëõ‚àí0)2+3(ùëõ‚àí0)+1=(ùëõ‚àí1)3+3(ùëõ‚àí1)2+3(ùëõ‚àí1)+1=(ùëõ‚àí2)3+3(ùëõ‚àí2)2+3(ùëõ‚àí2)+1‚ãÆ=(ùëõ‚àíùëõ)3+3(ùëõ‚àíùëõ)2+3(ùëõ‚àíùëõ)+1\n\nAgain terms cancel, and we get\n\n(ùëõ+1)3=3(‚àëùëñ=1ùëõùëñ2)+3(‚àëùëñ=1ùëõùëñ)+(ùëõ+1)\n\nConveniently, we can reuse the solution we just got for the second sum, and with a bit of algebra obtain the final formula for this form as well.\n\nOr in other words, with a bit of refactoring1, we can take a formula that was only of utility in one limited situation and instead obtain ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0007", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "a proof technique that can be reused to solve several related problems.\n\nAnalogously, finding the right spot in your program to refactor can lead to a profoundly useful point of leverage from which to improve your code. Let‚Äôs see how we might apply similar reasoning to our example string-appending problem above.\n\n3 Abstracting the problem\nIn order to try other strategies for accumulating the string, we will now abstract our format(String) method over the string accumulation process. In particular, we define an interface for objects that provide a string accumulation service. The full interface provides several more useful methods, but to start out we need only two:\n\npublic interface StringAccumulator {\n  /**\n   * Appends the given character to the end of the accumulated string.\n   *\n   * @", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0008", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "param c the character to append\n   * @return a reference to {@code this} (for method chaining)\n   */\n  @Override\n  StringAccumulator append(char c);\n\n  /**\n   * Returns the accumulated string value. Should be the same as\n   * {@code #toString()}.\n   *\n   * @return the accumulated string value\n   */\n  String stringValue();\n}\nThe idea is that using an object of a class that implements StringAccumulator, we can repeatedly append characters, potentially allowing the object to manage the accumulation in a more efficient way than repeated string appends, and then when we‚Äôre done, extract the resulting string2:\n\nStringAccumulator result = new ...StringAccumulator();\n\nfor (...) {\n    ...\n    result.append(c);\n    ...\n}\n\nreturn result.stringValue();\nIn order to demonstrate that our approach is soun", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0009", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "d, we first implement the interface in a class that uses the same string-appending technique that gave us the bad performance above:\n\n/**\n * A string accumulator implementation that just stores the string. This is\n * very simple to implement but will suffer the same poor performance as\n * naive string appending.\n */\npublic final class StringStringAccumulator implements StringAccumulator {\n  private String contents = \"\";\n\n  @Override\n  public String stringValue() {\n    return contents;\n  }\n\n  @Override\n  public StringStringAccumulator append(char c) {\n    contents += c;\n    return this;\n  }\n}\nOf course, the above does not make our code run any faster, but it enables us to run our tests and ensure that abstracting over string accumulation doesn‚Äôt break our existing code. Once we know that is", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0010", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": " the case, we can try to implement the interface in a way that improves our string accumulation performance.\n\n4 Improving our technique\nThe key to improving our string accumulation performance is to avoid allocating and copying each time the append(char) method is called. Instead, we will accumulate characters in an array, which we may allow to be larger than is necessary to hold the characters accumulated thus far. By trading space for time, we hope to speed up duration formatting.\n\nWe start by writing an ArrayStringAccumulator class that uses a character array, rather than a String, to hold the characters:\n\npublic class ArrayStringAccumulator implements StringAccumulator {\n  private char[] contents = new char[INITIAL_CAPACITY];\n  private int length = 0;\n}\nIn this class, in addition to th", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0011", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "e char[] field contents holding the characters, we need the length field to keep track of how much of contents is currently filled with characters that we have accumulated. This will allow us to use an array that is not yet full, so that we can add more characters without reallocating and copying. Initially, contents points to a freshly allocated character array of some capacity (which doesn‚Äôt particularly matter, so long as it isn‚Äôt really large), and the length starts out at 0. We then have two public methods to implement.\n\nIn order to get the accumulated String value, method stringValue() initializes a new string to the valid prefix of the array and returns that:\n\n@Override\npublic final String stringValue() {\n  return String.valueOf(contents, 0, length);\n}\nThe static String#valueOf(char", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0012", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "[], int, int) method takes a character array, the offset where the new string should start, and a count of characters to include. We want the first length characters of array contents.\n\nWe also need to implement the append(char) method, which adds a character to the end of the buffer. The buffer may or may not have to grow before we can add a character to it, so we will delegate to a private helper ensureCapacity(int) that expands the array to the requested capacity if necessary:\n\n@Override\npublic final ArrayStringAccumulator append(char c) {\n  ensureCapacity(length + 1);\n  contents[length++] = c ;\n  return this;\n}\nThe method ensures that we have room for one additional character, then stores it at the end of contents and increments the length field to record the fact that we have added a ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0013", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "character. It returns this as required by the StringAccumulator interface.\n\nNow we need to implement ensureCapacity(int). We will express only a small amount of the growing logic here, delegating to two other methods to decide what size to expand to, and to do the expansion itself:\n\n/**\n * Resizes the underlying array, if necessary, to ensure that the capacity\n * exceeds the specified {@code minCapacity}.\n *\n * @param minCapacity lower bound for the new capacity\n */\npublic final void ensureCapacity(int minCapacity) {\n  if (contents.length < minCapacity) {\n    resize(determineNewCapacity(minCapacity));\n  }\n}\nIf the capacity of the underlying array is sufficient to hold minCapacity characters, there is no need to expand. Otherwise, we delegate to method determineNewCapacity(int) to decide wh", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0014", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "at size to grow to, and then to method resize(int) to do the actual growing. Method resize(int), in turn, can delegate to the static Arrays.copyOf(char[], int) method, which makes a copy of an array of the requested size:\n\n/**\n * Resizes the underlying array to the given capacity.\n *\n * @param newCapacity the new capacity of the array\n */\nprivate void resize(int newCapacity) {\n  contents = Arrays.copyOf(contents, newCapacity);\n}\nIt remains to implement the determineNewCapacity(int) method, which determines what size to expand array contents to when expansion is necessary. (If we expand only to the needed capacity, we have merely reimplemented the nonperformant version of string accumulation that we started with. We‚Äôll try that, among other things, just to be sure.) Because we would like to", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0015", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": " try a variety of array expansion strategies, we will abstract over this decision.\n\n5 Abstracting the expansion strategy\nRather than implement one ArrayStringAccumulator class with a fixed expansion strategy, we will change the above to an abstract base class AbstractArrayStringAccumulator, which defers the implementation of the determineNewCapacity(int) method, and thus the expansion strategy, to its concrete subclasses. Thus, we rename class ArrayStringAccumulator to AbstractArrayStringAccumulator. Here is the whole class at this point3:\n\npublic abstract class AbstractArrayStringAccumulator\n  implements StringAccumulator\n{\n  private char[] contents = new char[INITIAL_CAPACITY];\n  private int length = 0;\n\n  /**\n   * The initial array capacity.\n   */\n  public final static int INITIAL_CAPAC", "topics": ["strategy"]}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0016", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "ITY = 10;\n\n  @Override\n  public final String stringValue() {\n    return String.valueOf(contents, 0, length);\n  }\n\n  @Override\n  public final String toString() {\n    return stringValue();\n  }\n\n  @Override\n  public final ArrayStringAccumulator append(char c) {\n    ensureCapacity(length + 1);\n    contents[length++] = c ;\n    return this;\n  }\n\n  /**\n   * Returns the current capacity of the string accumulator, after which\n   * expansion will be necessary.\n   *\n   * @return the current capacity\n   */\n  public int capacity() {\n    return contents.length;\n  }\n\n  public final void ensureCapacity(int minCapacity) {\n    if (contents.length < minCapacity) {\n      resize(determineNewCapacity(minCapacity));\n    }\n  }\n\n  private void resize(int newCapacity) {\n    contents = Arrays.copyOf(contents, newCap", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0017", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "acity);\n  }\n\n  /**\n   * Returns the capacity to expand to, given the requested minimum\n   * capacity.\n   *\n   * @param minCapacity the requested minimum capacity\n   * @return the capacity to expand to\n   */\n  protected abstract int determineNewCapacity(int minCapacity);\n}\nIn order to implement a concrete StringAccumulator class, it thus suffices to extend AbstractArrayStringAccumulator and override the determineNewCapacity(int) method to implement a particular expansion strategy. Note that we added a method capacity() in order to allow subclasses to find out the current capacity, since the actual representation array contents is private. (We don‚Äôt want subclasses to be able to mess with our invariants!)\n\n5.1 Four strategies for growing\nNow we can try several strategies for growing the arra", "topics": ["strategy"]}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0018", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "y, and use benchmarks to compare them. Unsurprisingly, will first reimplement the na√Øve strategy of keeping the array at the exact size needed. (If nothing else, this continues to provide proof of concept for our abstractions.) We call this class ExactArrayStringAccumulator; if our understanding of the problem is correct, this will give us the same poor performance that we started with:\n\n/**\n * A string accumulator class that always expands to exactly the\n * necessary size to hold the current accumulated character sequence.\n */\npublic final class ExactArrayStringAccumulator\n  extends AbstractArrayStringAccumulator\n{\n  @Override\n  protected int determineNewCapacity(int minCapacity) {\n    return minCapacity;\n  }\n}\nSince we hypothesized that the source of the poor performance was frequent arr", "topics": ["strategy"]}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0019", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "ay expansions, one reasonable strategy might be to expand the array some larger but fixed step at a time. The strategy of class LinearArrayStringAccumulator is to expand to the smallest multiple of DEFAULT_STEP that will hold the requested minimum capacity:\n\npublic final class LinearArrayStringAccumulator\n  extends AbstractArrayStringAccumulator\n{\n  public static int DEFAULT_STEP = 16;\n\n  @Override\n  protected int determineNewCapacity(int minCapacity) {\n    // (a + b - 1) / b computes ceil((double) a / b)\n    return ((minCapacity + DEFAULT_STEP - 1) / DEFAULT_STEP) * DEFAULT_STEP;\n  }\n}\nIf we consider LinearArrayStringAccumulator carefully, we may notice that it still expands a linear number of times to build a string‚Äîjust 16 times fewer times‚Äîwhich means that the ‚àë\n sum that adds up to a ", "topics": ["strategy"]}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0020", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "quadratic expression still applies. If we want to expand fewer than a linear number of times, we need to grow less often still. One way to do this is by doubling, which ensures that to reach an array of size ùëõ\n we grow only a logarithmic number of times. We‚Äôll call this strategy DoublingArrayStringAccumulator:\n\npublic final class DoublingArrayStringAccumulator\n  extends AbstractArrayStringAccumulator\n{\n  @Override\n  protected int determineNewCapacity(int minCapacity) {\n    return Integer.max(minCapacity, capacity() * 2);\n  }\n}\nAs a final strategy, we might elect to allocate a sufficiently large array that expansion is unnecessary, at least in the cases where we know how large an array we are going to need. The version of AbstractArrayStringAccumulator that we just wrote does not provide a ", "topics": ["strategy"]}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0021", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "way for subclasses to influence the initial array size (though the full version here does). However, we can approximate this behavior up to a point by returning a sufficiently large value from determineNewCapacity(int) such that none of our benchmarks exceed it, and we will thus get exactly one reallocation, regardless of how large the string must grow. (The risk here is that this allocation is so large that it hurts our performance, but if that is the case, the benchmarks will show it.)\n\npublic final class PreallocArrayStringAccumulator\n  extends AbstractArrayStringAccumulator\n{\n  @Override\n  protected int determineNewCapacity(int minCapacity) {\n    return Integer.max(minCapacity, 100_000);\n  }\n}\n5.2 Benchmarking the strategies\nNow that we have four strategies for growing the array, we wo", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0022", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "uld like to compare them. The benchmarks in StringAccumulatorBench build strings of several sizes using our array-growing strategies. Here are the results:\n\nAccumulating strings using several strategies\n\nAs we can see, StringStringAccumulator and ExactArrayStringAccumulator perform very similarly to our original implementation of the format method, which is unsurprising, since each of them expands the string or array each time a character is added. The other implementations all look significantly faster but similar to each other, but if we want to see the difference between the linear-step strategy, the doubling strategy, and the prealloc strategy, then we need to try larger cases. In this benchmark, we increase the the size of the accumulated strings by a factor of 10:\n\nAccumulating large", "topics": ["strategy"]}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0023", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "r strings using the fastest strategies\n\nNow we can see that LinearArrayStringAccumulator‚Äôs growth is similar to StringStringAccumulator‚Äôs and ExactArrayStringAccumulator‚Äôs, only with better constant factors. Expanding the string less often by a constant factor means that the growth in time has the same shape, merely scaled down (or starting from a smaller baseline). But eventually, for large enough strings, the strategy taken by LinearArrayStringAccumulator will become nonperformant. The doubling and prealloc strategies, on the other hand, are inherently linear, and no matter how much we expand, the time they take will be proportional to the size of the string they are building. The prealloc strategy may be faster by some constant factor, but with a significant decrease in flexibility, sin", "topics": ["strategy"]}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0024", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "ce it requires choosing a size up front.\n\n6 Applying our results\nNow that we have a good idea how our various expansion strategies perform, we should verify that they work not only when benchmarking mere string accumulation, but in the context for which we intended them, the duration format method. Here is a benchmark comparing our string accumulation classes with each other and with two classes from the Java library, StringBuilder and StringBuffer4:\n\nDuration formatting using different implementations of string\naccumulation\n\nAs we can see, our string accumulation benchmark was valid for predicting the performance of a duration formatting benchmark (though whether that validity extends to \"real-world\" duration formatting is another question, which we won‚Äôt attempt to answer here).\n\n7 Diffe", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0025", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "rences between the code in this lecture and the full version that I‚Äôve been linking to\nThe code in this lecture is simplified from more comprehensive implementations of the same classes, which I have linked throughout. The differences are:\n\nThe full StringAccumulator interface includes methods for appending not only single characters but CharSequences, which is an interface that includes Strings and other ways to represent (sequences of) characters.\nThe full StringAccumulator interface extends the interface Appendable from the Java library. Appendable specifies a similar concept (but is slightly more complex). Extending Appendable is what allows us to use the same benchmarking code for our classes and for Java‚Äôs StringBuilder and StringBuffer, since those implement Appendable as well.\nThe ", "topics": []}
{"chunk_id": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt::chunk0026", "source": "data\\raw\\notes\\Lecture 18 Intro to Performance.txt", "text": "full version of AbstractArrayStringAccumulator defines a method initialCapacity(), which subclasses can override to choose a different initial capacity for the array than the default. The PreallocArrayStringAccumulator class overrides this method in order to preallocate a large array more elegantly than we did above.\n8 Conclusion\nThis is merely an introduction to performance. In the next lecture, we will see how to reason about resource usage more formally, using the concept of asymptotic complexity and big-O notation.\n\n1Quite literally!\n\n2Can you see a similarity with the builder pattern here?\n\n3Note that the full version linked in the previous sentence is more comprehensive, but rather than explain the details here, I summarize some of the differences near the end of this lecture and lea", "topics": []}
