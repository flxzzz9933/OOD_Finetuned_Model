{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0017] nite, which means that our idea breaks down right at the start: “collect the remaining elements” is an ill-defined notion!\n\nSo we can’t actually implement this method. Yet the Iterator interface requires that we define something there. The best we can do is throw an exception, saying we give up:\n\n@Override\npublic void remove() {\n  throw new UnsupportedOperationException(\"Can't remove from this Enumeration\");\n}\nFortunately, the designers of the Iterator interface realized that not all iterators have a well-defined notion of removing items — consider what it might mean to iterate over all positive integers, say, and try to remove one of them. Accordingly, the documentation for this method specifies that the UnsupportedOperationException may be used to indicate exactly this failure mode.3\n\n5.\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0023]  (This gets somewhat tricky when a class implements two interfaces, both of which provide a default method with the same name and the same signature – in such cases, the class is required to override the method explicitly, to resolve the ambiguity.) The default implementation for the remove() method in the Iterator interface simply throws exactly this exception...so you don’t even have to mention it in your code unless you truly want to support this method.\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0015] nts();\n  T nextElement();\n}\nThis interface was used to describe enumerating the various items in a collection. For various reasons, this interface was deprecated in favor of the following, more familiar interface:\n\ninterface Iterator<T> {\n  boolean hasNext();\n  T next();\n  void remove();\n}\nSuppose your project has to work with some ancient Java library, that includes a class that implements Enumerator, and you’d like to use it with modern Iterators. Which kind of adapter – object or class – would you most likely need to use?\n\nSince this Enumerator-implementing class already exists, and we can’t modify it, we’ll define an object adapter to wrap the instances of that class and make them behave like an Iterator.\n\nGetting started is easy enough:\n\nclass EnumeratorIterator<T> implements Iterator\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\/**\n * Interface for simple sets of integers. This is part of a demonstration of\n * the dangers of inheritance.\n *\/\npublic interface IntSet1 extends Iterable<Integer> {\n  \/**\n   * Adds the given value to this set.\n   *\n   * @param value the integer add\n   *\/\n  void add(int value);\n\n  \/**\n   * Adds all the values in the given collection to this set.\n   *\n   * @param values the integers to add\n   *\/\n  default\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/**\n   * Removes the given value from this set, if present.\n   *\n   * @param value the integer to remove\n   *\/\n  void remove(int value);\n\n  \/*\n   * Determines whether a particular integer value is a member of this set.\n   *\n   * @param value the integer to check\n   * @return whether {@code value} is a member of this set\n   *\/\n  boolean member(int value);\n\n  \/**\n   * Returns an iterator over the elements.\n   *\n   * @return an iterator\n   *\/\n  Iterator<Integer> iterator();\n}\n\n<\/CodeSuffix>","target":"<Target>\nvoid addAll(Collection<Integer> values) {\n    for (int z : values) {\n      add(z);\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1030\\src\\cs3500\\lec09\\IntSet1.java","mask_span":[491,583],"topics":["gui","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0017] nite, which means that our idea breaks down right at the start: “collect the remaining elements” is an ill-defined notion!\n\nSo we can’t actually implement this method. Yet the Iterator interface requires that we define something there. The best we can do is throw an exception, saying we give up:\n\n@Override\npublic void remove() {\n  throw new UnsupportedOperationException(\"Can't remove from this Enumeration\");\n}\nFortunately, the designers of the Iterator interface realized that not all iterators have a well-defined notion of removing items — consider what it might mean to iterate over all positive integers, say, and try to remove one of them. Accordingly, the documentation for this method specifies that the UnsupportedOperationException may be used to indicate exactly this failure mode.3\n\n5.\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\n\n\/**\n * An implementation of {@link IntSet1} using the Collections Framework's\n * {@link HashSet}. Yes, this is silly, but it's the quickest route to the\n * point of the demonstration.\n *\/\npublic class IntSet1Impl implements IntSet1 {\n  private final Set<Integer> set = new HashSet<>();\n\n  @Override\n  public final void add(int value) {\n    set.add(value);\n  }\n\n  @Override\n  public final void remove(int value) {\n    set.remove(value);\n  }\n\n  @Override\n  public final boolean member(int value) {\n    return set.contains(value);\n  }\n\n  @Override\n  public final\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\nIterator<Integer> iterator() {\n    return set.iterator();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1030\\src\\cs3500\\lec09\\IntSet1Impl.java","mask_span":[659,720],"topics":["decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0010]  as an IntSet1 that we can pass to graph. But what if we’d like to use the resulting object with both libraries, with no further adaptation? A two-way adapter implements two interfaces, most often being a Target as well as an Adaptee, sending requests received via either interface to the underlying adaptee object. For example, we can declare our IntSet2ToIntSet1Adapter to implement both interfaces:\n\npublic final class IntSet2ToIntSet1Adapter implements IntSet1, IntSet2 { ... }\nthe implementation from the previous section remains, and to implement IntSet2 as well, we merely need to forward those requests to the IntSet2 adaptee:\n\n@Override\npublic void unionWith(IntSet2 other) {\n  adaptee.unionWith(other);\n}\n\n@Override\npublic void differenceFrom(IntSet2 other) {\n  adaptee.differenceFrom(other\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\/**\n * Adapts {@link IntSet1Impl} to the {@link IntSet2} interface. This is the\n * class adapter pattern.\n *\/\npublic class IntSet1ImplToIntSet2Adapter\n  extends IntSet1Impl\n  implements IntSet2\n{\n  \/**\n   * Constructs a new empty {@code IntSet1Adapter}.\n   *\/\n  public static IntSet1ImplToIntSet2\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/**\n   * Constructs a new single-element {@code IntSet1Adapter}.\n   *\/\n  public static IntSet1ImplToIntSet2Adapter singleton(int i) {\n    IntSet1ImplToIntSet2Adapter result = new IntSet1ImplToIntSet2Adapter();\n    result.add(i);\n    return result;\n  }\n\n  @Override\n  public final void unionWith(IntSet2 other) {\n    for (int i : other.asList()) {\n      add(i);\n    }\n  }\n\n  @Override\n  public final void differenceFrom(IntSet2 other) {\n    for (int i : other.asList()) {\n      remove(i);\n    }\n  }\n\n  @Override\n  public final boolean isSupersetOf(IntSet2 other) {\n    for (int z : other.asList()) {\n      if (! member(z)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  @Override\n  public final List<Integer> asList() {\n    List<Integer> result = new ArrayList<>();\n    for (int i : this) {\n      result.add(i);\n    }\n    return result;\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\nAdapter empty() {\n    return new IntSet1ImplToIntSet2Adapter();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1030\\src\\cs3500\\lec09\\IntSet1ImplToIntSet2Adapter.java","mask_span":[371,438],"topics":["decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0010]  as an IntSet1 that we can pass to graph. But what if we’d like to use the resulting object with both libraries, with no further adaptation? A two-way adapter implements two interfaces, most often being a Target as well as an Adaptee, sending requests received via either interface to the underlying adaptee object. For example, we can declare our IntSet2ToIntSet1Adapter to implement both interfaces:\n\npublic final class IntSet2ToIntSet1Adapter implements IntSet1, IntSet2 { ... }\nthe implementation from the previous section remains, and to implement IntSet2 as well, we merely need to forward those requests to the IntSet2 adaptee:\n\n@Override\npublic void unionWith(IntSet2 other) {\n  adaptee.unionWith(other);\n}\n\n@Override\npublic void differenceFrom(IntSet2 other) {\n  adaptee.differenceFrom(other\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\/**\n * Adapts {@link IntSet1Impl} to the {@link IntSet2} interface. This is the\n * class adapter pattern.\n *\/\npublic class IntSet1ImplToIntSet2Adapter\n  extends IntSet1Impl\n  implements IntSet2\n{\n  \/**\n   * Constructs a new empty {@code IntSet1Adapter}.\n   *\/\n  public static IntSet1ImplToIntSet2Adapter empty() {\n    return new IntSet1ImplToIntSet2Adapter();\n  }\n\n  \/**\n   * Constructs a new single-element {@code IntSet1Adapter}.\n   *\/\n  public static IntSet1ImplToIntSet2Adapter singleton(int i) {\n    IntSet1ImplToIntSet2Adapter result = new IntSet1ImplToIntSet2Adapter();\n    result.add(i);\n    return result;\n  }\n\n  @Override\n  public final void unionWith(IntSet2 other) {\n    for (int i : other.asList()) {\n      add(i);\n    }\n  }\n\n  @Override\n  public final void differenceFrom(IntSet2 other) {\n    for (int i : other.asList()) {\n      remove(i);\n    }\n  }\n\n  @Override\n  public final boolean isSupersetOf(IntSet2 other) {\n    for (int z : other.asList()) {\n      if (! member(z)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  @Override\n  public final\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\nList<Integer> asList() {\n    List<Integer> result = new ArrayList<>();\n    for (int i : this) {\n      result.add(i);\n    }\n    return result;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1030\\src\\cs3500\\lec09\\IntSet1ImplToIntSet2Adapter.java","mask_span":[1152,1297],"topics":["decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0003]    *\/\n  List<Integer> asList();\n}\nThe prob library provides a class IntSet2Impl that implements IntSet2. For creating instances, IntSet2Impl provides two static factories, empty() and singleton(int):\n\npublic class IntSet2Impl implements IntSet2 {\n  \/** Creates a new, empty integer set. *\/\n  public static empty() { ... }\n\n  \/** Creates a new, singleton integer set with the given member. *\/\n  public static singleton(int member) { ... }\n\n  ...\n}\nWhat if we want to use both of these libraries from the same program, and furthermore, we want to use some sets with both. Perhaps we want to use graph’s sets, which implement IntSet1, with code that works with prob’s sets, which implement IntSet2. Can we do it? Yes, with an adapter.\n\n2 The class adapter pattern\nTo make this abstract for a moment, sup\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n\/**\n * An implementation of the alternative {@link IntSet2} interface, using\n * the Collections Framework's {@link HashSet} as {@link IntSet1Impl}\n * does.\n *\/\npublic final class IntSet2Impl implements IntSet2 {\n  private final Set<Integer> set = new HashSet<>();\n\n  private IntSet2Impl() { }\n\n  \/**\n   * Constructs a new empty {@code IntSet2}.\n   *\/\n  public static IntSet2 empty() {\n    return new IntSet2Impl();\n  }\n\n  \/**\n   * Constructs a new single-element {@code IntSet2}.\n   *\/\n  public static IntSet2 singleton(int i) {\n    IntSet2Impl result = new IntSet2Impl();\n    result.set.add(i);\n    return result;\n  }\n\n  @Override\n  public void unionWith(IntSet2 other) {\n    set.addAll(other.asList());\n  }\n\n  @Override\n  public void differenceFrom(IntSet2 other) {\n    set.removeAll(other.asList());\n  }\n\n  @Override\n  public boolean isSupersetOf(IntSet2 other) {\n    for (int z : other.asList()) {\n      if (! set.contains(z)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic List<Integer> asList() {\n    return new ArrayList<>(set);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1030\\src\\cs3500\\lec09\\IntSet2Impl.java","mask_span":[1129,1197],"topics":["decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0010]  as an IntSet1 that we can pass to graph. But what if we’d like to use the resulting object with both libraries, with no further adaptation? A two-way adapter implements two interfaces, most often being a Target as well as an Adaptee, sending requests received via either interface to the underlying adaptee object. For example, we can declare our IntSet2ToIntSet1Adapter to implement both interfaces:\n\npublic final class IntSet2ToIntSet1Adapter implements IntSet1, IntSet2 { ... }\nthe implementation from the previous section remains, and to implement IntSet2 as well, we merely need to forward those requests to the IntSet2 adaptee:\n\n@Override\npublic void unionWith(IntSet2 other) {\n  adaptee.unionWith(other);\n}\n\n@Override\npublic void differenceFrom(IntSet2 other) {\n  adaptee.differenceFrom(other\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\n\n\/**\n * Adapts an {@link IntSet2} to the {@link IntSet1} interface. The is the\n * object adapter pattern.\n *\/\npublic final class IntSet2ToIntSet1Adapter implements IntSet1, IntSet2 {\n  private final IntSet2 adaptee;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic IntSet2ToIntSet1Adapter(IntSet2 adaptee) {\n    Objects.requireNonNull(adaptee);\n    this.adaptee = adaptee;\n  }\n\n  @Override\n  public void add(int value) {\n    unionWith(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public void remove(int value) {\n    differenceFrom(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public boolean member(int value) {\n    return isSupersetOf(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return asList().iterator();\n  }\n\n  @Override\n  public void unionWith(IntSet2 other) {\n    adaptee.unionWith(other);\n  }\n\n  @Override\n  public void differenceFrom(IntSet2 other) {\n    adaptee.differenceFrom(other);\n  }\n\n  @Override\n  public boolean isSupersetOf(IntSet2 other) {\n    return adaptee.isSupersetOf(other);\n  }\n\n  @Override\n  public List<Integer> asList() {\n    return adaptee.asList();\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic IntSet2ToIntSet1Adapter() {\n    this(IntSet2Impl.empty());\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1030\\src\\cs3500\\lec09\\IntSet2ToIntSet1Adapter.java","mask_span":[318,387],"topics":["decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0010]  as an IntSet1 that we can pass to graph. But what if we’d like to use the resulting object with both libraries, with no further adaptation? A two-way adapter implements two interfaces, most often being a Target as well as an Adaptee, sending requests received via either interface to the underlying adaptee object. For example, we can declare our IntSet2ToIntSet1Adapter to implement both interfaces:\n\npublic final class IntSet2ToIntSet1Adapter implements IntSet1, IntSet2 { ... }\nthe implementation from the previous section remains, and to implement IntSet2 as well, we merely need to forward those requests to the IntSet2 adaptee:\n\n@Override\npublic void unionWith(IntSet2 other) {\n  adaptee.unionWith(other);\n}\n\n@Override\npublic void differenceFrom(IntSet2 other) {\n  adaptee.differenceFrom(other\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\n\n\/**\n * Adapts an {@link IntSet2} to the {@link IntSet1} interface. The is the\n * object adapter pattern.\n *\/\npublic final class IntSet2ToIntSet1Adapter implements IntSet1, IntSet2 {\n  private final IntSet2 adaptee;\n\n  public IntSet2ToIntSet1Adapter() {\n    this(IntSet2Impl.empty());\n  }\n\n  public IntSet2ToIntSet1Adapter(IntSet2 adaptee) {\n    Objects.requireNonNull(adaptee);\n    this.adaptee = adaptee;\n  }\n\n  @Override\n  public void add(int value) {\n    unionWith(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public void remove(int value) {\n    differenceFrom(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public boolean member(int value) {\n    return isSupersetOf(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return asList().iterator();\n  }\n\n  @Override\n  public void unionWith(IntSet2 other) {\n    adaptee.unionWith(other);\n  }\n\n  @Override\n  public void differenceFrom(IntSet2 other) {\n    adaptee.differenceFrom(other);\n  }\n\n  @Override\n  public boolean isSupersetOf(IntSet2 other) {\n    return adaptee.isSupersetOf(other);\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic List<Integer> asList() {\n    return adaptee.asList();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1030\\src\\cs3500\\lec09\\IntSet2ToIntSet1Adapter.java","mask_span":[1207,1271],"topics":["decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0021]  details to clients, which makes code more flexible.\n\nWe then write two assertions about the behavior of our example Book object, each in its own method. The static method assertEquals is similar to check-expect, in that it takes two arguments, first the expected value and second the expression to evaluate and check; the test succeeds when the values are “equal”.2\n\n@Test\npublic void testCiteApa() {\n  assertEquals(\n    \"Salman Rushdie (1980). Midnight's Children. London: Jonathan Cape.\",\n    rushdie.citeApa());\n}\n\n@Test\npublic void testCiteMla() {\n  assertEquals(\n    \"Salman Rushdie. Midnight's Children. London: Jonathan Cape, 1980.\",\n    rushdie.citeMla());\n}\nEach test case method must be preceeded by the annotation @Test for JUnit to find and run it, must return void and must require no a\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\npublic class IntSet1ImplToIntSet2AdapterTest {\n  IntSet1ImplToIntSet2Adapter set1 = new IntSet1ImplToIntSet2Adapter();\n  IntSet1ImplToIntSet2Adapter set2 = IntSet1ImplToIntSet2Adapter.singleton(5);\n\n  @Before\n  public void setUp() throws Exception {\n    set1.add(2);\n    set1.unionWith(sing(3));\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void memberSeesUnionWith() {\n    assertTrue(set1.member(3));\n  }\n\n  @Test\n  public void memberSeesSingleton() {\n    assertTrue(set2.member(5));\n  }\n\n  @Test\n  public void memberCanReturnFalse() {\n    assertFalse(set2.member(2));\n    assertFalse(set2.member(3));\n    assertFalse(set2.member(4));\n    assertFalse(set1.member(5));\n  }\n\n  @Test\n  public void isSupersetOfSeesAdd() {\n    assertTrue(set1.isSupersetOf(sing(2)));\n  }\n\n  @Test\n  public void isSupersetOfSeesUnionWith() {\n    assertTrue(set1.isSupersetOf(sing(3)));\n  }\n\n  @Test\n  public void isSupersetOfSeesSingleton() {\n    assertTrue(set2.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void isSupersetOfCanReturnFalse() {\n    assertFalse(set2.isSupersetOf(sing(2)));\n    assertFalse(set2.isSupersetOf(sing(3)));\n    assertFalse(set2.isSupersetOf(sing(4)));\n    assertFalse(set1.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void removeRemoves() {\n    set2.remove(2);\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n\n  \/\/ No tests for iterator or asList yet.\n\n  public static IntSet2 sing(int value) {\n    return IntSet2Impl.singleton(value);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void memberSeesAdd() {\n    assertTrue(set1.member(2));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1030\\test\\cs3500\\lec09\\IntSet1ImplToIntSet2AdapterTest.java","mask_span":[471,536],"topics":["testing","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0021]  details to clients, which makes code more flexible.\n\nWe then write two assertions about the behavior of our example Book object, each in its own method. The static method assertEquals is similar to check-expect, in that it takes two arguments, first the expected value and second the expression to evaluate and check; the test succeeds when the values are “equal”.2\n\n@Test\npublic void testCiteApa() {\n  assertEquals(\n    \"Salman Rushdie (1980). Midnight's Children. London: Jonathan Cape.\",\n    rushdie.citeApa());\n}\n\n@Test\npublic void testCiteMla() {\n  assertEquals(\n    \"Salman Rushdie. Midnight's Children. London: Jonathan Cape, 1980.\",\n    rushdie.citeMla());\n}\nEach test case method must be preceeded by the annotation @Test for JUnit to find and run it, must return void and must require no a\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\npublic class IntSet1ImplToIntSet2AdapterTest {\n  IntSet1ImplToIntSet2Adapter set1 = new IntSet1ImplToIntSet2Adapter();\n  IntSet1ImplToIntSet2Adapter set2 = IntSet1ImplToIntSet2Adapter.singleton(5);\n\n  @Before\n  public void setUp() throws Exception {\n    set1.add(2);\n    set1.unionWith(sing(3));\n  }\n\n  @Test\n  public void memberSeesAdd() {\n    assertTrue(set1.member(2));\n  }\n\n  @Test\n  public void memberSeesUnionWith() {\n    assertTrue(set1.member(3));\n  }\n\n  @Test\n  public void memberSeesSingleton() {\n    assertTrue(set2.member(5));\n  }\n\n  @Test\n  public void memberCanReturnFalse() {\n    assertFalse(set2.member(2));\n    assertFalse(set2.member(3));\n    assertFalse(set2.member(4));\n    assertFalse(set1.member(5));\n  }\n\n  @Test\n  public void isSupersetOfSeesAdd() {\n    assertTrue(set1.isSupersetOf(sing(2)));\n  }\n\n  @Test\n  public void isSupersetOfSeesUnionWith() {\n    assertTrue(set1.isSupersetOf(sing(3)));\n  }\n\n  @Test\n  public void isSupersetOfSeesSingleton() {\n    assertTrue(set2.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void isSupersetOfCanReturnFalse() {\n    assertFalse(set2.isSupersetOf(sing(2)));\n    assertFalse(set2.isSupersetOf(sing(3)));\n    assertFalse(set2.isSupersetOf(sing(4)));\n    assertFalse(set1.isSupersetOf(sing(5)));\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/\/ No tests for iterator or asList yet.\n\n  public static IntSet2 sing(int value) {\n    return IntSet2Impl.singleton(value);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void removeRemoves() {\n    set2.remove(2);\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1030\\test\\cs3500\\lec09\\IntSet1ImplToIntSet2AdapterTest.java","mask_span":[1433,1551],"topics":["testing","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0021]  details to clients, which makes code more flexible.\n\nWe then write two assertions about the behavior of our example Book object, each in its own method. The static method assertEquals is similar to check-expect, in that it takes two arguments, first the expected value and second the expression to evaluate and check; the test succeeds when the values are “equal”.2\n\n@Test\npublic void testCiteApa() {\n  assertEquals(\n    \"Salman Rushdie (1980). Midnight's Children. London: Jonathan Cape.\",\n    rushdie.citeApa());\n}\n\n@Test\npublic void testCiteMla() {\n  assertEquals(\n    \"Salman Rushdie. Midnight's Children. London: Jonathan Cape, 1980.\",\n    rushdie.citeMla());\n}\nEach test case method must be preceeded by the annotation @Test for JUnit to find and run it, must return void and must require no a\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static cs3500.lec09.IntSet1ImplToIntSet2AdapterTest.sing;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\n\npublic class IntSet2ToIntSet1AdapterTest {\n  IntSet2ToIntSet1Adapter set1 = new IntSet2ToIntSet1Adapter();\n\n  IntSet2 set2Base = sing(5);\n  IntSet2ToIntSet1Adapter set2 = new IntSet2ToIntSet1Adapter(set2Base);\n\n  @Before\n  public void setUp() throws Exception {\n    set1.add(2);\n    set1.unionWith(sing(3));\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void memberSeesUnionWith() {\n    assertTrue(set1.member(3));\n  }\n\n  @Test\n  public void memberSeesSingleton() {\n    assertTrue(set2.member(5));\n  }\n\n  @Test\n  public void memberCanReturnFalse() {\n    assertFalse(set2.member(2));\n    assertFalse(set2.member(3));\n    assertFalse(set2.member(4));\n    assertFalse(set1.member(5));\n  }\n\n  @Test\n  public void isSupersetOfSeesAdd() {\n    assertTrue(set1.isSupersetOf(sing(2)));\n  }\n\n  @Test\n  public void isSupersetOfSeesUnionWith() {\n    assertTrue(set1.isSupersetOf(sing(3)));\n  }\n\n  @Test\n  public void isSupersetOfSeesSingleton() {\n    assertTrue(set2.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void isSupersetOfCanReturnFalse() {\n    assertFalse(set2.isSupersetOf(sing(2)));\n    assertFalse(set2.isSupersetOf(sing(3)));\n    assertFalse(set2.isSupersetOf(sing(4)));\n    assertFalse(set1.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void removeRemoves() {\n    set2.remove(2);\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n\n  @Test\n  public void removeInBaseVisibleInAdapter() {\n    set2Base.differenceFrom(sing(2));\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n\n  @Test\n  public void removeInAdapterVisibleInBase() {\n    set2.remove(2);\n    assertFalse(set2Base.isSupersetOf(sing(2)));\n    assertTrue(set2Base.isSupersetOf(sing(2)));\n  }\n\n  \/\/ No tests for iterator or asList yet.\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void memberSeesAdd() {\n    assertTrue(set1.member(2));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1030\\test\\cs3500\\lec09\\IntSet2ToIntSet1AdapterTest.java","mask_span":[548,613],"topics":["testing","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0021]  details to clients, which makes code more flexible.\n\nWe then write two assertions about the behavior of our example Book object, each in its own method. The static method assertEquals is similar to check-expect, in that it takes two arguments, first the expected value and second the expression to evaluate and check; the test succeeds when the values are “equal”.2\n\n@Test\npublic void testCiteApa() {\n  assertEquals(\n    \"Salman Rushdie (1980). Midnight's Children. London: Jonathan Cape.\",\n    rushdie.citeApa());\n}\n\n@Test\npublic void testCiteMla() {\n  assertEquals(\n    \"Salman Rushdie. Midnight's Children. London: Jonathan Cape, 1980.\",\n    rushdie.citeMla());\n}\nEach test case method must be preceeded by the annotation @Test for JUnit to find and run it, must return void and must require no a\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static cs3500.lec09.IntSet1ImplToIntSet2AdapterTest.sing;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\n\npublic class IntSet2ToIntSet1AdapterTest {\n  IntSet2ToIntSet1Adapter set1 = new IntSet2ToIntSet1Adapter();\n\n  IntSet2 set2Base = sing(5);\n  IntSet2ToIntSet1Adapter set2 = new IntSet2ToIntSet1Adapter(set2Base);\n\n  @Before\n  public void setUp() throws Exception {\n    set1.add(2);\n    set1.unionWith(sing(3));\n  }\n\n  @Test\n  public void memberSeesAdd() {\n    assertTrue(set1.member(2));\n  }\n\n  @Test\n  public void memberSeesUnionWith() {\n    assertTrue(set1.member(3));\n  }\n\n  @Test\n  public void memberSeesSingleton() {\n    assertTrue(set2.member(5));\n  }\n\n  @Test\n  public void memberCanReturnFalse() {\n    assertFalse(set2.member(2));\n    assertFalse(set2.member(3));\n    assertFalse(set2.member(4));\n    assertFalse(set1.member(5));\n  }\n\n  @Test\n  public void isSupersetOfSeesAdd() {\n    assertTrue(set1.isSupersetOf(sing(2)));\n  }\n\n  @Test\n  public void isSupersetOfSeesUnionWith() {\n    assertTrue(set1.isSupersetOf(sing(3)));\n  }\n\n  @Test\n  public void isSupersetOfSeesSingleton() {\n    assertTrue(set2.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void isSupersetOfCanReturnFalse() {\n    assertFalse(set2.isSupersetOf(sing(2)));\n    assertFalse(set2.isSupersetOf(sing(3)));\n    assertFalse(set2.isSupersetOf(sing(4)));\n    assertFalse(set1.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void removeRemoves() {\n    set2.remove(2);\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n\n  @Test\n  public void removeInBaseVisibleInAdapter() {\n    set2Base.differenceFrom(sing(2));\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/\/ No tests for iterator or asList yet.\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void removeInAdapterVisibleInBase() {\n    set2.remove(2);\n    assertFalse(set2Base.isSupersetOf(sing(2)));\n    assertTrue(set2Base.isSupersetOf(sing(2)));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1030\\test\\cs3500\\lec09\\IntSet2ToIntSet1AdapterTest.java","mask_span":[1803,1968],"topics":["testing","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec14;\n\nimport cs3500.lec09.IntSet1ImplToIntSet2Adapter;\nimport cs3500.lec09.IntSet2;\nimport cs3500.lec09.IntSet2Impl;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\npublic class IntSet1ImplToIntSet2AdapterTest {\n  IntSet1ImplToIntSet2Adapter set1 = new IntSet1ImplToIntSet2Adapter();\n  IntSet1ImplToIntSet2Adapter set2 = IntSet1ImplToIntSet2Adapter.singleton(5);\n\n  @Before\n  public void setUp() throws Exception {\n    set1.add(2);\n    set1.unionWith(sing(3));\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void memberSeesUnionWith() {\n    assertTrue(set1.member(3));\n  }\n\n  @Test\n  public void memberSeesSingleton() {\n    assertTrue(set2.member(5));\n  }\n\n  @Test\n  public void memberCanReturnFalse() {\n    assertFalse(set2.member(2));\n    assertFalse(set2.member(3));\n    assertFalse(set2.member(4));\n    assertFalse(set1.member(5));\n  }\n\n  @Test\n  public void isSupersetOfSeesAdd() {\n    assertTrue(set1.isSupersetOf(sing(2)));\n  }\n\n  @Test\n  public void isSupersetOfSeesUnionWith() {\n    assertTrue(set1.isSupersetOf(sing(3)));\n  }\n\n  @Test\n  public void isSupersetOfSeesSingleton() {\n    assertTrue(set2.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void isSupersetOfCanReturnFalse() {\n    assertFalse(set2.isSupersetOf(sing(2)));\n    assertFalse(set2.isSupersetOf(sing(3)));\n    assertFalse(set2.isSupersetOf(sing(4)));\n    assertFalse(set1.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void removeRemoves() {\n    set2.remove(2);\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n\n  \/\/ No tests for iterator or asList yet.\n\n  static IntSet2 sing(int value) {\n    return IntSet2Impl.singleton(value);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void memberSeesAdd() {\n    assertTrue(set1.member(2));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1030\\test\\cs3500\\lec14\\IntSet1ImplToIntSet2AdapterTest.java","mask_span":[582,647],"topics":["testing","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec14;\n\nimport cs3500.lec09.IntSet1ImplToIntSet2Adapter;\nimport cs3500.lec09.IntSet2;\nimport cs3500.lec09.IntSet2Impl;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\npublic class IntSet1ImplToIntSet2AdapterTest {\n  IntSet1ImplToIntSet2Adapter set1 = new IntSet1ImplToIntSet2Adapter();\n  IntSet1ImplToIntSet2Adapter set2 = IntSet1ImplToIntSet2Adapter.singleton(5);\n\n  @Before\n  public void setUp() throws Exception {\n    set1.add(2);\n    set1.unionWith(sing(3));\n  }\n\n  @Test\n  public void memberSeesAdd() {\n    assertTrue(set1.member(2));\n  }\n\n  @Test\n  public void memberSeesUnionWith() {\n    assertTrue(set1.member(3));\n  }\n\n  @Test\n  public void memberSeesSingleton() {\n    assertTrue(set2.member(5));\n  }\n\n  @Test\n  public void memberCanReturnFalse() {\n    assertFalse(set2.member(2));\n    assertFalse(set2.member(3));\n    assertFalse(set2.member(4));\n    assertFalse(set1.member(5));\n  }\n\n  @Test\n  public void isSupersetOfSeesAdd() {\n    assertTrue(set1.isSupersetOf(sing(2)));\n  }\n\n  @Test\n  public void isSupersetOfSeesUnionWith() {\n    assertTrue(set1.isSupersetOf(sing(3)));\n  }\n\n  @Test\n  public void isSupersetOfSeesSingleton() {\n    assertTrue(set2.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void isSupersetOfCanReturnFalse() {\n    assertFalse(set2.isSupersetOf(sing(2)));\n    assertFalse(set2.isSupersetOf(sing(3)));\n    assertFalse(set2.isSupersetOf(sing(4)));\n    assertFalse(set1.isSupersetOf(sing(5)));\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/\/ No tests for iterator or asList yet.\n\n  static IntSet2 sing(int value) {\n    return IntSet2Impl.singleton(value);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void removeRemoves() {\n    set2.remove(2);\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1030\\test\\cs3500\\lec14\\IntSet1ImplToIntSet2AdapterTest.java","mask_span":[1544,1662],"topics":["testing","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0019] sented as a reference to a chunk of memory, and the value of the array, so far as Java is concerned, is the reference itself, not the chunk of memory. This means that re-assigning or passing an array results in aliasing, having more than one name for the same thing:\n\nint[] anotherArray = intArray;\nanotherArray[0] = -9;\nassertEquals(-9, intArray[0]);\nNot only does == for arrays compare references rather than contents, but equals(Object) does as well. This means, for example, that this JUnit test will fail:\n\nassertEquals(new int[] {3, 6}, new int[] {3, 6}); \/\/ fails!\nYes, the arrays have the same contents, but not the same physical identity. To test for equality on the contents of two arrays, use assertArrayEquals:\n\nassertArrayEquals(new int[] {3, 6}, new int[] {3, 6});\nIn order to compare a\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec14;\n\nimport cs3500.lec09.IntSet2;\nimport cs3500.lec09.IntSet2ToIntSet1Adapter;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static cs3500.lec09.IntSet1ImplToIntSet2AdapterTest.sing;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\n\npublic class IntSet2ToIntSet1AdapterTest {\n  IntSet2ToIntSet1Adapter set1 = new IntSet2ToIntSet1Adapter();\n\n  IntSet2 set2Base = sing(5);\n  IntSet2ToIntSet1Adapter set2 = new IntSet2ToIntSet1Adapter(set2Base);\n\n  @Before\n  public void setUp() throws Exception {\n    set1.add(2);\n    set1.unionWith(sing(3));\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void memberSeesUnionWith() {\n    assertTrue(set1.member(3));\n  }\n\n  @Test\n  public void memberSeesSingleton() {\n    assertTrue(set2.member(5));\n  }\n\n  @Test\n  public void memberCanReturnFalse() {\n    assertFalse(set2.member(2));\n    assertFalse(set2.member(3));\n    assertFalse(set2.member(4));\n    assertFalse(set1.member(5));\n  }\n\n  @Test\n  public void isSupersetOfSeesAdd() {\n    assertTrue(set1.isSupersetOf(sing(2)));\n  }\n\n  @Test\n  public void isSupersetOfSeesUnionWith() {\n    assertTrue(set1.isSupersetOf(sing(3)));\n  }\n\n  @Test\n  public void isSupersetOfSeesSingleton() {\n    assertTrue(set2.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void isSupersetOfCanReturnFalse() {\n    assertFalse(set2.isSupersetOf(sing(2)));\n    assertFalse(set2.isSupersetOf(sing(3)));\n    assertFalse(set2.isSupersetOf(sing(4)));\n    assertFalse(set1.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void removeRemoves() {\n    set2.remove(2);\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n\n  @Test\n  public void removeInBaseVisibleInAdapter() {\n    set2Base.differenceFrom(sing(2));\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n\n  @Test\n  public void removeInAdapterVisibleInBase() {\n    set2.remove(2);\n    assertFalse(set2Base.isSupersetOf(sing(2)));\n    assertTrue(set2Base.isSupersetOf(sing(2)));\n  }\n\n  \/\/ No tests for iterator or asList yet.\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void memberSeesAdd() {\n    assertTrue(set1.member(2));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1030\\test\\cs3500\\lec14\\IntSet2ToIntSet1AdapterTest.java","mask_span":[622,687],"topics":["testing","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0019] sented as a reference to a chunk of memory, and the value of the array, so far as Java is concerned, is the reference itself, not the chunk of memory. This means that re-assigning or passing an array results in aliasing, having more than one name for the same thing:\n\nint[] anotherArray = intArray;\nanotherArray[0] = -9;\nassertEquals(-9, intArray[0]);\nNot only does == for arrays compare references rather than contents, but equals(Object) does as well. This means, for example, that this JUnit test will fail:\n\nassertEquals(new int[] {3, 6}, new int[] {3, 6}); \/\/ fails!\nYes, the arrays have the same contents, but not the same physical identity. To test for equality on the contents of two arrays, use assertArrayEquals:\n\nassertArrayEquals(new int[] {3, 6}, new int[] {3, 6});\nIn order to compare a\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec14;\n\nimport cs3500.lec09.IntSet2;\nimport cs3500.lec09.IntSet2ToIntSet1Adapter;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static cs3500.lec09.IntSet1ImplToIntSet2AdapterTest.sing;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\n\npublic class IntSet2ToIntSet1AdapterTest {\n  IntSet2ToIntSet1Adapter set1 = new IntSet2ToIntSet1Adapter();\n\n  IntSet2 set2Base = sing(5);\n  IntSet2ToIntSet1Adapter set2 = new IntSet2ToIntSet1Adapter(set2Base);\n\n  @Before\n  public void setUp() throws Exception {\n    set1.add(2);\n    set1.unionWith(sing(3));\n  }\n\n  @Test\n  public void memberSeesAdd() {\n    assertTrue(set1.member(2));\n  }\n\n  @Test\n  public void memberSeesUnionWith() {\n    assertTrue(set1.member(3));\n  }\n\n  @Test\n  public void memberSeesSingleton() {\n    assertTrue(set2.member(5));\n  }\n\n  @Test\n  public void memberCanReturnFalse() {\n    assertFalse(set2.member(2));\n    assertFalse(set2.member(3));\n    assertFalse(set2.member(4));\n    assertFalse(set1.member(5));\n  }\n\n  @Test\n  public void isSupersetOfSeesAdd() {\n    assertTrue(set1.isSupersetOf(sing(2)));\n  }\n\n  @Test\n  public void isSupersetOfSeesUnionWith() {\n    assertTrue(set1.isSupersetOf(sing(3)));\n  }\n\n  @Test\n  public void isSupersetOfSeesSingleton() {\n    assertTrue(set2.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void isSupersetOfCanReturnFalse() {\n    assertFalse(set2.isSupersetOf(sing(2)));\n    assertFalse(set2.isSupersetOf(sing(3)));\n    assertFalse(set2.isSupersetOf(sing(4)));\n    assertFalse(set1.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void removeRemoves() {\n    set2.remove(2);\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n\n  @Test\n  public void removeInBaseVisibleInAdapter() {\n    set2Base.differenceFrom(sing(2));\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/\/ No tests for iterator or asList yet.\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void removeInAdapterVisibleInBase() {\n    set2.remove(2);\n    assertFalse(set2Base.isSupersetOf(sing(2)));\n    assertTrue(set2Base.isSupersetOf(sing(2)));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1030\\test\\cs3500\\lec14\\IntSet2ToIntSet1AdapterTest.java","mask_span":[1877,2042],"topics":["testing","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0017] nite, which means that our idea breaks down right at the start: “collect the remaining elements” is an ill-defined notion!\n\nSo we can’t actually implement this method. Yet the Iterator interface requires that we define something there. The best we can do is throw an exception, saying we give up:\n\n@Override\npublic void remove() {\n  throw new UnsupportedOperationException(\"Can't remove from this Enumeration\");\n}\nFortunately, the designers of the Iterator interface realized that not all iterators have a well-defined notion of removing items — consider what it might mean to iterate over all positive integers, say, and try to remove one of them. Accordingly, the documentation for this method specifies that the UnsupportedOperationException may be used to indicate exactly this failure mode.3\n\n5.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.adapters;\n\nimport java.awt.*;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport cs3500.lec09.IntSet1Impl;\nimport cs3500.lec09.IntSet2;\n\npublic class IntSet1ToIntSet2 extends IntSet1Impl implements IntSet2 {\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void differenceFrom(IntSet2 other) {\n    for(int val : other.asList()) {\n      super.remove(val);\n    }\n  }\n\n  @Override\n  public boolean isSupersetOf(IntSet2 other) {\n    for(int val : other.asList()) {\n      if(!super.member(val)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  @Override\n  public List<Integer> asList() {\n    Iterator<Integer> it = super.iterator();\n    List<Integer> ans = new ArrayList<>();\n    \/*\n    while(it.hasNext()) {\n      ans.add(it.next());\n    }\n    *\/\n    for(int val : this) {\n      ans.add(val);\n    }\n\n    return ans;\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void unionWith(IntSet2 other) {\n    \/\/loop over other\n    for(int val : other.asList()) {\n      \/\/if not a member of us, add them\n      super.add(val);\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1335\\src\\cs3500\\adapters\\IntSet1ToIntSet2.java","mask_span":[272,440],"topics":["decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0017] nite, which means that our idea breaks down right at the start: “collect the remaining elements” is an ill-defined notion!\n\nSo we can’t actually implement this method. Yet the Iterator interface requires that we define something there. The best we can do is throw an exception, saying we give up:\n\n@Override\npublic void remove() {\n  throw new UnsupportedOperationException(\"Can't remove from this Enumeration\");\n}\nFortunately, the designers of the Iterator interface realized that not all iterators have a well-defined notion of removing items — consider what it might mean to iterate over all positive integers, say, and try to remove one of them. Accordingly, the documentation for this method specifies that the UnsupportedOperationException may be used to indicate exactly this failure mode.3\n\n5.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.adapters;\n\nimport java.awt.*;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport cs3500.lec09.IntSet1Impl;\nimport cs3500.lec09.IntSet2;\n\npublic class IntSet1ToIntSet2 extends IntSet1Impl implements IntSet2 {\n  @Override\n  public void unionWith(IntSet2 other) {\n    \/\/loop over other\n    for(int val : other.asList()) {\n      \/\/if not a member of us, add them\n      super.add(val);\n    }\n  }\n\n  @Override\n  public void differenceFrom(IntSet2 other) {\n    for(int val : other.asList()) {\n      super.remove(val);\n    }\n  }\n\n  @Override\n  public boolean isSupersetOf(IntSet2 other) {\n    for(int val : other.asList()) {\n      if(!super.member(val)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic List<Integer> asList() {\n    Iterator<Integer> it = super.iterator();\n    List<Integer> ans = new ArrayList<>();\n    \/*\n    while(it.hasNext()) {\n      ans.add(it.next());\n    }\n    *\/\n    for(int val : this) {\n      ans.add(val);\n    }\n\n    return ans;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1335\\src\\cs3500\\adapters\\IntSet1ToIntSet2.java","mask_span":[770,1034],"topics":["decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0017] nite, which means that our idea breaks down right at the start: “collect the remaining elements” is an ill-defined notion!\n\nSo we can’t actually implement this method. Yet the Iterator interface requires that we define something there. The best we can do is throw an exception, saying we give up:\n\n@Override\npublic void remove() {\n  throw new UnsupportedOperationException(\"Can't remove from this Enumeration\");\n}\nFortunately, the designers of the Iterator interface realized that not all iterators have a well-defined notion of removing items — consider what it might mean to iterate over all positive integers, say, and try to remove one of them. Accordingly, the documentation for this method specifies that the UnsupportedOperationException may be used to indicate exactly this failure mode.3\n\n5.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.adapters;\n\nimport java.util.Iterator;\n\nimport cs3500.lec09.IntSet1;\nimport cs3500.lec09.IntSet2;\nimport cs3500.lec09.IntSet2Impl;\n\npublic class IntSet2ToIntSet1 implements IntSet1 {\n\n  private IntSet2 delegate;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/\/IntSet2Impl.empty()\n  \/\/IntSet2Impl.singleton(int)\n\n\n  @Override\n  public void add(int value) {\n    delegate.unionWith(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public void remove(int value) {\n    delegate.differenceFrom(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public boolean member(int value) {\n    return delegate.isSupersetOf(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return delegate.asList().iterator();\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic IntSet2ToIntSet1(IntSet2 other) {\n    this.delegate = other;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1335\\src\\cs3500\\adapters\\IntSet2ToIntSet1.java","mask_span":[229,300],"topics":["decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0017] nite, which means that our idea breaks down right at the start: “collect the remaining elements” is an ill-defined notion!\n\nSo we can’t actually implement this method. Yet the Iterator interface requires that we define something there. The best we can do is throw an exception, saying we give up:\n\n@Override\npublic void remove() {\n  throw new UnsupportedOperationException(\"Can't remove from this Enumeration\");\n}\nFortunately, the designers of the Iterator interface realized that not all iterators have a well-defined notion of removing items — consider what it might mean to iterate over all positive integers, say, and try to remove one of them. Accordingly, the documentation for this method specifies that the UnsupportedOperationException may be used to indicate exactly this failure mode.3\n\n5.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.adapters;\n\nimport java.util.Iterator;\n\nimport cs3500.lec09.IntSet1;\nimport cs3500.lec09.IntSet2;\nimport cs3500.lec09.IntSet2Impl;\n\npublic class IntSet2ToIntSet1 implements IntSet1 {\n\n  private IntSet2 delegate;\n\n  public IntSet2ToIntSet1(IntSet2 other) {\n    this.delegate = other;\n  }\n\n  \/\/IntSet2Impl.empty()\n  \/\/IntSet2Impl.singleton(int)\n\n\n  @Override\n  public void add(int value) {\n    delegate.unionWith(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public void remove(int value) {\n    delegate.differenceFrom(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public boolean member(int value) {\n    return delegate.isSupersetOf(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic Iterator<Integer> iterator() {\n    return delegate.asList().iterator();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1335\\src\\cs3500\\adapters\\IntSet2ToIntSet1.java","mask_span":[703,785],"topics":["decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0017] nite, which means that our idea breaks down right at the start: “collect the remaining elements” is an ill-defined notion!\n\nSo we can’t actually implement this method. Yet the Iterator interface requires that we define something there. The best we can do is throw an exception, saying we give up:\n\n@Override\npublic void remove() {\n  throw new UnsupportedOperationException(\"Can't remove from this Enumeration\");\n}\nFortunately, the designers of the Iterator interface realized that not all iterators have a well-defined notion of removing items — consider what it might mean to iterate over all positive integers, say, and try to remove one of them. Accordingly, the documentation for this method specifies that the UnsupportedOperationException may be used to indicate exactly this failure mode.3\n\n5.\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0023]  (This gets somewhat tricky when a class implements two interfaces, both of which provide a default method with the same name and the same signature – in such cases, the class is required to override the method explicitly, to resolve the ambiguity.) The default implementation for the remove() method in the Iterator interface simply throws exactly this exception...so you don’t even have to mention it in your code unless you truly want to support this method.\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0015] nts();\n  T nextElement();\n}\nThis interface was used to describe enumerating the various items in a collection. For various reasons, this interface was deprecated in favor of the following, more familiar interface:\n\ninterface Iterator<T> {\n  boolean hasNext();\n  T next();\n  void remove();\n}\nSuppose your project has to work with some ancient Java library, that includes a class that implements Enumerator, and you’d like to use it with modern Iterators. Which kind of adapter – object or class – would you most likely need to use?\n\nSince this Enumerator-implementing class already exists, and we can’t modify it, we’ll define an object adapter to wrap the instances of that class and make them behave like an Iterator.\n\nGetting started is easy enough:\n\nclass EnumeratorIterator<T> implements Iterator\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\/**\n * Interface for simple sets of integers. This is part of a demonstration of\n * the dangers of inheritance.\n *\/\npublic interface IntSet1 extends Iterable<Integer> {\n  \/**\n   * Adds the given value to this set.\n   *\n   * @param value the integer add\n   *\/\n  void add(int value);\n\n  \/**\n   * Adds all the values in the given collection to this set.\n   *\n   * @param values the integers to add\n   *\/\n  default\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/**\n   * Removes the given value from this set, if present.\n   *\n   * @param value the integer to remove\n   *\/\n  void remove(int value);\n\n  \/*\n   * Determines whether a particular integer value is a member of this set.\n   *\n   * @param value the integer to check\n   * @return whether {@code value} is a member of this set\n   *\/\n  boolean member(int value);\n\n  \/**\n   * Returns an iterator over the elements.\n   *\n   * @return an iterator\n   *\/\n  Iterator<Integer> iterator();\n}\n\n<\/CodeSuffix>","target":"<Target>\nvoid addAll(Collection<Integer> values) {\n    for (int z : values) {\n      add(z);\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1335\\src\\cs3500\\lec09\\IntSet1.java","mask_span":[491,583],"topics":["gui","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0017] nite, which means that our idea breaks down right at the start: “collect the remaining elements” is an ill-defined notion!\n\nSo we can’t actually implement this method. Yet the Iterator interface requires that we define something there. The best we can do is throw an exception, saying we give up:\n\n@Override\npublic void remove() {\n  throw new UnsupportedOperationException(\"Can't remove from this Enumeration\");\n}\nFortunately, the designers of the Iterator interface realized that not all iterators have a well-defined notion of removing items — consider what it might mean to iterate over all positive integers, say, and try to remove one of them. Accordingly, the documentation for this method specifies that the UnsupportedOperationException may be used to indicate exactly this failure mode.3\n\n5.\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\n\n\/**\n * An implementation of {@link IntSet1} using the Collections Framework's\n * {@link HashSet}. Yes, this is silly, but it's the quickest route to the\n * point of the demonstration.\n *\/\npublic class IntSet1Impl implements IntSet1 {\n  private final Set<Integer> set = new HashSet<>();\n\n  @Override\n  public final void add(int value) {\n    set.add(value);\n  }\n\n  @Override\n  public final void remove(int value) {\n    set.remove(value);\n  }\n\n  @Override\n  public final boolean member(int value) {\n    return set.contains(value);\n  }\n\n  @Override\n  public final\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\nIterator<Integer> iterator() {\n    return set.iterator();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1335\\src\\cs3500\\lec09\\IntSet1Impl.java","mask_span":[659,720],"topics":["decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0010]  as an IntSet1 that we can pass to graph. But what if we’d like to use the resulting object with both libraries, with no further adaptation? A two-way adapter implements two interfaces, most often being a Target as well as an Adaptee, sending requests received via either interface to the underlying adaptee object. For example, we can declare our IntSet2ToIntSet1Adapter to implement both interfaces:\n\npublic final class IntSet2ToIntSet1Adapter implements IntSet1, IntSet2 { ... }\nthe implementation from the previous section remains, and to implement IntSet2 as well, we merely need to forward those requests to the IntSet2 adaptee:\n\n@Override\npublic void unionWith(IntSet2 other) {\n  adaptee.unionWith(other);\n}\n\n@Override\npublic void differenceFrom(IntSet2 other) {\n  adaptee.differenceFrom(other\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\/**\n * Adapts {@link IntSet1Impl} to the {@link IntSet2} interface. This is the\n * class adapter pattern.\n *\/\npublic class IntSet1ImplToIntSet2Adapter\n  extends IntSet1Impl\n  implements IntSet2\n{\n  \/**\n   * Constructs a new empty {@code IntSet1Adapter}.\n   *\/\n  public static IntSet1ImplToIntSet2\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/**\n   * Constructs a new single-element {@code IntSet1Adapter}.\n   *\/\n  public static IntSet1ImplToIntSet2Adapter singleton(int i) {\n    IntSet1ImplToIntSet2Adapter result = new IntSet1ImplToIntSet2Adapter();\n    result.add(i);\n    return result;\n  }\n\n  @Override\n  public final void unionWith(IntSet2 other) {\n    for (int i : other.asList()) {\n      add(i);\n    }\n  }\n\n  @Override\n  public final void differenceFrom(IntSet2 other) {\n    for (int i : other.asList()) {\n      remove(i);\n    }\n  }\n\n  @Override\n  public final boolean isSupersetOf(IntSet2 other) {\n    for (int z : other.asList()) {\n      if (! member(z)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  @Override\n  public final List<Integer> asList() {\n    List<Integer> result = new ArrayList<>();\n    for (int i : this) {\n      result.add(i);\n    }\n    return result;\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\nAdapter empty() {\n    return new IntSet1ImplToIntSet2Adapter();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1335\\src\\cs3500\\lec09\\IntSet1ImplToIntSet2Adapter.java","mask_span":[371,438],"topics":["decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0010]  as an IntSet1 that we can pass to graph. But what if we’d like to use the resulting object with both libraries, with no further adaptation? A two-way adapter implements two interfaces, most often being a Target as well as an Adaptee, sending requests received via either interface to the underlying adaptee object. For example, we can declare our IntSet2ToIntSet1Adapter to implement both interfaces:\n\npublic final class IntSet2ToIntSet1Adapter implements IntSet1, IntSet2 { ... }\nthe implementation from the previous section remains, and to implement IntSet2 as well, we merely need to forward those requests to the IntSet2 adaptee:\n\n@Override\npublic void unionWith(IntSet2 other) {\n  adaptee.unionWith(other);\n}\n\n@Override\npublic void differenceFrom(IntSet2 other) {\n  adaptee.differenceFrom(other\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\/**\n * Adapts {@link IntSet1Impl} to the {@link IntSet2} interface. This is the\n * class adapter pattern.\n *\/\npublic class IntSet1ImplToIntSet2Adapter\n  extends IntSet1Impl\n  implements IntSet2\n{\n  \/**\n   * Constructs a new empty {@code IntSet1Adapter}.\n   *\/\n  public static IntSet1ImplToIntSet2Adapter empty() {\n    return new IntSet1ImplToIntSet2Adapter();\n  }\n\n  \/**\n   * Constructs a new single-element {@code IntSet1Adapter}.\n   *\/\n  public static IntSet1ImplToIntSet2Adapter singleton(int i) {\n    IntSet1ImplToIntSet2Adapter result = new IntSet1ImplToIntSet2Adapter();\n    result.add(i);\n    return result;\n  }\n\n  @Override\n  public final void unionWith(IntSet2 other) {\n    for (int i : other.asList()) {\n      add(i);\n    }\n  }\n\n  @Override\n  public final void differenceFrom(IntSet2 other) {\n    for (int i : other.asList()) {\n      remove(i);\n    }\n  }\n\n  @Override\n  public final boolean isSupersetOf(IntSet2 other) {\n    for (int z : other.asList()) {\n      if (! member(z)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  @Override\n  public final\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\nList<Integer> asList() {\n    List<Integer> result = new ArrayList<>();\n    for (int i : this) {\n      result.add(i);\n    }\n    return result;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1335\\src\\cs3500\\lec09\\IntSet1ImplToIntSet2Adapter.java","mask_span":[1152,1297],"topics":["decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0003]    *\/\n  List<Integer> asList();\n}\nThe prob library provides a class IntSet2Impl that implements IntSet2. For creating instances, IntSet2Impl provides two static factories, empty() and singleton(int):\n\npublic class IntSet2Impl implements IntSet2 {\n  \/** Creates a new, empty integer set. *\/\n  public static empty() { ... }\n\n  \/** Creates a new, singleton integer set with the given member. *\/\n  public static singleton(int member) { ... }\n\n  ...\n}\nWhat if we want to use both of these libraries from the same program, and furthermore, we want to use some sets with both. Perhaps we want to use graph’s sets, which implement IntSet1, with code that works with prob’s sets, which implement IntSet2. Can we do it? Yes, with an adapter.\n\n2 The class adapter pattern\nTo make this abstract for a moment, sup\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n\/**\n * An implementation of the alternative {@link IntSet2} interface, using\n * the Collections Framework's {@link HashSet} as {@link IntSet1Impl}\n * does.\n *\/\npublic final class IntSet2Impl implements IntSet2 {\n  private final Set<Integer> set = new HashSet<>();\n\n  private IntSet2Impl() { }\n\n  \/**\n   * Constructs a new empty {@code IntSet2}.\n   *\/\n  public static IntSet2 empty() {\n    return new IntSet2Impl();\n  }\n\n  \/**\n   * Constructs a new single-element {@code IntSet2}.\n   *\/\n  public static IntSet2 singleton(int i) {\n    IntSet2Impl result = new IntSet2Impl();\n    result.set.add(i);\n    return result;\n  }\n\n  @Override\n  public void unionWith(IntSet2 other) {\n    set.addAll(other.asList());\n  }\n\n  @Override\n  public void differenceFrom(IntSet2 other) {\n    set.removeAll(other.asList());\n  }\n\n  @Override\n  public boolean isSupersetOf(IntSet2 other) {\n    for (int z : other.asList()) {\n      if (! set.contains(z)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic List<Integer> asList() {\n    return new ArrayList<>(set);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1335\\src\\cs3500\\lec09\\IntSet2Impl.java","mask_span":[1129,1197],"topics":["decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0010]  as an IntSet1 that we can pass to graph. But what if we’d like to use the resulting object with both libraries, with no further adaptation? A two-way adapter implements two interfaces, most often being a Target as well as an Adaptee, sending requests received via either interface to the underlying adaptee object. For example, we can declare our IntSet2ToIntSet1Adapter to implement both interfaces:\n\npublic final class IntSet2ToIntSet1Adapter implements IntSet1, IntSet2 { ... }\nthe implementation from the previous section remains, and to implement IntSet2 as well, we merely need to forward those requests to the IntSet2 adaptee:\n\n@Override\npublic void unionWith(IntSet2 other) {\n  adaptee.unionWith(other);\n}\n\n@Override\npublic void differenceFrom(IntSet2 other) {\n  adaptee.differenceFrom(other\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\n\n\/**\n * Adapts an {@link IntSet2} to the {@link IntSet1} interface. The is the\n * object adapter pattern.\n *\/\npublic final class IntSet2ToIntSet1Adapter implements IntSet1, IntSet2 {\n  private final IntSet2 adaptee;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic IntSet2ToIntSet1Adapter(IntSet2 adaptee) {\n    Objects.requireNonNull(adaptee);\n    this.adaptee = adaptee;\n  }\n\n  @Override\n  public void add(int value) {\n    unionWith(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public void remove(int value) {\n    differenceFrom(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public boolean member(int value) {\n    return isSupersetOf(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return asList().iterator();\n  }\n\n  @Override\n  public void unionWith(IntSet2 other) {\n    adaptee.unionWith(other);\n  }\n\n  @Override\n  public void differenceFrom(IntSet2 other) {\n    adaptee.differenceFrom(other);\n  }\n\n  @Override\n  public boolean isSupersetOf(IntSet2 other) {\n    return adaptee.isSupersetOf(other);\n  }\n\n  @Override\n  public List<Integer> asList() {\n    return adaptee.asList();\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic IntSet2ToIntSet1Adapter() {\n    this(IntSet2Impl.empty());\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1335\\src\\cs3500\\lec09\\IntSet2ToIntSet1Adapter.java","mask_span":[318,387],"topics":["decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0010]  as an IntSet1 that we can pass to graph. But what if we’d like to use the resulting object with both libraries, with no further adaptation? A two-way adapter implements two interfaces, most often being a Target as well as an Adaptee, sending requests received via either interface to the underlying adaptee object. For example, we can declare our IntSet2ToIntSet1Adapter to implement both interfaces:\n\npublic final class IntSet2ToIntSet1Adapter implements IntSet1, IntSet2 { ... }\nthe implementation from the previous section remains, and to implement IntSet2 as well, we merely need to forward those requests to the IntSet2 adaptee:\n\n@Override\npublic void unionWith(IntSet2 other) {\n  adaptee.unionWith(other);\n}\n\n@Override\npublic void differenceFrom(IntSet2 other) {\n  adaptee.differenceFrom(other\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\n\n\/**\n * Adapts an {@link IntSet2} to the {@link IntSet1} interface. The is the\n * object adapter pattern.\n *\/\npublic final class IntSet2ToIntSet1Adapter implements IntSet1, IntSet2 {\n  private final IntSet2 adaptee;\n\n  public IntSet2ToIntSet1Adapter() {\n    this(IntSet2Impl.empty());\n  }\n\n  public IntSet2ToIntSet1Adapter(IntSet2 adaptee) {\n    Objects.requireNonNull(adaptee);\n    this.adaptee = adaptee;\n  }\n\n  @Override\n  public void add(int value) {\n    unionWith(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public void remove(int value) {\n    differenceFrom(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public boolean member(int value) {\n    return isSupersetOf(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return asList().iterator();\n  }\n\n  @Override\n  public void unionWith(IntSet2 other) {\n    adaptee.unionWith(other);\n  }\n\n  @Override\n  public void differenceFrom(IntSet2 other) {\n    adaptee.differenceFrom(other);\n  }\n\n  @Override\n  public boolean isSupersetOf(IntSet2 other) {\n    return adaptee.isSupersetOf(other);\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic List<Integer> asList() {\n    return adaptee.asList();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1335\\src\\cs3500\\lec09\\IntSet2ToIntSet1Adapter.java","mask_span":[1207,1271],"topics":["decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0021]  details to clients, which makes code more flexible.\n\nWe then write two assertions about the behavior of our example Book object, each in its own method. The static method assertEquals is similar to check-expect, in that it takes two arguments, first the expected value and second the expression to evaluate and check; the test succeeds when the values are “equal”.2\n\n@Test\npublic void testCiteApa() {\n  assertEquals(\n    \"Salman Rushdie (1980). Midnight's Children. London: Jonathan Cape.\",\n    rushdie.citeApa());\n}\n\n@Test\npublic void testCiteMla() {\n  assertEquals(\n    \"Salman Rushdie. Midnight's Children. London: Jonathan Cape, 1980.\",\n    rushdie.citeMla());\n}\nEach test case method must be preceeded by the annotation @Test for JUnit to find and run it, must return void and must require no a\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\npublic class IntSet1ImplToIntSet2AdapterTest {\n  IntSet1ImplToIntSet2Adapter set1 = new IntSet1ImplToIntSet2Adapter();\n  IntSet1ImplToIntSet2Adapter set2 = IntSet1ImplToIntSet2Adapter.singleton(5);\n\n  @Before\n  public void setUp() throws Exception {\n    set1.add(2);\n    set1.unionWith(sing(3));\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void memberSeesUnionWith() {\n    assertTrue(set1.member(3));\n  }\n\n  @Test\n  public void memberSeesSingleton() {\n    assertTrue(set2.member(5));\n  }\n\n  @Test\n  public void memberCanReturnFalse() {\n    assertFalse(set2.member(2));\n    assertFalse(set2.member(3));\n    assertFalse(set2.member(4));\n    assertFalse(set1.member(5));\n  }\n\n  @Test\n  public void isSupersetOfSeesAdd() {\n    assertTrue(set1.isSupersetOf(sing(2)));\n  }\n\n  @Test\n  public void isSupersetOfSeesUnionWith() {\n    assertTrue(set1.isSupersetOf(sing(3)));\n  }\n\n  @Test\n  public void isSupersetOfSeesSingleton() {\n    assertTrue(set2.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void isSupersetOfCanReturnFalse() {\n    assertFalse(set2.isSupersetOf(sing(2)));\n    assertFalse(set2.isSupersetOf(sing(3)));\n    assertFalse(set2.isSupersetOf(sing(4)));\n    assertFalse(set1.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void removeRemoves() {\n    set2.remove(2);\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n\n  \/\/ No tests for iterator or asList yet.\n\n  public static IntSet2 sing(int value) {\n    return IntSet2Impl.singleton(value);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void memberSeesAdd() {\n    assertTrue(set1.member(2));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1335\\test\\cs3500\\lec09\\IntSet1ImplToIntSet2AdapterTest.java","mask_span":[471,536],"topics":["testing","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0021]  details to clients, which makes code more flexible.\n\nWe then write two assertions about the behavior of our example Book object, each in its own method. The static method assertEquals is similar to check-expect, in that it takes two arguments, first the expected value and second the expression to evaluate and check; the test succeeds when the values are “equal”.2\n\n@Test\npublic void testCiteApa() {\n  assertEquals(\n    \"Salman Rushdie (1980). Midnight's Children. London: Jonathan Cape.\",\n    rushdie.citeApa());\n}\n\n@Test\npublic void testCiteMla() {\n  assertEquals(\n    \"Salman Rushdie. Midnight's Children. London: Jonathan Cape, 1980.\",\n    rushdie.citeMla());\n}\nEach test case method must be preceeded by the annotation @Test for JUnit to find and run it, must return void and must require no a\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\npublic class IntSet1ImplToIntSet2AdapterTest {\n  IntSet1ImplToIntSet2Adapter set1 = new IntSet1ImplToIntSet2Adapter();\n  IntSet1ImplToIntSet2Adapter set2 = IntSet1ImplToIntSet2Adapter.singleton(5);\n\n  @Before\n  public void setUp() throws Exception {\n    set1.add(2);\n    set1.unionWith(sing(3));\n  }\n\n  @Test\n  public void memberSeesAdd() {\n    assertTrue(set1.member(2));\n  }\n\n  @Test\n  public void memberSeesUnionWith() {\n    assertTrue(set1.member(3));\n  }\n\n  @Test\n  public void memberSeesSingleton() {\n    assertTrue(set2.member(5));\n  }\n\n  @Test\n  public void memberCanReturnFalse() {\n    assertFalse(set2.member(2));\n    assertFalse(set2.member(3));\n    assertFalse(set2.member(4));\n    assertFalse(set1.member(5));\n  }\n\n  @Test\n  public void isSupersetOfSeesAdd() {\n    assertTrue(set1.isSupersetOf(sing(2)));\n  }\n\n  @Test\n  public void isSupersetOfSeesUnionWith() {\n    assertTrue(set1.isSupersetOf(sing(3)));\n  }\n\n  @Test\n  public void isSupersetOfSeesSingleton() {\n    assertTrue(set2.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void isSupersetOfCanReturnFalse() {\n    assertFalse(set2.isSupersetOf(sing(2)));\n    assertFalse(set2.isSupersetOf(sing(3)));\n    assertFalse(set2.isSupersetOf(sing(4)));\n    assertFalse(set1.isSupersetOf(sing(5)));\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/\/ No tests for iterator or asList yet.\n\n  public static IntSet2 sing(int value) {\n    return IntSet2Impl.singleton(value);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void removeRemoves() {\n    set2.remove(2);\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1335\\test\\cs3500\\lec09\\IntSet1ImplToIntSet2AdapterTest.java","mask_span":[1433,1551],"topics":["testing","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0021]  details to clients, which makes code more flexible.\n\nWe then write two assertions about the behavior of our example Book object, each in its own method. The static method assertEquals is similar to check-expect, in that it takes two arguments, first the expected value and second the expression to evaluate and check; the test succeeds when the values are “equal”.2\n\n@Test\npublic void testCiteApa() {\n  assertEquals(\n    \"Salman Rushdie (1980). Midnight's Children. London: Jonathan Cape.\",\n    rushdie.citeApa());\n}\n\n@Test\npublic void testCiteMla() {\n  assertEquals(\n    \"Salman Rushdie. Midnight's Children. London: Jonathan Cape, 1980.\",\n    rushdie.citeMla());\n}\nEach test case method must be preceeded by the annotation @Test for JUnit to find and run it, must return void and must require no a\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static cs3500.lec09.IntSet1ImplToIntSet2AdapterTest.sing;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\n\npublic class IntSet2ToIntSet1AdapterTest {\n  IntSet2ToIntSet1Adapter set1 = new IntSet2ToIntSet1Adapter();\n\n  IntSet2 set2Base = sing(5);\n  IntSet2ToIntSet1Adapter set2 = new IntSet2ToIntSet1Adapter(set2Base);\n\n  @Before\n  public void setUp() throws Exception {\n    set1.add(2);\n    set1.unionWith(sing(3));\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void memberSeesUnionWith() {\n    assertTrue(set1.member(3));\n  }\n\n  @Test\n  public void memberSeesSingleton() {\n    assertTrue(set2.member(5));\n  }\n\n  @Test\n  public void memberCanReturnFalse() {\n    assertFalse(set2.member(2));\n    assertFalse(set2.member(3));\n    assertFalse(set2.member(4));\n    assertFalse(set1.member(5));\n  }\n\n  @Test\n  public void isSupersetOfSeesAdd() {\n    assertTrue(set1.isSupersetOf(sing(2)));\n  }\n\n  @Test\n  public void isSupersetOfSeesUnionWith() {\n    assertTrue(set1.isSupersetOf(sing(3)));\n  }\n\n  @Test\n  public void isSupersetOfSeesSingleton() {\n    assertTrue(set2.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void isSupersetOfCanReturnFalse() {\n    assertFalse(set2.isSupersetOf(sing(2)));\n    assertFalse(set2.isSupersetOf(sing(3)));\n    assertFalse(set2.isSupersetOf(sing(4)));\n    assertFalse(set1.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void removeRemoves() {\n    set2.remove(2);\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n\n  @Test\n  public void removeInBaseVisibleInAdapter() {\n    set2Base.differenceFrom(sing(2));\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n\n  @Test\n  public void removeInAdapterVisibleInBase() {\n    set2.remove(2);\n    assertFalse(set2Base.isSupersetOf(sing(2)));\n    assertTrue(set2Base.isSupersetOf(sing(2)));\n  }\n\n  \/\/ No tests for iterator or asList yet.\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void memberSeesAdd() {\n    assertTrue(set1.member(2));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1335\\test\\cs3500\\lec09\\IntSet2ToIntSet1AdapterTest.java","mask_span":[548,613],"topics":["testing","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 2 The essence of objects.txt::chunk0021]  details to clients, which makes code more flexible.\n\nWe then write two assertions about the behavior of our example Book object, each in its own method. The static method assertEquals is similar to check-expect, in that it takes two arguments, first the expected value and second the expression to evaluate and check; the test succeeds when the values are “equal”.2\n\n@Test\npublic void testCiteApa() {\n  assertEquals(\n    \"Salman Rushdie (1980). Midnight's Children. London: Jonathan Cape.\",\n    rushdie.citeApa());\n}\n\n@Test\npublic void testCiteMla() {\n  assertEquals(\n    \"Salman Rushdie. Midnight's Children. London: Jonathan Cape, 1980.\",\n    rushdie.citeMla());\n}\nEach test case method must be preceeded by the annotation @Test for JUnit to find and run it, must return void and must require no a\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec09;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static cs3500.lec09.IntSet1ImplToIntSet2AdapterTest.sing;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\n\npublic class IntSet2ToIntSet1AdapterTest {\n  IntSet2ToIntSet1Adapter set1 = new IntSet2ToIntSet1Adapter();\n\n  IntSet2 set2Base = sing(5);\n  IntSet2ToIntSet1Adapter set2 = new IntSet2ToIntSet1Adapter(set2Base);\n\n  @Before\n  public void setUp() throws Exception {\n    set1.add(2);\n    set1.unionWith(sing(3));\n  }\n\n  @Test\n  public void memberSeesAdd() {\n    assertTrue(set1.member(2));\n  }\n\n  @Test\n  public void memberSeesUnionWith() {\n    assertTrue(set1.member(3));\n  }\n\n  @Test\n  public void memberSeesSingleton() {\n    assertTrue(set2.member(5));\n  }\n\n  @Test\n  public void memberCanReturnFalse() {\n    assertFalse(set2.member(2));\n    assertFalse(set2.member(3));\n    assertFalse(set2.member(4));\n    assertFalse(set1.member(5));\n  }\n\n  @Test\n  public void isSupersetOfSeesAdd() {\n    assertTrue(set1.isSupersetOf(sing(2)));\n  }\n\n  @Test\n  public void isSupersetOfSeesUnionWith() {\n    assertTrue(set1.isSupersetOf(sing(3)));\n  }\n\n  @Test\n  public void isSupersetOfSeesSingleton() {\n    assertTrue(set2.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void isSupersetOfCanReturnFalse() {\n    assertFalse(set2.isSupersetOf(sing(2)));\n    assertFalse(set2.isSupersetOf(sing(3)));\n    assertFalse(set2.isSupersetOf(sing(4)));\n    assertFalse(set1.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void removeRemoves() {\n    set2.remove(2);\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n\n  @Test\n  public void removeInBaseVisibleInAdapter() {\n    set2Base.differenceFrom(sing(2));\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/\/ No tests for iterator or asList yet.\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void removeInAdapterVisibleInBase() {\n    set2.remove(2);\n    assertFalse(set2Base.isSupersetOf(sing(2)));\n    assertTrue(set2Base.isSupersetOf(sing(2)));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1335\\test\\cs3500\\lec09\\IntSet2ToIntSet1AdapterTest.java","mask_span":[1803,1968],"topics":["testing","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec14;\n\nimport cs3500.lec09.IntSet1ImplToIntSet2Adapter;\nimport cs3500.lec09.IntSet2;\nimport cs3500.lec09.IntSet2Impl;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\npublic class IntSet1ImplToIntSet2AdapterTest {\n  IntSet1ImplToIntSet2Adapter set1 = new IntSet1ImplToIntSet2Adapter();\n  IntSet1ImplToIntSet2Adapter set2 = IntSet1ImplToIntSet2Adapter.singleton(5);\n\n  @Before\n  public void setUp() throws Exception {\n    set1.add(2);\n    set1.unionWith(sing(3));\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void memberSeesUnionWith() {\n    assertTrue(set1.member(3));\n  }\n\n  @Test\n  public void memberSeesSingleton() {\n    assertTrue(set2.member(5));\n  }\n\n  @Test\n  public void memberCanReturnFalse() {\n    assertFalse(set2.member(2));\n    assertFalse(set2.member(3));\n    assertFalse(set2.member(4));\n    assertFalse(set1.member(5));\n  }\n\n  @Test\n  public void isSupersetOfSeesAdd() {\n    assertTrue(set1.isSupersetOf(sing(2)));\n  }\n\n  @Test\n  public void isSupersetOfSeesUnionWith() {\n    assertTrue(set1.isSupersetOf(sing(3)));\n  }\n\n  @Test\n  public void isSupersetOfSeesSingleton() {\n    assertTrue(set2.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void isSupersetOfCanReturnFalse() {\n    assertFalse(set2.isSupersetOf(sing(2)));\n    assertFalse(set2.isSupersetOf(sing(3)));\n    assertFalse(set2.isSupersetOf(sing(4)));\n    assertFalse(set1.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void removeRemoves() {\n    set2.remove(2);\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n\n  \/\/ No tests for iterator or asList yet.\n\n  static IntSet2 sing(int value) {\n    return IntSet2Impl.singleton(value);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void memberSeesAdd() {\n    assertTrue(set1.member(2));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1335\\test\\cs3500\\lec14\\IntSet1ImplToIntSet2AdapterTest.java","mask_span":[582,647],"topics":["testing","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec14;\n\nimport cs3500.lec09.IntSet1ImplToIntSet2Adapter;\nimport cs3500.lec09.IntSet2;\nimport cs3500.lec09.IntSet2Impl;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\npublic class IntSet1ImplToIntSet2AdapterTest {\n  IntSet1ImplToIntSet2Adapter set1 = new IntSet1ImplToIntSet2Adapter();\n  IntSet1ImplToIntSet2Adapter set2 = IntSet1ImplToIntSet2Adapter.singleton(5);\n\n  @Before\n  public void setUp() throws Exception {\n    set1.add(2);\n    set1.unionWith(sing(3));\n  }\n\n  @Test\n  public void memberSeesAdd() {\n    assertTrue(set1.member(2));\n  }\n\n  @Test\n  public void memberSeesUnionWith() {\n    assertTrue(set1.member(3));\n  }\n\n  @Test\n  public void memberSeesSingleton() {\n    assertTrue(set2.member(5));\n  }\n\n  @Test\n  public void memberCanReturnFalse() {\n    assertFalse(set2.member(2));\n    assertFalse(set2.member(3));\n    assertFalse(set2.member(4));\n    assertFalse(set1.member(5));\n  }\n\n  @Test\n  public void isSupersetOfSeesAdd() {\n    assertTrue(set1.isSupersetOf(sing(2)));\n  }\n\n  @Test\n  public void isSupersetOfSeesUnionWith() {\n    assertTrue(set1.isSupersetOf(sing(3)));\n  }\n\n  @Test\n  public void isSupersetOfSeesSingleton() {\n    assertTrue(set2.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void isSupersetOfCanReturnFalse() {\n    assertFalse(set2.isSupersetOf(sing(2)));\n    assertFalse(set2.isSupersetOf(sing(3)));\n    assertFalse(set2.isSupersetOf(sing(4)));\n    assertFalse(set1.isSupersetOf(sing(5)));\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/\/ No tests for iterator or asList yet.\n\n  static IntSet2 sing(int value) {\n    return IntSet2Impl.singleton(value);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void removeRemoves() {\n    set2.remove(2);\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1335\\test\\cs3500\\lec14\\IntSet1ImplToIntSet2AdapterTest.java","mask_span":[1544,1662],"topics":["testing","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0019] sented as a reference to a chunk of memory, and the value of the array, so far as Java is concerned, is the reference itself, not the chunk of memory. This means that re-assigning or passing an array results in aliasing, having more than one name for the same thing:\n\nint[] anotherArray = intArray;\nanotherArray[0] = -9;\nassertEquals(-9, intArray[0]);\nNot only does == for arrays compare references rather than contents, but equals(Object) does as well. This means, for example, that this JUnit test will fail:\n\nassertEquals(new int[] {3, 6}, new int[] {3, 6}); \/\/ fails!\nYes, the arrays have the same contents, but not the same physical identity. To test for equality on the contents of two arrays, use assertArrayEquals:\n\nassertArrayEquals(new int[] {3, 6}, new int[] {3, 6});\nIn order to compare a\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec14;\n\nimport cs3500.lec09.IntSet2;\nimport cs3500.lec09.IntSet2ToIntSet1Adapter;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static cs3500.lec09.IntSet1ImplToIntSet2AdapterTest.sing;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\n\npublic class IntSet2ToIntSet1AdapterTest {\n  IntSet2ToIntSet1Adapter set1 = new IntSet2ToIntSet1Adapter();\n\n  IntSet2 set2Base = sing(5);\n  IntSet2ToIntSet1Adapter set2 = new IntSet2ToIntSet1Adapter(set2Base);\n\n  @Before\n  public void setUp() throws Exception {\n    set1.add(2);\n    set1.unionWith(sing(3));\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void memberSeesUnionWith() {\n    assertTrue(set1.member(3));\n  }\n\n  @Test\n  public void memberSeesSingleton() {\n    assertTrue(set2.member(5));\n  }\n\n  @Test\n  public void memberCanReturnFalse() {\n    assertFalse(set2.member(2));\n    assertFalse(set2.member(3));\n    assertFalse(set2.member(4));\n    assertFalse(set1.member(5));\n  }\n\n  @Test\n  public void isSupersetOfSeesAdd() {\n    assertTrue(set1.isSupersetOf(sing(2)));\n  }\n\n  @Test\n  public void isSupersetOfSeesUnionWith() {\n    assertTrue(set1.isSupersetOf(sing(3)));\n  }\n\n  @Test\n  public void isSupersetOfSeesSingleton() {\n    assertTrue(set2.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void isSupersetOfCanReturnFalse() {\n    assertFalse(set2.isSupersetOf(sing(2)));\n    assertFalse(set2.isSupersetOf(sing(3)));\n    assertFalse(set2.isSupersetOf(sing(4)));\n    assertFalse(set1.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void removeRemoves() {\n    set2.remove(2);\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n\n  @Test\n  public void removeInBaseVisibleInAdapter() {\n    set2Base.differenceFrom(sing(2));\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n\n  @Test\n  public void removeInAdapterVisibleInBase() {\n    set2.remove(2);\n    assertFalse(set2Base.isSupersetOf(sing(2)));\n    assertTrue(set2Base.isSupersetOf(sing(2)));\n  }\n\n  \/\/ No tests for iterator or asList yet.\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void memberSeesAdd() {\n    assertTrue(set1.member(2));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1335\\test\\cs3500\\lec14\\IntSet2ToIntSet1AdapterTest.java","mask_span":[622,687],"topics":["testing","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0019] sented as a reference to a chunk of memory, and the value of the array, so far as Java is concerned, is the reference itself, not the chunk of memory. This means that re-assigning or passing an array results in aliasing, having more than one name for the same thing:\n\nint[] anotherArray = intArray;\nanotherArray[0] = -9;\nassertEquals(-9, intArray[0]);\nNot only does == for arrays compare references rather than contents, but equals(Object) does as well. This means, for example, that this JUnit test will fail:\n\nassertEquals(new int[] {3, 6}, new int[] {3, 6}); \/\/ fails!\nYes, the arrays have the same contents, but not the same physical identity. To test for equality on the contents of two arrays, use assertArrayEquals:\n\nassertArrayEquals(new int[] {3, 6}, new int[] {3, 6});\nIn order to compare a\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec14;\n\nimport cs3500.lec09.IntSet2;\nimport cs3500.lec09.IntSet2ToIntSet1Adapter;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static cs3500.lec09.IntSet1ImplToIntSet2AdapterTest.sing;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\n\npublic class IntSet2ToIntSet1AdapterTest {\n  IntSet2ToIntSet1Adapter set1 = new IntSet2ToIntSet1Adapter();\n\n  IntSet2 set2Base = sing(5);\n  IntSet2ToIntSet1Adapter set2 = new IntSet2ToIntSet1Adapter(set2Base);\n\n  @Before\n  public void setUp() throws Exception {\n    set1.add(2);\n    set1.unionWith(sing(3));\n  }\n\n  @Test\n  public void memberSeesAdd() {\n    assertTrue(set1.member(2));\n  }\n\n  @Test\n  public void memberSeesUnionWith() {\n    assertTrue(set1.member(3));\n  }\n\n  @Test\n  public void memberSeesSingleton() {\n    assertTrue(set2.member(5));\n  }\n\n  @Test\n  public void memberCanReturnFalse() {\n    assertFalse(set2.member(2));\n    assertFalse(set2.member(3));\n    assertFalse(set2.member(4));\n    assertFalse(set1.member(5));\n  }\n\n  @Test\n  public void isSupersetOfSeesAdd() {\n    assertTrue(set1.isSupersetOf(sing(2)));\n  }\n\n  @Test\n  public void isSupersetOfSeesUnionWith() {\n    assertTrue(set1.isSupersetOf(sing(3)));\n  }\n\n  @Test\n  public void isSupersetOfSeesSingleton() {\n    assertTrue(set2.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void isSupersetOfCanReturnFalse() {\n    assertFalse(set2.isSupersetOf(sing(2)));\n    assertFalse(set2.isSupersetOf(sing(3)));\n    assertFalse(set2.isSupersetOf(sing(4)));\n    assertFalse(set1.isSupersetOf(sing(5)));\n  }\n\n  @Test\n  public void removeRemoves() {\n    set2.remove(2);\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n\n  @Test\n  public void removeInBaseVisibleInAdapter() {\n    set2Base.differenceFrom(sing(2));\n    assertFalse(set2.member(2));\n    assertTrue(set2.member(2));\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/\/ No tests for iterator or asList yet.\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void removeInAdapterVisibleInBase() {\n    set2.remove(2);\n    assertFalse(set2Base.isSupersetOf(sing(2)));\n    assertTrue(set2Base.isSupersetOf(sing(2)));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-1335\\test\\cs3500\\lec14\\IntSet2ToIntSet1AdapterTest.java","mask_span":[1877,2042],"topics":["testing","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.io.InputStreamReader;\n\n\/**\n * Run a Tic Tac Toe game interactively on the console.\n *\/\npublic class Main {\n  \/**\n   * Run a Tic Tac Toe game interactively on the console.\n   *\/\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    new TicTacToeConsoleController(new InputStreamReader(System.in),\n        System.out).playGame(new MovableTicTacToeModel());\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\code-reuse-1030\\src\\cs3500\\tictactoe\\Main.java","mask_span":[218,390],"topics":["gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0003] ing a move for; it just seeks out the first open square:\n\nclass AnyOpenSquare implements TicTacToeStrategy {\n  public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n    for (int r = 0; r < 3; r++)\n      for (int c = 0; c < 3; c++)\n        if (model.getPieceAt(r, c) == null)\n          return new Coord(r, c);\n    return null;\n  }\n}\n(Note: we are returning null at the moment to indicate the lack of an available move. This not a great idea – might consider throwing an exception instead, to indicate that our strategy could not succeed. But see Avoiding null: Multiple strategy signatures below for a better approach still.)\n\nHow might we implement the second strategy? We could implement the entirety of the logic (choose corners or else choose random), but part of that logic has been impl\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0007] provide separate methods for playing as X and playing as O:\n\n\/**\n * Places an X mark in the specified cell.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if it's O's turn, if the game is\n * over, or if there is already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid moveAsX(int column, int row);\n\n\/** ...same as above, but for O... *\/\nvoid moveAsO(int column, int row);\n(Note: is the Javadoc above any good? What is left unclear, that ought to be specified more carefully?)\n\nWith the above design, the model must throw an exception if its client calls moveAsX when it is O’s turn or moveAsO when it is X’s turn.\n\nAlternatively, because the model must track whose turn it is, we could \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\n\nimport java.util.ArrayDeque;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class MovableTicTacToeModel extends TicTacToeModel {\n\n  \/\/counter: number of plays that have taken place\n  \/\/List<Integer>: every 2 integers is a location\n  \/\/int[][]: each row is a coordinate\n  \/\/Queue<Point>\n\n  class Posn {\n    int x;\n    int y;\n\n    Posn(int x, int y) {\n      this.x = x;\n      this.y = y;\n    }\n  }\n\n  private int counter;\n  private Queue<Posn> positions;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void move(int row, int col) {\n    super.move(row, col);\n    \/\/if there are six pieces already on the board\n    if(positions.size() == 6) { \/\/or check counter == 6\n      \/\/remove the oldest one\n      Posn oldest = positions.remove();\n      board[oldest.x][oldest.y] = null;\n      \/\/counter--\n    }\n    positions.add(new Posn(row, col));\n    \/\/counter++;\n  }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic MovableTicTacToeModel() {\n    super();\n    counter = 0;\n    positions = new ArrayDeque<>();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\code-reuse-1030\\src\\cs3500\\tictactoe\\MovableTicTacToeModel.java","mask_span":[492,594],"topics":["strategy"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class TicTacToeConsoleController implements TicTacToeController {\n\n  private final Appendable out;\n  private final Scanner scan;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void playGame(TicTacToe model) {\n    try {\n      while(!model.isGameOver()) {\n        printGameState(model);\n        printPrompt(model);\n        readInputs(model);\n\n        if(model.isGameOver()) {\n          printGameState(model);\n        }\n      }\n    } catch (IOException ex) {\n      throw new IllegalStateException(\"Bad IO\");\n    }\n  }\n\n  private void transmit(String message) throws IOException {\n    out.append(message + \"\\n\");\n  }\n\n  private void printGameState(TicTacToe model) throws IOException {\n    transmit(model.toString());\n  }\n\n  private void printPrompt(TicTacToe model) throws IOException {\n    transmit(\"Enter a move for \" + model.getTurn() + \":\");\n  }\n\n  private void readInputs(TicTacToe model) {\n    int row;\n    row = readInt();\n    int col = readInt();\n    model.move(row, col);\n  }\n\n  private int readInt() {\n    int ans;\n    try {\n      ans = scan.nextInt() - 1;\n    } catch (InputMismatchException ex) {\n      String token = scan.next();\n      if(token.equals(\"q\") || token.equals(\"Q\")) {\n        \/\/How should I signal to playGame to quit the method?\n        \/\/1. Change some field to true and have every method react to that\n        \/\/2. Return -1 to indicate the game is over (and propagate that message)\n        \/\/3. Throw an exception and handle it when ready\n      }\n      ans = readInt();\n    }\n    return ans;\n  }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeConsoleController(Readable in, Appendable out) {\n    if (in == null || out == null) {\n      throw new IllegalArgumentException(\"Readable and Appendable can't be null\");\n    }\n    this.out = out;\n    scan = new Scanner(in);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\code-reuse-1030\\src\\cs3500\\tictactoe\\TicTacToeConsoleController.java","mask_span":[262,504],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class TicTacToeConsoleController implements TicTacToeController {\n\n  private final Appendable out;\n  private final Scanner scan;\n\n  public TicTacToeConsoleController(Readable in, Appendable out) {\n    if (in == null || out == null) {\n      throw new IllegalArgumentException(\"Readable and Appendable can't be null\");\n    }\n    this.out = out;\n    scan = new Scanner(in);\n  }\n\n  @Override\n  public void playGame(TicTacToe model) {\n    try {\n      while(!model.isGameOver()) {\n        printGameState(model);\n        printPrompt(model);\n        readInputs(model);\n\n        if(model.isGameOver()) {\n          printGameState(model);\n        }\n      }\n    } catch (IOException ex) {\n      throw new IllegalStateException(\"Bad IO\");\n    }\n  }\n\n  private void transmit(String message) throws IOException {\n    out.append(message + \"\\n\");\n  }\n\n  private void printGameState(TicTacToe model) throws IOException {\n    transmit(model.toString());\n  }\n\n  private void printPrompt(TicTacToe model) throws IOException {\n    transmit(\"Enter a move for \" + model.getTurn() + \":\");\n  }\n\n  private void readInputs(TicTacToe model) {\n    int row;\n    row = readInt();\n    int col = readInt();\n    model.move(row, col);\n  }\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\nprivate int readInt() {\n    int ans;\n    try {\n      ans = scan.nextInt() - 1;\n    } catch (InputMismatchException ex) {\n      String token = scan.next();\n      if(token.equals(\"q\") || token.equals(\"Q\")) {\n        \/\/How should I signal to playGame to quit the method?\n        \/\/1. Change some field to true and have every method react to that\n        \/\/2. Return -1 to indicate the game is over (and propagate that message)\n        \/\/3. Throw an exception and handle it when ready\n      }\n      ans = readInt();\n    }\n    return ans;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\code-reuse-1030\\src\\cs3500\\tictactoe\\TicTacToeConsoleController.java","mask_span":[1336,1873],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0023] given cell position. Because some cells may be empty of tokens, we need some way to distinguish empty cells from player numbers. The wrapped integer type Integer includes null, so we use Integer instead of int for the result with null representing empty cells.\n\nAdditionally, we will include a convenience method3 for asking whether a particular column is full.\n\n\/**\n * Gets the player whose token is at the given column and row. The\n * coordinates are zero-based and start in the lower left. Returns\n * {@code null} if there is no token in the given position.\n *\n * @param x the column coordinate ({@code 0 <= x < width})\n * @param y the row coordinate ({@code 0 <= y < height})\n * @return the player in the given position, or {@code null}\n * @throws IndexOutOfBoundsException if (x, y) is out of bo\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n\/**\n * Represents a single game of Tic Tac Toe. Three in a row down\/across\/diagonally to win; X goes\n * first.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n  protected final Player[][] board;\n  private Player turn;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void move(int row, int col) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(row, col);\n    if (board[row][col] != null) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[row][col] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (Player[] row : board) {\n      if (Arrays.stream(row).anyMatch(Objects::isNull)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (Player player : Player.values()) {\n      \/\/ check horizontals\n      for (Player[] row : board) {\n        if(Arrays.stream(row).allMatch(mark -> mark == player)) {\n          return player;\n        }\n      }\n      \/\/ check verticals\n      for (int col = 0; col < board[0].length; col++) {\n        if (board[0][col] == player && board[1][col] == player && board[2][col] == player) {\n          return player;\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n        return player;\n      }\n      if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n        return player;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int row = 0; row < board.length; row++) {\n      ret[row] = Arrays.copyOf(board[row], board[row].length);\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int row, int col) {\n    validateRowCol(row, col);\n    return board[row][col];\n  }\n\n  \/\/NOTE: Could be made non-static as well.\n  \/\/Made static here to show that there is no dynamic information needed. However, it can't be used\n  \/\/outside of this class due to it being private.\n  private static void validateRowCol(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + row + \",\" + col);\n    }\n  }\n\n  @Override\n  public String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard())\n        .map(row -> \" \" + Arrays.stream(row)\n            .map(player -> player == null ? \" \" : player.toString())\n            .collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\code-reuse-1030\\src\\cs3500\\tictactoe\\TicTacToeModel.java","mask_span":[343,423],"topics":["strategy","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0023] given cell position. Because some cells may be empty of tokens, we need some way to distinguish empty cells from player numbers. The wrapped integer type Integer includes null, so we use Integer instead of int for the result with null representing empty cells.\n\nAdditionally, we will include a convenience method3 for asking whether a particular column is full.\n\n\/**\n * Gets the player whose token is at the given column and row. The\n * coordinates are zero-based and start in the lower left. Returns\n * {@code null} if there is no token in the given position.\n *\n * @param x the column coordinate ({@code 0 <= x < width})\n * @param y the row coordinate ({@code 0 <= y < height})\n * @return the player in the given position, or {@code null}\n * @throws IndexOutOfBoundsException if (x, y) is out of bo\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n\/**\n * Represents a single game of Tic Tac Toe. Three in a row down\/across\/diagonally to win; X goes\n * first.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n  protected final Player[][] board;\n  private Player turn;\n\n  public TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n\n  @Override\n  public void move(int row, int col) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(row, col);\n    if (board[row][col] != null) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[row][col] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (Player[] row : board) {\n      if (Arrays.stream(row).anyMatch(Objects::isNull)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (Player player : Player.values()) {\n      \/\/ check horizontals\n      for (Player[] row : board) {\n        if(Arrays.stream(row).allMatch(mark -> mark == player)) {\n          return player;\n        }\n      }\n      \/\/ check verticals\n      for (int col = 0; col < board[0].length; col++) {\n        if (board[0][col] == player && board[1][col] == player && board[2][col] == player) {\n          return player;\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n        return player;\n      }\n      if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n        return player;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int row = 0; row < board.length; row++) {\n      ret[row] = Arrays.copyOf(board[row], board[row].length);\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int row, int col) {\n    validateRowCol(row, col);\n    return board[row][col];\n  }\n\n  \/\/NOTE: Could be made non-static as well.\n  \/\/Made static here to show that there is no dynamic information needed. However, it can't be used\n  \/\/outside of this class due to it being private.\n  private static void validateRowCol(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + row + \",\" + col);\n    }\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard())\n        .map(row -> \" \" + Arrays.stream(row)\n            .map(player -> player == null ? \" \" : player.toString())\n            .collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\code-reuse-1030\\src\\cs3500\\tictactoe\\TicTacToeModel.java","mask_span":[2634,3533],"topics":["strategy","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.io.InputStreamReader;\n\n\/**\n * Run a Tic Tac Toe game interactively on the console.\n *\/\npublic class Main {\n  \/**\n   * Run a Tic Tac Toe game interactively on the console.\n   *\/\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    new TicTacToeConsoleController(new InputStreamReader(System.in),\n        System.out).playGame(new MovableTicTacToeModel());\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\code-reuse-1335\\src\\cs3500\\tictactoe\\Main.java","mask_span":[218,390],"topics":["gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0007] provide separate methods for playing as X and playing as O:\n\n\/**\n * Places an X mark in the specified cell.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if it's O's turn, if the game is\n * over, or if there is already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid moveAsX(int column, int row);\n\n\/** ...same as above, but for O... *\/\nvoid moveAsO(int column, int row);\n(Note: is the Javadoc above any good? What is left unclear, that ought to be specified more carefully?)\n\nWith the above design, the model must throw an exception if its client calls moveAsX when it is O’s turn or moveAsO when it is X’s turn.\n\nAlternatively, because the model must track whose turn it is, we could \n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0003] ing a move for; it just seeks out the first open square:\n\nclass AnyOpenSquare implements TicTacToeStrategy {\n  public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n    for (int r = 0; r < 3; r++)\n      for (int c = 0; c < 3; c++)\n        if (model.getPieceAt(r, c) == null)\n          return new Coord(r, c);\n    return null;\n  }\n}\n(Note: we are returning null at the moment to indicate the lack of an available move. This not a great idea – might consider throwing an exception instead, to indicate that our strategy could not succeed. But see Avoiding null: Multiple strategy signatures below for a better approach still.)\n\nHow might we implement the second strategy? We could implement the entirety of the logic (choose corners or else choose random), but part of that logic has been impl\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class MovableTicTacToeModel extends TicTacToeModel {\n\n  \/\/Any new state?\n\n  \/\/Queue<Integer> \/\/ each pair is one coordinate\n\n  \/\/int[][] board \/\/ for each coordinate, how long has a piece been there\n\n  \/\/int numTurns \/\/ how many turns have passed so we don't remove too early\n\n  class Posn {\n    int row;\n    int col;\n\n    Posn(int row, int col) {\n      this.row = row;\n      this.col = col;\n    }\n  }\n\n  private Queue<Posn> moves;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void move(int row, int col) {\n    super.move(row, col);\n\n    if(moves.size() == 6) {\n      Posn oldest = moves.remove();\n      board[oldest.row][oldest.col] = null;\n    }\n\n    moves.add(new Posn(row, col));\n  }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic MovableTicTacToeModel() {\n    super();\n    this.moves = new ArrayDeque<>();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\code-reuse-1335\\src\\cs3500\\tictactoe\\MovableTicTacToeModel.java","mask_span":[523,609],"topics":["strategy"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class TicTacToeConsoleController implements TicTacToeController {\n\n  private final Appendable out;\n  private final Scanner scan;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void playGame(TicTacToe model) {\n    try {\n      while(!model.isGameOver()) {\n        printGameState(model);\n        printPrompt(model);\n        readInputs(model);\n\n        if(model.isGameOver()) {\n          printGameState(model);\n        }\n      }\n    } catch (IOException ex) {\n      throw new IllegalStateException(\"Bad IO\");\n    }\n  }\n\n  private void transmit(String message) throws IOException {\n    out.append(message + \"\\n\");\n  }\n\n  private void printGameState(TicTacToe model) throws IOException {\n    transmit(model.toString());\n  }\n\n  private void printPrompt(TicTacToe model) throws IOException {\n    transmit(\"Enter a move for \" + model.getTurn() + \":\");\n  }\n\n  private void readInputs(TicTacToe model) {\n    int row;\n    row = readInt();\n    int col = readInt();\n    model.move(row, col);\n  }\n\n  private int readInt() {\n    int ans;\n    try {\n      ans = scan.nextInt() - 1;\n    } catch (InputMismatchException ex) {\n      String token = scan.next();\n      if(token.equals(\"q\") || token.equals(\"Q\")) {\n        \/\/How should I signal to playGame to quit the method?\n        \/\/1. Change some field to true and have every method react to that\n        \/\/2. Return -1 to indicate the game is over (and propagate that message)\n        \/\/3. Throw an exception and handle it when ready\n      }\n      ans = readInt();\n    }\n    return ans;\n  }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeConsoleController(Readable in, Appendable out) {\n    if (in == null || out == null) {\n      throw new IllegalArgumentException(\"Readable and Appendable can't be null\");\n    }\n    this.out = out;\n    scan = new Scanner(in);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\code-reuse-1335\\src\\cs3500\\tictactoe\\TicTacToeConsoleController.java","mask_span":[262,504],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class TicTacToeConsoleController implements TicTacToeController {\n\n  private final Appendable out;\n  private final Scanner scan;\n\n  public TicTacToeConsoleController(Readable in, Appendable out) {\n    if (in == null || out == null) {\n      throw new IllegalArgumentException(\"Readable and Appendable can't be null\");\n    }\n    this.out = out;\n    scan = new Scanner(in);\n  }\n\n  @Override\n  public void playGame(TicTacToe model) {\n    try {\n      while(!model.isGameOver()) {\n        printGameState(model);\n        printPrompt(model);\n        readInputs(model);\n\n        if(model.isGameOver()) {\n          printGameState(model);\n        }\n      }\n    } catch (IOException ex) {\n      throw new IllegalStateException(\"Bad IO\");\n    }\n  }\n\n  private void transmit(String message) throws IOException {\n    out.append(message + \"\\n\");\n  }\n\n  private void printGameState(TicTacToe model) throws IOException {\n    transmit(model.toString());\n  }\n\n  private void printPrompt(TicTacToe model) throws IOException {\n    transmit(\"Enter a move for \" + model.getTurn() + \":\");\n  }\n\n  private void readInputs(TicTacToe model) {\n    int row;\n    row = readInt();\n    int col = readInt();\n    model.move(row, col);\n  }\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\nprivate int readInt() {\n    int ans;\n    try {\n      ans = scan.nextInt() - 1;\n    } catch (InputMismatchException ex) {\n      String token = scan.next();\n      if(token.equals(\"q\") || token.equals(\"Q\")) {\n        \/\/How should I signal to playGame to quit the method?\n        \/\/1. Change some field to true and have every method react to that\n        \/\/2. Return -1 to indicate the game is over (and propagate that message)\n        \/\/3. Throw an exception and handle it when ready\n      }\n      ans = readInt();\n    }\n    return ans;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\code-reuse-1335\\src\\cs3500\\tictactoe\\TicTacToeConsoleController.java","mask_span":[1336,1873],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0023] given cell position. Because some cells may be empty of tokens, we need some way to distinguish empty cells from player numbers. The wrapped integer type Integer includes null, so we use Integer instead of int for the result with null representing empty cells.\n\nAdditionally, we will include a convenience method3 for asking whether a particular column is full.\n\n\/**\n * Gets the player whose token is at the given column and row. The\n * coordinates are zero-based and start in the lower left. Returns\n * {@code null} if there is no token in the given position.\n *\n * @param x the column coordinate ({@code 0 <= x < width})\n * @param y the row coordinate ({@code 0 <= y < height})\n * @return the player in the given position, or {@code null}\n * @throws IndexOutOfBoundsException if (x, y) is out of bo\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n\/**\n * Represents a single game of Tic Tac Toe. Three in a row down\/across\/diagonally to win; X goes\n * first.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n  protected final Player[][] board;\n  private Player turn;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void move(int row, int col) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(row, col);\n    if (board[row][col] != null) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[row][col] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (Player[] row : board) {\n      if (Arrays.stream(row).anyMatch(Objects::isNull)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (Player player : Player.values()) {\n      \/\/ check horizontals\n      for (Player[] row : board) {\n        if(Arrays.stream(row).allMatch(mark -> mark == player)) {\n          return player;\n        }\n      }\n      \/\/ check verticals\n      for (int col = 0; col < board[0].length; col++) {\n        if (board[0][col] == player && board[1][col] == player && board[2][col] == player) {\n          return player;\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n        return player;\n      }\n      if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n        return player;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int row = 0; row < board.length; row++) {\n      ret[row] = Arrays.copyOf(board[row], board[row].length);\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int row, int col) {\n    validateRowCol(row, col);\n    return board[row][col];\n  }\n\n  \/\/NOTE: Could be made non-static as well.\n  \/\/Made static here to show that there is no dynamic information needed. However, it can't be used\n  \/\/outside of this class due to it being private.\n  private static void validateRowCol(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + row + \",\" + col);\n    }\n  }\n\n  @Override\n  public String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard())\n        .map(row -> \" \" + Arrays.stream(row)\n            .map(player -> player == null ? \" \" : player.toString())\n            .collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\code-reuse-1335\\src\\cs3500\\tictactoe\\TicTacToeModel.java","mask_span":[343,423],"topics":["strategy","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0023] given cell position. Because some cells may be empty of tokens, we need some way to distinguish empty cells from player numbers. The wrapped integer type Integer includes null, so we use Integer instead of int for the result with null representing empty cells.\n\nAdditionally, we will include a convenience method3 for asking whether a particular column is full.\n\n\/**\n * Gets the player whose token is at the given column and row. The\n * coordinates are zero-based and start in the lower left. Returns\n * {@code null} if there is no token in the given position.\n *\n * @param x the column coordinate ({@code 0 <= x < width})\n * @param y the row coordinate ({@code 0 <= y < height})\n * @return the player in the given position, or {@code null}\n * @throws IndexOutOfBoundsException if (x, y) is out of bo\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n\/**\n * Represents a single game of Tic Tac Toe. Three in a row down\/across\/diagonally to win; X goes\n * first.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n  protected final Player[][] board;\n  private Player turn;\n\n  public TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n\n  @Override\n  public void move(int row, int col) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(row, col);\n    if (board[row][col] != null) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[row][col] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (Player[] row : board) {\n      if (Arrays.stream(row).anyMatch(Objects::isNull)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (Player player : Player.values()) {\n      \/\/ check horizontals\n      for (Player[] row : board) {\n        if(Arrays.stream(row).allMatch(mark -> mark == player)) {\n          return player;\n        }\n      }\n      \/\/ check verticals\n      for (int col = 0; col < board[0].length; col++) {\n        if (board[0][col] == player && board[1][col] == player && board[2][col] == player) {\n          return player;\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n        return player;\n      }\n      if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n        return player;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int row = 0; row < board.length; row++) {\n      ret[row] = Arrays.copyOf(board[row], board[row].length);\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int row, int col) {\n    validateRowCol(row, col);\n    return board[row][col];\n  }\n\n  \/\/NOTE: Could be made non-static as well.\n  \/\/Made static here to show that there is no dynamic information needed. However, it can't be used\n  \/\/outside of this class due to it being private.\n  private static void validateRowCol(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + row + \",\" + col);\n    }\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard())\n        .map(row -> \" \" + Arrays.stream(row)\n            .map(player -> player == null ? \" \" : player.toString())\n            .collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\code-reuse-1335\\src\\cs3500\\tictactoe\\TicTacToeModel.java","mask_span":[2634,3533],"topics":["strategy","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0029] meters. Here’s the interface:\n\npublic static final class Builder {\n  \/**\n   * Sets the width of the game grid.\n   *\n   * @param width the width (positive)\n   * @return {@code this}, for method chaining\n   *\/\n  public Builder width(int width) { ... }\n\n  \/**\n   * Sets the height of the game grid.\n   *\n   * @param height the height (positive)\n   * @return {@code this}, for method chaining\n   *\/\n  public Builder height(int height) { ... }\n\n  \/**\n   * Sets the goal line length for the game.\n   *\n   * @param goal the goal (positive)\n   * @return {@code this}, for method chaining\n   *\/\n  public Builder goal(int goal) { ... }\n\n  \/**\n   * Sets the players for the game. Makes a defensive copy of the\n   * player array, so the client cannot change it from under us.\n   *\n   * @param players the array o\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0030] f player names (non-null, non-empty,\n   *                and every element non-null)\n   * @return {@code this}, for method chaining\n   *\/\n  public Builder players(String... players) { ... }\n\n  \/**\n   * Builds and returns the specified {@link ConnectNModel}.\n   *\n   * @return a new {@code ConnectNModel}\n   *\/\n  public ConnectNModel build() { ... }\n}\nThen to create our wide Connect Four instance, we can use the builder object to specify only the parameters we want:\n\nConnectNGame.builder().width(15).build()\n4.1 How to obtain a Builder?\nIn the code above, we include a public static method on the ConnectNModel class that provides a means of obtaining a Builder object. We could just expose the constructor of the Builder class directly:\n\n(new ConnectNGame.Builder())...\nbut this is less flexible a\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0028] the builder. Instead, the client first creates some kind of builder object, which encapsulates the configuration parameters for the game:\n\n\/**\n * Constructs a builder for configuring and then creating a game model\n * instance. Defaults to a standard game of Connect Four with players\n * named \"White\" and \"Red\".\n *\n * @return the new builder\n *\/\npublic static Builder builder();\nThe builder starts out with the default parameter values, and then provides several methods for changing whichever parameters we choose without saying anything about the others. In this case, that means we need a method for each of the parameters: the width, the height, the goal, and the array of players. Then, the builder provides a method build() that instantiates a game model object using the builder’s current para\n---\n[data\\raw\\notes\\notes-1335.txt::chunk0001] \n\n    public Decorator(Base base) {\n        ...\n    }\n} \/\/ might be necessary, but dependent on the implementation\n\n\n\n\n\n\n\n\n\n\n\n\ninterface Beverage {\n    Size size();\n    double price();\n}\n\nenum Size { SMALL, MED, LARGE };\n\nclass Coffee implements Beverage { ... }\nclass Tea implements Beverage { ... }\n\nAdd-ons:\n- Milk\n- Cream\n- Sugar\n- Fruit\n- Syrups\n- Whipped Cream\n- Charcoal\n\nclass MilkAdded implements Beverage {\n\n    private Beverage base;\n\n    public MilkAdded(Beverage base) {\n        this.base = base;\n    }\n\n    public Size size() {\n        return this.base.size():\n    }\n\n    public double price() {\n        return 1.00 + this.base.price();\n    }\n}\n\nclass CharcoalAdded implements Beverage {\n\n    private Beverage base;\n\n    public CharcoalAdded(Beverage base) {\n        this.base = base;\n \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.connectn;\n\npublic class ConnectN {\n\n  private int width, height;\n  private int goal;\n  private int numPlayers;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic static ConnectNBuilder builder() {\n    return new ConnectNBuilder();\n  }\n\n  public static class ConnectNBuilder {\n    private int width, height, goal, numPlayers;\n\n    public ConnectNBuilder() {\n      this.width = 7;\n      this.height = 8;\n      this.goal = 4;\n      this.numPlayers = 2;\n    }\n\n    public ConnectN build() {\n      return new ConnectN(width, height, goal, numPlayers);\n    }\n\n    public ConnectNBuilder setWidth(int width) {\n      this.width = width;\n      return this;\n    }\n\n    public ConnectNBuilder setHeight(int height) {\n      this.height = height;\n      return this;\n    }\n\n    public ConnectNBuilder setGoal(int goal) {\n      this.goal = goal;\n      return this;\n    }\n\n    public ConnectNBuilder setNumPlayers(int numPlayers) {\n      this.numPlayers = numPlayers;\n      return this;\n    }\n  }\n}\n\n\n\/\/ConnectNBuilder usage\n\n\/\/ConnectNBuilder builder = new ConnectNBuilder();\n\/\/ConnectN model = builder.build(); \/\/full default\n\n\/\/game with goal length of  3\n\/\/builder.setGoal(3);\n\/\/builder.build();\n\n\/\/ new ConnectNBuilder().setGoal(3).setNumPlayer(5).build();\n\n\n\n<\/CodeSuffix>","target":"<Target>\npublic ConnectN(int width, int height, int goal, int numPlayers) {\n    this.width = width;\n    this.height = height;\n    this.goal = goal;\n    this.numPlayers = numPlayers;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\src\\cs3500\\connectn\\ConnectN.java","mask_span":[129,305],"topics":["decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0029] meters. Here’s the interface:\n\npublic static final class Builder {\n  \/**\n   * Sets the width of the game grid.\n   *\n   * @param width the width (positive)\n   * @return {@code this}, for method chaining\n   *\/\n  public Builder width(int width) { ... }\n\n  \/**\n   * Sets the height of the game grid.\n   *\n   * @param height the height (positive)\n   * @return {@code this}, for method chaining\n   *\/\n  public Builder height(int height) { ... }\n\n  \/**\n   * Sets the goal line length for the game.\n   *\n   * @param goal the goal (positive)\n   * @return {@code this}, for method chaining\n   *\/\n  public Builder goal(int goal) { ... }\n\n  \/**\n   * Sets the players for the game. Makes a defensive copy of the\n   * player array, so the client cannot change it from under us.\n   *\n   * @param players the array o\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0030] f player names (non-null, non-empty,\n   *                and every element non-null)\n   * @return {@code this}, for method chaining\n   *\/\n  public Builder players(String... players) { ... }\n\n  \/**\n   * Builds and returns the specified {@link ConnectNModel}.\n   *\n   * @return a new {@code ConnectNModel}\n   *\/\n  public ConnectNModel build() { ... }\n}\nThen to create our wide Connect Four instance, we can use the builder object to specify only the parameters we want:\n\nConnectNGame.builder().width(15).build()\n4.1 How to obtain a Builder?\nIn the code above, we include a public static method on the ConnectNModel class that provides a means of obtaining a Builder object. We could just expose the constructor of the Builder class directly:\n\n(new ConnectNGame.Builder())...\nbut this is less flexible a\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0028] the builder. Instead, the client first creates some kind of builder object, which encapsulates the configuration parameters for the game:\n\n\/**\n * Constructs a builder for configuring and then creating a game model\n * instance. Defaults to a standard game of Connect Four with players\n * named \"White\" and \"Red\".\n *\n * @return the new builder\n *\/\npublic static Builder builder();\nThe builder starts out with the default parameter values, and then provides several methods for changing whichever parameters we choose without saying anything about the others. In this case, that means we need a method for each of the parameters: the width, the height, the goal, and the array of players. Then, the builder provides a method build() that instantiates a game model object using the builder’s current para\n---\n[data\\raw\\notes\\notes-1335.txt::chunk0001] \n\n    public Decorator(Base base) {\n        ...\n    }\n} \/\/ might be necessary, but dependent on the implementation\n\n\n\n\n\n\n\n\n\n\n\n\ninterface Beverage {\n    Size size();\n    double price();\n}\n\nenum Size { SMALL, MED, LARGE };\n\nclass Coffee implements Beverage { ... }\nclass Tea implements Beverage { ... }\n\nAdd-ons:\n- Milk\n- Cream\n- Sugar\n- Fruit\n- Syrups\n- Whipped Cream\n- Charcoal\n\nclass MilkAdded implements Beverage {\n\n    private Beverage base;\n\n    public MilkAdded(Beverage base) {\n        this.base = base;\n    }\n\n    public Size size() {\n        return this.base.size():\n    }\n\n    public double price() {\n        return 1.00 + this.base.price();\n    }\n}\n\nclass CharcoalAdded implements Beverage {\n\n    private Beverage base;\n\n    public CharcoalAdded(Beverage base) {\n        this.base = base;\n \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.connectn;\n\npublic class ConnectN {\n\n  private int width, height;\n  private int goal;\n  private int numPlayers;\n\n  public ConnectN(int width, int height, int goal, int numPlayers) {\n    this.width = width;\n    this.height = height;\n    this.goal = goal;\n    this.numPlayers = numPlayers;\n  }\n\n  public static ConnectNBuilder builder() {\n    return new ConnectNBuilder();\n  }\n\n  public static class ConnectNBuilder {\n    private int width, height, goal, numPlayers;\n\n    public ConnectNBuilder() {\n      this.width = 7;\n      this.height = 8;\n      this.goal = 4;\n      this.numPlayers = 2;\n    }\n\n    public ConnectN build() {\n      return new ConnectN(width, height, goal, numPlayers);\n    }\n\n    public ConnectNBuilder setWidth(int width) {\n      this.width = width;\n      return this;\n    }\n\n    public ConnectNBuilder setHeight(int height) {\n      this.height = height;\n      return this;\n    }\n\n    public ConnectNBuilder setGoal(int goal) {\n      this.goal = goal;\n      return this;\n    }\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n}\n\n\n\/\/ConnectNBuilder usage\n\n\/\/ConnectNBuilder builder = new ConnectNBuilder();\n\/\/ConnectN model = builder.build(); \/\/full default\n\n\/\/game with goal length of  3\n\/\/builder.setGoal(3);\n\/\/builder.build();\n\n\/\/ new ConnectNBuilder().setGoal(3).setNumPlayer(5).build();\n\n\n\n<\/CodeSuffix>","target":"<Target>\npublic ConnectNBuilder setNumPlayers(int numPlayers) {\n      this.numPlayers = numPlayers;\n      return this;\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\src\\cs3500\\connectn\\ConnectN.java","mask_span":[1015,1130],"topics":["decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0015] acingTurtleModel m) {\n    m.trace(this.d);\n  }\n\n  ...\n\n}\nNow we can change the logic of our controller to:\n\nTake a one-word command from the user.\nCreate the corresponding TracingTurtleCommand object..\nExecute the command object.\nString in = s.next();\ntry {\n  switch (in) {\n    case \"q\":\n    case \"quit\":\n      return;\n   case \"show\":\n     for (Line l : m.getLines()) {\n        System.out.println(l);\n     }\n     break;\n   case \"move\":\n      cmd = new Move(s.nextDouble());\n      break;\n   case \"trace\":\n      cmd = new Trace(s.nextDouble());\n      break;\n   case \"turn\":\n      cmd = new Turn(s.nextDouble());\n      break;\n   case \"square\":\n      cmd = new Square(s.nextDouble());\n      break;\n   default:\n      System.out.println(String.format(\"Unknown command %s\", in));\n      cmd = null;\n      bre\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0019] Double()));\n    knownCommands.put(\"turn\",s->new Turn(s.nextDouble()));\n    knownCommands.put(\"trace\", s->new Trace(s.nextDouble()));\n    knownCommands.put(\"square\", s -> new Square(s.nextDouble()));\nThen our controller logic becomes:\n\nTake a one-word command from the user.\nFind if the command exists in the map. If so, execute the corresponding function object to get the command object.\nExecute the command object.\nThe second step above becomes a map lookup, instead of a switch statement!\n\nwhile(scan.hasNext()) {\n  TracingTurtleCommand c;\n  String in = scan.next();\n  if (in.equalsIgnoreCase(\"q\") || in.equalsIgnoreCase(\"quit\"))\n    return;\n  Function<Scanner, TracingTurtleCommand> cmd =\n  knownCommands.getOrDefault(in, null);\n  if (cmd == null) {\n    throw new IllegalArgumentException();\n  } \n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control;\n\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\nimport cs3500.turtle.control.commands.Move;\nimport cs3500.turtle.control.commands.Square;\nimport cs3500.turtle.control.commands.Trace;\nimport cs3500.turtle.control.commands.Turn;\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class CommandController {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    Scanner s = new Scanner(System.in);\n    TracingTurtleModel m = new SmarterTurtle();\n    TracingTurtleCommand cmd = null;\n    while (s.hasNext()) {\n      String in = s.next();\n      try {\n        switch (in) {\n          case \"q\":\n          case \"quit\":\n            return;\n          case \"show\":\n            for (Line l : m.getLines()) {\n              System.out.println(l);\n            }\n            break;\n          case \"move\":\n            cmd = new Move(s.nextDouble());\n            break;\n          case \"trace\":\n            cmd = new Trace(s.nextDouble());\n            break;\n          case \"turn\":\n            cmd = new Turn(s.nextDouble());\n            break;\n          case \"square\":\n            cmd = new Square(s.nextDouble());\n            break;\n          default:\n            System.out.println(String.format(\"Unknown command %s\", in));\n            cmd = null;\n            break;\n        }\n        if (cmd != null) cmd.execute(m);\n      } catch (InputMismatchException ime) {\n        System.out.println(\"Bad length to \" + in);\n      }\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\src\\cs3500\\turtle\\control\\CommandController.java","mask_span":[501,1602],"topics":["command","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0019] Double()));\n    knownCommands.put(\"turn\",s->new Turn(s.nextDouble()));\n    knownCommands.put(\"trace\", s->new Trace(s.nextDouble()));\n    knownCommands.put(\"square\", s -> new Square(s.nextDouble()));\nThen our controller logic becomes:\n\nTake a one-word command from the user.\nFind if the command exists in the map. If so, execute the corresponding function object to get the command object.\nExecute the command object.\nThe second step above becomes a map lookup, instead of a switch statement!\n\nwhile(scan.hasNext()) {\n  TracingTurtleCommand c;\n  String in = scan.next();\n  if (in.equalsIgnoreCase(\"q\") || in.equalsIgnoreCase(\"quit\"))\n    return;\n  Function<Scanner, TracingTurtleCommand> cmd =\n  knownCommands.getOrDefault(in, null);\n  if (cmd == null) {\n    throw new IllegalArgumentException();\n  } \n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0001] lative to current position and direction (as the turtle) instead of absolute Cartesian coordinates. For example, driving directions provide navigation relative to the current position and direction (“Drive 0.3 miles”, “Take left onto...”).\n\n1.1 Basic Design\nBased on the basic operations identified above for turtle model, we begin by designing an interface for the model of our program:\n\n\/**\n * This interface specifies the operations on a 2D turtle\n * <p>\n * A 2D turtle is characterized by a position (x,y) and a\n * heading (where it is looking).\n * <p>\n * It can be asked to draw the path it has moved using one of\n * the commands below.\n *\/\npublic interface TurtleModel {\n    \/**\n     * Move the turtle by the specified distance along its\n     * heading. Do not change heading\n     *\n     * @par\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Stack;\nimport java.util.function.Function;\n\nimport cs3500.turtle.control.commands.Move;\nimport cs3500.turtle.control.commands.Square;\nimport cs3500.turtle.control.commands.Trace;\nimport cs3500.turtle.control.commands.Turn;\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class ExtensibleController {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    Scanner scan = new Scanner(System.in);\n    TracingTurtleModel m = new SmarterTurtle();\n    Stack<TracingTurtleCommand> commands = new Stack<>();\n\n    Map<String, Function<Scanner, TracingTurtleCommand>> knownCommands = new HashMap<>();\n    knownCommands.put(\"move\", (Scanner s) -> { return new Move(s.nextDouble()); });\n    knownCommands.put(\"turn\", (Scanner s) -> { return new Turn(s.nextDouble()); });\n    knownCommands.put(\"trace\", (Scanner s) -> { return new Trace(s.nextDouble()); });\n    knownCommands.put(\"square\", (Scanner s) -> { return new Square(s.nextDouble()); });\n    knownCommands.put(\"show\", (Scanner s) -> {\n      return (TracingTurtleModel model) -> {\n        for (Line l : model.getLines())\n          System.out.println(l);\n      };\n    });\n    while(scan.hasNext()) {\n      TracingTurtleCommand c;\n      String in = scan.next();\n      if (in.equalsIgnoreCase(\"q\") || in.equalsIgnoreCase(\"quit\"))\n        return;\n      Function<Scanner, TracingTurtleCommand> cmd = knownCommands.getOrDefault(in, null);\n      if (cmd == null) {\n        throw new IllegalArgumentException();\n      } else {\n        c = cmd.apply(scan);\n        commands.add(c);\n        c.execute(m);\n      }\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\src\\cs3500\\turtle\\control\\ExtensibleController.java","mask_span":[571,1817],"topics":["command","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0015] acingTurtleModel m) {\n    m.trace(this.d);\n  }\n\n  ...\n\n}\nNow we can change the logic of our controller to:\n\nTake a one-word command from the user.\nCreate the corresponding TracingTurtleCommand object..\nExecute the command object.\nString in = s.next();\ntry {\n  switch (in) {\n    case \"q\":\n    case \"quit\":\n      return;\n   case \"show\":\n     for (Line l : m.getLines()) {\n        System.out.println(l);\n     }\n     break;\n   case \"move\":\n      cmd = new Move(s.nextDouble());\n      break;\n   case \"trace\":\n      cmd = new Trace(s.nextDouble());\n      break;\n   case \"turn\":\n      cmd = new Turn(s.nextDouble());\n      break;\n   case \"square\":\n      cmd = new Square(s.nextDouble());\n      break;\n   default:\n      System.out.println(String.format(\"Unknown command %s\", in));\n      cmd = null;\n      bre\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control;\n\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class SimpleController {\n  public static void main(String[] args) {\n    Scanner s = new Scanner(System.in);\n    TracingTurtleModel m = new SmarterTurtle();\n    while (s.hasNext()) {\n      String in = s.next();\n      switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          showLinesHelper(m);\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            System.out.println(\"Bad length to move\");\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            System.out.println(\"Bad length to trace\");\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            turnHelper(m, d);\n          } catch (InputMismatchException ime) {\n            System.out.println(\"Bad length to turn\");\n          }\n          break;\n        case \"square\":\n          try {\n            double d = s.nextDouble();\n            squareHelper(m, d);\n          } catch (InputMismatchException ime) {\n            System.out.println(\"Bad length to turn\");\n          }\n          break;\n        default:\n          System.out.println(String.format(\"Unknown command %s\", in));\n          break;\n      }\n    }\n  }\n\n  interface Command {\n    void execute(TracingTurtleModel model);\n  }\n\n  class ShowLines implements Command {\n\n    @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n  class Turn implements Command {\n\n    private double angle;\n\n    public Turn(double angle) {\n      this.angle = angle;\n    }\n\n    @Override\n    public void execute(TracingTurtleModel model) {\n      model.turn(angle);\n    }\n  }\n\n  private static void showLinesHelper(TracingTurtleModel m) {\n    for (Line l : m.getLines()) {\n      System.out.println(l);\n    }\n  }\n\n  private static void turnHelper(TracingTurtleModel m, double d) {\n    m.turn(d);\n  }\n\n  private static void squareHelper(TracingTurtleModel m, double d) {\n    m.trace(d);\n    m.turn(90);\n    m.trace(d);\n    m.turn(90);\n    m.trace(d);\n    m.turn(90);\n    m.trace(d);\n    m.turn(90);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel model) {\n      for (Line l : model.getLines()) {\n        System.out.println(l);\n      }\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\src\\cs3500\\turtle\\control\\SimpleController.java","mask_span":[1846,1978],"topics":["command","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0015] acingTurtleModel m) {\n    m.trace(this.d);\n  }\n\n  ...\n\n}\nNow we can change the logic of our controller to:\n\nTake a one-word command from the user.\nCreate the corresponding TracingTurtleCommand object..\nExecute the command object.\nString in = s.next();\ntry {\n  switch (in) {\n    case \"q\":\n    case \"quit\":\n      return;\n   case \"show\":\n     for (Line l : m.getLines()) {\n        System.out.println(l);\n     }\n     break;\n   case \"move\":\n      cmd = new Move(s.nextDouble());\n      break;\n   case \"trace\":\n      cmd = new Trace(s.nextDouble());\n      break;\n   case \"turn\":\n      cmd = new Turn(s.nextDouble());\n      break;\n   case \"square\":\n      cmd = new Square(s.nextDouble());\n      break;\n   default:\n      System.out.println(String.format(\"Unknown command %s\", in));\n      cmd = null;\n      bre\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control;\n\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class SimpleController {\n  public static void main(String[] args) {\n    Scanner s = new Scanner(System.in);\n    TracingTurtleModel m = new SmarterTurtle();\n    while (s.hasNext()) {\n      String in = s.next();\n      switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          showLinesHelper(m);\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            System.out.println(\"Bad length to move\");\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            System.out.println(\"Bad length to trace\");\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            turnHelper(m, d);\n          } catch (InputMismatchException ime) {\n            System.out.println(\"Bad length to turn\");\n          }\n          break;\n        case \"square\":\n          try {\n            double d = s.nextDouble();\n            squareHelper(m, d);\n          } catch (InputMismatchException ime) {\n            System.out.println(\"Bad length to turn\");\n          }\n          break;\n        default:\n          System.out.println(String.format(\"Unknown command %s\", in));\n          break;\n      }\n    }\n  }\n\n  interface Command {\n    void execute(TracingTurtleModel model);\n  }\n\n  class ShowLines implements Command {\n\n    @Override\n    public void execute(TracingTurtleModel model) {\n      for (Line l : model.getLines()) {\n        System.out.println(l);\n      }\n    }\n  }\n\n  class Turn implements Command {\n\n    private double angle;\n\n    public Turn(double angle) {\n      this.angle = angle;\n    }\n\n    @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n  private static void showLinesHelper(TracingTurtleModel m) {\n    for (Line l : m.getLines()) {\n      System.out.println(l);\n    }\n  }\n\n  private static void turnHelper(TracingTurtleModel m, double d) {\n    m.turn(d);\n  }\n\n  private static void squareHelper(TracingTurtleModel m, double d) {\n    m.trace(d);\n    m.turn(90);\n    m.trace(d);\n    m.turn(90);\n    m.trace(d);\n    m.turn(90);\n    m.trace(d);\n    m.turn(90);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel model) {\n      model.turn(angle);\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\src\\cs3500\\turtle\\control\\SimpleController.java","mask_span":[2129,2207],"topics":["command","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0001] lative to current position and direction (as the turtle) instead of absolute Cartesian coordinates. For example, driving directions provide navigation relative to the current position and direction (“Drive 0.3 miles”, “Take left onto...”).\n\n1.1 Basic Design\nBased on the basic operations identified above for turtle model, we begin by designing an interface for the model of our program:\n\n\/**\n * This interface specifies the operations on a 2D turtle\n * <p>\n * A 2D turtle is characterized by a position (x,y) and a\n * heading (where it is looking).\n * <p>\n * It can be asked to draw the path it has moved using one of\n * the commands below.\n *\/\npublic interface TurtleModel {\n    \/**\n     * Move the turtle by the specified distance along its\n     * heading. Do not change heading\n     *\n     * @par\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by ashesh on 10\/26\/2016.\n *\/\npublic class Koch implements TracingTurtleCommand {\n\n  private double d;\n  private int depth;\n\n  public Koch(double distance,int depth) {\n    d = distance;\n    this.depth = depth;\n  }\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\nprivate void drawKoch(double distance,int depth,TracingTurtleModel model) {\n    if (depth>0) {\n      drawKoch(distance\/3,depth-1,model);\n      model.turn(60);\n      drawKoch(distance\/3,depth-1,model);\n      model.turn(-120);\n      drawKoch(distance\/3,depth-1,model);\n      model.turn(60);\n      drawKoch(distance\/3,depth-1,model);\n    }\n    else {\n      model.trace(distance);\n    }\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel model) {\n    drawKoch(d,depth, model);\n    model.turn(-120);\n    drawKoch(d,depth, model);\n    model.turn(-120);\n    drawKoch(d,depth, model);\n    model.turn(-120);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\src\\cs3500\\turtle\\control\\commands\\Koch.java","mask_span":[390,597],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0001] lative to current position and direction (as the turtle) instead of absolute Cartesian coordinates. For example, driving directions provide navigation relative to the current position and direction (“Drive 0.3 miles”, “Take left onto...”).\n\n1.1 Basic Design\nBased on the basic operations identified above for turtle model, we begin by designing an interface for the model of our program:\n\n\/**\n * This interface specifies the operations on a 2D turtle\n * <p>\n * A 2D turtle is characterized by a position (x,y) and a\n * heading (where it is looking).\n * <p>\n * It can be asked to draw the path it has moved using one of\n * the commands below.\n *\/\npublic interface TurtleModel {\n    \/**\n     * Move the turtle by the specified distance along its\n     * heading. Do not change heading\n     *\n     * @par\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class Move implements TracingTurtleCommand {\n  double d;\n\n  public Move(Double d) {\n    this.d = d;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel model) {\n    model.move(this.d);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\src\\cs3500\\turtle\\control\\commands\\Move.java","mask_span":[316,391],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0007] istance);\nList<Line> getLines();\nIt may be tempting to simply add these methods to the TurtleModel interface and implement them in the SimpleTurtle class. However doing so has several problems:\n\nWe no longer have a turtle without the capability to draw. Clients that currently use TurtleModel and SimpleTurtle now have extra operations that is not relevant. This violates the Interface Segregation principle.\nEditing code that is in use is recipe for disaster. If we accidentally broke what was previous working, it affects client code. This violates the Open for Extension, Closed for Modification principle.\nHow do we add these operations? We extend the existing interface and then implement it by reusing the existing implementation (with inheritance).\n\n\npublic interface TracingTurtleModel extend\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by ashesh on 10\/28\/2016.\n *\/\npublic class Retrieve implements TracingTurtleCommand {\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel model) {\n    model.retrieve();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\src\\cs3500\\turtle\\control\\commands\\Retrieve.java","mask_span":[261,334],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0001] lative to current position and direction (as the turtle) instead of absolute Cartesian coordinates. For example, driving directions provide navigation relative to the current position and direction (“Drive 0.3 miles”, “Take left onto...”).\n\n1.1 Basic Design\nBased on the basic operations identified above for turtle model, we begin by designing an interface for the model of our program:\n\n\/**\n * This interface specifies the operations on a 2D turtle\n * <p>\n * A 2D turtle is characterized by a position (x,y) and a\n * heading (where it is looking).\n * <p>\n * It can be asked to draw the path it has moved using one of\n * the commands below.\n *\/\npublic interface TurtleModel {\n    \/**\n     * Move the turtle by the specified distance along its\n     * heading. Do not change heading\n     *\n     * @par\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by ashesh on 10\/28\/2016.\n *\/\npublic class Save implements TracingTurtleCommand{\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel model) {\n    model.save();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\src\\cs3500\\turtle\\control\\commands\\Save.java","mask_span":[257,326],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0007] istance);\nList<Line> getLines();\nIt may be tempting to simply add these methods to the TurtleModel interface and implement them in the SimpleTurtle class. However doing so has several problems:\n\nWe no longer have a turtle without the capability to draw. Clients that currently use TurtleModel and SimpleTurtle now have extra operations that is not relevant. This violates the Interface Segregation principle.\nEditing code that is in use is recipe for disaster. If we accidentally broke what was previous working, it affects client code. This violates the Open for Extension, Closed for Modification principle.\nHow do we add these operations? We extend the existing interface and then implement it by reusing the existing implementation (with inheritance).\n\n\npublic interface TracingTurtleModel extend\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\npublic class Show implements TracingTurtleCommand {\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel model) {\n    for (Line l : model.getLines()) {\n      System.out.println(l);\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\src\\cs3500\\turtle\\control\\commands\\Show.java","mask_span":[253,377],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class Square implements TracingTurtleCommand {\n  double d;\n\n  public Square(Double d) {\n    this.d = d;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel model) {\n    for (int i = 0; i < 4; i++) {\n      model.trace(this.d);\n      model.turn(90);\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\src\\cs3500\\turtle\\control\\commands\\Square.java","mask_span":[320,460],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0007] istance);\nList<Line> getLines();\nIt may be tempting to simply add these methods to the TurtleModel interface and implement them in the SimpleTurtle class. However doing so has several problems:\n\nWe no longer have a turtle without the capability to draw. Clients that currently use TurtleModel and SimpleTurtle now have extra operations that is not relevant. This violates the Interface Segregation principle.\nEditing code that is in use is recipe for disaster. If we accidentally broke what was previous working, it affects client code. This violates the Open for Extension, Closed for Modification principle.\nHow do we add these operations? We extend the existing interface and then implement it by reusing the existing implementation (with inheritance).\n\n\npublic interface TracingTurtleModel extend\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class Trace implements TracingTurtleCommand {\n  double d;\n\n  public Trace(Double d) {\n    this.d = d;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel model) {\n    model.trace(this.d);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\src\\cs3500\\turtle\\control\\commands\\Trace.java","mask_span":[318,394],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0001] lative to current position and direction (as the turtle) instead of absolute Cartesian coordinates. For example, driving directions provide navigation relative to the current position and direction (“Drive 0.3 miles”, “Take left onto...”).\n\n1.1 Basic Design\nBased on the basic operations identified above for turtle model, we begin by designing an interface for the model of our program:\n\n\/**\n * This interface specifies the operations on a 2D turtle\n * <p>\n * A 2D turtle is characterized by a position (x,y) and a\n * heading (where it is looking).\n * <p>\n * It can be asked to draw the path it has moved using one of\n * the commands below.\n *\/\npublic interface TurtleModel {\n    \/**\n     * Move the turtle by the specified distance along its\n     * heading. Do not change heading\n     *\n     * @par\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class Turn implements TracingTurtleCommand {\n  double d;\n\n  public Turn(Double d) {\n    this.d = d;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel model) {\n    model.turn(this.d);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\src\\cs3500\\turtle\\control\\commands\\Turn.java","mask_span":[316,391],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0003] \n\n\/**\n * This class represents a 2D position\n *\/\npublic final class Position2D {\n  private final double x;\n  private final double y;\n\n  \/**\n   * Initialize this object to the specified position\n   *\/\n  public Position2D(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  \/**\n   * Copy constructor\n   *\/\n  public Position2D(Position2D v) {\n    this(v.x, v.y);\n  }\n\n\n\n  public double getX() {\n    return x;\n  }\n\n  public double getY() {\n    return y;\n  }\n\n\n  @Override\n  public String toString() {\n    return String.format(\"(%f, %f)\", this.x, this.y);\n  }\n\n  @Override\n  public boolean equals(Object a) {\n    if (this == a) {\n      return true;\n    }\n    if (!(a instanceof Position2D)) {\n      return false;\n    }\n\n    Position2D that = (Position2D) a;\n\n    return ((Math.abs(this.x - that.x\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.model;\n\nimport java.util.Objects;\n\n\/**\n * This class represents a 2D position\n *\/\npublic final class Position2D {\n  private final double x;\n\n  public double getX() {\n    return x;\n  }\n\n  public double getY() {\n    return y;\n  }\n\n  private final double y;\n\n  \/**\n   * Initialize this object to the specified position\n   *\/\n  public Position2D(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  \/**\n   * Copy constructor\n   *\/\n  public Position2D(Position2D v) {\n    this(v.x, v.y);\n  }\n\n  @Override\n  public String toString() {\n    return String.format(\"(%f, %f)\", this.x, this.y);\n  }\n\n  @Override\n  public boolean equals(Object a) {\n    if (this == a) {\n      return true;\n    }\n    if (!(a instanceof Position2D)) {\n      return false;\n    }\n\n    Position2D that = (Position2D) a;\n\n    return ((Math.abs(this.x - that.x) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\src\\cs3500\\turtle\\model\\Position2D.java","mask_span":[922,990],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.model;\n\nimport java.util.Objects;\nimport java.util.Stack;\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n  }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic SimpleTurtle() {\n    this(new Position2D(0, 0), 0);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\src\\cs3500\\turtle\\model\\SimpleTurtle.java","mask_span":[626,688],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.tracingmodel;\n\nimport java.util.Objects;\n\nimport cs3500.turtle.model.Position2D;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic final class Line {\n  public final Position2D start;\n  public final Position2D end;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public String toString() {\n    return String.format(\"%s--%s\", this.start.toString(), this.end.toString());\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (!(o instanceof Line)) {\n      return false;\n    }\n\n    Line line = (Line) o;\n\n    return (this.start.equals(line.start) && this.end.equals(line.end))\n            || (this.end.equals(line.start) && this.start.equals(line.end));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.start, this.end);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic Line(Position2D start, Position2D end) {\n    this.start = start;\n    this.end = end;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\src\\cs3500\\turtle\\tracingmodel\\Line.java","mask_span":[240,335],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.tracingmodel;\n\nimport java.util.Objects;\n\nimport cs3500.turtle.model.Position2D;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic final class Line {\n  public final Position2D start;\n  public final Position2D end;\n\n  public Line(Position2D start, Position2D end) {\n    this.start = start;\n    this.end = end;\n  }\n\n  @Override\n  public String toString() {\n    return String.format(\"%s--%s\", this.start.toString(), this.end.toString());\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (!(o instanceof Line)) {\n      return false;\n    }\n\n    Line line = (Line) o;\n\n    return (this.start.equals(line.start) && this.end.equals(line.end))\n            || (this.end.equals(line.start) && this.start.equals(line.end));\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic int hashCode() {\n    return Objects.hash(this.start, this.end);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\src\\cs3500\\turtle\\tracingmodel\\Line.java","mask_span":[811,885],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.tracingmodel;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.model.SimpleTurtle;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public List<Line> getLines() {\n    return new ArrayList<>(lines);\n  }\n\n  \/\/list of lines traced since this object was created\n  List<Line> lines;\n\n}\n\n\n\/*\n10\/03 : Misc topics (testing, toString, Pile abstractions, Readable\/Appendable)\n\n10\/05: Encapsulation and invariants\n\nHw3\n\n10\/10: columbus day\n\n10\/12: Design problem (Turtles) -- talk through modelling of nouns (get to positions, lines?, turtles, tracing turtles extend simple turtles), get up to Commands as an abstraction, but not undoable ones, set up keyboard map but don't do it yet\n\nHW4 due 10\/14\n\n10\/17: Inheritance and composition\n\n10\/19: Intro to performance, More about performance\n\nHw5 due\n\n10\/24: First exam\n\n10\/26: Design discussion of music  models\n\n10\/31: Class activity: GUI (bad, basic mvc examples), MIDI\n\n11\/02: Adapters\n\nHw6 due on 11\/7\n\n11\/07: Commands\n\n11\/09: Commands (Class activity: adapters (Turtles))\n\n11\/14: Strategy (and decorator?) patterns\n\n\n11\/16: XXX (Command\/Observer)\n\n11\/21: XXX (Singleton\/Iterator\/Proxy)\n\nHw7 due 11\/21\n\n11\/28: Intro to Javascript\n\n11\/30: Javascript inheritance and patterns\n\n12\/05: Exam review\n\n12\/07: Promises\/Android\n\n\n\nadapters, strategy - TicTacToe, command - move, turn, ...square, ...fractal, undoable?\n\n\n\n\nPosition2D exists\nTurtleModel interface exists\nSimpleTurtle exists\n\ntalk-through SimpleTurtle\n\nmotivate tracing\n\ndesign TracingTurtleModel -- is it a TurtleModel? yes, so extend interface\nimplement SmarterTurtle -- extend or delegate?  either way will work, but inheritance is simpler\n\nmotivate the command-line controller\n\ndesign the controller with hard-coded switch with hard-coded method calls (move, turn, trace)\n\nhave some simple tests\n\nadd a new square case\n\ntest??? introduce Commands\n\n\n *\/\n<\/CodeSuffix>","target":"<Target>\npublic SmarterTurtle() {\n    super();\n    lines = new ArrayList<>();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\src\\cs3500\\turtle\\tracingmodel\\SmarterTurtle.java","mask_span":[295,367],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.tracingmodel;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.model.SimpleTurtle;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/\/list of lines traced since this object was created\n  List<Line> lines;\n\n}\n\n\n\/*\n10\/03 : Misc topics (testing, toString, Pile abstractions, Readable\/Appendable)\n\n10\/05: Encapsulation and invariants\n\nHw3\n\n10\/10: columbus day\n\n10\/12: Design problem (Turtles) -- talk through modelling of nouns (get to positions, lines?, turtles, tracing turtles extend simple turtles), get up to Commands as an abstraction, but not undoable ones, set up keyboard map but don't do it yet\n\nHW4 due 10\/14\n\n10\/17: Inheritance and composition\n\n10\/19: Intro to performance, More about performance\n\nHw5 due\n\n10\/24: First exam\n\n10\/26: Design discussion of music  models\n\n10\/31: Class activity: GUI (bad, basic mvc examples), MIDI\n\n11\/02: Adapters\n\nHw6 due on 11\/7\n\n11\/07: Commands\n\n11\/09: Commands (Class activity: adapters (Turtles))\n\n11\/14: Strategy (and decorator?) patterns\n\n\n11\/16: XXX (Command\/Observer)\n\n11\/21: XXX (Singleton\/Iterator\/Proxy)\n\nHw7 due 11\/21\n\n11\/28: Intro to Javascript\n\n11\/30: Javascript inheritance and patterns\n\n12\/05: Exam review\n\n12\/07: Promises\/Android\n\n\n\nadapters, strategy - TicTacToe, command - move, turn, ...square, ...fractal, undoable?\n\n\n\n\nPosition2D exists\nTurtleModel interface exists\nSimpleTurtle exists\n\ntalk-through SimpleTurtle\n\nmotivate tracing\n\ndesign TracingTurtleModel -- is it a TurtleModel? yes, so extend interface\nimplement SmarterTurtle -- extend or delegate?  either way will work, but inheritance is simpler\n\nmotivate the command-line controller\n\ndesign the controller with hard-coded switch with hard-coded method calls (move, turn, trace)\n\nhave some simple tests\n\nadd a new square case\n\ntest??? introduce Commands\n\n\n *\/\n<\/CodeSuffix>","target":"<Target>\npublic List<Line> getLines() {\n    return new ArrayList<>(lines);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\src\\cs3500\\turtle\\tracingmodel\\SmarterTurtle.java","mask_span":[551,620],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle;\n\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.model.SimpleTurtle;\nimport cs3500.turtle.model.TurtleModel;\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\nimport static org.junit.Assert.*;\n\n\/**\n * Created by ashesh on 5\/23\/2016.\n *\/\npublic final class SmarterTurtleTest {\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void testDrawSomething() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    Position2D p1 = t.getPosition();\n    t.save();\n    t.turn(45);\n    t.trace(10);\n    t.retrieve();\n\n    t.save();\n    t.turn(135);\n    t.trace(10);\n    t.retrieve();\n\n    t.save();\n    t.turn(-90);\n    t.trace(10);\n    t.retrieve();\n\n      List<Line> actualLines = t.getLines();\n      List<Line> expectedLines = new ArrayList<>();\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(45.0)), 10.0 * Math.sin(Math.toRadians(45.0)))));\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(135.0)), 10.0 * Math.sin(Math.toRadians(135.0)))));\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(-90)), 10.0 * Math.sin(Math.toRadians(-90)))));\n\n      assertEquals(expectedLines.size(), actualLines.size());\n\n      for (int i = 0; i < expectedLines.size(); i++) {\n        assertEquals(expectedLines.get(i), actualLines.get(i));\n    }\n  }\n\n  @Test\n  public void testInit() {\n    TurtleModel t = new SimpleTurtle();\n\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testMove() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.move(10);\n    assertEquals(10.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTurnOnly() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.turn(10);\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n\n\n    t.turn(-100);\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTurnAndMove() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.turn(30);\n    t.move(10);\n    assertEquals(10.0 * Math.cos(Math.toRadians(30)), t.getPosition().getX(), 0.001);\n    assertEquals(10.0 * Math.sin(Math.toRadians(30)), t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTrace() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    t.trace(10);\n    List<Line> lines = t.getLines();\n    assertEquals(1, lines.size());\n    assertEquals(0.0, lines.get(0).start.getX(), 0.001);\n    assertEquals(0.0, lines.get(0).start.getY(), 0.001);\n    assertEquals(10.0, lines.get(0).end.getX(), 0.001);\n    assertEquals(0.0, lines.get(0).end.getY(), 0.001);\n  }\n\n  @Test\n  public void testMultipleTrace() {\n    TracingTurtleModel t = new SmarterTurtle();\n    List<Line> expectedLines = new ArrayList<>();\n    for (int i = 0; i < 10; i++) {\n      t.turn(90);\n      t.trace(10);\n      t.turn(-90);\n      t.trace(10);\n      t.turn(-90);\n      t.trace(10);\n      t.turn(90);\n      t.trace(10);\n      expectedLines.add(new Line(new Position2D(20 * i, 0),\n                                 new Position2D(20 * i, 10)));\n\n      expectedLines.add(new Line(new Position2D(20 * i, 10),\n                                 new Position2D(20 * i + 10, 10)));\n\n      expectedLines.add(new Line(new Position2D(20 * i + 10, 10),\n                                 new Position2D(20 * i + 10, 0)));\n\n      expectedLines.add(new Line(new Position2D(20 * i + 10, 0),\n                                 new Position2D(20 * i + 20, 0)));\n    }\n\n    List<Line> actualLines = t.getLines();\n    assertEquals(expectedLines.size(), actualLines.size());\n    for (int i = 0; i < expectedLines.size(); i++) {\n      assertEquals(expectedLines.get(i), actualLines.get(i));\n    }\n  }\n\n  @Test\n  public void testPush() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.move(10);\n    Position2D initPosition = t.getPosition();\n    t.save();\n    t.turn(90);\n    t.move(10);\n    t.retrieve();\n    Position2D finalPosition = t.getPosition();\n    assertEquals(initPosition.getX(), finalPosition.getX(), 0.01);\n    assertEquals(finalPosition.getY(), finalPosition.getY(), 0.01);\n  }\n\n}\n<\/CodeSuffix>","target":"<Target>\npublic void testOne() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    t.turn(60);\n    t.trace(19);\n    t.turn(-120);\n    t.trace(19);\n    t.turn(-120);\n    t.trace(19);\n    List<Line> tlines = t.getLines();\n\n    TracingTurtleModel t2 = new SmarterTurtle();\n\n    t2.trace(19);\n    t2.turn(120);\n    t2.trace(19);\n    t2.turn(120);\n    t2.trace(19);\n\n    List<Line> t2lines = t2.getLines();\n\n    assertEquals(tlines.size(), t2lines.size());\n\n    for (Line l : tlines) {\n      assertTrue(t2lines.contains(l));\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\test\\cs3500\\turtle\\SmarterTurtleTest.java","mask_span":[492,1015],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle;\n\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.model.SimpleTurtle;\nimport cs3500.turtle.model.TurtleModel;\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\nimport static org.junit.Assert.*;\n\n\/**\n * Created by ashesh on 5\/23\/2016.\n *\/\npublic final class SmarterTurtleTest {\n\n  @Test\n  public void testOne() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    t.turn(60);\n    t.trace(19);\n    t.turn(-120);\n    t.trace(19);\n    t.turn(-120);\n    t.trace(19);\n    List<Line> tlines = t.getLines();\n\n    TracingTurtleModel t2 = new SmarterTurtle();\n\n    t2.trace(19);\n    t2.turn(120);\n    t2.trace(19);\n    t2.turn(120);\n    t2.trace(19);\n\n    List<Line> t2lines = t2.getLines();\n\n    assertEquals(tlines.size(), t2lines.size());\n\n    for (Line l : tlines) {\n      assertTrue(t2lines.contains(l));\n    }\n  }\n\n  @Test\n  public void testDrawSomething() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    Position2D p1 = t.getPosition();\n    t.save();\n    t.turn(45);\n    t.trace(10);\n    t.retrieve();\n\n    t.save();\n    t.turn(135);\n    t.trace(10);\n    t.retrieve();\n\n    t.save();\n    t.turn(-90);\n    t.trace(10);\n    t.retrieve();\n\n      List<Line> actualLines = t.getLines();\n      List<Line> expectedLines = new ArrayList<>();\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(45.0)), 10.0 * Math.sin(Math.toRadians(45.0)))));\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(135.0)), 10.0 * Math.sin(Math.toRadians(135.0)))));\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(-90)), 10.0 * Math.sin(Math.toRadians(-90)))));\n\n      assertEquals(expectedLines.size(), actualLines.size());\n\n      for (int i = 0; i < expectedLines.size(); i++) {\n        assertEquals(expectedLines.get(i), actualLines.get(i));\n    }\n  }\n\n  @Test\n  public void testInit() {\n    TurtleModel t = new SimpleTurtle();\n\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testMove() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.move(10);\n    assertEquals(10.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTurnOnly() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.turn(10);\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n\n\n    t.turn(-100);\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTurnAndMove() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.turn(30);\n    t.move(10);\n    assertEquals(10.0 * Math.cos(Math.toRadians(30)), t.getPosition().getX(), 0.001);\n    assertEquals(10.0 * Math.sin(Math.toRadians(30)), t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTrace() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    t.trace(10);\n    List<Line> lines = t.getLines();\n    assertEquals(1, lines.size());\n    assertEquals(0.0, lines.get(0).start.getX(), 0.001);\n    assertEquals(0.0, lines.get(0).start.getY(), 0.001);\n    assertEquals(10.0, lines.get(0).end.getX(), 0.001);\n    assertEquals(0.0, lines.get(0).end.getY(), 0.001);\n  }\n\n  @Test\n  public void testMultipleTrace() {\n    TracingTurtleModel t = new SmarterTurtle();\n    List<Line> expectedLines = new ArrayList<>();\n    for (int i = 0; i < 10; i++) {\n      t.turn(90);\n      t.trace(10);\n      t.turn(-90);\n      t.trace(10);\n      t.turn(-90);\n      t.trace(10);\n      t.turn(90);\n      t.trace(10);\n      expectedLines.add(new Line(new Position2D(20 * i, 0),\n                                 new Position2D(20 * i, 10)));\n\n      expectedLines.add(new Line(new Position2D(20 * i, 10),\n                                 new Position2D(20 * i + 10, 10)));\n\n      expectedLines.add(new Line(new Position2D(20 * i + 10, 10),\n                                 new Position2D(20 * i + 10, 0)));\n\n      expectedLines.add(new Line(new Position2D(20 * i + 10, 0),\n                                 new Position2D(20 * i + 20, 0)));\n    }\n\n    List<Line> actualLines = t.getLines();\n    assertEquals(expectedLines.size(), actualLines.size());\n    for (int i = 0; i < expectedLines.size(); i++) {\n      assertEquals(expectedLines.get(i), actualLines.get(i));\n    }\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n<\/CodeSuffix>","target":"<Target>\npublic void testPush() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.move(10);\n    Position2D initPosition = t.getPosition();\n    t.save();\n    t.turn(90);\n    t.move(10);\n    t.retrieve();\n    Position2D finalPosition = t.getPosition();\n    assertEquals(initPosition.getX(), finalPosition.getX(), 0.01);\n    assertEquals(finalPosition.getY(), finalPosition.getY(), 0.01);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1030\\test\\cs3500\\turtle\\SmarterTurtleTest.java","mask_span":[4771,5150],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0029] meters. Here’s the interface:\n\npublic static final class Builder {\n  \/**\n   * Sets the width of the game grid.\n   *\n   * @param width the width (positive)\n   * @return {@code this}, for method chaining\n   *\/\n  public Builder width(int width) { ... }\n\n  \/**\n   * Sets the height of the game grid.\n   *\n   * @param height the height (positive)\n   * @return {@code this}, for method chaining\n   *\/\n  public Builder height(int height) { ... }\n\n  \/**\n   * Sets the goal line length for the game.\n   *\n   * @param goal the goal (positive)\n   * @return {@code this}, for method chaining\n   *\/\n  public Builder goal(int goal) { ... }\n\n  \/**\n   * Sets the players for the game. Makes a defensive copy of the\n   * player array, so the client cannot change it from under us.\n   *\n   * @param players the array o\n---\n[data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0018]  additional kinds of nonsense states that were method earlier, such as dimensions being negative or the columns list containing values that don’t correspond to players. We guard against these possibilities by imposing class invariants and checking that they’re respected. In the case of Connect N, we want know that the dimensions are always sensible (positive), the turn stands for a valid player, the length of the columns list equals width of the grid, the length of every column in the list doesn’t exceed height, an all the elements of the columns are non-null integers between 0 and players - 1.\n\nIn order to apply class invariant reasoning, we need to determine what invariants we have (or think we have), and then check the code to make sure that’s true.\n\n6 The class invariant reasoning prin\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0030] f player names (non-null, non-empty,\n   *                and every element non-null)\n   * @return {@code this}, for method chaining\n   *\/\n  public Builder players(String... players) { ... }\n\n  \/**\n   * Builds and returns the specified {@link ConnectNModel}.\n   *\n   * @return a new {@code ConnectNModel}\n   *\/\n  public ConnectNModel build() { ... }\n}\nThen to create our wide Connect Four instance, we can use the builder object to specify only the parameters we want:\n\nConnectNGame.builder().width(15).build()\n4.1 How to obtain a Builder?\nIn the code above, we include a public static method on the ConnectNModel class that provides a means of obtaining a Builder object. We could just expose the constructor of the Builder class directly:\n\n(new ConnectNGame.Builder())...\nbut this is less flexible a\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0024] unds\n *\/\nInteger getPlayerAt(int x, int y);\n\n\/**\n * Determines whether the specified column is full and thus cannot be played\n * in.\n *\n * @param which the column to check\n * @return whether column {@code which} is full\n *\/\nboolean isColumnFull(int which);\n4 Configuring the model: the Builder pattern\nNote: for more on the Builder pattern, see Bloch, Item 2.\n\nWe designed our Connect N game to have some flexibility in its parameters, so it’s worth discussing how a client can select those parameters when instantiating the model. We could, of course offer a constructor that takes all of the parameters that are allowed to vary:\n\n\/**\n * Constructs a new game model with the given parameters.\n *\n * @param width    the width of the grid (positive)\n * @param height   the height of the grid (positive\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.connectn;\n\npublic class ConnectN {\n\n  private int turn;\n  private int board[][];\n  private boolean gameStarted;\n  private boolean isGameOver;\n  private int goal;\n  private int numPlayers;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic static ConnectNBuilder builder() {\n    return new ConnectNBuilder();\n  }\n\n  public static class ConnectNBuilder {\n\n    public ConnectNBuilder() {\n\n    }\n\n  }\n}\n\n\n\/\/ConnectNBuilder builder = new ConnectNBuilder();\n\/\/model = builder.build(); \/\/ default Connect 4\n\n\/\/builder.setGoal(3);\n\/\/model = builder.build(); \/\/ Connect 3 game with default board and 2 players\n\n\/\/builder = new ConnectNBuilder();\n\/\/builder.setWidth(3);\n\/\/builder.setHeight(4);\n\/\/model = builder.build();\n\n\/\/or add on top of the above with\n\/\/builder.setWidth(3);\n\/\/builder.setHeight(3);\n\/\/builder.setGoal(3);\n\/\/model = builder.build(); \/\/ TicTacToe with gravity\n\n\n\/\/Actual builder use\n\/\/ model = new ConnectNBuilder().setWidth(3).setGoal(4).build();\n\n\n\n\n\n<\/CodeSuffix>","target":"<Target>\nprivate ConnectN(int width, int height, int goal, int numPlayers) {\n    this.board = new int[height][width];\n    this.goal = goal;\n    this.numPlayers = numPlayers;\n    \/\/... init the rest ...\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\src\\cs3500\\connectn\\ConnectN.java","mask_span":[206,402],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0015] acingTurtleModel m) {\n    m.trace(this.d);\n  }\n\n  ...\n\n}\nNow we can change the logic of our controller to:\n\nTake a one-word command from the user.\nCreate the corresponding TracingTurtleCommand object..\nExecute the command object.\nString in = s.next();\ntry {\n  switch (in) {\n    case \"q\":\n    case \"quit\":\n      return;\n   case \"show\":\n     for (Line l : m.getLines()) {\n        System.out.println(l);\n     }\n     break;\n   case \"move\":\n      cmd = new Move(s.nextDouble());\n      break;\n   case \"trace\":\n      cmd = new Trace(s.nextDouble());\n      break;\n   case \"turn\":\n      cmd = new Turn(s.nextDouble());\n      break;\n   case \"square\":\n      cmd = new Square(s.nextDouble());\n      break;\n   default:\n      System.out.println(String.format(\"Unknown command %s\", in));\n      cmd = null;\n      bre\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0019] Double()));\n    knownCommands.put(\"turn\",s->new Turn(s.nextDouble()));\n    knownCommands.put(\"trace\", s->new Trace(s.nextDouble()));\n    knownCommands.put(\"square\", s -> new Square(s.nextDouble()));\nThen our controller logic becomes:\n\nTake a one-word command from the user.\nFind if the command exists in the map. If so, execute the corresponding function object to get the command object.\nExecute the command object.\nThe second step above becomes a map lookup, instead of a switch statement!\n\nwhile(scan.hasNext()) {\n  TracingTurtleCommand c;\n  String in = scan.next();\n  if (in.equalsIgnoreCase(\"q\") || in.equalsIgnoreCase(\"quit\"))\n    return;\n  Function<Scanner, TracingTurtleCommand> cmd =\n  knownCommands.getOrDefault(in, null);\n  if (cmd == null) {\n    throw new IllegalArgumentException();\n  } \n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control;\n\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.Scanner;\n\nimport cs3500.turtle.control.commands.Move;\nimport cs3500.turtle.control.commands.Square;\nimport cs3500.turtle.control.commands.Trace;\nimport cs3500.turtle.control.commands.Turn;\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class CommandController {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    Scanner s = new Scanner(System.in);\n    TracingTurtleModel m = new SmarterTurtle();\n    TracingTurtleCommand cmd = null;\n    while (s.hasNext()) {\n      String in = s.next();\n      try {\n        switch (in) {\n          case \"q\":\n          case \"quit\":\n            return;\n          case \"show\":\n            for (Line l : m.getLines()) {\n              System.out.println(l);\n            }\n            break;\n          case \"move\":\n            cmd = new Move(s.nextDouble());\n            \/*\n            * interface CommandBuilder {\n            *    Command build (Scanner scan);\n            *  \/\/Function<Scanner, Command> <--- written as a lambda\n             *\/\n            break;\n          case \"trace\":\n            cmd = new Trace(s.nextDouble());\n            break;\n          case \"turn\":\n            cmd = new Turn(s.nextDouble());\n            break;\n          case \"square\":\n            cmd = new Square(s.nextDouble());\n            break;\n          default:\n            System.out.println(String.format(\"Unknown command %s\", in));\n            cmd = null;\n            break;\n        }\n        if (cmd != null) cmd.execute(m);\n      } catch (InputMismatchException ime) {\n        System.out.println(\"Bad length to \" + in);\n      }\n    }\n  }\n}\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\src\\cs3500\\turtle\\control\\CommandController.java","mask_span":[524,1815],"topics":["command","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0019] Double()));\n    knownCommands.put(\"turn\",s->new Turn(s.nextDouble()));\n    knownCommands.put(\"trace\", s->new Trace(s.nextDouble()));\n    knownCommands.put(\"square\", s -> new Square(s.nextDouble()));\nThen our controller logic becomes:\n\nTake a one-word command from the user.\nFind if the command exists in the map. If so, execute the corresponding function object to get the command object.\nExecute the command object.\nThe second step above becomes a map lookup, instead of a switch statement!\n\nwhile(scan.hasNext()) {\n  TracingTurtleCommand c;\n  String in = scan.next();\n  if (in.equalsIgnoreCase(\"q\") || in.equalsIgnoreCase(\"quit\"))\n    return;\n  Function<Scanner, TracingTurtleCommand> cmd =\n  knownCommands.getOrDefault(in, null);\n  if (cmd == null) {\n    throw new IllegalArgumentException();\n  } \n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0001] lative to current position and direction (as the turtle) instead of absolute Cartesian coordinates. For example, driving directions provide navigation relative to the current position and direction (“Drive 0.3 miles”, “Take left onto...”).\n\n1.1 Basic Design\nBased on the basic operations identified above for turtle model, we begin by designing an interface for the model of our program:\n\n\/**\n * This interface specifies the operations on a 2D turtle\n * <p>\n * A 2D turtle is characterized by a position (x,y) and a\n * heading (where it is looking).\n * <p>\n * It can be asked to draw the path it has moved using one of\n * the commands below.\n *\/\npublic interface TurtleModel {\n    \/**\n     * Move the turtle by the specified distance along its\n     * heading. Do not change heading\n     *\n     * @par\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Stack;\nimport java.util.function.Function;\n\nimport cs3500.turtle.control.commands.Move;\nimport cs3500.turtle.control.commands.Square;\nimport cs3500.turtle.control.commands.Trace;\nimport cs3500.turtle.control.commands.Turn;\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class ExtensibleController {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    Scanner scan = new Scanner(System.in);\n    TracingTurtleModel m = new SmarterTurtle();\n    Stack<UndoableTTCmd> commands = new Stack<>();\n\n    Map<String, Function<Scanner, TracingTurtleCommand>> knownCommands = new HashMap<>();\n    knownCommands.put(\"move\", (Scanner s) -> { return new Move(s.nextDouble()); });\n    knownCommands.put(\"turn\", (Scanner s) -> { return new Turn(s.nextDouble()); });\n    knownCommands.put(\"trace\", (Scanner s) -> { return new Trace(s.nextDouble()); });\n    knownCommands.put(\"square\", (Scanner s) -> { return new Square(s.nextDouble()); });\n    knownCommands.put(\"show\", (Scanner s) -> {\n      return (TracingTurtleModel model) -> {\n        for (Line l : model.getLines())\n          System.out.println(l);\n      };\n    });\n    while(scan.hasNext()) {\n      TracingTurtleCommand c;\n      String in = scan.next();\n      if (in.equalsIgnoreCase(\"q\") || in.equalsIgnoreCase(\"quit\"))\n        return;\n      Function<Scanner, TracingTurtleCommand> cmd = knownCommands.getOrDefault(in, null);\n      if (cmd == null) {\n        throw new IllegalArgumentException();\n      } else {\n        c = cmd.apply(scan);\n        \/\/If the command is an undoable one\n        \/\/NOTE: Can still be done with double-dispatch. You will need a method\n        \/\/ in each command object\n        \/\/ that takes in the stack and decides whether the command object should\n        \/\/ be added to the stack.\n        if (c instanceof UndoableTTCmd) {\n          commands.add((UndoableTTCmd) c);\n        }\n        c.execute(m);\n      }\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\src\\cs3500\\turtle\\control\\ExtensibleController.java","mask_span":[571,2152],"topics":["command","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0015] acingTurtleModel m) {\n    m.trace(this.d);\n  }\n\n  ...\n\n}\nNow we can change the logic of our controller to:\n\nTake a one-word command from the user.\nCreate the corresponding TracingTurtleCommand object..\nExecute the command object.\nString in = s.next();\ntry {\n  switch (in) {\n    case \"q\":\n    case \"quit\":\n      return;\n   case \"show\":\n     for (Line l : m.getLines()) {\n        System.out.println(l);\n     }\n     break;\n   case \"move\":\n      cmd = new Move(s.nextDouble());\n      break;\n   case \"trace\":\n      cmd = new Trace(s.nextDouble());\n      break;\n   case \"turn\":\n      cmd = new Turn(s.nextDouble());\n      break;\n   case \"square\":\n      cmd = new Square(s.nextDouble());\n      break;\n   default:\n      System.out.println(String.format(\"Unknown command %s\", in));\n      cmd = null;\n      bre\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control;\n\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.Scanner;\n\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class SimpleController {\n  public static void main(String[] args) {\n    Scanner s = new Scanner(System.in);\n    TracingTurtleModel m = new SmarterTurtle();\n    while (s.hasNext()) {\n      String in = s.next();\n      switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          showHelper(m);\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            System.out.println(\"Bad length to move\");\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            System.out.println(\"Bad length to trace\");\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            turnHelper(m, d);\n          } catch (InputMismatchException ime) {\n            System.out.println(\"Bad length to turn\");\n          }\n          break;\n        case \"square\":\n          try {\n            double d = s.nextDouble();\n            squareHelper(m, d);\n          } catch (InputMismatchException ime) {\n            System.out.println(\"Bad length to turn\");\n          }\n          break;\n        default:\n          System.out.println(String.format(\"Unknown command %s\", in));\n          break;\n      }\n    }\n  }\n\n\n\n  interface Command {\n    void execute(TracingTurtleModel model);\n  }\n\n  class ShowLines implements Command {\n\n    @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n  private static void showHelper(TracingTurtleModel m) {\n    for (Line l : m.getLines()) {\n      System.out.println(l);\n    }\n  }\n\n  class Turn implements Command {\n    private double angle;\n\n    public Turn(double angle) {\n      this.angle = angle;\n    }\n\n    @Override\n    public void execute(TracingTurtleModel model) {\n      model.turn(angle);\n    }\n  }\n\n  private static void turnHelper(TracingTurtleModel m, double d) {\n    m.turn(d);\n  }\n\n  private static void squareHelper(TracingTurtleModel m, double d) {\n    m.trace(d);\n    m.turn(90);\n    m.trace(d);\n    m.turn(90);\n    m.trace(d);\n    m.turn(90);\n    m.trace(d);\n    m.turn(90);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel model) {\n      for (Line l : model.getLines()) {\n        System.out.println(l);\n      }\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\src\\cs3500\\turtle\\control\\SimpleController.java","mask_span":[1866,1998],"topics":["command","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0015] acingTurtleModel m) {\n    m.trace(this.d);\n  }\n\n  ...\n\n}\nNow we can change the logic of our controller to:\n\nTake a one-word command from the user.\nCreate the corresponding TracingTurtleCommand object..\nExecute the command object.\nString in = s.next();\ntry {\n  switch (in) {\n    case \"q\":\n    case \"quit\":\n      return;\n   case \"show\":\n     for (Line l : m.getLines()) {\n        System.out.println(l);\n     }\n     break;\n   case \"move\":\n      cmd = new Move(s.nextDouble());\n      break;\n   case \"trace\":\n      cmd = new Trace(s.nextDouble());\n      break;\n   case \"turn\":\n      cmd = new Turn(s.nextDouble());\n      break;\n   case \"square\":\n      cmd = new Square(s.nextDouble());\n      break;\n   default:\n      System.out.println(String.format(\"Unknown command %s\", in));\n      cmd = null;\n      bre\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control;\n\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.Scanner;\n\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class SimpleController {\n  public static void main(String[] args) {\n    Scanner s = new Scanner(System.in);\n    TracingTurtleModel m = new SmarterTurtle();\n    while (s.hasNext()) {\n      String in = s.next();\n      switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          showHelper(m);\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            System.out.println(\"Bad length to move\");\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            System.out.println(\"Bad length to trace\");\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            turnHelper(m, d);\n          } catch (InputMismatchException ime) {\n            System.out.println(\"Bad length to turn\");\n          }\n          break;\n        case \"square\":\n          try {\n            double d = s.nextDouble();\n            squareHelper(m, d);\n          } catch (InputMismatchException ime) {\n            System.out.println(\"Bad length to turn\");\n          }\n          break;\n        default:\n          System.out.println(String.format(\"Unknown command %s\", in));\n          break;\n      }\n    }\n  }\n\n\n\n  interface Command {\n    void execute(TracingTurtleModel model);\n  }\n\n  class ShowLines implements Command {\n\n    @Override\n    public void execute(TracingTurtleModel model) {\n      for (Line l : model.getLines()) {\n        System.out.println(l);\n      }\n    }\n  }\n\n  private static void showHelper(TracingTurtleModel m) {\n    for (Line l : m.getLines()) {\n      System.out.println(l);\n    }\n  }\n\n  class Turn implements Command {\n    private double angle;\n\n    public Turn(double angle) {\n      this.angle = angle;\n    }\n\n    @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n  private static void turnHelper(TracingTurtleModel m, double d) {\n    m.turn(d);\n  }\n\n  private static void squareHelper(TracingTurtleModel m, double d) {\n    m.trace(d);\n    m.turn(90);\n    m.trace(d);\n    m.turn(90);\n    m.trace(d);\n    m.turn(90);\n    m.trace(d);\n    m.turn(90);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel model) {\n      model.turn(angle);\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\src\\cs3500\\turtle\\control\\SimpleController.java","mask_span":[2279,2357],"topics":["command","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0001] lative to current position and direction (as the turtle) instead of absolute Cartesian coordinates. For example, driving directions provide navigation relative to the current position and direction (“Drive 0.3 miles”, “Take left onto...”).\n\n1.1 Basic Design\nBased on the basic operations identified above for turtle model, we begin by designing an interface for the model of our program:\n\n\/**\n * This interface specifies the operations on a 2D turtle\n * <p>\n * A 2D turtle is characterized by a position (x,y) and a\n * heading (where it is looking).\n * <p>\n * It can be asked to draw the path it has moved using one of\n * the commands below.\n *\/\npublic interface TurtleModel {\n    \/**\n     * Move the turtle by the specified distance along its\n     * heading. Do not change heading\n     *\n     * @par\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by ashesh on 10\/26\/2016.\n *\/\npublic class Koch implements TracingTurtleCommand {\n\n  private double d;\n  private int depth;\n\n  public Koch(double distance,int depth) {\n    d = distance;\n    this.depth = depth;\n  }\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\nprivate void drawKoch(double distance,int depth,TracingTurtleModel model) {\n    if (depth>0) {\n      drawKoch(distance\/3,depth-1,model);\n      model.turn(60);\n      drawKoch(distance\/3,depth-1,model);\n      model.turn(-120);\n      drawKoch(distance\/3,depth-1,model);\n      model.turn(60);\n      drawKoch(distance\/3,depth-1,model);\n    }\n    else {\n      model.trace(distance);\n    }\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel model) {\n    drawKoch(d,depth, model);\n    model.turn(-120);\n    drawKoch(d,depth, model);\n    model.turn(-120);\n    drawKoch(d,depth, model);\n    model.turn(-120);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\src\\cs3500\\turtle\\control\\commands\\Koch.java","mask_span":[390,597],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0001] lative to current position and direction (as the turtle) instead of absolute Cartesian coordinates. For example, driving directions provide navigation relative to the current position and direction (“Drive 0.3 miles”, “Take left onto...”).\n\n1.1 Basic Design\nBased on the basic operations identified above for turtle model, we begin by designing an interface for the model of our program:\n\n\/**\n * This interface specifies the operations on a 2D turtle\n * <p>\n * A 2D turtle is characterized by a position (x,y) and a\n * heading (where it is looking).\n * <p>\n * It can be asked to draw the path it has moved using one of\n * the commands below.\n *\/\npublic interface TurtleModel {\n    \/**\n     * Move the turtle by the specified distance along its\n     * heading. Do not change heading\n     *\n     * @par\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.control.UndoableTTCmd;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class Move implements UndoableTTCmd {\n  double d;\n\n  public Move(Double d) {\n    this.d = d;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void undo(TracingTurtleModel m) {\n    m.move(-this.d);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel model) {\n    model.move(this.d);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\src\\cs3500\\turtle\\control\\commands\\Move.java","mask_span":[353,428],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0007] istance);\nList<Line> getLines();\nIt may be tempting to simply add these methods to the TurtleModel interface and implement them in the SimpleTurtle class. However doing so has several problems:\n\nWe no longer have a turtle without the capability to draw. Clients that currently use TurtleModel and SimpleTurtle now have extra operations that is not relevant. This violates the Interface Segregation principle.\nEditing code that is in use is recipe for disaster. If we accidentally broke what was previous working, it affects client code. This violates the Open for Extension, Closed for Modification principle.\nHow do we add these operations? We extend the existing interface and then implement it by reusing the existing implementation (with inheritance).\n\n\npublic interface TracingTurtleModel extend\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by ashesh on 10\/28\/2016.\n *\/\npublic class Retrieve implements TracingTurtleCommand {\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel model) {\n    model.retrieve();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\src\\cs3500\\turtle\\control\\commands\\Retrieve.java","mask_span":[261,334],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0001] lative to current position and direction (as the turtle) instead of absolute Cartesian coordinates. For example, driving directions provide navigation relative to the current position and direction (“Drive 0.3 miles”, “Take left onto...”).\n\n1.1 Basic Design\nBased on the basic operations identified above for turtle model, we begin by designing an interface for the model of our program:\n\n\/**\n * This interface specifies the operations on a 2D turtle\n * <p>\n * A 2D turtle is characterized by a position (x,y) and a\n * heading (where it is looking).\n * <p>\n * It can be asked to draw the path it has moved using one of\n * the commands below.\n *\/\npublic interface TurtleModel {\n    \/**\n     * Move the turtle by the specified distance along its\n     * heading. Do not change heading\n     *\n     * @par\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by ashesh on 10\/28\/2016.\n *\/\npublic class Save implements TracingTurtleCommand{\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel model) {\n    model.save();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\src\\cs3500\\turtle\\control\\commands\\Save.java","mask_span":[257,326],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0007] istance);\nList<Line> getLines();\nIt may be tempting to simply add these methods to the TurtleModel interface and implement them in the SimpleTurtle class. However doing so has several problems:\n\nWe no longer have a turtle without the capability to draw. Clients that currently use TurtleModel and SimpleTurtle now have extra operations that is not relevant. This violates the Interface Segregation principle.\nEditing code that is in use is recipe for disaster. If we accidentally broke what was previous working, it affects client code. This violates the Open for Extension, Closed for Modification principle.\nHow do we add these operations? We extend the existing interface and then implement it by reusing the existing implementation (with inheritance).\n\n\npublic interface TracingTurtleModel extend\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\npublic class Show implements TracingTurtleCommand {\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel model) {\n    for (Line l : model.getLines()) {\n      System.out.println(l);\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\src\\cs3500\\turtle\\control\\commands\\Show.java","mask_span":[253,377],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class Square implements TracingTurtleCommand {\n  double d;\n\n  public Square(Double d) {\n    this.d = d;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel model) {\n    for (int i = 0; i < 4; i++) {\n      model.trace(this.d);\n      model.turn(90);\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\src\\cs3500\\turtle\\control\\commands\\Square.java","mask_span":[320,460],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0007] istance);\nList<Line> getLines();\nIt may be tempting to simply add these methods to the TurtleModel interface and implement them in the SimpleTurtle class. However doing so has several problems:\n\nWe no longer have a turtle without the capability to draw. Clients that currently use TurtleModel and SimpleTurtle now have extra operations that is not relevant. This violates the Interface Segregation principle.\nEditing code that is in use is recipe for disaster. If we accidentally broke what was previous working, it affects client code. This violates the Open for Extension, Closed for Modification principle.\nHow do we add these operations? We extend the existing interface and then implement it by reusing the existing implementation (with inheritance).\n\n\npublic interface TracingTurtleModel extend\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class Trace implements TracingTurtleCommand {\n  double d;\n\n  public Trace(Double d) {\n    this.d = d;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel model) {\n    model.trace(this.d);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\src\\cs3500\\turtle\\control\\commands\\Trace.java","mask_span":[318,394],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0001] lative to current position and direction (as the turtle) instead of absolute Cartesian coordinates. For example, driving directions provide navigation relative to the current position and direction (“Drive 0.3 miles”, “Take left onto...”).\n\n1.1 Basic Design\nBased on the basic operations identified above for turtle model, we begin by designing an interface for the model of our program:\n\n\/**\n * This interface specifies the operations on a 2D turtle\n * <p>\n * A 2D turtle is characterized by a position (x,y) and a\n * heading (where it is looking).\n * <p>\n * It can be asked to draw the path it has moved using one of\n * the commands below.\n *\/\npublic interface TurtleModel {\n    \/**\n     * Move the turtle by the specified distance along its\n     * heading. Do not change heading\n     *\n     * @par\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class Turn implements TracingTurtleCommand {\n  double d;\n\n  public Turn(Double d) {\n    this.d = d;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel model) {\n    model.turn(this.d);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\src\\cs3500\\turtle\\control\\commands\\Turn.java","mask_span":[316,391],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0003] \n\n\/**\n * This class represents a 2D position\n *\/\npublic final class Position2D {\n  private final double x;\n  private final double y;\n\n  \/**\n   * Initialize this object to the specified position\n   *\/\n  public Position2D(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  \/**\n   * Copy constructor\n   *\/\n  public Position2D(Position2D v) {\n    this(v.x, v.y);\n  }\n\n\n\n  public double getX() {\n    return x;\n  }\n\n  public double getY() {\n    return y;\n  }\n\n\n  @Override\n  public String toString() {\n    return String.format(\"(%f, %f)\", this.x, this.y);\n  }\n\n  @Override\n  public boolean equals(Object a) {\n    if (this == a) {\n      return true;\n    }\n    if (!(a instanceof Position2D)) {\n      return false;\n    }\n\n    Position2D that = (Position2D) a;\n\n    return ((Math.abs(this.x - that.x\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.model;\n\nimport java.util.Objects;\n\n\/**\n * This class represents a 2D position\n *\/\npublic final class Position2D {\n  private final double x;\n\n  public double getX() {\n    return x;\n  }\n\n  public double getY() {\n    return y;\n  }\n\n  private final double y;\n\n  \/**\n   * Initialize this object to the specified position\n   *\/\n  public Position2D(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  \/**\n   * Copy constructor\n   *\/\n  public Position2D(Position2D v) {\n    this(v.x, v.y);\n  }\n\n  @Override\n  public String toString() {\n    return String.format(\"(%f, %f)\", this.x, this.y);\n  }\n\n  @Override\n  public boolean equals(Object a) {\n    if (this == a) {\n      return true;\n    }\n    if (!(a instanceof Position2D)) {\n      return false;\n    }\n\n    Position2D that = (Position2D) a;\n\n    return ((Math.abs(this.x - that.x) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\src\\cs3500\\turtle\\model\\Position2D.java","mask_span":[922,990],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.model;\n\nimport java.util.Objects;\nimport java.util.Stack;\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n  }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic SimpleTurtle() {\n    this(new Position2D(0, 0), 0);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\src\\cs3500\\turtle\\model\\SimpleTurtle.java","mask_span":[626,688],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.tracingmodel;\n\nimport java.util.Objects;\n\nimport cs3500.turtle.model.Position2D;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic final class Line {\n  public final Position2D start;\n  public final Position2D end;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public String toString() {\n    return String.format(\"%s--%s\", this.start.toString(), this.end.toString());\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (!(o instanceof Line)) {\n      return false;\n    }\n\n    Line line = (Line) o;\n\n    return (this.start.equals(line.start) && this.end.equals(line.end))\n            || (this.end.equals(line.start) && this.start.equals(line.end));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.start, this.end);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic Line(Position2D start, Position2D end) {\n    this.start = start;\n    this.end = end;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\src\\cs3500\\turtle\\tracingmodel\\Line.java","mask_span":[240,335],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.tracingmodel;\n\nimport java.util.Objects;\n\nimport cs3500.turtle.model.Position2D;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic final class Line {\n  public final Position2D start;\n  public final Position2D end;\n\n  public Line(Position2D start, Position2D end) {\n    this.start = start;\n    this.end = end;\n  }\n\n  @Override\n  public String toString() {\n    return String.format(\"%s--%s\", this.start.toString(), this.end.toString());\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (!(o instanceof Line)) {\n      return false;\n    }\n\n    Line line = (Line) o;\n\n    return (this.start.equals(line.start) && this.end.equals(line.end))\n            || (this.end.equals(line.start) && this.start.equals(line.end));\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic int hashCode() {\n    return Objects.hash(this.start, this.end);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\src\\cs3500\\turtle\\tracingmodel\\Line.java","mask_span":[811,885],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.tracingmodel;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.model.SimpleTurtle;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public List<Line> getLines() {\n    return new ArrayList<>(lines);\n  }\n\n  \/\/list of lines traced since this object was created\n  List<Line> lines;\n\n}\n\n\n\/*\n10\/03 : Misc topics (testing, toString, Pile abstractions, Readable\/Appendable)\n\n10\/05: Encapsulation and invariants\n\nHw3\n\n10\/10: columbus day\n\n10\/12: Design problem (Turtles) -- talk through modelling of nouns (get to positions, lines?, turtles, tracing turtles extend simple turtles), get up to Commands as an abstraction, but not undoable ones, set up keyboard map but don't do it yet\n\nHW4 due 10\/14\n\n10\/17: Inheritance and composition\n\n10\/19: Intro to performance, More about performance\n\nHw5 due\n\n10\/24: First exam\n\n10\/26: Design discussion of music  models\n\n10\/31: Class activity: GUI (bad, basic mvc examples), MIDI\n\n11\/02: Adapters\n\nHw6 due on 11\/7\n\n11\/07: Commands\n\n11\/09: Commands (Class activity: adapters (Turtles))\n\n11\/14: Strategy (and decorator?) patterns\n\n\n11\/16: XXX (Command\/Observer)\n\n11\/21: XXX (Singleton\/Iterator\/Proxy)\n\nHw7 due 11\/21\n\n11\/28: Intro to Javascript\n\n11\/30: Javascript inheritance and patterns\n\n12\/05: Exam review\n\n12\/07: Promises\/Android\n\n\n\nadapters, strategy - TicTacToe, command - move, turn, ...square, ...fractal, undoable?\n\n\n\n\nPosition2D exists\nTurtleModel interface exists\nSimpleTurtle exists\n\ntalk-through SimpleTurtle\n\nmotivate tracing\n\ndesign TracingTurtleModel -- is it a TurtleModel? yes, so extend interface\nimplement SmarterTurtle -- extend or delegate?  either way will work, but inheritance is simpler\n\nmotivate the command-line controller\n\ndesign the controller with hard-coded switch with hard-coded method calls (move, turn, trace)\n\nhave some simple tests\n\nadd a new square case\n\ntest??? introduce Commands\n\n\n *\/\n<\/CodeSuffix>","target":"<Target>\npublic SmarterTurtle() {\n    super();\n    lines = new ArrayList<>();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\src\\cs3500\\turtle\\tracingmodel\\SmarterTurtle.java","mask_span":[295,367],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.tracingmodel;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.model.SimpleTurtle;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/\/list of lines traced since this object was created\n  List<Line> lines;\n\n}\n\n\n\/*\n10\/03 : Misc topics (testing, toString, Pile abstractions, Readable\/Appendable)\n\n10\/05: Encapsulation and invariants\n\nHw3\n\n10\/10: columbus day\n\n10\/12: Design problem (Turtles) -- talk through modelling of nouns (get to positions, lines?, turtles, tracing turtles extend simple turtles), get up to Commands as an abstraction, but not undoable ones, set up keyboard map but don't do it yet\n\nHW4 due 10\/14\n\n10\/17: Inheritance and composition\n\n10\/19: Intro to performance, More about performance\n\nHw5 due\n\n10\/24: First exam\n\n10\/26: Design discussion of music  models\n\n10\/31: Class activity: GUI (bad, basic mvc examples), MIDI\n\n11\/02: Adapters\n\nHw6 due on 11\/7\n\n11\/07: Commands\n\n11\/09: Commands (Class activity: adapters (Turtles))\n\n11\/14: Strategy (and decorator?) patterns\n\n\n11\/16: XXX (Command\/Observer)\n\n11\/21: XXX (Singleton\/Iterator\/Proxy)\n\nHw7 due 11\/21\n\n11\/28: Intro to Javascript\n\n11\/30: Javascript inheritance and patterns\n\n12\/05: Exam review\n\n12\/07: Promises\/Android\n\n\n\nadapters, strategy - TicTacToe, command - move, turn, ...square, ...fractal, undoable?\n\n\n\n\nPosition2D exists\nTurtleModel interface exists\nSimpleTurtle exists\n\ntalk-through SimpleTurtle\n\nmotivate tracing\n\ndesign TracingTurtleModel -- is it a TurtleModel? yes, so extend interface\nimplement SmarterTurtle -- extend or delegate?  either way will work, but inheritance is simpler\n\nmotivate the command-line controller\n\ndesign the controller with hard-coded switch with hard-coded method calls (move, turn, trace)\n\nhave some simple tests\n\nadd a new square case\n\ntest??? introduce Commands\n\n\n *\/\n<\/CodeSuffix>","target":"<Target>\npublic List<Line> getLines() {\n    return new ArrayList<>(lines);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\src\\cs3500\\turtle\\tracingmodel\\SmarterTurtle.java","mask_span":[551,620],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle;\n\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.model.SimpleTurtle;\nimport cs3500.turtle.model.TurtleModel;\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\nimport static org.junit.Assert.*;\n\n\/**\n * Created by ashesh on 5\/23\/2016.\n *\/\npublic final class SmarterTurtleTest {\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void testDrawSomething() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    Position2D p1 = t.getPosition();\n    t.save();\n    t.turn(45);\n    t.trace(10);\n    t.retrieve();\n\n    t.save();\n    t.turn(135);\n    t.trace(10);\n    t.retrieve();\n\n    t.save();\n    t.turn(-90);\n    t.trace(10);\n    t.retrieve();\n\n      List<Line> actualLines = t.getLines();\n      List<Line> expectedLines = new ArrayList<>();\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(45.0)), 10.0 * Math.sin(Math.toRadians(45.0)))));\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(135.0)), 10.0 * Math.sin(Math.toRadians(135.0)))));\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(-90)), 10.0 * Math.sin(Math.toRadians(-90)))));\n\n      assertEquals(expectedLines.size(), actualLines.size());\n\n      for (int i = 0; i < expectedLines.size(); i++) {\n        assertEquals(expectedLines.get(i), actualLines.get(i));\n    }\n  }\n\n  @Test\n  public void testInit() {\n    TurtleModel t = new SimpleTurtle();\n\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testMove() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.move(10);\n    assertEquals(10.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTurnOnly() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.turn(10);\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n\n\n    t.turn(-100);\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTurnAndMove() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.turn(30);\n    t.move(10);\n    assertEquals(10.0 * Math.cos(Math.toRadians(30)), t.getPosition().getX(), 0.001);\n    assertEquals(10.0 * Math.sin(Math.toRadians(30)), t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTrace() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    t.trace(10);\n    List<Line> lines = t.getLines();\n    assertEquals(1, lines.size());\n    assertEquals(0.0, lines.get(0).start.getX(), 0.001);\n    assertEquals(0.0, lines.get(0).start.getY(), 0.001);\n    assertEquals(10.0, lines.get(0).end.getX(), 0.001);\n    assertEquals(0.0, lines.get(0).end.getY(), 0.001);\n  }\n\n  @Test\n  public void testMultipleTrace() {\n    TracingTurtleModel t = new SmarterTurtle();\n    List<Line> expectedLines = new ArrayList<>();\n    for (int i = 0; i < 10; i++) {\n      t.turn(90);\n      t.trace(10);\n      t.turn(-90);\n      t.trace(10);\n      t.turn(-90);\n      t.trace(10);\n      t.turn(90);\n      t.trace(10);\n      expectedLines.add(new Line(new Position2D(20 * i, 0),\n                                 new Position2D(20 * i, 10)));\n\n      expectedLines.add(new Line(new Position2D(20 * i, 10),\n                                 new Position2D(20 * i + 10, 10)));\n\n      expectedLines.add(new Line(new Position2D(20 * i + 10, 10),\n                                 new Position2D(20 * i + 10, 0)));\n\n      expectedLines.add(new Line(new Position2D(20 * i + 10, 0),\n                                 new Position2D(20 * i + 20, 0)));\n    }\n\n    List<Line> actualLines = t.getLines();\n    assertEquals(expectedLines.size(), actualLines.size());\n    for (int i = 0; i < expectedLines.size(); i++) {\n      assertEquals(expectedLines.get(i), actualLines.get(i));\n    }\n  }\n\n  @Test\n  public void testPush() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.move(10);\n    Position2D initPosition = t.getPosition();\n    t.save();\n    t.turn(90);\n    t.move(10);\n    t.retrieve();\n    Position2D finalPosition = t.getPosition();\n    assertEquals(initPosition.getX(), finalPosition.getX(), 0.01);\n    assertEquals(finalPosition.getY(), finalPosition.getY(), 0.01);\n  }\n\n}\n<\/CodeSuffix>","target":"<Target>\npublic void testOne() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    t.turn(60);\n    t.trace(19);\n    t.turn(-120);\n    t.trace(19);\n    t.turn(-120);\n    t.trace(19);\n    List<Line> tlines = t.getLines();\n\n    TracingTurtleModel t2 = new SmarterTurtle();\n\n    t2.trace(19);\n    t2.turn(120);\n    t2.trace(19);\n    t2.turn(120);\n    t2.trace(19);\n\n    List<Line> t2lines = t2.getLines();\n\n    assertEquals(tlines.size(), t2lines.size());\n\n    for (Line l : tlines) {\n      assertTrue(t2lines.contains(l));\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\test\\cs3500\\turtle\\SmarterTurtleTest.java","mask_span":[492,1015],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle;\n\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.model.SimpleTurtle;\nimport cs3500.turtle.model.TurtleModel;\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\nimport static org.junit.Assert.*;\n\n\/**\n * Created by ashesh on 5\/23\/2016.\n *\/\npublic final class SmarterTurtleTest {\n\n  @Test\n  public void testOne() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    t.turn(60);\n    t.trace(19);\n    t.turn(-120);\n    t.trace(19);\n    t.turn(-120);\n    t.trace(19);\n    List<Line> tlines = t.getLines();\n\n    TracingTurtleModel t2 = new SmarterTurtle();\n\n    t2.trace(19);\n    t2.turn(120);\n    t2.trace(19);\n    t2.turn(120);\n    t2.trace(19);\n\n    List<Line> t2lines = t2.getLines();\n\n    assertEquals(tlines.size(), t2lines.size());\n\n    for (Line l : tlines) {\n      assertTrue(t2lines.contains(l));\n    }\n  }\n\n  @Test\n  public void testDrawSomething() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    Position2D p1 = t.getPosition();\n    t.save();\n    t.turn(45);\n    t.trace(10);\n    t.retrieve();\n\n    t.save();\n    t.turn(135);\n    t.trace(10);\n    t.retrieve();\n\n    t.save();\n    t.turn(-90);\n    t.trace(10);\n    t.retrieve();\n\n      List<Line> actualLines = t.getLines();\n      List<Line> expectedLines = new ArrayList<>();\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(45.0)), 10.0 * Math.sin(Math.toRadians(45.0)))));\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(135.0)), 10.0 * Math.sin(Math.toRadians(135.0)))));\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(-90)), 10.0 * Math.sin(Math.toRadians(-90)))));\n\n      assertEquals(expectedLines.size(), actualLines.size());\n\n      for (int i = 0; i < expectedLines.size(); i++) {\n        assertEquals(expectedLines.get(i), actualLines.get(i));\n    }\n  }\n\n  @Test\n  public void testInit() {\n    TurtleModel t = new SimpleTurtle();\n\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testMove() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.move(10);\n    assertEquals(10.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTurnOnly() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.turn(10);\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n\n\n    t.turn(-100);\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTurnAndMove() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.turn(30);\n    t.move(10);\n    assertEquals(10.0 * Math.cos(Math.toRadians(30)), t.getPosition().getX(), 0.001);\n    assertEquals(10.0 * Math.sin(Math.toRadians(30)), t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTrace() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    t.trace(10);\n    List<Line> lines = t.getLines();\n    assertEquals(1, lines.size());\n    assertEquals(0.0, lines.get(0).start.getX(), 0.001);\n    assertEquals(0.0, lines.get(0).start.getY(), 0.001);\n    assertEquals(10.0, lines.get(0).end.getX(), 0.001);\n    assertEquals(0.0, lines.get(0).end.getY(), 0.001);\n  }\n\n  @Test\n  public void testMultipleTrace() {\n    TracingTurtleModel t = new SmarterTurtle();\n    List<Line> expectedLines = new ArrayList<>();\n    for (int i = 0; i < 10; i++) {\n      t.turn(90);\n      t.trace(10);\n      t.turn(-90);\n      t.trace(10);\n      t.turn(-90);\n      t.trace(10);\n      t.turn(90);\n      t.trace(10);\n      expectedLines.add(new Line(new Position2D(20 * i, 0),\n                                 new Position2D(20 * i, 10)));\n\n      expectedLines.add(new Line(new Position2D(20 * i, 10),\n                                 new Position2D(20 * i + 10, 10)));\n\n      expectedLines.add(new Line(new Position2D(20 * i + 10, 10),\n                                 new Position2D(20 * i + 10, 0)));\n\n      expectedLines.add(new Line(new Position2D(20 * i + 10, 0),\n                                 new Position2D(20 * i + 20, 0)));\n    }\n\n    List<Line> actualLines = t.getLines();\n    assertEquals(expectedLines.size(), actualLines.size());\n    for (int i = 0; i < expectedLines.size(); i++) {\n      assertEquals(expectedLines.get(i), actualLines.get(i));\n    }\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n<\/CodeSuffix>","target":"<Target>\npublic void testPush() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.move(10);\n    Position2D initPosition = t.getPosition();\n    t.save();\n    t.turn(90);\n    t.move(10);\n    t.retrieve();\n    Position2D finalPosition = t.getPosition();\n    assertEquals(initPosition.getX(), finalPosition.getX(), 0.01);\n    assertEquals(finalPosition.getY(), finalPosition.getY(), 0.01);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\command-1335\\test\\cs3500\\turtle\\SmarterTurtleTest.java","mask_span":[4771,5150],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0003] nd print out their sum:\n\nimport java.util.Scanner;\n\npublic class SimpleCalc1 {\n  public static void main(String[] args) {\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", num1 + num2);\n  }\n}\n(A Scanner is a utility class that makes it much easier for us to read inputs from a source: instead of having to read in text and laboriously try to parse it into numbers or booleans or whatever, we can ask the Scanner to do it for us.)\n\nThe code above is simple, and it obviously works (assuming Scanners do what they’re supposed to do). So how can we test it? What sorts of inputs might a user type in when using this program, and how might they go wrong?\n\nThere are two broad categories of things to test here\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0013] pendable out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) throws IOException {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.append(String.format(\"%d\\n\", calc.add(num1, num2)));\n  }\n}\nNote that this version of go claims that it throws IOException. Because Appendables are more general, they might include things that might fail to write properly. It so happens that using a PrintStream directly will not claim to throw exceptions, but because we’re now using the more general interface, we have to be aware of the possibility. Our main method will have to handle the possible exception:\n\npublic class SimpleCalc5 {\n  public static void main(String[] \n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0005] (String[] args) {\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", new Calculator().add(num1, num2));\n  }\n}\nThis seems strictly worse than before, since we have more code than before, and it doesn’t do anything new. However, now that we can instantiate a Calculator separately from the main method, we can write tests for it:\n\npublic class TestCalc2 {\n  @Test\n  public void testAdd() {\n    assertEquals(7, new Calculator().add(3, 4));\n    assertEquals(12, new Calculator().add(-5, 17));\n  }\n}\nWe now have automated confirmation that our arithmetic is being performed correctly — without needing to involve a user in the testing process. This is important, because users aren’t reliable, and don’t always \n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0006] reproduce the same behavior each time they use a program.\n3 Version 3: A very simple controller\nIf extracting a bit of code out of the main method made it easier to test, then perhaps we should keep trying to extract more code out of it. Let’s extract basically all the remaining code into a separate interface and class:\n\ninterface CalcController {\n  \/\/ Ignore the `throws` clause for now...\n  void go(SimpleCalc calc) throws IOException;\n}\n\nclass CalcController3 implements CalcController {\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main once again to use it:\npublic class SimpleCalc3\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec08;\n\nimport java.util.Scanner;\n\n\/**\n * Demonstrates a simple command-line-based calculator\n *\/\npublic class SimpleCalc1 {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", num1 + num2);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\controller-1030-0129\\src\\cs3500\\lec08\\SimpleCalc1.java","mask_span":[142,345],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0006] reproduce the same behavior each time they use a program.\n3 Version 3: A very simple controller\nIf extracting a bit of code out of the main method made it easier to test, then perhaps we should keep trying to extract more code out of it. Let’s extract basically all the remaining code into a separate interface and class:\n\ninterface CalcController {\n  \/\/ Ignore the `throws` clause for now...\n  void go(SimpleCalc calc) throws IOException;\n}\n\nclass CalcController3 implements CalcController {\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main once again to use it:\npublic class SimpleCalc3\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0005] (String[] args) {\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", new Calculator().add(num1, num2));\n  }\n}\nThis seems strictly worse than before, since we have more code than before, and it doesn’t do anything new. However, now that we can instantiate a Calculator separately from the main method, we can write tests for it:\n\npublic class TestCalc2 {\n  @Test\n  public void testAdd() {\n    assertEquals(7, new Calculator().add(3, 4));\n    assertEquals(12, new Calculator().add(-5, 17));\n  }\n}\nWe now have automated confirmation that our arithmetic is being performed correctly — without needing to involve a user in the testing process. This is important, because users aren’t reliable, and don’t always \n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0004] : is the input being obtained correctly, and is the arithmetic being performed correctly? Let’s tackle the second one, first.\n\n2 Version 2: Extracting a model\nThe first problem with the code above is that we have no programmatic control over it. The inputs come directly from the user — they’re hardcoded to come from System.in — and the arithmetic is performed as a subexpression whose output is sent directly to System.out. Let’s extract that expression into a helper function, which will be the beginnings of our model.\n\ninterface SimpleCalc {\n  int add(int num1, int num2);\n}\n\nclass Calculator implements SimpleCalc {\n  public int add(int num1, int num2) { return num1 + num2; }\n}\nWe can now rewrite our main method to use this class instead:\n\npublic class SimpleCalc2 {\n  public static void main\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0008] plements CalcController {\n  private final InputStream in;\n  private final PrintStream out;\n  CalcController4(InputStream in, PrintStream out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main to use it:\n\npublic class SimpleCalc4 {\n  public static void main(String[] args) {\n    new CalcController4(System.in, System.out).go(new Calculator());\n  }\n}\nNow, we have the ability to instantiate a controller using some other input and output streams, and we can test the controller itself.\n\n4 Version 4: Mocks, part 1—imitation objects for testing\nBecause\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec08;\n\nimport java.util.Scanner;\n\n\/**\n * Demonstrates a simple command-line-based calculator\n *\/\npublic class SimpleCalc2 {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\ninterface ICalculator {\n  int add(int num1, int num2);\n}\n\nclass Calculator implements ICalculator {\n  public int add(int num1, int num2) {\n    return num1 + num2;\n  }\n}\n\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", new Calculator().add(num1, num2));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\controller-1030-0129\\src\\cs3500\\lec08\\SimpleCalc2.java","mask_span":[142,366],"topics":["testing","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0008] plements CalcController {\n  private final InputStream in;\n  private final PrintStream out;\n  CalcController4(InputStream in, PrintStream out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main to use it:\n\npublic class SimpleCalc4 {\n  public static void main(String[] args) {\n    new CalcController4(System.in, System.out).go(new Calculator());\n  }\n}\nNow, we have the ability to instantiate a controller using some other input and output streams, and we can test the controller itself.\n\n4 Version 4: Mocks, part 1—imitation objects for testing\nBecause\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0006] reproduce the same behavior each time they use a program.\n3 Version 3: A very simple controller\nIf extracting a bit of code out of the main method made it easier to test, then perhaps we should keep trying to extract more code out of it. Let’s extract basically all the remaining code into a separate interface and class:\n\ninterface CalcController {\n  \/\/ Ignore the `throws` clause for now...\n  void go(SimpleCalc calc) throws IOException;\n}\n\nclass CalcController3 implements CalcController {\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main once again to use it:\npublic class SimpleCalc3\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0015]  answer. But it does not quite confirm that the controller is passing the inputs through correctly. For instance, the following controller will produce the \"right\" answer, but for the wrong reasons:\n\npublic class BadController implements CalcController {\n  ...\n  public void go(Calculator calc) throws IOException {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt() + 10;\n    num2 = scan.nextInt() - 10;\n    this.out.append(String.format(\"%d\\n\", calc.add(num2, num1)));\n  }\n}\nAs our tests are currently written, we have no way of distinguishing this bizarre controller from a better one. This particular scenario is admittedly contrived, but it’s easy to see scenarios where errors could arise: swapping inputs because we confuse\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0013] pendable out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) throws IOException {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.append(String.format(\"%d\\n\", calc.add(num1, num2)));\n  }\n}\nNote that this version of go claims that it throws IOException. Because Appendables are more general, they might include things that might fail to write properly. It so happens that using a PrintStream directly will not claim to throw exceptions, but because we’re now using the more general interface, we have to be aware of the possibility. Our main method will have to handle the possible exception:\n\npublic class SimpleCalc5 {\n  public static void main(String[] \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec08;\n\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Objects;\nimport java.util.Scanner;\n\n\/**\n * Demonstrates a simple command-line-based calculator\n *\/\npublic class SimpleCalc3 {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\nclass Controller3 implements CalcController {\n  private Readable input;\n  private Appendable output; \/\/all output is stored here\n\n  public Controller3(Readable input, Appendable output) {\n    this.input = input;\n    this.output = output;\n  }\n\n  public void runCalculator(ICalculator calc) throws IOException {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(input);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    String formattedOutput = String.format(\"%d\", calc.add(num1, num2));\n    output.append(formattedOutput);\n  }\n}\n\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    try {\n      new Controller3(new InputStreamReader(System.in), System.out).runCalculator(new Calculator());\n    } catch (IOException ex) {\n      throw new RuntimeException(\"Something went wrong with the I\/O\");\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\controller-1030-0129\\src\\cs3500\\lec08\\SimpleCalc3.java","mask_span":[230,493],"topics":["testing","mvc","gui"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0008] plements CalcController {\n  private final InputStream in;\n  private final PrintStream out;\n  CalcController4(InputStream in, PrintStream out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main to use it:\n\npublic class SimpleCalc4 {\n  public static void main(String[] args) {\n    new CalcController4(System.in, System.out).go(new Calculator());\n  }\n}\nNow, we have the ability to instantiate a controller using some other input and output streams, and we can test the controller itself.\n\n4 Version 4: Mocks, part 1—imitation objects for testing\nBecause\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0006] reproduce the same behavior each time they use a program.\n3 Version 3: A very simple controller\nIf extracting a bit of code out of the main method made it easier to test, then perhaps we should keep trying to extract more code out of it. Let’s extract basically all the remaining code into a separate interface and class:\n\ninterface CalcController {\n  \/\/ Ignore the `throws` clause for now...\n  void go(SimpleCalc calc) throws IOException;\n}\n\nclass CalcController3 implements CalcController {\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main once again to use it:\npublic class SimpleCalc3\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0005] (String[] args) {\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", new Calculator().add(num1, num2));\n  }\n}\nThis seems strictly worse than before, since we have more code than before, and it doesn’t do anything new. However, now that we can instantiate a Calculator separately from the main method, we can write tests for it:\n\npublic class TestCalc2 {\n  @Test\n  public void testAdd() {\n    assertEquals(7, new Calculator().add(3, 4));\n    assertEquals(12, new Calculator().add(-5, 17));\n  }\n}\nWe now have automated confirmation that our arithmetic is being performed correctly — without needing to involve a user in the testing process. This is important, because users aren’t reliable, and don’t always \n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0015]  answer. But it does not quite confirm that the controller is passing the inputs through correctly. For instance, the following controller will produce the \"right\" answer, but for the wrong reasons:\n\npublic class BadController implements CalcController {\n  ...\n  public void go(Calculator calc) throws IOException {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt() + 10;\n    num2 = scan.nextInt() - 10;\n    this.out.append(String.format(\"%d\\n\", calc.add(num2, num1)));\n  }\n}\nAs our tests are currently written, we have no way of distinguishing this bizarre controller from a better one. This particular scenario is admittedly contrived, but it’s easy to see scenarios where errors could arise: swapping inputs because we confuse\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec08;\n\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.util.Objects;\nimport java.util.Scanner;\n\n\/**\n * Demonstrates a simple command-line-based calculator\n *\/\npublic class SimpleCalc4 {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\nclass Controller4 implements CalcController {\n  private final InputStream in;\n  private final PrintStream out;\n  Controller4(InputStream in, PrintStream out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void runCalculator(ICalculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\n\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    new Controller4(System.in, System.out).runCalculator(new Calculator());\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\controller-1030-0129\\src\\cs3500\\lec08\\SimpleCalc4.java","mask_span":[224,344],"topics":["testing","mvc","gui"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0008] plements CalcController {\n  private final InputStream in;\n  private final PrintStream out;\n  CalcController4(InputStream in, PrintStream out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main to use it:\n\npublic class SimpleCalc4 {\n  public static void main(String[] args) {\n    new CalcController4(System.in, System.out).go(new Calculator());\n  }\n}\nNow, we have the ability to instantiate a controller using some other input and output streams, and we can test the controller itself.\n\n4 Version 4: Mocks, part 1—imitation objects for testing\nBecause\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0006] reproduce the same behavior each time they use a program.\n3 Version 3: A very simple controller\nIf extracting a bit of code out of the main method made it easier to test, then perhaps we should keep trying to extract more code out of it. Let’s extract basically all the remaining code into a separate interface and class:\n\ninterface CalcController {\n  \/\/ Ignore the `throws` clause for now...\n  void go(SimpleCalc calc) throws IOException;\n}\n\nclass CalcController3 implements CalcController {\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main once again to use it:\npublic class SimpleCalc3\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0014] args) {\n    try {\n      new CalcController5(new InputStreamReader(System.in), System.out).go(new Calculator());\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\nNow that we’ve generalized our types, our tests get a lot easier. In particular, it’s easy to turn a string into a Readable, and a standard StringBuilder is Appendable1:\n\npublic class TestController5 {\n  @Test\n  public void testGo() throws IOException {\n    StringBuilder out = new StringBuilder();\n    Reader in = new StringReader(\"3 4\");\n    CalcController controller5 = new Controller5(in, out);\n    controller5.go(new Calculator());\n    assertEquals(\"7\\n\", out.toString());\n  }\n}\nMuch cleaner!\n\n6 Mocks, part 2—imitating models\nOur test above is enough to confirm that a user can input some numbers, and get back an\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0013] pendable out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) throws IOException {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.append(String.format(\"%d\\n\", calc.add(num1, num2)));\n  }\n}\nNote that this version of go claims that it throws IOException. Because Appendables are more general, they might include things that might fail to write properly. It so happens that using a PrintStream directly will not claim to throw exceptions, but because we’re now using the more general interface, we have to be aware of the possibility. Our main method will have to handle the possible exception:\n\npublic class SimpleCalc5 {\n  public static void main(String[] \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec08;\n\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Objects;\nimport java.util.Scanner;\n\n\/**\n * Demonstrates a simple command-line-based calculator\n *\/\npublic class SimpleCalc5 {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\nclass Controller5 implements CalcController {\n  final Readable in;\n  final Appendable out;\n  Controller5(Readable in, Appendable out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void runCalculator(ICalculator calc) throws IOException {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt() + 15;\n    num2 = scan.nextInt() - 15;\n    this.out.append(String.format(\"%d\\n\", calc.add(num1, num2)));\n  }\n}\n\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    try {\n      new Controller5(new InputStreamReader(System.in), System.out).runCalculator(new Calculator());\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\controller-1030-0129\\src\\cs3500\\lec08\\SimpleCalc5.java","mask_span":[230,448],"topics":["testing","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0008] plements CalcController {\n  private final InputStream in;\n  private final PrintStream out;\n  CalcController4(InputStream in, PrintStream out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main to use it:\n\npublic class SimpleCalc4 {\n  public static void main(String[] args) {\n    new CalcController4(System.in, System.out).go(new Calculator());\n  }\n}\nNow, we have the ability to instantiate a controller using some other input and output streams, and we can test the controller itself.\n\n4 Version 4: Mocks, part 1—imitation objects for testing\nBecause\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0006] reproduce the same behavior each time they use a program.\n3 Version 3: A very simple controller\nIf extracting a bit of code out of the main method made it easier to test, then perhaps we should keep trying to extract more code out of it. Let’s extract basically all the remaining code into a separate interface and class:\n\ninterface CalcController {\n  \/\/ Ignore the `throws` clause for now...\n  void go(SimpleCalc calc) throws IOException;\n}\n\nclass CalcController3 implements CalcController {\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main once again to use it:\npublic class SimpleCalc3\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0014] args) {\n    try {\n      new CalcController5(new InputStreamReader(System.in), System.out).go(new Calculator());\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\nNow that we’ve generalized our types, our tests get a lot easier. In particular, it’s easy to turn a string into a Readable, and a standard StringBuilder is Appendable1:\n\npublic class TestController5 {\n  @Test\n  public void testGo() throws IOException {\n    StringBuilder out = new StringBuilder();\n    Reader in = new StringReader(\"3 4\");\n    CalcController controller5 = new Controller5(in, out);\n    controller5.go(new Calculator());\n    assertEquals(\"7\\n\", out.toString());\n  }\n}\nMuch cleaner!\n\n6 Mocks, part 2—imitating models\nOur test above is enough to confirm that a user can input some numbers, and get back an\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0013] pendable out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) throws IOException {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.append(String.format(\"%d\\n\", calc.add(num1, num2)));\n  }\n}\nNote that this version of go claims that it throws IOException. Because Appendables are more general, they might include things that might fail to write properly. It so happens that using a PrintStream directly will not claim to throw exceptions, but because we’re now using the more general interface, we have to be aware of the possibility. Our main method will have to handle the possible exception:\n\npublic class SimpleCalc5 {\n  public static void main(String[] \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec08;\n\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Objects;\nimport java.util.Scanner;\n\n\/**\n * Demonstrates a simple command-line-based calculator\n *\/\npublic class SimpleCalc6 {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\nclass Controller6 implements CalcController {\n  final Readable in;\n  final Appendable out;\n  Controller6(Readable in, Appendable out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void runCalculator(ICalculator calc) throws IOException {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    while (true) {\n      switch (scan.next()) {\n        case \"+\":\n          num1 = scan.nextInt();\n          num2 = scan.nextInt();\n          this.out.append(String.format(\"%d\\n\", calc.add(num1, num2)));\n          break;\n        case \"q\":\n          return;\n      }\n    }\n  }\n}\n\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    try {\n      new Controller6(new InputStreamReader(System.in), System.out).runCalculator(new Calculator());\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\controller-1030-0129\\src\\cs3500\\lec08\\SimpleCalc6.java","mask_span":[230,448],"topics":["testing","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0005] (String[] args) {\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", new Calculator().add(num1, num2));\n  }\n}\nThis seems strictly worse than before, since we have more code than before, and it doesn’t do anything new. However, now that we can instantiate a Calculator separately from the main method, we can write tests for it:\n\npublic class TestCalc2 {\n  @Test\n  public void testAdd() {\n    assertEquals(7, new Calculator().add(3, 4));\n    assertEquals(12, new Calculator().add(-5, 17));\n  }\n}\nWe now have automated confirmation that our arithmetic is being performed correctly — without needing to involve a user in the testing process. This is important, because users aren’t reliable, and don’t always \n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0008] plements CalcController {\n  private final InputStream in;\n  private final PrintStream out;\n  CalcController4(InputStream in, PrintStream out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main to use it:\n\npublic class SimpleCalc4 {\n  public static void main(String[] args) {\n    new CalcController4(System.in, System.out).go(new Calculator());\n  }\n}\nNow, we have the ability to instantiate a controller using some other input and output streams, and we can test the controller itself.\n\n4 Version 4: Mocks, part 1—imitation objects for testing\nBecause\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0016] d row coordinates with column coordinates, or forgetting whether our indices were zero-based or one-based, etc. So how could we fix this?\n\nRemember that our model is an interface too! So we can mock up an alternate definition for it. Since our goal for this mock is solely to ensure that the arguments are being passed in correctly, we might not care about the actual result of our method. Here is an intriguing possibility:\n\npublic class ConfirmInputsCalculator implements Calculator {\n  final StringBuilder log;\n  public ConfirmInputsCalculator(StringBuilder log) {\n    this.log = Objects.requireNonNull(log);\n  }\n  public int add(int num1, int num2) {\n    log.append(String.format(\"num1 = %d, num2 = %d\\n\", num1, num2));\n    return 0; \/\/ WE DON'T CARE ABOUT THIS ANSWER\n  }\n}\n\n\/\/ in our tests clas\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0014] args) {\n    try {\n      new CalcController5(new InputStreamReader(System.in), System.out).go(new Calculator());\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\nNow that we’ve generalized our types, our tests get a lot easier. In particular, it’s easy to turn a string into a Readable, and a standard StringBuilder is Appendable1:\n\npublic class TestController5 {\n  @Test\n  public void testGo() throws IOException {\n    StringBuilder out = new StringBuilder();\n    Reader in = new StringReader(\"3 4\");\n    CalcController controller5 = new Controller5(in, out);\n    controller5.go(new Calculator());\n    assertEquals(\"7\\n\", out.toString());\n  }\n}\nMuch cleaner!\n\n6 Mocks, part 2—imitating models\nOur test above is enough to confirm that a user can input some numbers, and get back an\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec08;\n\npublic class MockCalculator implements ICalculator {\n\n  private StringBuilder log;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public int add(int num1, int num2) {\n    log.append(num1 + \" \" + num2);\n    return 0;\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic MockCalculator(StringBuilder log) {\n    this.log = log;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\controller-1030-0129\\test\\cs3500\\lec08\\MockCalculator.java","mask_span":[109,175],"topics":["testing","mvc","gui"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0014] args) {\n    try {\n      new CalcController5(new InputStreamReader(System.in), System.out).go(new Calculator());\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\nNow that we’ve generalized our types, our tests get a lot easier. In particular, it’s easy to turn a string into a Readable, and a standard StringBuilder is Appendable1:\n\npublic class TestController5 {\n  @Test\n  public void testGo() throws IOException {\n    StringBuilder out = new StringBuilder();\n    Reader in = new StringReader(\"3 4\");\n    CalcController controller5 = new Controller5(in, out);\n    controller5.go(new Calculator());\n    assertEquals(\"7\\n\", out.toString());\n  }\n}\nMuch cleaner!\n\n6 Mocks, part 2—imitating models\nOur test above is enough to confirm that a user can input some numbers, and get back an\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0017] s:\n@Test\npublic void testInputs() throws IOException {\n  Reader in = new StringReader(\"3 4\");\n  StringBuilder dontCareOutput = new StringBuilder();\n  CalcController controller5 = new Controller5(in, dontCareOutput);\n\n  StringBuilder log = new StringBuilder();\n  Calculator calc = new ConfirmInputsCalculator(log);\n\n  controller5.go(calc);\n  assertEquals(\"num1 = 3, num2 = 4\\n\", log.toString());\n}\nNote carefully what this test does and does not do: it does not check that the output of the model is correct! It only checks that the model has received inputs that we expect from the controller. And yet this test will distinguish the BadController implementation from the others. We’ve now resolved the dangling testing problem alluded to all the way at the start of these notes.\n\nMocks aren’t just us\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0005] (String[] args) {\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", new Calculator().add(num1, num2));\n  }\n}\nThis seems strictly worse than before, since we have more code than before, and it doesn’t do anything new. However, now that we can instantiate a Calculator separately from the main method, we can write tests for it:\n\npublic class TestCalc2 {\n  @Test\n  public void testAdd() {\n    assertEquals(7, new Calculator().add(3, 4));\n    assertEquals(12, new Calculator().add(-5, 17));\n  }\n}\nWe now have automated confirmation that our arithmetic is being performed correctly — without needing to involve a user in the testing process. This is important, because users aren’t reliable, and don’t always \n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0022] controller another empty StringBuilder to use as output, we can compare its value to our expected one, and thereby test our controller:\nvoid testRun(Model model, Interaction... interactions) throws IOException {\n  StringBuilder fakeUserInput = new StringBuilder();\n  StringBuilder expectedOutput = new StringBuilder();\n\n  for (Interaction interaction : interactions) {\n    interaction.apply(fakeUserInput, expectedOutput);\n  }\n\n  StringReader input = new StringReader(fakeUserInput.toString());\n  StringBuilder actualOutput = new StringBuilder();\n\n  Controller controller = new Controller(model, input, actualOutput);\n  controller.run();\n\n  assertEquals(expectedOutput.toString(), actualOutput.toString());\n}\n(We pass in a model rather than a controller because we need to construct the controller in\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec08;\n\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.io.StringReader;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n\npublic class TestCalculator2 {\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void testController() {\n    \/\/I can't even enter input!!\n    \/\/Answer: Have the controller take in a Readable\n    \/\/  And in the test, create a StringReader with the input you want\n    Readable input = new StringReader(\"3\\n4\\n\");\n    \/\/For output: Have the controller take in an Appendable\n    \/\/  And in the test, create a StringBuilder to store that output...\n    StringBuilder output = new StringBuilder();\n    Controller3 controller = new Controller3(input, output);\n    try {\n      controller.runCalculator(new Calculator());\n      \/\/... We can use toString on the builder to get that output.\n      \/\/ And we can do whatever asserts we want on it!\n      assertEquals(\"7\", output.toString());\n      \/\/What do i assert here? The program just ends...\n    } catch (IOException ex) {\n      fail(\"I\/O error occured when it shouldn't\");\n    }\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void testAdd() {\n    assertEquals(7, new Calculator().add(3, 4));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\controller-1030-0129\\test\\cs3500\\lec08\\TestCalculator2.java","mask_span":[229,305],"topics":["testing","mvc","gui"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0014] args) {\n    try {\n      new CalcController5(new InputStreamReader(System.in), System.out).go(new Calculator());\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\nNow that we’ve generalized our types, our tests get a lot easier. In particular, it’s easy to turn a string into a Readable, and a standard StringBuilder is Appendable1:\n\npublic class TestController5 {\n  @Test\n  public void testGo() throws IOException {\n    StringBuilder out = new StringBuilder();\n    Reader in = new StringReader(\"3 4\");\n    CalcController controller5 = new Controller5(in, out);\n    controller5.go(new Calculator());\n    assertEquals(\"7\\n\", out.toString());\n  }\n}\nMuch cleaner!\n\n6 Mocks, part 2—imitating models\nOur test above is enough to confirm that a user can input some numbers, and get back an\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0017] s:\n@Test\npublic void testInputs() throws IOException {\n  Reader in = new StringReader(\"3 4\");\n  StringBuilder dontCareOutput = new StringBuilder();\n  CalcController controller5 = new Controller5(in, dontCareOutput);\n\n  StringBuilder log = new StringBuilder();\n  Calculator calc = new ConfirmInputsCalculator(log);\n\n  controller5.go(calc);\n  assertEquals(\"num1 = 3, num2 = 4\\n\", log.toString());\n}\nNote carefully what this test does and does not do: it does not check that the output of the model is correct! It only checks that the model has received inputs that we expect from the controller. And yet this test will distinguish the BadController implementation from the others. We’ve now resolved the dangling testing problem alluded to all the way at the start of these notes.\n\nMocks aren’t just us\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0008] plements CalcController {\n  private final InputStream in;\n  private final PrintStream out;\n  CalcController4(InputStream in, PrintStream out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main to use it:\n\npublic class SimpleCalc4 {\n  public static void main(String[] args) {\n    new CalcController4(System.in, System.out).go(new Calculator());\n  }\n}\nNow, we have the ability to instantiate a controller using some other input and output streams, and we can test the controller itself.\n\n4 Version 4: Mocks, part 1—imitation objects for testing\nBecause\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0005] (String[] args) {\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", new Calculator().add(num1, num2));\n  }\n}\nThis seems strictly worse than before, since we have more code than before, and it doesn’t do anything new. However, now that we can instantiate a Calculator separately from the main method, we can write tests for it:\n\npublic class TestCalc2 {\n  @Test\n  public void testAdd() {\n    assertEquals(7, new Calculator().add(3, 4));\n    assertEquals(12, new Calculator().add(-5, 17));\n  }\n}\nWe now have automated confirmation that our arithmetic is being performed correctly — without needing to involve a user in the testing process. This is important, because users aren’t reliable, and don’t always \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec08;\n\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\n\npublic class TestController5 {\n\n  \/\/integration test: a test to check behavior of components working together\n  @Test\n  public void testRunCalculator() throws Exception {\n    StringBuffer out = new StringBuffer();\n    Reader in = new StringReader(\"3 4\");\n    CalcController controller5 = new Controller5(in, out);\n    controller5.runCalculator(new Calculator());\n    assertEquals(\"7\\n\", out.toString());\n  }\n\n  \/\/unit test for the controller! helps check one of the jobs of the controller,\n  \/\/to pass input from the user correctly to the model as specified by the program\n  @Test\n  public void testControllerCorrectlyCallsAdd() throws IOException {\n    Readable input = new StringReader(\"3\\n4\\n\");\n    StringBuilder output = new StringBuilder();\n    StringBuilder log = new StringBuilder();\n    CalcController controller = new Controller5(input, output);\n    controller.runCalculator(new MockCalculator(log));\n    \/\/Want to assert we get \"3 4\" from the fake model\n    assertEquals(\"3 4\", log.toString());\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void testFailingAppendable() {\n    Readable input = new StringReader(\"3 4\");\n    Appendable output = new FailingAppendable();\n    CalcController controller = new Controller5(input, output);\n    assertThrows(IOException.class,\n        () -> controller.runCalculator(new Calculator()));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\controller-1030-0129\\test\\cs3500\\lec08\\TestController5.java","mask_span":[1240,1535],"topics":["testing","mvc","gui"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0003] nd print out their sum:\n\nimport java.util.Scanner;\n\npublic class SimpleCalc1 {\n  public static void main(String[] args) {\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", num1 + num2);\n  }\n}\n(A Scanner is a utility class that makes it much easier for us to read inputs from a source: instead of having to read in text and laboriously try to parse it into numbers or booleans or whatever, we can ask the Scanner to do it for us.)\n\nThe code above is simple, and it obviously works (assuming Scanners do what they’re supposed to do). So how can we test it? What sorts of inputs might a user type in when using this program, and how might they go wrong?\n\nThere are two broad categories of things to test here\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0013] pendable out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) throws IOException {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.append(String.format(\"%d\\n\", calc.add(num1, num2)));\n  }\n}\nNote that this version of go claims that it throws IOException. Because Appendables are more general, they might include things that might fail to write properly. It so happens that using a PrintStream directly will not claim to throw exceptions, but because we’re now using the more general interface, we have to be aware of the possibility. Our main method will have to handle the possible exception:\n\npublic class SimpleCalc5 {\n  public static void main(String[] \n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0005] (String[] args) {\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", new Calculator().add(num1, num2));\n  }\n}\nThis seems strictly worse than before, since we have more code than before, and it doesn’t do anything new. However, now that we can instantiate a Calculator separately from the main method, we can write tests for it:\n\npublic class TestCalc2 {\n  @Test\n  public void testAdd() {\n    assertEquals(7, new Calculator().add(3, 4));\n    assertEquals(12, new Calculator().add(-5, 17));\n  }\n}\nWe now have automated confirmation that our arithmetic is being performed correctly — without needing to involve a user in the testing process. This is important, because users aren’t reliable, and don’t always \n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0006] reproduce the same behavior each time they use a program.\n3 Version 3: A very simple controller\nIf extracting a bit of code out of the main method made it easier to test, then perhaps we should keep trying to extract more code out of it. Let’s extract basically all the remaining code into a separate interface and class:\n\ninterface CalcController {\n  \/\/ Ignore the `throws` clause for now...\n  void go(SimpleCalc calc) throws IOException;\n}\n\nclass CalcController3 implements CalcController {\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main once again to use it:\npublic class SimpleCalc3\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec08;\n\nimport java.util.Scanner;\n\n\/**\n * Demonstrates a simple command-line-based calculator\n *\/\npublic class SimpleCalc1 {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", num1 + num2);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\controller-1335-0129\\src\\cs3500\\lec08\\SimpleCalc1.java","mask_span":[142,345],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0006] reproduce the same behavior each time they use a program.\n3 Version 3: A very simple controller\nIf extracting a bit of code out of the main method made it easier to test, then perhaps we should keep trying to extract more code out of it. Let’s extract basically all the remaining code into a separate interface and class:\n\ninterface CalcController {\n  \/\/ Ignore the `throws` clause for now...\n  void go(SimpleCalc calc) throws IOException;\n}\n\nclass CalcController3 implements CalcController {\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main once again to use it:\npublic class SimpleCalc3\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0005] (String[] args) {\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", new Calculator().add(num1, num2));\n  }\n}\nThis seems strictly worse than before, since we have more code than before, and it doesn’t do anything new. However, now that we can instantiate a Calculator separately from the main method, we can write tests for it:\n\npublic class TestCalc2 {\n  @Test\n  public void testAdd() {\n    assertEquals(7, new Calculator().add(3, 4));\n    assertEquals(12, new Calculator().add(-5, 17));\n  }\n}\nWe now have automated confirmation that our arithmetic is being performed correctly — without needing to involve a user in the testing process. This is important, because users aren’t reliable, and don’t always \n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0004] : is the input being obtained correctly, and is the arithmetic being performed correctly? Let’s tackle the second one, first.\n\n2 Version 2: Extracting a model\nThe first problem with the code above is that we have no programmatic control over it. The inputs come directly from the user — they’re hardcoded to come from System.in — and the arithmetic is performed as a subexpression whose output is sent directly to System.out. Let’s extract that expression into a helper function, which will be the beginnings of our model.\n\ninterface SimpleCalc {\n  int add(int num1, int num2);\n}\n\nclass Calculator implements SimpleCalc {\n  public int add(int num1, int num2) { return num1 + num2; }\n}\nWe can now rewrite our main method to use this class instead:\n\npublic class SimpleCalc2 {\n  public static void main\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0008] plements CalcController {\n  private final InputStream in;\n  private final PrintStream out;\n  CalcController4(InputStream in, PrintStream out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main to use it:\n\npublic class SimpleCalc4 {\n  public static void main(String[] args) {\n    new CalcController4(System.in, System.out).go(new Calculator());\n  }\n}\nNow, we have the ability to instantiate a controller using some other input and output streams, and we can test the controller itself.\n\n4 Version 4: Mocks, part 1—imitation objects for testing\nBecause\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec08;\n\nimport java.util.Scanner;\n\n\/**\n * Demonstrates a simple command-line-based calculator\n *\/\npublic class SimpleCalc2 {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\ninterface ICalculator {\n  int add(int num1, int num2);\n}\n\nclass Calculator implements ICalculator {\n  public int add(int num1, int num2) {\n    return num1 + num2;\n  }\n}\n\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", new Calculator().add(num1, num2));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\controller-1335-0129\\src\\cs3500\\lec08\\SimpleCalc2.java","mask_span":[142,366],"topics":["testing","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0008] plements CalcController {\n  private final InputStream in;\n  private final PrintStream out;\n  CalcController4(InputStream in, PrintStream out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main to use it:\n\npublic class SimpleCalc4 {\n  public static void main(String[] args) {\n    new CalcController4(System.in, System.out).go(new Calculator());\n  }\n}\nNow, we have the ability to instantiate a controller using some other input and output streams, and we can test the controller itself.\n\n4 Version 4: Mocks, part 1—imitation objects for testing\nBecause\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0006] reproduce the same behavior each time they use a program.\n3 Version 3: A very simple controller\nIf extracting a bit of code out of the main method made it easier to test, then perhaps we should keep trying to extract more code out of it. Let’s extract basically all the remaining code into a separate interface and class:\n\ninterface CalcController {\n  \/\/ Ignore the `throws` clause for now...\n  void go(SimpleCalc calc) throws IOException;\n}\n\nclass CalcController3 implements CalcController {\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main once again to use it:\npublic class SimpleCalc3\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0013] pendable out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) throws IOException {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.append(String.format(\"%d\\n\", calc.add(num1, num2)));\n  }\n}\nNote that this version of go claims that it throws IOException. Because Appendables are more general, they might include things that might fail to write properly. It so happens that using a PrintStream directly will not claim to throw exceptions, but because we’re now using the more general interface, we have to be aware of the possibility. Our main method will have to handle the possible exception:\n\npublic class SimpleCalc5 {\n  public static void main(String[] \n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0015]  answer. But it does not quite confirm that the controller is passing the inputs through correctly. For instance, the following controller will produce the \"right\" answer, but for the wrong reasons:\n\npublic class BadController implements CalcController {\n  ...\n  public void go(Calculator calc) throws IOException {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt() + 10;\n    num2 = scan.nextInt() - 10;\n    this.out.append(String.format(\"%d\\n\", calc.add(num2, num1)));\n  }\n}\nAs our tests are currently written, we have no way of distinguishing this bizarre controller from a better one. This particular scenario is admittedly contrived, but it’s easy to see scenarios where errors could arise: swapping inputs because we confuse\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec08;\n\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Objects;\nimport java.util.Scanner;\n\n\/**\n * Demonstrates a simple command-line-based calculator\n *\/\npublic class SimpleCalc3 {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\nclass Controller3 implements CalcController {\n  private Readable input;\n  private Appendable output;\n\n  public Controller3(Readable input, Appendable output) {\n    this.input = input;\n    this.output = output;\n  }\n\n  public void runCalculator(ICalculator calc) throws IOException {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(input);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    String formattedOutput = String.format(\"%d\", calc.add(num1, num2));\n    output.append(formattedOutput);\n  }\n}\n\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    try {\n      new Controller3(new InputStreamReader(System.in), System.out)\n          .runCalculator(new Calculator());\n    } catch (IOException ex) {\n      throw new RuntimeException(\"Something has gone wrong\");\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\controller-1335-0129\\src\\cs3500\\lec08\\SimpleCalc3.java","mask_span":[230,495],"topics":["testing","mvc","gui"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0008] plements CalcController {\n  private final InputStream in;\n  private final PrintStream out;\n  CalcController4(InputStream in, PrintStream out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main to use it:\n\npublic class SimpleCalc4 {\n  public static void main(String[] args) {\n    new CalcController4(System.in, System.out).go(new Calculator());\n  }\n}\nNow, we have the ability to instantiate a controller using some other input and output streams, and we can test the controller itself.\n\n4 Version 4: Mocks, part 1—imitation objects for testing\nBecause\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0006] reproduce the same behavior each time they use a program.\n3 Version 3: A very simple controller\nIf extracting a bit of code out of the main method made it easier to test, then perhaps we should keep trying to extract more code out of it. Let’s extract basically all the remaining code into a separate interface and class:\n\ninterface CalcController {\n  \/\/ Ignore the `throws` clause for now...\n  void go(SimpleCalc calc) throws IOException;\n}\n\nclass CalcController3 implements CalcController {\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main once again to use it:\npublic class SimpleCalc3\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0005] (String[] args) {\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", new Calculator().add(num1, num2));\n  }\n}\nThis seems strictly worse than before, since we have more code than before, and it doesn’t do anything new. However, now that we can instantiate a Calculator separately from the main method, we can write tests for it:\n\npublic class TestCalc2 {\n  @Test\n  public void testAdd() {\n    assertEquals(7, new Calculator().add(3, 4));\n    assertEquals(12, new Calculator().add(-5, 17));\n  }\n}\nWe now have automated confirmation that our arithmetic is being performed correctly — without needing to involve a user in the testing process. This is important, because users aren’t reliable, and don’t always \n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0015]  answer. But it does not quite confirm that the controller is passing the inputs through correctly. For instance, the following controller will produce the \"right\" answer, but for the wrong reasons:\n\npublic class BadController implements CalcController {\n  ...\n  public void go(Calculator calc) throws IOException {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt() + 10;\n    num2 = scan.nextInt() - 10;\n    this.out.append(String.format(\"%d\\n\", calc.add(num2, num1)));\n  }\n}\nAs our tests are currently written, we have no way of distinguishing this bizarre controller from a better one. This particular scenario is admittedly contrived, but it’s easy to see scenarios where errors could arise: swapping inputs because we confuse\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec08;\n\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.util.Objects;\nimport java.util.Scanner;\n\n\/**\n * Demonstrates a simple command-line-based calculator\n *\/\npublic class SimpleCalc4 {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\nclass Controller4 implements CalcController {\n  private final InputStream in;\n  private final PrintStream out;\n  Controller4(InputStream in, PrintStream out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void runCalculator(ICalculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\n\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    new Controller4(System.in, System.out).runCalculator(new Calculator());\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\controller-1335-0129\\src\\cs3500\\lec08\\SimpleCalc4.java","mask_span":[224,344],"topics":["testing","mvc","gui"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0008] plements CalcController {\n  private final InputStream in;\n  private final PrintStream out;\n  CalcController4(InputStream in, PrintStream out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main to use it:\n\npublic class SimpleCalc4 {\n  public static void main(String[] args) {\n    new CalcController4(System.in, System.out).go(new Calculator());\n  }\n}\nNow, we have the ability to instantiate a controller using some other input and output streams, and we can test the controller itself.\n\n4 Version 4: Mocks, part 1—imitation objects for testing\nBecause\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0006] reproduce the same behavior each time they use a program.\n3 Version 3: A very simple controller\nIf extracting a bit of code out of the main method made it easier to test, then perhaps we should keep trying to extract more code out of it. Let’s extract basically all the remaining code into a separate interface and class:\n\ninterface CalcController {\n  \/\/ Ignore the `throws` clause for now...\n  void go(SimpleCalc calc) throws IOException;\n}\n\nclass CalcController3 implements CalcController {\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main once again to use it:\npublic class SimpleCalc3\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0013] pendable out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) throws IOException {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.append(String.format(\"%d\\n\", calc.add(num1, num2)));\n  }\n}\nNote that this version of go claims that it throws IOException. Because Appendables are more general, they might include things that might fail to write properly. It so happens that using a PrintStream directly will not claim to throw exceptions, but because we’re now using the more general interface, we have to be aware of the possibility. Our main method will have to handle the possible exception:\n\npublic class SimpleCalc5 {\n  public static void main(String[] \n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0014] args) {\n    try {\n      new CalcController5(new InputStreamReader(System.in), System.out).go(new Calculator());\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\nNow that we’ve generalized our types, our tests get a lot easier. In particular, it’s easy to turn a string into a Readable, and a standard StringBuilder is Appendable1:\n\npublic class TestController5 {\n  @Test\n  public void testGo() throws IOException {\n    StringBuilder out = new StringBuilder();\n    Reader in = new StringReader(\"3 4\");\n    CalcController controller5 = new Controller5(in, out);\n    controller5.go(new Calculator());\n    assertEquals(\"7\\n\", out.toString());\n  }\n}\nMuch cleaner!\n\n6 Mocks, part 2—imitating models\nOur test above is enough to confirm that a user can input some numbers, and get back an\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec08;\n\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Objects;\nimport java.util.Scanner;\n\n\/**\n * Demonstrates a simple command-line-based calculator\n *\/\npublic class SimpleCalc5 {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\nclass Controller5 implements CalcController {\n  final Readable in;\n  final Appendable out;\n  Controller5(Readable in, Appendable out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void runCalculator(ICalculator calc) throws IOException {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt() + 17;\n    num2 = scan.nextInt() - 17;\n    this.out.append(String.format(\"%d\\n\", calc.add(num1, num2)));\n  }\n}\n\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    try {\n      new Controller5(new InputStreamReader(System.in), System.out).runCalculator(new Calculator());\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\controller-1335-0129\\src\\cs3500\\lec08\\SimpleCalc5.java","mask_span":[230,448],"topics":["testing","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0008] plements CalcController {\n  private final InputStream in;\n  private final PrintStream out;\n  CalcController4(InputStream in, PrintStream out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main to use it:\n\npublic class SimpleCalc4 {\n  public static void main(String[] args) {\n    new CalcController4(System.in, System.out).go(new Calculator());\n  }\n}\nNow, we have the ability to instantiate a controller using some other input and output streams, and we can test the controller itself.\n\n4 Version 4: Mocks, part 1—imitation objects for testing\nBecause\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0006] reproduce the same behavior each time they use a program.\n3 Version 3: A very simple controller\nIf extracting a bit of code out of the main method made it easier to test, then perhaps we should keep trying to extract more code out of it. Let’s extract basically all the remaining code into a separate interface and class:\n\ninterface CalcController {\n  \/\/ Ignore the `throws` clause for now...\n  void go(SimpleCalc calc) throws IOException;\n}\n\nclass CalcController3 implements CalcController {\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main once again to use it:\npublic class SimpleCalc3\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0014] args) {\n    try {\n      new CalcController5(new InputStreamReader(System.in), System.out).go(new Calculator());\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\nNow that we’ve generalized our types, our tests get a lot easier. In particular, it’s easy to turn a string into a Readable, and a standard StringBuilder is Appendable1:\n\npublic class TestController5 {\n  @Test\n  public void testGo() throws IOException {\n    StringBuilder out = new StringBuilder();\n    Reader in = new StringReader(\"3 4\");\n    CalcController controller5 = new Controller5(in, out);\n    controller5.go(new Calculator());\n    assertEquals(\"7\\n\", out.toString());\n  }\n}\nMuch cleaner!\n\n6 Mocks, part 2—imitating models\nOur test above is enough to confirm that a user can input some numbers, and get back an\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0013] pendable out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) throws IOException {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.append(String.format(\"%d\\n\", calc.add(num1, num2)));\n  }\n}\nNote that this version of go claims that it throws IOException. Because Appendables are more general, they might include things that might fail to write properly. It so happens that using a PrintStream directly will not claim to throw exceptions, but because we’re now using the more general interface, we have to be aware of the possibility. Our main method will have to handle the possible exception:\n\npublic class SimpleCalc5 {\n  public static void main(String[] \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec08;\n\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Objects;\nimport java.util.Scanner;\n\n\/**\n * Demonstrates a simple command-line-based calculator\n *\/\npublic class SimpleCalc6 {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\nclass Controller6 implements CalcController {\n  final Readable in;\n  final Appendable out;\n  Controller6(Readable in, Appendable out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void runCalculator(ICalculator calc) throws IOException {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    while (true) {\n      switch (scan.next()) {\n        case \"+\":\n          num1 = scan.nextInt();\n          num2 = scan.nextInt();\n          this.out.append(String.format(\"%d\\n\", calc.add(num1, num2)));\n          break;\n        case \"q\":\n          return;\n      }\n    }\n  }\n}\n\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    try {\n      new Controller6(new InputStreamReader(System.in), System.out).runCalculator(new Calculator());\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\controller-1335-0129\\src\\cs3500\\lec08\\SimpleCalc6.java","mask_span":[230,448],"topics":["testing","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0005] (String[] args) {\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", new Calculator().add(num1, num2));\n  }\n}\nThis seems strictly worse than before, since we have more code than before, and it doesn’t do anything new. However, now that we can instantiate a Calculator separately from the main method, we can write tests for it:\n\npublic class TestCalc2 {\n  @Test\n  public void testAdd() {\n    assertEquals(7, new Calculator().add(3, 4));\n    assertEquals(12, new Calculator().add(-5, 17));\n  }\n}\nWe now have automated confirmation that our arithmetic is being performed correctly — without needing to involve a user in the testing process. This is important, because users aren’t reliable, and don’t always \n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0014] args) {\n    try {\n      new CalcController5(new InputStreamReader(System.in), System.out).go(new Calculator());\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\nNow that we’ve generalized our types, our tests get a lot easier. In particular, it’s easy to turn a string into a Readable, and a standard StringBuilder is Appendable1:\n\npublic class TestController5 {\n  @Test\n  public void testGo() throws IOException {\n    StringBuilder out = new StringBuilder();\n    Reader in = new StringReader(\"3 4\");\n    CalcController controller5 = new Controller5(in, out);\n    controller5.go(new Calculator());\n    assertEquals(\"7\\n\", out.toString());\n  }\n}\nMuch cleaner!\n\n6 Mocks, part 2—imitating models\nOur test above is enough to confirm that a user can input some numbers, and get back an\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0008] plements CalcController {\n  private final InputStream in;\n  private final PrintStream out;\n  CalcController4(InputStream in, PrintStream out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main to use it:\n\npublic class SimpleCalc4 {\n  public static void main(String[] args) {\n    new CalcController4(System.in, System.out).go(new Calculator());\n  }\n}\nNow, we have the ability to instantiate a controller using some other input and output streams, and we can test the controller itself.\n\n4 Version 4: Mocks, part 1—imitation objects for testing\nBecause\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0023]  the test itself, using the given model.)\n\nThis sort of schematic function is called a test harness: it is the infrastructure by which we can run a variety of structurally-related tests without having to repeat ourselves. (In general, test harnesses can be much more complex...up to, say, being able to detect and run all our tests for us, and produce an easy-to-read report of the results. In other words, JUnit.) Now we merely need to say:\n\ntestRun(new Calculator(),\n  new InputInteraction(\"+ 3 4\\n\"),\n  new PrintInteraction(\"7\"),\n  new InputInteraction(\"+ 5 7\\n\"),\n  new PrintInteraction(\"12\"),\n  new InputInteraction(\"q\\n\"));\nBut we can do better yet!\n\n7.3 Streamlining the code further\nThe definitions for PrintInteraction and InputInteraction are clunky, full of boilerplate that would be nice \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec08;\n\npublic class MockCalculator implements ICalculator {\n  private StringBuilder log;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public int add(int num1, int num2) {\n    log.append(num1 + \" \" + num2);\n    return -10;\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic MockCalculator(StringBuilder log) {\n    this.log = log;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\controller-1335-0129\\test\\cs3500\\lec08\\MockCalculator.java","mask_span":[108,174],"topics":["testing","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0014] args) {\n    try {\n      new CalcController5(new InputStreamReader(System.in), System.out).go(new Calculator());\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\nNow that we’ve generalized our types, our tests get a lot easier. In particular, it’s easy to turn a string into a Readable, and a standard StringBuilder is Appendable1:\n\npublic class TestController5 {\n  @Test\n  public void testGo() throws IOException {\n    StringBuilder out = new StringBuilder();\n    Reader in = new StringReader(\"3 4\");\n    CalcController controller5 = new Controller5(in, out);\n    controller5.go(new Calculator());\n    assertEquals(\"7\\n\", out.toString());\n  }\n}\nMuch cleaner!\n\n6 Mocks, part 2—imitating models\nOur test above is enough to confirm that a user can input some numbers, and get back an\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0017] s:\n@Test\npublic void testInputs() throws IOException {\n  Reader in = new StringReader(\"3 4\");\n  StringBuilder dontCareOutput = new StringBuilder();\n  CalcController controller5 = new Controller5(in, dontCareOutput);\n\n  StringBuilder log = new StringBuilder();\n  Calculator calc = new ConfirmInputsCalculator(log);\n\n  controller5.go(calc);\n  assertEquals(\"num1 = 3, num2 = 4\\n\", log.toString());\n}\nNote carefully what this test does and does not do: it does not check that the output of the model is correct! It only checks that the model has received inputs that we expect from the controller. And yet this test will distinguish the BadController implementation from the others. We’ve now resolved the dangling testing problem alluded to all the way at the start of these notes.\n\nMocks aren’t just us\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0008] plements CalcController {\n  private final InputStream in;\n  private final PrintStream out;\n  CalcController4(InputStream in, PrintStream out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main to use it:\n\npublic class SimpleCalc4 {\n  public static void main(String[] args) {\n    new CalcController4(System.in, System.out).go(new Calculator());\n  }\n}\nNow, we have the ability to instantiate a controller using some other input and output streams, and we can test the controller itself.\n\n4 Version 4: Mocks, part 1—imitation objects for testing\nBecause\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0022] controller another empty StringBuilder to use as output, we can compare its value to our expected one, and thereby test our controller:\nvoid testRun(Model model, Interaction... interactions) throws IOException {\n  StringBuilder fakeUserInput = new StringBuilder();\n  StringBuilder expectedOutput = new StringBuilder();\n\n  for (Interaction interaction : interactions) {\n    interaction.apply(fakeUserInput, expectedOutput);\n  }\n\n  StringReader input = new StringReader(fakeUserInput.toString());\n  StringBuilder actualOutput = new StringBuilder();\n\n  Controller controller = new Controller(model, input, actualOutput);\n  controller.run();\n\n  assertEquals(expectedOutput.toString(), actualOutput.toString());\n}\n(We pass in a model rather than a controller because we need to construct the controller in\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec08;\n\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.io.StringReader;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n\npublic class TestCalculator2 {\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void testController() {\n    \/\/2. How do I give my test input so it runs automatically?\n    \/\/Answer: Make the Controller take in a Readable\n    \/\/  Then create a StringReader in the test.\n    StringReader input = new StringReader(\"3\\n4\\n\");\n\n    \/\/1. How do I even get the output so I can write an assert?\n    \/\/Answer: Make the controller take in an Appendalbe\n    \/\/  Then create a StringBuilder in the test and pass it into the controller.\n    StringBuilder output = new StringBuilder();\n    CalcController controller = new Controller3(input, output);\n    try {\n      controller.runCalculator(new Calculator());\n      assertEquals(\"7\", output.toString());\n    } catch (IOException ex) {\n      fail(\"Sent exception when not expected\");\n    }\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void testAdd() {\n    assertEquals(7, new Calculator().add(3, 4));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\controller-1335-0129\\test\\cs3500\\lec08\\TestCalculator2.java","mask_span":[229,305],"topics":["testing","mvc","gui"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0014] args) {\n    try {\n      new CalcController5(new InputStreamReader(System.in), System.out).go(new Calculator());\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\nNow that we’ve generalized our types, our tests get a lot easier. In particular, it’s easy to turn a string into a Readable, and a standard StringBuilder is Appendable1:\n\npublic class TestController5 {\n  @Test\n  public void testGo() throws IOException {\n    StringBuilder out = new StringBuilder();\n    Reader in = new StringReader(\"3 4\");\n    CalcController controller5 = new Controller5(in, out);\n    controller5.go(new Calculator());\n    assertEquals(\"7\\n\", out.toString());\n  }\n}\nMuch cleaner!\n\n6 Mocks, part 2—imitating models\nOur test above is enough to confirm that a user can input some numbers, and get back an\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0017] s:\n@Test\npublic void testInputs() throws IOException {\n  Reader in = new StringReader(\"3 4\");\n  StringBuilder dontCareOutput = new StringBuilder();\n  CalcController controller5 = new Controller5(in, dontCareOutput);\n\n  StringBuilder log = new StringBuilder();\n  Calculator calc = new ConfirmInputsCalculator(log);\n\n  controller5.go(calc);\n  assertEquals(\"num1 = 3, num2 = 4\\n\", log.toString());\n}\nNote carefully what this test does and does not do: it does not check that the output of the model is correct! It only checks that the model has received inputs that we expect from the controller. And yet this test will distinguish the BadController implementation from the others. We’ve now resolved the dangling testing problem alluded to all the way at the start of these notes.\n\nMocks aren’t just us\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0008] plements CalcController {\n  private final InputStream in;\n  private final PrintStream out;\n  CalcController4(InputStream in, PrintStream out) {\n    this.in = in;\n    this.out = out;\n  }\n  public void go(Calculator calc) {\n    Objects.requireNonNull(calc);\n    int num1, num2;\n    Scanner scan = new Scanner(this.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    this.out.printf(\"%d\", calc.add(num1, num2));\n  }\n}\nand rewrite main to use it:\n\npublic class SimpleCalc4 {\n  public static void main(String[] args) {\n    new CalcController4(System.in, System.out).go(new Calculator());\n  }\n}\nNow, we have the ability to instantiate a controller using some other input and output streams, and we can test the controller itself.\n\n4 Version 4: Mocks, part 1—imitation objects for testing\nBecause\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0005] (String[] args) {\n    int num1, num2;\n    Scanner scan = new Scanner(System.in);\n    num1 = scan.nextInt();\n    num2 = scan.nextInt();\n    System.out.printf(\"%d\", new Calculator().add(num1, num2));\n  }\n}\nThis seems strictly worse than before, since we have more code than before, and it doesn’t do anything new. However, now that we can instantiate a Calculator separately from the main method, we can write tests for it:\n\npublic class TestCalc2 {\n  @Test\n  public void testAdd() {\n    assertEquals(7, new Calculator().add(3, 4));\n    assertEquals(12, new Calculator().add(-5, 17));\n  }\n}\nWe now have automated confirmation that our arithmetic is being performed correctly — without needing to involve a user in the testing process. This is important, because users aren’t reliable, and don’t always \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec08;\n\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\n\npublic class TestController5 {\n\n  \/\/integration test: a test that checks the behavior of components working together\n  @Test\n  public void testRunCalculator() throws Exception {\n    StringBuffer out = new StringBuffer();\n    Reader in = new StringReader(\"3 4\");\n    CalcController controller5 = new Controller5(in, out);\n    controller5.runCalculator(new Calculator());\n    assertEquals(\"7\\n\", out.toString());\n  }\n\n  @Test\n  public void testInputs() throws IOException {\n    StringReader in = new StringReader(\"3 4\");\n    StringBuilder out = new StringBuilder();\n    CalcController controller = new Controller5(in, out);\n    StringBuilder log = new StringBuilder();\n    controller.runCalculator(new MockCalculator(log));\n    assertEquals(\"3 4\", log.toString());\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void testFailingAppendable() {\n    StringReader in = new StringReader(\"3 4\");\n    Appendable out = new FailingAppendable();\n    CalcController controller = new Controller5(in, out);\n    assertThrows(IOException.class,\n        () -> controller.runCalculator(new Calculator()));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\controller-1335-0129\\test\\cs3500\\lec08\\TestController5.java","mask_span":[997,1284],"topics":["testing","mvc","gui"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0016] erhaps it would be useful if the current and all future implementations of Duration could work together seamlessly, including being considered equal if they represent the same length of time. To do this, we need to rewrite the equals method to compare not only to another DurationImpl but to any Duration via its interface. We can do this in this case because inSeconds() is part of the interface and returns sufficient information to test for equality. So we create a more general equals that compares seconds:\n\n@Override\npublic boolean equals(Object that) {\n  if (this == that) {\n    return true;\n  }\n\n  if (! (that instanceof Duration)) {\n    return false;\n  }\n\n  return ((Duration) that).inSeconds() == this.inSeconds();\n}\nWe’re nearly done, but not yet. Above we wrote that equals and hashCode s\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0015]  (this == o) {\n    return true;\n  }\n\n  \/\/ If o isn't the right class then it can't be equal:\n  if (! (o instanceof DurationImpl)) {\n    return false;\n  }\n\n  \/\/ The successful instanceof check means our cast will succeed:\n  DurationImpl that = (DurationImpl) o;\n\n  return this.hours == that.hours\n      && this.minutes == that.minutes\n      && this.seconds == that.seconds;\n}\n\n@Override\npublic int hashCode() {\n  return Objects.hash(hours, minutes, seconds);\n}\nThe static method Objects.hash(Object...) takes any number of arguments, each of which it hashes using that argument’s hashCode() method, and then combining the results in a reasonable way.\nHowever, if we choose to, we can do better. Because Duration is an interface, we should expect that it will be implemented more times in the future. P\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0017] hould always be overridden together (or not at all), and similarly, changing one of them often requires changing the other. A proper hashCode method will return the same hash code for any two Durations that are equal according to the equals method. That means that hashCode should only use as inputs values that are part of the equals comparison, which in this case means we should hash the total seconds:\n\n@Override\npublic int hashCode() {\n  return Long.hashCode(inSeconds());\n}\n2.5 Full circle\nFinally, building the extra flexibility into DurationImpl doesn’t do us any good if future implementations of Duration don’t follow the same rules. So we document how equals and hashCode must work for all implementations of the Duration interface in the interface itself:\n\n\/**\n * Durations, with a resolu\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0013] hat) {\n  return new DurationImpl(this.inSeconds() + that.inSeconds());\n}\n2.4 Standard methods\nBecause Duration extends Comparable<Duration>, we need to implement the compareTo(Duration) method. We could do this by comparing the components, but it’s simpler to compare the total seconds:\n\n@Override\npublic int compareTo(Duration that) {\n  return Long.compare(this.inSeconds(), that.inSeconds());\n}\nNote that the Long class has a static method for comparing primitive, lowercase-ell long values, because primitive values cannot themselves have methods.\nAll classes should override Object.toString() with something reasonable. In this case, asHms is a fine implementation of toString:\n\n@Override\npublic String toString() {\n  return asHms();\n}\nFinally, we need to decide whether to override Object.equals\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\nimport java.util.Objects;\n\npublic abstract class AbstractDuration implements Duration {\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/\/protected means any subclass of this class can see it\n  protected abstract Duration fromSeconds(long seconds);\n\n  @Override\n  public int compareTo(Duration other) {\n    return Long.compare(this.inSeconds(), other.inSeconds());\n  }\n\n  @Override\n  public boolean equals(Object other) {\n    if (!(other instanceof Duration)) {\n      return false;\n    }\n    Duration that = (Duration) other;\n    return this.compareTo(that) == 0;\n    \/\/return this.inSeconds() == that.inSeconds();\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.inSeconds());\n  }\n\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic Duration plus(Duration other) {\n    return fromSeconds(this.inSeconds() + other.inSeconds());\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1030-0115\\src\\cs3500\\durations\\AbstractDuration.java","mask_span":[130,234],"topics":["decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0016] erhaps it would be useful if the current and all future implementations of Duration could work together seamlessly, including being considered equal if they represent the same length of time. To do this, we need to rewrite the equals method to compare not only to another DurationImpl but to any Duration via its interface. We can do this in this case because inSeconds() is part of the interface and returns sufficient information to test for equality. So we create a more general equals that compares seconds:\n\n@Override\npublic boolean equals(Object that) {\n  if (this == that) {\n    return true;\n  }\n\n  if (! (that instanceof Duration)) {\n    return false;\n  }\n\n  return ((Duration) that).inSeconds() == this.inSeconds();\n}\nWe’re nearly done, but not yet. Above we wrote that equals and hashCode s\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0015]  (this == o) {\n    return true;\n  }\n\n  \/\/ If o isn't the right class then it can't be equal:\n  if (! (o instanceof DurationImpl)) {\n    return false;\n  }\n\n  \/\/ The successful instanceof check means our cast will succeed:\n  DurationImpl that = (DurationImpl) o;\n\n  return this.hours == that.hours\n      && this.minutes == that.minutes\n      && this.seconds == that.seconds;\n}\n\n@Override\npublic int hashCode() {\n  return Objects.hash(hours, minutes, seconds);\n}\nThe static method Objects.hash(Object...) takes any number of arguments, each of which it hashes using that argument’s hashCode() method, and then combining the results in a reasonable way.\nHowever, if we choose to, we can do better. Because Duration is an interface, we should expect that it will be implemented more times in the future. P\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0017] hould always be overridden together (or not at all), and similarly, changing one of them often requires changing the other. A proper hashCode method will return the same hash code for any two Durations that are equal according to the equals method. That means that hashCode should only use as inputs values that are part of the equals comparison, which in this case means we should hash the total seconds:\n\n@Override\npublic int hashCode() {\n  return Long.hashCode(inSeconds());\n}\n2.5 Full circle\nFinally, building the extra flexibility into DurationImpl doesn’t do us any good if future implementations of Duration don’t follow the same rules. So we document how equals and hashCode must work for all implementations of the Duration interface in the interface itself:\n\n\/**\n * Durations, with a resolu\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0013] hat) {\n  return new DurationImpl(this.inSeconds() + that.inSeconds());\n}\n2.4 Standard methods\nBecause Duration extends Comparable<Duration>, we need to implement the compareTo(Duration) method. We could do this by comparing the components, but it’s simpler to compare the total seconds:\n\n@Override\npublic int compareTo(Duration that) {\n  return Long.compare(this.inSeconds(), that.inSeconds());\n}\nNote that the Long class has a static method for comparing primitive, lowercase-ell long values, because primitive values cannot themselves have methods.\nAll classes should override Object.toString() with something reasonable. In this case, asHms is a fine implementation of toString:\n\n@Override\npublic String toString() {\n  return asHms();\n}\nFinally, we need to decide whether to override Object.equals\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\nimport java.util.Objects;\n\npublic abstract class AbstractDuration implements Duration {\n\n  @Override\n  public Duration plus(Duration other) {\n    return fromSeconds(this.inSeconds() + other.inSeconds());\n  }\n\n  \/\/protected means any subclass of this class can see it\n  protected abstract Duration fromSeconds(long seconds);\n\n  @Override\n  public int compareTo(Duration other) {\n    return Long.compare(this.inSeconds(), other.inSeconds());\n  }\n\n  @Override\n  public boolean equals(Object other) {\n    if (!(other instanceof Duration)) {\n      return false;\n    }\n    Duration that = (Duration) other;\n    return this.compareTo(that) == 0;\n    \/\/return this.inSeconds() == that.inSeconds();\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic int hashCode() {\n    return Objects.hash(this.inSeconds());\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1030-0115\\src\\cs3500\\durations\\AbstractDuration.java","mask_span":[736,806],"topics":["decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0010] onicalize in the constructor. (Furthermore, a real class is likely to have additional methods that require the canonicalized components.) Thus, we add code to the constructor to canonicalize the representation:\n\nif (seconds > 59) {\n  minutes += seconds \/ 60;\n  seconds %= 60;\n}\n\nif (minutes > 59) {\n  hours += minutes \/ 60;\n  minutes %= 60;\n}\nThis ensures that the seconds and minutes never exceed 59 (because if they did, we would add to the minutes or hours, respectively, instead).\n2.3 Domain-specific methods\nThe observation methods are simple:\n\n@Override\npublic long inSeconds() {\n  return 3600 * hours + 60 * minutes + seconds;\n}\n\n@Override\npublic String asHms() {\n  return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n}\nIn a Java format string, the code %d means that the next param\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0012] (long inSeconds) {\n  if (inSeconds < 0) {\n    throw new IllegalArgumentException(\"must be non-negative\");\n  }\n\n  this.seconds = (int) (inSeconds % 60);\n  this.minutes = (int) (inSeconds \/ 60 % 60);\n  this.hours = (int) (inSeconds \/ 3600);  \/\/ overflow...\n}\nIn each assignment above, (int) is a numeric cast that converts from type long, in this case, to type int. Because the range of long is larger, not all longs can be represented correctly as ints, and instead will overflow, producing the wrong answer. The first two casts are guaranteed not to overflow, since x % 60 is between 0 and 59, plenty small to fit in an int, for any x. However, if inSeconds is large enough6 then the resulting object won’t be right.\n\nWith the new constructor, plus is easy:\n\n@Override\npublic Duration plus(Duration t\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0008]  so:\n\n\/**\n * Constructs a duration in terms of its length in hours, minutes, and\n * seconds.\n *\n * @param hours the number of hours\n * @param minutes the number of minutes\n * @param seconds the number of seconds\n * @throws IllegalArgumentException if any argument is negative\n *\/\npublic DurationImpl(int hours, int minutes, int seconds) {\n  if (hours < 0 || minutes < 0 || seconds < 0) {\n    throw new IllegalArgumentException(\"must be non-negative\");\n  }\n\n  \/\/ Insert omitted code from below \/\/\n\n  this.hours = hours;\n  this.minutes = minutes;\n  this.seconds = seconds;\n}\nThis constructor checks that each parameter is non-negative (as it makes sense in this context), to ensure that durations are not negative (this is called an invariant). However, this is not enough. Consider the following durat\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0013] hat) {\n  return new DurationImpl(this.inSeconds() + that.inSeconds());\n}\n2.4 Standard methods\nBecause Duration extends Comparable<Duration>, we need to implement the compareTo(Duration) method. We could do this by comparing the components, but it’s simpler to compare the total seconds:\n\n@Override\npublic int compareTo(Duration that) {\n  return Long.compare(this.inSeconds(), that.inSeconds());\n}\nNote that the Long class has a static method for comparing primitive, lowercase-ell long values, because primitive values cannot themselves have methods.\nAll classes should override Object.toString() with something reasonable. In this case, asHms is a fine implementation of toString:\n\n@Override\npublic String toString() {\n  return asHms();\n}\nFinally, we need to decide whether to override Object.equals\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\n\/\/NOTE: Implemented some of the other methods to focus on the important details next lecture\n\/\/      Mainly equals and plus.\n\nimport java.util.Objects;\n\npublic class HMSDuration extends AbstractDuration {\n\n  private int hours;\n  private int minutes;\n  private int seconds;\n\n  \/**\n   * Creates a non-negative duration with the given hours, minutes, seconds\n   * @param hours number of hours in the duration\n   * @param minutes number of minutes in the duration\n   * @param seconds number of seconds in the duration\n   * @throws IllegalArgumentException if hours, minutes, or seconds < 0\n   *\/\n  public HMSDuration(int hours, int minutes, int seconds) throws IllegalArgumentException {\n    if (hours < 0 || minutes < 0 || seconds < 0) {\n      throw new IllegalArgumentException(\"Bad arguments\");\n    }\n\n    this.hours = hours;\n    this.minutes = minutes;\n    this.seconds = seconds;\n    if(seconds >= 60) {\n      this.minutes += seconds \/ 60;\n      this.seconds = seconds % 60; \/\/Get the remainder of a division\n    }\n\n    if(minutes >= 60) {\n      this.hours += this.minutes \/ 60;\n      this.minutes = this.minutes % 60;\n    }\n\n  }\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public long inSeconds() {\n    return this.hours * 3600 + this.minutes * 60 + this.seconds;\n  }\n\n  @Override\n  public String asHms() {\n    int hours = this.hours;\n    int minutes = this.minutes;\n    int seconds = this.seconds;\n    return String.format(\"%02d:%02d:%02d\", hours, minutes, seconds);\n  }\n\n  @Override\n  protected Duration fromSeconds(long seconds) {\n    return new HMSDuration(seconds);\n  }\n\n\n\n\n\n\n\n\n\n\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic HMSDuration(long seconds) {\n    \/\/... pretend we implemented it\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1030-0115\\src\\cs3500\\durations\\HMSDuration.java","mask_span":[1161,1235],"topics":["decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0010] onicalize in the constructor. (Furthermore, a real class is likely to have additional methods that require the canonicalized components.) Thus, we add code to the constructor to canonicalize the representation:\n\nif (seconds > 59) {\n  minutes += seconds \/ 60;\n  seconds %= 60;\n}\n\nif (minutes > 59) {\n  hours += minutes \/ 60;\n  minutes %= 60;\n}\nThis ensures that the seconds and minutes never exceed 59 (because if they did, we would add to the minutes or hours, respectively, instead).\n2.3 Domain-specific methods\nThe observation methods are simple:\n\n@Override\npublic long inSeconds() {\n  return 3600 * hours + 60 * minutes + seconds;\n}\n\n@Override\npublic String asHms() {\n  return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n}\nIn a Java format string, the code %d means that the next param\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0012] (long inSeconds) {\n  if (inSeconds < 0) {\n    throw new IllegalArgumentException(\"must be non-negative\");\n  }\n\n  this.seconds = (int) (inSeconds % 60);\n  this.minutes = (int) (inSeconds \/ 60 % 60);\n  this.hours = (int) (inSeconds \/ 3600);  \/\/ overflow...\n}\nIn each assignment above, (int) is a numeric cast that converts from type long, in this case, to type int. Because the range of long is larger, not all longs can be represented correctly as ints, and instead will overflow, producing the wrong answer. The first two casts are guaranteed not to overflow, since x % 60 is between 0 and 59, plenty small to fit in an int, for any x. However, if inSeconds is large enough6 then the resulting object won’t be right.\n\nWith the new constructor, plus is easy:\n\n@Override\npublic Duration plus(Duration t\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0008]  so:\n\n\/**\n * Constructs a duration in terms of its length in hours, minutes, and\n * seconds.\n *\n * @param hours the number of hours\n * @param minutes the number of minutes\n * @param seconds the number of seconds\n * @throws IllegalArgumentException if any argument is negative\n *\/\npublic DurationImpl(int hours, int minutes, int seconds) {\n  if (hours < 0 || minutes < 0 || seconds < 0) {\n    throw new IllegalArgumentException(\"must be non-negative\");\n  }\n\n  \/\/ Insert omitted code from below \/\/\n\n  this.hours = hours;\n  this.minutes = minutes;\n  this.seconds = seconds;\n}\nThis constructor checks that each parameter is non-negative (as it makes sense in this context), to ensure that durations are not negative (this is called an invariant). However, this is not enough. Consider the following durat\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0013] hat) {\n  return new DurationImpl(this.inSeconds() + that.inSeconds());\n}\n2.4 Standard methods\nBecause Duration extends Comparable<Duration>, we need to implement the compareTo(Duration) method. We could do this by comparing the components, but it’s simpler to compare the total seconds:\n\n@Override\npublic int compareTo(Duration that) {\n  return Long.compare(this.inSeconds(), that.inSeconds());\n}\nNote that the Long class has a static method for comparing primitive, lowercase-ell long values, because primitive values cannot themselves have methods.\nAll classes should override Object.toString() with something reasonable. In this case, asHms is a fine implementation of toString:\n\n@Override\npublic String toString() {\n  return asHms();\n}\nFinally, we need to decide whether to override Object.equals\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\n\/\/NOTE: Implemented some of the other methods to focus on the important details next lecture\n\/\/      Mainly equals and plus.\n\nimport java.util.Objects;\n\npublic class HMSDuration extends AbstractDuration {\n\n  private int hours;\n  private int minutes;\n  private int seconds;\n\n  \/**\n   * Creates a non-negative duration with the given hours, minutes, seconds\n   * @param hours number of hours in the duration\n   * @param minutes number of minutes in the duration\n   * @param seconds number of seconds in the duration\n   * @throws IllegalArgumentException if hours, minutes, or seconds < 0\n   *\/\n  public HMSDuration(int hours, int minutes, int seconds) throws IllegalArgumentException {\n    if (hours < 0 || minutes < 0 || seconds < 0) {\n      throw new IllegalArgumentException(\"Bad arguments\");\n    }\n\n    this.hours = hours;\n    this.minutes = minutes;\n    this.seconds = seconds;\n    if(seconds >= 60) {\n      this.minutes += seconds \/ 60;\n      this.seconds = seconds % 60; \/\/Get the remainder of a division\n    }\n\n    if(minutes >= 60) {\n      this.hours += this.minutes \/ 60;\n      this.minutes = this.minutes % 60;\n    }\n\n  }\n\n  public HMSDuration(long seconds) {\n    \/\/... pretend we implemented it\n  }\n\n  @Override\n  public long inSeconds() {\n    return this.hours * 3600 + this.minutes * 60 + this.seconds;\n  }\n\n  @Override\n  public String asHms() {\n    int hours = this.hours;\n    int minutes = this.minutes;\n    int seconds = this.seconds;\n    return String.format(\"%02d:%02d:%02d\", hours, minutes, seconds);\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\nprotected Duration fromSeconds(long seconds) {\n    return new HMSDuration(seconds);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1030-0115\\src\\cs3500\\durations\\HMSDuration.java","mask_span":[1565,1652],"topics":["decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0010] onicalize in the constructor. (Furthermore, a real class is likely to have additional methods that require the canonicalized components.) Thus, we add code to the constructor to canonicalize the representation:\n\nif (seconds > 59) {\n  minutes += seconds \/ 60;\n  seconds %= 60;\n}\n\nif (minutes > 59) {\n  hours += minutes \/ 60;\n  minutes %= 60;\n}\nThis ensures that the seconds and minutes never exceed 59 (because if they did, we would add to the minutes or hours, respectively, instead).\n2.3 Domain-specific methods\nThe observation methods are simple:\n\n@Override\npublic long inSeconds() {\n  return 3600 * hours + 60 * minutes + seconds;\n}\n\n@Override\npublic String asHms() {\n  return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n}\nIn a Java format string, the code %d means that the next param\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0013] hat) {\n  return new DurationImpl(this.inSeconds() + that.inSeconds());\n}\n2.4 Standard methods\nBecause Duration extends Comparable<Duration>, we need to implement the compareTo(Duration) method. We could do this by comparing the components, but it’s simpler to compare the total seconds:\n\n@Override\npublic int compareTo(Duration that) {\n  return Long.compare(this.inSeconds(), that.inSeconds());\n}\nNote that the Long class has a static method for comparing primitive, lowercase-ell long values, because primitive values cannot themselves have methods.\nAll classes should override Object.toString() with something reasonable. In this case, asHms is a fine implementation of toString:\n\n@Override\npublic String toString() {\n  return asHms();\n}\nFinally, we need to decide whether to override Object.equals\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0004] *\n   * @return the number of seconds (non-negative)\n   *\/\n  long inSeconds();\n\n  \/**\n   * Formats this duration in the form {@code H:MM:SS} where the minutes and\n   * seconds are both zero-padded to two digits, but the hours are not.\n   *\n   * @return this duration formatted in hours, minutes, and seconds\n   *\/\n  String asHms();\n\n  \/**\n   * Returns the sum of two durations.\n   *\n   * @param other the duration to add to {@code this}\n   * @return the sum of the durations\n   *\/\n  Duration plus(Duration other);\n}\nThings to notice:\n\nWe extend interface Comparable in order to define its comparison method compareTo on durations. In particular, extending interface Comparable<Duration> means that all Durations need to be comparable to Durations.\nThe interface and the methods each have a Javadoc com\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\nimport static org.junit.Assert.fail;\n\npublic class SimpleDurationsTest {\n\n  private Duration day;\n  private Duration ninetySeconds;\n  private Duration threeMinutes;\n\n  \/\/NOTE: This code does not compile yet because we haven't written this class.\n  \/\/      In your code, the class should at least have an empty constructor and\n  \/\/      implement the interface (i.e. class HMSDuration implements Duration)\n  @Before\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void testValidConstruction() {\n    assertEquals(\"24:00:00\", day.asHms());\n    assertEquals(\"00:01:30\", ninetySeconds.asHms());\n    assertEquals(\"100:00:00\", new HMSDuration(100, 0, 0).asHms());\n  }\n\n  @Test\n  public void testInvalidConstruction() {\n    assertThrows(IllegalArgumentException.class,\n        () -> { new HMSDuration(-1, 0,0 ); }); \/\/line 35 is a LAMBDA\n  }\n\n  @Test\n  public void testInSeconds() {\n    assertEquals(24 * 60 * 60, day.inSeconds());\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void setup() {\n    day = new HMSDuration(24, 0 ,0);\n    ninetySeconds = new HMSDuration(0, 0, 90);\n    threeMinutes = new HMSDuration(0, 3, 00);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1030-0115\\test\\cs3500\\durations\\SimpleDurationsTest.java","mask_span":[583,738],"topics":["testing","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0010] onicalize in the constructor. (Furthermore, a real class is likely to have additional methods that require the canonicalized components.) Thus, we add code to the constructor to canonicalize the representation:\n\nif (seconds > 59) {\n  minutes += seconds \/ 60;\n  seconds %= 60;\n}\n\nif (minutes > 59) {\n  hours += minutes \/ 60;\n  minutes %= 60;\n}\nThis ensures that the seconds and minutes never exceed 59 (because if they did, we would add to the minutes or hours, respectively, instead).\n2.3 Domain-specific methods\nThe observation methods are simple:\n\n@Override\npublic long inSeconds() {\n  return 3600 * hours + 60 * minutes + seconds;\n}\n\n@Override\npublic String asHms() {\n  return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n}\nIn a Java format string, the code %d means that the next param\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0013] hat) {\n  return new DurationImpl(this.inSeconds() + that.inSeconds());\n}\n2.4 Standard methods\nBecause Duration extends Comparable<Duration>, we need to implement the compareTo(Duration) method. We could do this by comparing the components, but it’s simpler to compare the total seconds:\n\n@Override\npublic int compareTo(Duration that) {\n  return Long.compare(this.inSeconds(), that.inSeconds());\n}\nNote that the Long class has a static method for comparing primitive, lowercase-ell long values, because primitive values cannot themselves have methods.\nAll classes should override Object.toString() with something reasonable. In this case, asHms is a fine implementation of toString:\n\n@Override\npublic String toString() {\n  return asHms();\n}\nFinally, we need to decide whether to override Object.equals\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0004] *\n   * @return the number of seconds (non-negative)\n   *\/\n  long inSeconds();\n\n  \/**\n   * Formats this duration in the form {@code H:MM:SS} where the minutes and\n   * seconds are both zero-padded to two digits, but the hours are not.\n   *\n   * @return this duration formatted in hours, minutes, and seconds\n   *\/\n  String asHms();\n\n  \/**\n   * Returns the sum of two durations.\n   *\n   * @param other the duration to add to {@code this}\n   * @return the sum of the durations\n   *\/\n  Duration plus(Duration other);\n}\nThings to notice:\n\nWe extend interface Comparable in order to define its comparison method compareTo on durations. In particular, extending interface Comparable<Duration> means that all Durations need to be comparable to Durations.\nThe interface and the methods each have a Javadoc com\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\nimport static org.junit.Assert.fail;\n\npublic class SimpleDurationsTest {\n\n  private Duration day;\n  private Duration ninetySeconds;\n  private Duration threeMinutes;\n\n  \/\/NOTE: This code does not compile yet because we haven't written this class.\n  \/\/      In your code, the class should at least have an empty constructor and\n  \/\/      implement the interface (i.e. class HMSDuration implements Duration)\n  @Before\n  public void setup() {\n    day = new HMSDuration(24, 0 ,0);\n    ninetySeconds = new HMSDuration(0, 0, 90);\n    threeMinutes = new HMSDuration(0, 3, 00);\n  }\n\n  @Test\n  public void testValidConstruction() {\n    assertEquals(\"24:00:00\", day.asHms());\n    assertEquals(\"00:01:30\", ninetySeconds.asHms());\n    assertEquals(\"100:00:00\", new HMSDuration(100, 0, 0).asHms());\n  }\n\n  @Test\n  public void testInvalidConstruction() {\n    assertThrows(IllegalArgumentException.class,\n        () -> { new HMSDuration(-1, 0,0 ); }); \/\/line 35 is a LAMBDA\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void testInSeconds() {\n    assertEquals(24 * 60 * 60, day.inSeconds());\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1030-0115\\test\\cs3500\\durations\\SimpleDurationsTest.java","mask_span":[1139,1221],"topics":["testing","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0010] onicalize in the constructor. (Furthermore, a real class is likely to have additional methods that require the canonicalized components.) Thus, we add code to the constructor to canonicalize the representation:\n\nif (seconds > 59) {\n  minutes += seconds \/ 60;\n  seconds %= 60;\n}\n\nif (minutes > 59) {\n  hours += minutes \/ 60;\n  minutes %= 60;\n}\nThis ensures that the seconds and minutes never exceed 59 (because if they did, we would add to the minutes or hours, respectively, instead).\n2.3 Domain-specific methods\nThe observation methods are simple:\n\n@Override\npublic long inSeconds() {\n  return 3600 * hours + 60 * minutes + seconds;\n}\n\n@Override\npublic String asHms() {\n  return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n}\nIn a Java format string, the code %d means that the next param\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0004] *\n   * @return the number of seconds (non-negative)\n   *\/\n  long inSeconds();\n\n  \/**\n   * Formats this duration in the form {@code H:MM:SS} where the minutes and\n   * seconds are both zero-padded to two digits, but the hours are not.\n   *\n   * @return this duration formatted in hours, minutes, and seconds\n   *\/\n  String asHms();\n\n  \/**\n   * Returns the sum of two durations.\n   *\n   * @param other the duration to add to {@code this}\n   * @return the sum of the durations\n   *\/\n  Duration plus(Duration other);\n}\nThings to notice:\n\nWe extend interface Comparable in order to define its comparison method compareTo on durations. In particular, extending interface Comparable<Duration> means that all Durations need to be comparable to Durations.\nThe interface and the methods each have a Javadoc com\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0013] hat) {\n  return new DurationImpl(this.inSeconds() + that.inSeconds());\n}\n2.4 Standard methods\nBecause Duration extends Comparable<Duration>, we need to implement the compareTo(Duration) method. We could do this by comparing the components, but it’s simpler to compare the total seconds:\n\n@Override\npublic int compareTo(Duration that) {\n  return Long.compare(this.inSeconds(), that.inSeconds());\n}\nNote that the Long class has a static method for comparing primitive, lowercase-ell long values, because primitive values cannot themselves have methods.\nAll classes should override Object.toString() with something reasonable. In this case, asHms is a fine implementation of toString:\n\n@Override\npublic String toString() {\n  return asHms();\n}\nFinally, we need to decide whether to override Object.equals\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0012] (long inSeconds) {\n  if (inSeconds < 0) {\n    throw new IllegalArgumentException(\"must be non-negative\");\n  }\n\n  this.seconds = (int) (inSeconds % 60);\n  this.minutes = (int) (inSeconds \/ 60 % 60);\n  this.hours = (int) (inSeconds \/ 3600);  \/\/ overflow...\n}\nIn each assignment above, (int) is a numeric cast that converts from type long, in this case, to type int. Because the range of long is larger, not all longs can be represented correctly as ints, and instead will overflow, producing the wrong answer. The first two casts are guaranteed not to overflow, since x % 60 is between 0 and 59, plenty small to fit in an int, for any x. However, if inSeconds is large enough6 then the resulting object won’t be right.\n\nWith the new constructor, plus is easy:\n\n@Override\npublic Duration plus(Duration t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\npublic class SimpleDuration implements Duration {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public long inSeconds() {\n    return 0;\n  }\n\n  @Override\n  public String asHms() {\n    return null;\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic SimpleDuration(int hours, int minutes, int seconds) {\n    \/\/TODO: Implement this constructor\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1335-0109\\src\\cs3500\\durations\\SimpleDuration.java","mask_span":[80,183],"topics":["decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0004] *\n   * @return the number of seconds (non-negative)\n   *\/\n  long inSeconds();\n\n  \/**\n   * Formats this duration in the form {@code H:MM:SS} where the minutes and\n   * seconds are both zero-padded to two digits, but the hours are not.\n   *\n   * @return this duration formatted in hours, minutes, and seconds\n   *\/\n  String asHms();\n\n  \/**\n   * Returns the sum of two durations.\n   *\n   * @param other the duration to add to {@code this}\n   * @return the sum of the durations\n   *\/\n  Duration plus(Duration other);\n}\nThings to notice:\n\nWe extend interface Comparable in order to define its comparison method compareTo on durations. In particular, extending interface Comparable<Duration> means that all Durations need to be comparable to Durations.\nThe interface and the methods each have a Javadoc com\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0013] hat) {\n  return new DurationImpl(this.inSeconds() + that.inSeconds());\n}\n2.4 Standard methods\nBecause Duration extends Comparable<Duration>, we need to implement the compareTo(Duration) method. We could do this by comparing the components, but it’s simpler to compare the total seconds:\n\n@Override\npublic int compareTo(Duration that) {\n  return Long.compare(this.inSeconds(), that.inSeconds());\n}\nNote that the Long class has a static method for comparing primitive, lowercase-ell long values, because primitive values cannot themselves have methods.\nAll classes should override Object.toString() with something reasonable. In this case, asHms is a fine implementation of toString:\n\n@Override\npublic String toString() {\n  return asHms();\n}\nFinally, we need to decide whether to override Object.equals\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0012] (long inSeconds) {\n  if (inSeconds < 0) {\n    throw new IllegalArgumentException(\"must be non-negative\");\n  }\n\n  this.seconds = (int) (inSeconds % 60);\n  this.minutes = (int) (inSeconds \/ 60 % 60);\n  this.hours = (int) (inSeconds \/ 3600);  \/\/ overflow...\n}\nIn each assignment above, (int) is a numeric cast that converts from type long, in this case, to type int. Because the range of long is larger, not all longs can be represented correctly as ints, and instead will overflow, producing the wrong answer. The first two casts are guaranteed not to overflow, since x % 60 is between 0 and 59, plenty small to fit in an int, for any x. However, if inSeconds is large enough6 then the resulting object won’t be right.\n\nWith the new constructor, plus is easy:\n\n@Override\npublic Duration plus(Duration t\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0010] onicalize in the constructor. (Furthermore, a real class is likely to have additional methods that require the canonicalized components.) Thus, we add code to the constructor to canonicalize the representation:\n\nif (seconds > 59) {\n  minutes += seconds \/ 60;\n  seconds %= 60;\n}\n\nif (minutes > 59) {\n  hours += minutes \/ 60;\n  minutes %= 60;\n}\nThis ensures that the seconds and minutes never exceed 59 (because if they did, we would add to the minutes or hours, respectively, instead).\n2.3 Domain-specific methods\nThe observation methods are simple:\n\n@Override\npublic long inSeconds() {\n  return 3600 * hours + 60 * minutes + seconds;\n}\n\n@Override\npublic String asHms() {\n  return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n}\nIn a Java format string, the code %d means that the next param\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class DurationTests {\n\n  private Duration oneeighty;\n  private Duration threemins;\n\n  @Before\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void testInSeconds() {\n    assertEquals(3 * 60, threemins.inSeconds());\n  }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void setup() {\n    this.oneeighty = new SimpleDuration(0, 0, 180);\n    this.threemins = new SimpleDuration(0 ,3, 0);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1335-0109\\test\\cs3500\\durations\\DurationTests.java","mask_span":[225,352],"topics":["decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0010] onicalize in the constructor. (Furthermore, a real class is likely to have additional methods that require the canonicalized components.) Thus, we add code to the constructor to canonicalize the representation:\n\nif (seconds > 59) {\n  minutes += seconds \/ 60;\n  seconds %= 60;\n}\n\nif (minutes > 59) {\n  hours += minutes \/ 60;\n  minutes %= 60;\n}\nThis ensures that the seconds and minutes never exceed 59 (because if they did, we would add to the minutes or hours, respectively, instead).\n2.3 Domain-specific methods\nThe observation methods are simple:\n\n@Override\npublic long inSeconds() {\n  return 3600 * hours + 60 * minutes + seconds;\n}\n\n@Override\npublic String asHms() {\n  return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n}\nIn a Java format string, the code %d means that the next param\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0004] *\n   * @return the number of seconds (non-negative)\n   *\/\n  long inSeconds();\n\n  \/**\n   * Formats this duration in the form {@code H:MM:SS} where the minutes and\n   * seconds are both zero-padded to two digits, but the hours are not.\n   *\n   * @return this duration formatted in hours, minutes, and seconds\n   *\/\n  String asHms();\n\n  \/**\n   * Returns the sum of two durations.\n   *\n   * @param other the duration to add to {@code this}\n   * @return the sum of the durations\n   *\/\n  Duration plus(Duration other);\n}\nThings to notice:\n\nWe extend interface Comparable in order to define its comparison method compareTo on durations. In particular, extending interface Comparable<Duration> means that all Durations need to be comparable to Durations.\nThe interface and the methods each have a Javadoc com\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0013] hat) {\n  return new DurationImpl(this.inSeconds() + that.inSeconds());\n}\n2.4 Standard methods\nBecause Duration extends Comparable<Duration>, we need to implement the compareTo(Duration) method. We could do this by comparing the components, but it’s simpler to compare the total seconds:\n\n@Override\npublic int compareTo(Duration that) {\n  return Long.compare(this.inSeconds(), that.inSeconds());\n}\nNote that the Long class has a static method for comparing primitive, lowercase-ell long values, because primitive values cannot themselves have methods.\nAll classes should override Object.toString() with something reasonable. In this case, asHms is a fine implementation of toString:\n\n@Override\npublic String toString() {\n  return asHms();\n}\nFinally, we need to decide whether to override Object.equals\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0012] (long inSeconds) {\n  if (inSeconds < 0) {\n    throw new IllegalArgumentException(\"must be non-negative\");\n  }\n\n  this.seconds = (int) (inSeconds % 60);\n  this.minutes = (int) (inSeconds \/ 60 % 60);\n  this.hours = (int) (inSeconds \/ 3600);  \/\/ overflow...\n}\nIn each assignment above, (int) is a numeric cast that converts from type long, in this case, to type int. Because the range of long is larger, not all longs can be represented correctly as ints, and instead will overflow, producing the wrong answer. The first two casts are guaranteed not to overflow, since x % 60 is between 0 and 59, plenty small to fit in an int, for any x. However, if inSeconds is large enough6 then the resulting object won’t be right.\n\nWith the new constructor, plus is easy:\n\n@Override\npublic Duration plus(Duration t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\n\/**\n * A Duration that stores time in hours, minutes, and seconds.\n * Ensures seconds and minutes are between 0 and 59 inclusive.\n *\/\npublic class HMSDuration implements Duration {\n\n  private int hours;\n  private int minutes;\n  private int seconds;\n\n  \/**\n   * Creates a non-negative duration of this hours, minutes, and seconds such that\n   * 0 <= minutes < 60 and 0 <= seconds < 60\n   * @param hours number of hours to represent in the duration\n   * @param minutes number of minutes to represent in the duration\n   * @param seconds number of seconds to represent in the duration\n   * @throws IllegalArgumentException if hours, minutes, or seconds < 0\n   *\/\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public long inSeconds() {\n    return 0;\n  }\n\n  @Override\n  public String asHms() {\n    return String.format(\"%02d:%02d:%02d\", hours, minutes, seconds);\n  }\n\n  @Override\n  public Duration plus(Duration other) {\n    return null;\n  }\n\n  @Override\n  public int compareTo(Duration o) {\n    return 0;\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic HMSDuration(int hours, int minutes, int seconds) {\n    if (hours < 0 || minutes < 0 || seconds < 0) {\n      throw new IllegalArgumentException(\"Bad arguments\");\n    }\n\n    this.hours = hours;\n    this.minutes = minutes;\n    this.seconds = seconds;\n\n    if (seconds >= 60) {\n      this.minutes += seconds \/ 60;\n      this.seconds = seconds % 60;\n    }\n\n    if (this.minutes >= 60) {\n      this.hours += this.minutes \/ 60;\n      this.minutes = this.minutes % 60;\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1335-0113\\src\\cs3500\\durations\\HMSDuration.java","mask_span":[688,1165],"topics":["decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0013] hat) {\n  return new DurationImpl(this.inSeconds() + that.inSeconds());\n}\n2.4 Standard methods\nBecause Duration extends Comparable<Duration>, we need to implement the compareTo(Duration) method. We could do this by comparing the components, but it’s simpler to compare the total seconds:\n\n@Override\npublic int compareTo(Duration that) {\n  return Long.compare(this.inSeconds(), that.inSeconds());\n}\nNote that the Long class has a static method for comparing primitive, lowercase-ell long values, because primitive values cannot themselves have methods.\nAll classes should override Object.toString() with something reasonable. In this case, asHms is a fine implementation of toString:\n\n@Override\npublic String toString() {\n  return asHms();\n}\nFinally, we need to decide whether to override Object.equals\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0010] onicalize in the constructor. (Furthermore, a real class is likely to have additional methods that require the canonicalized components.) Thus, we add code to the constructor to canonicalize the representation:\n\nif (seconds > 59) {\n  minutes += seconds \/ 60;\n  seconds %= 60;\n}\n\nif (minutes > 59) {\n  hours += minutes \/ 60;\n  minutes %= 60;\n}\nThis ensures that the seconds and minutes never exceed 59 (because if they did, we would add to the minutes or hours, respectively, instead).\n2.3 Domain-specific methods\nThe observation methods are simple:\n\n@Override\npublic long inSeconds() {\n  return 3600 * hours + 60 * minutes + seconds;\n}\n\n@Override\npublic String asHms() {\n  return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n}\nIn a Java format string, the code %d means that the next param\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0012] (long inSeconds) {\n  if (inSeconds < 0) {\n    throw new IllegalArgumentException(\"must be non-negative\");\n  }\n\n  this.seconds = (int) (inSeconds % 60);\n  this.minutes = (int) (inSeconds \/ 60 % 60);\n  this.hours = (int) (inSeconds \/ 3600);  \/\/ overflow...\n}\nIn each assignment above, (int) is a numeric cast that converts from type long, in this case, to type int. Because the range of long is larger, not all longs can be represented correctly as ints, and instead will overflow, producing the wrong answer. The first two casts are guaranteed not to overflow, since x % 60 is between 0 and 59, plenty small to fit in an int, for any x. However, if inSeconds is large enough6 then the resulting object won’t be right.\n\nWith the new constructor, plus is easy:\n\n@Override\npublic Duration plus(Duration t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\n\npublic class DurationTests {\n\n  private Duration oneeighty;\n  private Duration threemins;\n\n  @Before\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void testValidConstruction() {\n    assertEquals(\"00:03:00\", oneeighty.asHms());\n    assertEquals(180, oneeighty.inSeconds());\n  }\n\n  @Test\n  public void testInvalidConstructor() {\n    assertThrows(IllegalArgumentException.class,\n        () -> { new HMSDuration(-1, 0, 0); });\n    assertThrows(IllegalArgumentException.class,\n        () -> { new HMSDuration(0, -1, 0); });\n  }\n\n  @Test\n  public void testInSeconds() {\n    assertEquals(3 * 60, threemins.inSeconds());\n  }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void setup() {\n    oneeighty = new HMSDuration(0, 0, 180);\n    threemins = new HMSDuration(0, 3, 0);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1335-0113\\test\\cs3500\\durations\\DurationTests.java","mask_span":[270,381],"topics":["testing","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0013] hat) {\n  return new DurationImpl(this.inSeconds() + that.inSeconds());\n}\n2.4 Standard methods\nBecause Duration extends Comparable<Duration>, we need to implement the compareTo(Duration) method. We could do this by comparing the components, but it’s simpler to compare the total seconds:\n\n@Override\npublic int compareTo(Duration that) {\n  return Long.compare(this.inSeconds(), that.inSeconds());\n}\nNote that the Long class has a static method for comparing primitive, lowercase-ell long values, because primitive values cannot themselves have methods.\nAll classes should override Object.toString() with something reasonable. In this case, asHms is a fine implementation of toString:\n\n@Override\npublic String toString() {\n  return asHms();\n}\nFinally, we need to decide whether to override Object.equals\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0010] onicalize in the constructor. (Furthermore, a real class is likely to have additional methods that require the canonicalized components.) Thus, we add code to the constructor to canonicalize the representation:\n\nif (seconds > 59) {\n  minutes += seconds \/ 60;\n  seconds %= 60;\n}\n\nif (minutes > 59) {\n  hours += minutes \/ 60;\n  minutes %= 60;\n}\nThis ensures that the seconds and minutes never exceed 59 (because if they did, we would add to the minutes or hours, respectively, instead).\n2.3 Domain-specific methods\nThe observation methods are simple:\n\n@Override\npublic long inSeconds() {\n  return 3600 * hours + 60 * minutes + seconds;\n}\n\n@Override\npublic String asHms() {\n  return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n}\nIn a Java format string, the code %d means that the next param\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0012] (long inSeconds) {\n  if (inSeconds < 0) {\n    throw new IllegalArgumentException(\"must be non-negative\");\n  }\n\n  this.seconds = (int) (inSeconds % 60);\n  this.minutes = (int) (inSeconds \/ 60 % 60);\n  this.hours = (int) (inSeconds \/ 3600);  \/\/ overflow...\n}\nIn each assignment above, (int) is a numeric cast that converts from type long, in this case, to type int. Because the range of long is larger, not all longs can be represented correctly as ints, and instead will overflow, producing the wrong answer. The first two casts are guaranteed not to overflow, since x % 60 is between 0 and 59, plenty small to fit in an int, for any x. However, if inSeconds is large enough6 then the resulting object won’t be right.\n\nWith the new constructor, plus is easy:\n\n@Override\npublic Duration plus(Duration t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\n\npublic class DurationTests {\n\n  private Duration oneeighty;\n  private Duration threemins;\n\n  @Before\n  public void setup() {\n    oneeighty = new HMSDuration(0, 0, 180);\n    threemins = new HMSDuration(0, 3, 0);\n  }\n\n  @Test\n  public void testValidConstruction() {\n    assertEquals(\"00:03:00\", oneeighty.asHms());\n    assertEquals(180, oneeighty.inSeconds());\n  }\n\n  @Test\n  public void testInvalidConstructor() {\n    assertThrows(IllegalArgumentException.class,\n        () -> { new HMSDuration(-1, 0, 0); });\n    assertThrows(IllegalArgumentException.class,\n        () -> { new HMSDuration(0, -1, 0); });\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void testInSeconds() {\n    assertEquals(3 * 60, threemins.inSeconds());\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1335-0113\\test\\cs3500\\durations\\DurationTests.java","mask_span":[787,869],"topics":["testing","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0016] erhaps it would be useful if the current and all future implementations of Duration could work together seamlessly, including being considered equal if they represent the same length of time. To do this, we need to rewrite the equals method to compare not only to another DurationImpl but to any Duration via its interface. We can do this in this case because inSeconds() is part of the interface and returns sufficient information to test for equality. So we create a more general equals that compares seconds:\n\n@Override\npublic boolean equals(Object that) {\n  if (this == that) {\n    return true;\n  }\n\n  if (! (that instanceof Duration)) {\n    return false;\n  }\n\n  return ((Duration) that).inSeconds() == this.inSeconds();\n}\nWe’re nearly done, but not yet. Above we wrote that equals and hashCode s\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0017] hould always be overridden together (or not at all), and similarly, changing one of them often requires changing the other. A proper hashCode method will return the same hash code for any two Durations that are equal according to the equals method. That means that hashCode should only use as inputs values that are part of the equals comparison, which in this case means we should hash the total seconds:\n\n@Override\npublic int hashCode() {\n  return Long.hashCode(inSeconds());\n}\n2.5 Full circle\nFinally, building the extra flexibility into DurationImpl doesn’t do us any good if future implementations of Duration don’t follow the same rules. So we document how equals and hashCode must work for all implementations of the Duration interface in the interface itself:\n\n\/**\n * Durations, with a resolu\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0013] hat) {\n  return new DurationImpl(this.inSeconds() + that.inSeconds());\n}\n2.4 Standard methods\nBecause Duration extends Comparable<Duration>, we need to implement the compareTo(Duration) method. We could do this by comparing the components, but it’s simpler to compare the total seconds:\n\n@Override\npublic int compareTo(Duration that) {\n  return Long.compare(this.inSeconds(), that.inSeconds());\n}\nNote that the Long class has a static method for comparing primitive, lowercase-ell long values, because primitive values cannot themselves have methods.\nAll classes should override Object.toString() with something reasonable. In this case, asHms is a fine implementation of toString:\n\n@Override\npublic String toString() {\n  return asHms();\n}\nFinally, we need to decide whether to override Object.equals\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0015]  (this == o) {\n    return true;\n  }\n\n  \/\/ If o isn't the right class then it can't be equal:\n  if (! (o instanceof DurationImpl)) {\n    return false;\n  }\n\n  \/\/ The successful instanceof check means our cast will succeed:\n  DurationImpl that = (DurationImpl) o;\n\n  return this.hours == that.hours\n      && this.minutes == that.minutes\n      && this.seconds == that.seconds;\n}\n\n@Override\npublic int hashCode() {\n  return Objects.hash(hours, minutes, seconds);\n}\nThe static method Objects.hash(Object...) takes any number of arguments, each of which it hashes using that argument’s hashCode() method, and then combining the results in a reasonable way.\nHowever, if we choose to, we can do better. Because Duration is an interface, we should expect that it will be implemented more times in the future. P\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\nimport java.util.Objects;\n\npublic abstract class AbstractDuration implements Duration {\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public boolean equals(Object other) {\n    if(!(other instanceof Duration)) {\n      return false;\n    }\n\n    Duration that = (Duration) other;\n    return this.inSeconds() == that.inSeconds();\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(inSeconds());\n  }\n\n  @Override\n  public Duration plus(Duration other) {\n    return fromSeconds(this.inSeconds() + other.inSeconds());\n  }\n\n  abstract Duration fromSeconds(long seconds);\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic int compareTo(Duration other) {\n    return Long.compare(this.inSeconds(), other.inSeconds());\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1335-0115\\src\\cs3500\\durations\\AbstractDuration.java","mask_span":[130,234],"topics":["decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0016] erhaps it would be useful if the current and all future implementations of Duration could work together seamlessly, including being considered equal if they represent the same length of time. To do this, we need to rewrite the equals method to compare not only to another DurationImpl but to any Duration via its interface. We can do this in this case because inSeconds() is part of the interface and returns sufficient information to test for equality. So we create a more general equals that compares seconds:\n\n@Override\npublic boolean equals(Object that) {\n  if (this == that) {\n    return true;\n  }\n\n  if (! (that instanceof Duration)) {\n    return false;\n  }\n\n  return ((Duration) that).inSeconds() == this.inSeconds();\n}\nWe’re nearly done, but not yet. Above we wrote that equals and hashCode s\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0017] hould always be overridden together (or not at all), and similarly, changing one of them often requires changing the other. A proper hashCode method will return the same hash code for any two Durations that are equal according to the equals method. That means that hashCode should only use as inputs values that are part of the equals comparison, which in this case means we should hash the total seconds:\n\n@Override\npublic int hashCode() {\n  return Long.hashCode(inSeconds());\n}\n2.5 Full circle\nFinally, building the extra flexibility into DurationImpl doesn’t do us any good if future implementations of Duration don’t follow the same rules. So we document how equals and hashCode must work for all implementations of the Duration interface in the interface itself:\n\n\/**\n * Durations, with a resolu\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0013] hat) {\n  return new DurationImpl(this.inSeconds() + that.inSeconds());\n}\n2.4 Standard methods\nBecause Duration extends Comparable<Duration>, we need to implement the compareTo(Duration) method. We could do this by comparing the components, but it’s simpler to compare the total seconds:\n\n@Override\npublic int compareTo(Duration that) {\n  return Long.compare(this.inSeconds(), that.inSeconds());\n}\nNote that the Long class has a static method for comparing primitive, lowercase-ell long values, because primitive values cannot themselves have methods.\nAll classes should override Object.toString() with something reasonable. In this case, asHms is a fine implementation of toString:\n\n@Override\npublic String toString() {\n  return asHms();\n}\nFinally, we need to decide whether to override Object.equals\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0015]  (this == o) {\n    return true;\n  }\n\n  \/\/ If o isn't the right class then it can't be equal:\n  if (! (o instanceof DurationImpl)) {\n    return false;\n  }\n\n  \/\/ The successful instanceof check means our cast will succeed:\n  DurationImpl that = (DurationImpl) o;\n\n  return this.hours == that.hours\n      && this.minutes == that.minutes\n      && this.seconds == that.seconds;\n}\n\n@Override\npublic int hashCode() {\n  return Objects.hash(hours, minutes, seconds);\n}\nThe static method Objects.hash(Object...) takes any number of arguments, each of which it hashes using that argument’s hashCode() method, and then combining the results in a reasonable way.\nHowever, if we choose to, we can do better. Because Duration is an interface, we should expect that it will be implemented more times in the future. P\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\nimport java.util.Objects;\n\npublic abstract class AbstractDuration implements Duration {\n\n  @Override\n  public int compareTo(Duration other) {\n    return Long.compare(this.inSeconds(), other.inSeconds());\n  }\n\n  @Override\n  public boolean equals(Object other) {\n    if(!(other instanceof Duration)) {\n      return false;\n    }\n\n    Duration that = (Duration) other;\n    return this.inSeconds() == that.inSeconds();\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(inSeconds());\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\nabstract Duration fromSeconds(long seconds);\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic Duration plus(Duration other) {\n    return fromSeconds(this.inSeconds() + other.inSeconds());\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1335-0115\\src\\cs3500\\durations\\AbstractDuration.java","mask_span":[541,645],"topics":["decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0010] onicalize in the constructor. (Furthermore, a real class is likely to have additional methods that require the canonicalized components.) Thus, we add code to the constructor to canonicalize the representation:\n\nif (seconds > 59) {\n  minutes += seconds \/ 60;\n  seconds %= 60;\n}\n\nif (minutes > 59) {\n  hours += minutes \/ 60;\n  minutes %= 60;\n}\nThis ensures that the seconds and minutes never exceed 59 (because if they did, we would add to the minutes or hours, respectively, instead).\n2.3 Domain-specific methods\nThe observation methods are simple:\n\n@Override\npublic long inSeconds() {\n  return 3600 * hours + 60 * minutes + seconds;\n}\n\n@Override\npublic String asHms() {\n  return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n}\nIn a Java format string, the code %d means that the next param\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0012] (long inSeconds) {\n  if (inSeconds < 0) {\n    throw new IllegalArgumentException(\"must be non-negative\");\n  }\n\n  this.seconds = (int) (inSeconds % 60);\n  this.minutes = (int) (inSeconds \/ 60 % 60);\n  this.hours = (int) (inSeconds \/ 3600);  \/\/ overflow...\n}\nIn each assignment above, (int) is a numeric cast that converts from type long, in this case, to type int. Because the range of long is larger, not all longs can be represented correctly as ints, and instead will overflow, producing the wrong answer. The first two casts are guaranteed not to overflow, since x % 60 is between 0 and 59, plenty small to fit in an int, for any x. However, if inSeconds is large enough6 then the resulting object won’t be right.\n\nWith the new constructor, plus is easy:\n\n@Override\npublic Duration plus(Duration t\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0008]  so:\n\n\/**\n * Constructs a duration in terms of its length in hours, minutes, and\n * seconds.\n *\n * @param hours the number of hours\n * @param minutes the number of minutes\n * @param seconds the number of seconds\n * @throws IllegalArgumentException if any argument is negative\n *\/\npublic DurationImpl(int hours, int minutes, int seconds) {\n  if (hours < 0 || minutes < 0 || seconds < 0) {\n    throw new IllegalArgumentException(\"must be non-negative\");\n  }\n\n  \/\/ Insert omitted code from below \/\/\n\n  this.hours = hours;\n  this.minutes = minutes;\n  this.seconds = seconds;\n}\nThis constructor checks that each parameter is non-negative (as it makes sense in this context), to ensure that durations are not negative (this is called an invariant). However, this is not enough. Consider the following durat\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0004] *\n   * @return the number of seconds (non-negative)\n   *\/\n  long inSeconds();\n\n  \/**\n   * Formats this duration in the form {@code H:MM:SS} where the minutes and\n   * seconds are both zero-padded to two digits, but the hours are not.\n   *\n   * @return this duration formatted in hours, minutes, and seconds\n   *\/\n  String asHms();\n\n  \/**\n   * Returns the sum of two durations.\n   *\n   * @param other the duration to add to {@code this}\n   * @return the sum of the durations\n   *\/\n  Duration plus(Duration other);\n}\nThings to notice:\n\nWe extend interface Comparable in order to define its comparison method compareTo on durations. In particular, extending interface Comparable<Duration> means that all Durations need to be comparable to Durations.\nThe interface and the methods each have a Javadoc com\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\nimport java.util.Objects;\n\n\/**\n * A Duration that stores time in hours, minutes, and seconds.\n * Ensures seconds and minutes are between 0 and 59 inclusive.\n *\/\npublic class HMSDuration extends AbstractDuration {\n\n  private int hours;\n  private int minutes;\n  private int seconds;\n\n  \/**\n   * Creates a non-negative duration of this hours, minutes, and seconds such that\n   * 0 <= minutes < 60 and 0 <= seconds < 60\n   * @param hours number of hours to represent in the duration\n   * @param minutes number of minutes to represent in the duration\n   * @param seconds number of seconds to represent in the duration\n   * @throws IllegalArgumentException if hours, minutes, or seconds < 0\n   *\/\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic HMSDuration(long seconds) {\n    \/\/...pretend we implemented it\n  }\n\n  @Override\n  public long inSeconds() {\n    return this.hours * 3600 + this.minutes * 60 + this.seconds;\n  }\n\n  @Override\n  public String asHms() {\n    int hours = this.hours;\n    int minutes = this.minutes;\n    int seconds = this.seconds;\n    return String.format(\"%02d:%02d:%02d\", hours, minutes, seconds);\n  }\n\n  @Override\n  Duration fromSeconds(long seconds) {\n    return new HMSDuration(seconds);\n  }\n\n\n\n\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic HMSDuration(int hours, int minutes, int seconds) {\n    if (hours < 0 || minutes < 0 || seconds < 0) {\n      throw new IllegalArgumentException(\"Bad arguments\");\n    }\n\n    this.hours = hours;\n    this.minutes = minutes;\n    this.seconds = seconds;\n\n    if (seconds >= 60) {\n      this.minutes += seconds \/ 60;\n      this.seconds = seconds % 60;\n    }\n\n    if (this.minutes >= 60) {\n      this.hours += this.minutes \/ 60;\n      this.minutes = this.minutes % 60;\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1335-0115\\src\\cs3500\\durations\\HMSDuration.java","mask_span":[720,1197],"topics":["decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0010] onicalize in the constructor. (Furthermore, a real class is likely to have additional methods that require the canonicalized components.) Thus, we add code to the constructor to canonicalize the representation:\n\nif (seconds > 59) {\n  minutes += seconds \/ 60;\n  seconds %= 60;\n}\n\nif (minutes > 59) {\n  hours += minutes \/ 60;\n  minutes %= 60;\n}\nThis ensures that the seconds and minutes never exceed 59 (because if they did, we would add to the minutes or hours, respectively, instead).\n2.3 Domain-specific methods\nThe observation methods are simple:\n\n@Override\npublic long inSeconds() {\n  return 3600 * hours + 60 * minutes + seconds;\n}\n\n@Override\npublic String asHms() {\n  return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n}\nIn a Java format string, the code %d means that the next param\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0012] (long inSeconds) {\n  if (inSeconds < 0) {\n    throw new IllegalArgumentException(\"must be non-negative\");\n  }\n\n  this.seconds = (int) (inSeconds % 60);\n  this.minutes = (int) (inSeconds \/ 60 % 60);\n  this.hours = (int) (inSeconds \/ 3600);  \/\/ overflow...\n}\nIn each assignment above, (int) is a numeric cast that converts from type long, in this case, to type int. Because the range of long is larger, not all longs can be represented correctly as ints, and instead will overflow, producing the wrong answer. The first two casts are guaranteed not to overflow, since x % 60 is between 0 and 59, plenty small to fit in an int, for any x. However, if inSeconds is large enough6 then the resulting object won’t be right.\n\nWith the new constructor, plus is easy:\n\n@Override\npublic Duration plus(Duration t\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0008]  so:\n\n\/**\n * Constructs a duration in terms of its length in hours, minutes, and\n * seconds.\n *\n * @param hours the number of hours\n * @param minutes the number of minutes\n * @param seconds the number of seconds\n * @throws IllegalArgumentException if any argument is negative\n *\/\npublic DurationImpl(int hours, int minutes, int seconds) {\n  if (hours < 0 || minutes < 0 || seconds < 0) {\n    throw new IllegalArgumentException(\"must be non-negative\");\n  }\n\n  \/\/ Insert omitted code from below \/\/\n\n  this.hours = hours;\n  this.minutes = minutes;\n  this.seconds = seconds;\n}\nThis constructor checks that each parameter is non-negative (as it makes sense in this context), to ensure that durations are not negative (this is called an invariant). However, this is not enough. Consider the following durat\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0004] *\n   * @return the number of seconds (non-negative)\n   *\/\n  long inSeconds();\n\n  \/**\n   * Formats this duration in the form {@code H:MM:SS} where the minutes and\n   * seconds are both zero-padded to two digits, but the hours are not.\n   *\n   * @return this duration formatted in hours, minutes, and seconds\n   *\/\n  String asHms();\n\n  \/**\n   * Returns the sum of two durations.\n   *\n   * @param other the duration to add to {@code this}\n   * @return the sum of the durations\n   *\/\n  Duration plus(Duration other);\n}\nThings to notice:\n\nWe extend interface Comparable in order to define its comparison method compareTo on durations. In particular, extending interface Comparable<Duration> means that all Durations need to be comparable to Durations.\nThe interface and the methods each have a Javadoc com\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\nimport java.util.Objects;\n\n\/**\n * A Duration that stores time in hours, minutes, and seconds.\n * Ensures seconds and minutes are between 0 and 59 inclusive.\n *\/\npublic class HMSDuration extends AbstractDuration {\n\n  private int hours;\n  private int minutes;\n  private int seconds;\n\n  \/**\n   * Creates a non-negative duration of this hours, minutes, and seconds such that\n   * 0 <= minutes < 60 and 0 <= seconds < 60\n   * @param hours number of hours to represent in the duration\n   * @param minutes number of minutes to represent in the duration\n   * @param seconds number of seconds to represent in the duration\n   * @throws IllegalArgumentException if hours, minutes, or seconds < 0\n   *\/\n  public HMSDuration(int hours, int minutes, int seconds) {\n    if (hours < 0 || minutes < 0 || seconds < 0) {\n      throw new IllegalArgumentException(\"Bad arguments\");\n    }\n\n    this.hours = hours;\n    this.minutes = minutes;\n    this.seconds = seconds;\n\n    if (seconds >= 60) {\n      this.minutes += seconds \/ 60;\n      this.seconds = seconds % 60;\n    }\n\n    if (this.minutes >= 60) {\n      this.hours += this.minutes \/ 60;\n      this.minutes = this.minutes % 60;\n    }\n  }\n\n  public HMSDuration(long seconds) {\n    \/\/...pretend we implemented it\n  }\n\n  @Override\n  public long inSeconds() {\n    return this.hours * 3600 + this.minutes * 60 + this.seconds;\n  }\n\n  @Override\n  public String asHms() {\n    int hours = this.hours;\n    int minutes = this.minutes;\n    int seconds = this.seconds;\n    return String.format(\"%02d:%02d:%02d\", hours, minutes, seconds);\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\nDuration fromSeconds(long seconds) {\n    return new HMSDuration(seconds);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1335-0115\\src\\cs3500\\durations\\HMSDuration.java","mask_span":[1604,1681],"topics":["decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0013] hat) {\n  return new DurationImpl(this.inSeconds() + that.inSeconds());\n}\n2.4 Standard methods\nBecause Duration extends Comparable<Duration>, we need to implement the compareTo(Duration) method. We could do this by comparing the components, but it’s simpler to compare the total seconds:\n\n@Override\npublic int compareTo(Duration that) {\n  return Long.compare(this.inSeconds(), that.inSeconds());\n}\nNote that the Long class has a static method for comparing primitive, lowercase-ell long values, because primitive values cannot themselves have methods.\nAll classes should override Object.toString() with something reasonable. In this case, asHms is a fine implementation of toString:\n\n@Override\npublic String toString() {\n  return asHms();\n}\nFinally, we need to decide whether to override Object.equals\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0010] onicalize in the constructor. (Furthermore, a real class is likely to have additional methods that require the canonicalized components.) Thus, we add code to the constructor to canonicalize the representation:\n\nif (seconds > 59) {\n  minutes += seconds \/ 60;\n  seconds %= 60;\n}\n\nif (minutes > 59) {\n  hours += minutes \/ 60;\n  minutes %= 60;\n}\nThis ensures that the seconds and minutes never exceed 59 (because if they did, we would add to the minutes or hours, respectively, instead).\n2.3 Domain-specific methods\nThe observation methods are simple:\n\n@Override\npublic long inSeconds() {\n  return 3600 * hours + 60 * minutes + seconds;\n}\n\n@Override\npublic String asHms() {\n  return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n}\nIn a Java format string, the code %d means that the next param\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0012] (long inSeconds) {\n  if (inSeconds < 0) {\n    throw new IllegalArgumentException(\"must be non-negative\");\n  }\n\n  this.seconds = (int) (inSeconds % 60);\n  this.minutes = (int) (inSeconds \/ 60 % 60);\n  this.hours = (int) (inSeconds \/ 3600);  \/\/ overflow...\n}\nIn each assignment above, (int) is a numeric cast that converts from type long, in this case, to type int. Because the range of long is larger, not all longs can be represented correctly as ints, and instead will overflow, producing the wrong answer. The first two casts are guaranteed not to overflow, since x % 60 is between 0 and 59, plenty small to fit in an int, for any x. However, if inSeconds is large enough6 then the resulting object won’t be right.\n\nWith the new constructor, plus is easy:\n\n@Override\npublic Duration plus(Duration t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\n\npublic class DurationTests {\n\n  private Duration oneeighty;\n  private Duration threemins;\n\n  @Before\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void testValidConstruction() {\n    assertEquals(\"00:03:00\", oneeighty.asHms());\n    assertEquals(180, oneeighty.inSeconds());\n  }\n\n  @Test\n  public void testInvalidConstructor() {\n    assertThrows(IllegalArgumentException.class,\n        () -> { new HMSDuration(-1, 0, 0); });\n    assertThrows(IllegalArgumentException.class,\n        () -> { new HMSDuration(0, -1, 0); });\n  }\n\n  @Test\n  public void testInSeconds() {\n    assertEquals(3 * 60, threemins.inSeconds());\n  }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void setup() {\n    oneeighty = new HMSDuration(0, 0, 180);\n    threemins = new HMSDuration(0, 3, 0);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1335-0115\\test\\cs3500\\durations\\DurationTests.java","mask_span":[270,381],"topics":["testing","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0013] hat) {\n  return new DurationImpl(this.inSeconds() + that.inSeconds());\n}\n2.4 Standard methods\nBecause Duration extends Comparable<Duration>, we need to implement the compareTo(Duration) method. We could do this by comparing the components, but it’s simpler to compare the total seconds:\n\n@Override\npublic int compareTo(Duration that) {\n  return Long.compare(this.inSeconds(), that.inSeconds());\n}\nNote that the Long class has a static method for comparing primitive, lowercase-ell long values, because primitive values cannot themselves have methods.\nAll classes should override Object.toString() with something reasonable. In this case, asHms is a fine implementation of toString:\n\n@Override\npublic String toString() {\n  return asHms();\n}\nFinally, we need to decide whether to override Object.equals\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0010] onicalize in the constructor. (Furthermore, a real class is likely to have additional methods that require the canonicalized components.) Thus, we add code to the constructor to canonicalize the representation:\n\nif (seconds > 59) {\n  minutes += seconds \/ 60;\n  seconds %= 60;\n}\n\nif (minutes > 59) {\n  hours += minutes \/ 60;\n  minutes %= 60;\n}\nThis ensures that the seconds and minutes never exceed 59 (because if they did, we would add to the minutes or hours, respectively, instead).\n2.3 Domain-specific methods\nThe observation methods are simple:\n\n@Override\npublic long inSeconds() {\n  return 3600 * hours + 60 * minutes + seconds;\n}\n\n@Override\npublic String asHms() {\n  return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n}\nIn a Java format string, the code %d means that the next param\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0012] (long inSeconds) {\n  if (inSeconds < 0) {\n    throw new IllegalArgumentException(\"must be non-negative\");\n  }\n\n  this.seconds = (int) (inSeconds % 60);\n  this.minutes = (int) (inSeconds \/ 60 % 60);\n  this.hours = (int) (inSeconds \/ 3600);  \/\/ overflow...\n}\nIn each assignment above, (int) is a numeric cast that converts from type long, in this case, to type int. Because the range of long is larger, not all longs can be represented correctly as ints, and instead will overflow, producing the wrong answer. The first two casts are guaranteed not to overflow, since x % 60 is between 0 and 59, plenty small to fit in an int, for any x. However, if inSeconds is large enough6 then the resulting object won’t be right.\n\nWith the new constructor, plus is easy:\n\n@Override\npublic Duration plus(Duration t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\n\npublic class DurationTests {\n\n  private Duration oneeighty;\n  private Duration threemins;\n\n  @Before\n  public void setup() {\n    oneeighty = new HMSDuration(0, 0, 180);\n    threemins = new HMSDuration(0, 3, 0);\n  }\n\n  @Test\n  public void testValidConstruction() {\n    assertEquals(\"00:03:00\", oneeighty.asHms());\n    assertEquals(180, oneeighty.inSeconds());\n  }\n\n  @Test\n  public void testInvalidConstructor() {\n    assertThrows(IllegalArgumentException.class,\n        () -> { new HMSDuration(-1, 0, 0); });\n    assertThrows(IllegalArgumentException.class,\n        () -> { new HMSDuration(0, -1, 0); });\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void testInSeconds() {\n    assertEquals(3 * 60, threemins.inSeconds());\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1335-0115\\test\\cs3500\\durations\\DurationTests.java","mask_span":[787,869],"topics":["testing","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.io.InputStreamReader;\n\n\/**\n * Run a Tic Tac Toe game interactively on the console.\n *\/\npublic class Main {\n  \/**\n   * Run a Tic Tac Toe game interactively on the console.\n   *\/\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    new TicTacToeConsoleController(new InputStreamReader(System.in),\n        System.out).playGame(new TicTacToeModel());\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\exercise-1030\\src\\cs3500\\tictactoe\\Main.java","mask_span":[218,383],"topics":["gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class TicTacToeConsoleController implements TicTacToeController {\n\n  private final Appendable out;\n  private final Scanner scan;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void playGame(TicTacToe model) {\n    try {\n      while(!model.isGameOver()) {\n        printGameState(model);\n        printPrompt(model);\n        readInputs(model);\n      }\n    } catch (IOException ex) {\n      throw new IllegalStateException(\"Bad IO\");\n    }\n  }\n\n  private void transmit(String message) throws IOException {\n    out.append(message + \"\\n\");\n  }\n\n  private void printGameState(TicTacToe model) throws IOException {\n    transmit(model.toString());\n  }\n\n  private void printPrompt(TicTacToe model) throws IOException {\n    transmit(\"Enter a move for \" + model.getTurn() + \":\");\n  }\n\n  private void readInputs(TicTacToe model) {\n    int row;\n    row = readInt();\n    int col = readInt();\n    model.move(row, col);\n  }\n\n  private int readInt() {\n    int ans;\n    try {\n      ans = scan.nextInt() - 1;\n    } catch (InputMismatchException ex) {\n      String token = scan.next();\n      if(token.equals(\"q\") || token.equals(\"Q\")) {\n        \/\/How should I signal to playGame to quit the method?\n        \/\/1. Change some field to true and have every method react to that\n        \/\/2. Return -1 to indicate the game is over (and propagate that message)\n        \/\/3. Throw an exception and handle it when ready\n      }\n      ans = readInt();\n    }\n    return ans;\n  }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeConsoleController(Readable in, Appendable out) {\n    if (in == null || out == null) {\n      throw new IllegalArgumentException(\"Readable and Appendable can't be null\");\n    }\n    this.out = out;\n    scan = new Scanner(in);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\exercise-1030\\src\\cs3500\\tictactoe\\TicTacToeConsoleController.java","mask_span":[262,504],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class TicTacToeConsoleController implements TicTacToeController {\n\n  private final Appendable out;\n  private final Scanner scan;\n\n  public TicTacToeConsoleController(Readable in, Appendable out) {\n    if (in == null || out == null) {\n      throw new IllegalArgumentException(\"Readable and Appendable can't be null\");\n    }\n    this.out = out;\n    scan = new Scanner(in);\n  }\n\n  @Override\n  public void playGame(TicTacToe model) {\n    try {\n      while(!model.isGameOver()) {\n        printGameState(model);\n        printPrompt(model);\n        readInputs(model);\n      }\n    } catch (IOException ex) {\n      throw new IllegalStateException(\"Bad IO\");\n    }\n  }\n\n  private void transmit(String message) throws IOException {\n    out.append(message + \"\\n\");\n  }\n\n  private void printGameState(TicTacToe model) throws IOException {\n    transmit(model.toString());\n  }\n\n  private void printPrompt(TicTacToe model) throws IOException {\n    transmit(\"Enter a move for \" + model.getTurn() + \":\");\n  }\n\n  private void readInputs(TicTacToe model) {\n    int row;\n    row = readInt();\n    int col = readInt();\n    model.move(row, col);\n  }\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\nprivate int readInt() {\n    int ans;\n    try {\n      ans = scan.nextInt() - 1;\n    } catch (InputMismatchException ex) {\n      String token = scan.next();\n      if(token.equals(\"q\") || token.equals(\"Q\")) {\n        \/\/How should I signal to playGame to quit the method?\n        \/\/1. Change some field to true and have every method react to that\n        \/\/2. Return -1 to indicate the game is over (and propagate that message)\n        \/\/3. Throw an exception and handle it when ready\n      }\n      ans = readInt();\n    }\n    return ans;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\exercise-1030\\src\\cs3500\\tictactoe\\TicTacToeConsoleController.java","mask_span":[1259,1796],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0023] given cell position. Because some cells may be empty of tokens, we need some way to distinguish empty cells from player numbers. The wrapped integer type Integer includes null, so we use Integer instead of int for the result with null representing empty cells.\n\nAdditionally, we will include a convenience method3 for asking whether a particular column is full.\n\n\/**\n * Gets the player whose token is at the given column and row. The\n * coordinates are zero-based and start in the lower left. Returns\n * {@code null} if there is no token in the given position.\n *\n * @param x the column coordinate ({@code 0 <= x < width})\n * @param y the row coordinate ({@code 0 <= y < height})\n * @return the player in the given position, or {@code null}\n * @throws IndexOutOfBoundsException if (x, y) is out of bo\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n\/**\n * Represents a single game of Tic Tac Toe. Three in a row down\/across\/diagonally to win; X goes\n * first.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n  private final Player[][] board;\n  private Player turn;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void move(int row, int col) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(row, col);\n    if (board[row][col] != null) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[row][col] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (Player[] row : board) {\n      if (Arrays.stream(row).anyMatch(Objects::isNull)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (Player player : Player.values()) {\n      \/\/ check horizontals\n      for (Player[] row : board) {\n        if(Arrays.stream(row).allMatch(mark -> mark == player)) {\n          return player;\n        }\n      }\n      \/\/ check verticals\n      for (int col = 0; col < board[0].length; col++) {\n        if (board[0][col] == player && board[1][col] == player && board[2][col] == player) {\n          return player;\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n        return player;\n      }\n      if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n        return player;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int row = 0; row < board.length; row++) {\n      ret[row] = Arrays.copyOf(board[row], board[row].length);\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int row, int col) {\n    validateRowCol(row, col);\n    return board[row][col];\n  }\n\n  \/\/NOTE: Could be made non-static as well.\n  \/\/Made static here to show that there is no dynamic information needed. However, it can't be used\n  \/\/outside of this class due to it being private.\n  private static void validateRowCol(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + row + \",\" + col);\n    }\n  }\n\n  @Override\n  public String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard())\n        .map(row -> \" \" + Arrays.stream(row)\n            .map(player -> player == null ? \" \" : player.toString())\n            .collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\exercise-1030\\src\\cs3500\\tictactoe\\TicTacToeModel.java","mask_span":[341,421],"topics":["strategy","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0023] given cell position. Because some cells may be empty of tokens, we need some way to distinguish empty cells from player numbers. The wrapped integer type Integer includes null, so we use Integer instead of int for the result with null representing empty cells.\n\nAdditionally, we will include a convenience method3 for asking whether a particular column is full.\n\n\/**\n * Gets the player whose token is at the given column and row. The\n * coordinates are zero-based and start in the lower left. Returns\n * {@code null} if there is no token in the given position.\n *\n * @param x the column coordinate ({@code 0 <= x < width})\n * @param y the row coordinate ({@code 0 <= y < height})\n * @return the player in the given position, or {@code null}\n * @throws IndexOutOfBoundsException if (x, y) is out of bo\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n\/**\n * Represents a single game of Tic Tac Toe. Three in a row down\/across\/diagonally to win; X goes\n * first.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n  private final Player[][] board;\n  private Player turn;\n\n  public TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n\n  @Override\n  public void move(int row, int col) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(row, col);\n    if (board[row][col] != null) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[row][col] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (Player[] row : board) {\n      if (Arrays.stream(row).anyMatch(Objects::isNull)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (Player player : Player.values()) {\n      \/\/ check horizontals\n      for (Player[] row : board) {\n        if(Arrays.stream(row).allMatch(mark -> mark == player)) {\n          return player;\n        }\n      }\n      \/\/ check verticals\n      for (int col = 0; col < board[0].length; col++) {\n        if (board[0][col] == player && board[1][col] == player && board[2][col] == player) {\n          return player;\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n        return player;\n      }\n      if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n        return player;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int row = 0; row < board.length; row++) {\n      ret[row] = Arrays.copyOf(board[row], board[row].length);\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int row, int col) {\n    validateRowCol(row, col);\n    return board[row][col];\n  }\n\n  \/\/NOTE: Could be made non-static as well.\n  \/\/Made static here to show that there is no dynamic information needed. However, it can't be used\n  \/\/outside of this class due to it being private.\n  private static void validateRowCol(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + row + \",\" + col);\n    }\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard())\n        .map(row -> \" \" + Arrays.stream(row)\n            .map(player -> player == null ? \" \" : player.toString())\n            .collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\exercise-1030\\src\\cs3500\\tictactoe\\TicTacToeModel.java","mask_span":[2632,3531],"topics":["strategy","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0003] riage return.\n\nAt the end of the game, the controller should output, in order on separate lines:\n\nA final game state\n\"Game is over!\" followed by \"X wins.\" or \"O wins.\" or \"Tie game.\" depending on the outcome\nIf the user quits, the controller should output\n\n\"Game quit! Ending game state:\\n\" + model.toString() + \"\\n\"\n\nand end the playGame() method.\n\n2 Testing\nWe have supplied you with some basic JUnit tests as part of the starter code. Use these to verify that your implementation is correct. Write additional tests of your own: Assignment 3 is a testing-heavy assignment. Some of the additional cases you should implement are listed as comments in the test class you are given. Implement those tests at the least.\n\n3 Notes to Keep in Mind\nYou will likely need a while() loop; be aware that you can\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n<\/Context>","code_prefix":"<CodePrefix>\nimport static org.junit.Assert.assertEquals;\n\nimport cs3500.tictactoe.TicTacToe;\nimport cs3500.tictactoe.TicTacToeConsoleController;\nimport cs3500.tictactoe.TicTacToeController;\nimport cs3500.tictactoe.TicTacToeModel;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport org.junit.Test;\n\n\/**\n * Test cases for the tic tac toe controller, using mocks for readable and appendable.\n *\/\npublic class TicTacToeControllerTest {\n\n  \/\/ ADDITIONAL TEST CASES TO IMPLEMENT:\n  \/\/ Play game to completion, where there is a winner\n  \/\/ Input where the q comes instead of an integer for the row\n  \/\/ Input where the q comes instead of an integer for the column\n  \/\/ Input where non-integer garbage comes instead of an integer for the row\n  \/\/ Input where non-integer garbage comes instead of an integer for the column\n  \/\/ Input where the move is integers, but outside the bounds of the board\n  \/\/ Input where the move is integers, but invalid because the cell is occupied\n  \/\/ Multiple invalid moves in a row of various kinds\n  \/\/ Input including valid moves interspersed with invalid moves, game is played to completion\n  \/\/ What happens when the input ends \"abruptly\" -- no more input, but not quit, and game not over\n  \/\/ THIS IS NOT AN EXHAUSTIVE LIST\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void testBogusInputAsRow() {\n    TicTacToe m = new TicTacToeModel();\n    StringReader input = new StringReader(\"!#$ 2 q\");\n    StringBuilder gameLog = new StringBuilder();\n    TicTacToeController c = new TicTacToeConsoleController(input, gameLog);\n    c.playGame(m);\n    \/\/ split the output into an array of lines\n    String[] lines = gameLog.toString().split(\"\\n\");\n    \/\/ check that it's the correct number of lines\n    assertEquals(13, lines.length);\n    \/\/ check that the last 6 lines are correct\n    String lastMsg = String.join(\"\\n\",\n        Arrays.copyOfRange(lines, lines.length - 6, lines.length));\n    assertEquals(\"Game quit! Ending game state:\\n\"\n        + \"   |   |  \\n\"\n        + \"-----------\\n\"\n        + \"   |   |  \\n\"\n        + \"-----------\\n\"\n        + \"   |   |  \", lastMsg);\n    \/\/ note no trailing \\n here, because of the earlier split\n  }\n\n  @Test\n  public void testTieGame() {\n    TicTacToe m = new TicTacToeModel();\n    \/\/ note the entire sequence of user inputs for the entire game is in this one string:\n    StringReader input = new StringReader(\"2 2 1 1 3 3 1 2 1 3 2 3 2 1 3 1 3 2\");\n    StringBuilder gameLog = new StringBuilder();\n    TicTacToeController c = new TicTacToeConsoleController(input, gameLog);\n    c.playGame(m);\n    String[] lines = gameLog.toString().split(\"\\n\");\n    assertEquals(60, lines.length);\n    assertEquals(\"Game is over! Tie game.\", lines[lines.length - 1]);\n  }\n\n  @Test(expected = IllegalStateException.class)\n  public void testFailingAppendable() {\n    TicTacToe m = new TicTacToeModel();\n    StringReader input = new StringReader(\"2 2 1 1 3 3 1 2 1 3 2 3 2 1 3 1 3 2\");\n    Appendable gameLog = new FailingAppendable();\n    TicTacToeController c = new TicTacToeConsoleController(input, gameLog);\n    c.playGame(m);\n  }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void testSingleValidMove() {\n    TicTacToe m = new TicTacToeModel();\n    StringBuilder gameLog = new StringBuilder();\n    TicTacToeController c = new TicTacToeConsoleController(new StringReader(\"2 2 q\"), gameLog);\n    c.playGame(m);\n    assertEquals(\"   |   |  \\n\"\n        + \"-----------\\n\"\n        + \"   |   |  \\n\"\n        + \"-----------\\n\"\n        + \"   |   |  \\n\"\n        + \"Enter a move for X:\\n\"\n        + \"   |   |  \\n\"\n        + \"-----------\\n\"\n        + \"   | X |  \\n\"\n        + \"-----------\\n\"\n        + \"   |   |  \\n\"\n        + \"Enter a move for O:\\n\"\n        + \"Game quit! Ending game state:\\n\"\n        + \"   |   |  \\n\"\n        + \"-----------\\n\"\n        + \"   | X |  \\n\"\n        + \"-----------\\n\"\n        + \"   |   |  \\n\", gameLog.toString());\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\exercise-1030\\test\\TicTacToeControllerTest.java","mask_span":[1262,2027],"topics":["testing","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0003] riage return.\n\nAt the end of the game, the controller should output, in order on separate lines:\n\nA final game state\n\"Game is over!\" followed by \"X wins.\" or \"O wins.\" or \"Tie game.\" depending on the outcome\nIf the user quits, the controller should output\n\n\"Game quit! Ending game state:\\n\" + model.toString() + \"\\n\"\n\nand end the playGame() method.\n\n2 Testing\nWe have supplied you with some basic JUnit tests as part of the starter code. Use these to verify that your implementation is correct. Write additional tests of your own: Assignment 3 is a testing-heavy assignment. Some of the additional cases you should implement are listed as comments in the test class you are given. Implement those tests at the least.\n\n3 Notes to Keep in Mind\nYou will likely need a while() loop; be aware that you can\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n<\/Context>","code_prefix":"<CodePrefix>\nimport static org.junit.Assert.assertEquals;\n\nimport cs3500.tictactoe.TicTacToe;\nimport cs3500.tictactoe.TicTacToeConsoleController;\nimport cs3500.tictactoe.TicTacToeController;\nimport cs3500.tictactoe.TicTacToeModel;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport org.junit.Test;\n\n\/**\n * Test cases for the tic tac toe controller, using mocks for readable and appendable.\n *\/\npublic class TicTacToeControllerTest {\n\n  \/\/ ADDITIONAL TEST CASES TO IMPLEMENT:\n  \/\/ Play game to completion, where there is a winner\n  \/\/ Input where the q comes instead of an integer for the row\n  \/\/ Input where the q comes instead of an integer for the column\n  \/\/ Input where non-integer garbage comes instead of an integer for the row\n  \/\/ Input where non-integer garbage comes instead of an integer for the column\n  \/\/ Input where the move is integers, but outside the bounds of the board\n  \/\/ Input where the move is integers, but invalid because the cell is occupied\n  \/\/ Multiple invalid moves in a row of various kinds\n  \/\/ Input including valid moves interspersed with invalid moves, game is played to completion\n  \/\/ What happens when the input ends \"abruptly\" -- no more input, but not quit, and game not over\n  \/\/ THIS IS NOT AN EXHAUSTIVE LIST\n\n  @Test\n  public void testSingleValidMove() {\n    TicTacToe m = new TicTacToeModel();\n    StringBuilder gameLog = new StringBuilder();\n    TicTacToeController c = new TicTacToeConsoleController(new StringReader(\"2 2 q\"), gameLog);\n    c.playGame(m);\n    assertEquals(\"   |   |  \\n\"\n        + \"-----------\\n\"\n        + \"   |   |  \\n\"\n        + \"-----------\\n\"\n        + \"   |   |  \\n\"\n        + \"Enter a move for X:\\n\"\n        + \"   |   |  \\n\"\n        + \"-----------\\n\"\n        + \"   | X |  \\n\"\n        + \"-----------\\n\"\n        + \"   |   |  \\n\"\n        + \"Enter a move for O:\\n\"\n        + \"Game quit! Ending game state:\\n\"\n        + \"   |   |  \\n\"\n        + \"-----------\\n\"\n        + \"   | X |  \\n\"\n        + \"-----------\\n\"\n        + \"   |   |  \\n\", gameLog.toString());\n  }\n\n  @Test\n  public void testBogusInputAsRow() {\n    TicTacToe m = new TicTacToeModel();\n    StringReader input = new StringReader(\"!#$ 2 q\");\n    StringBuilder gameLog = new StringBuilder();\n    TicTacToeController c = new TicTacToeConsoleController(input, gameLog);\n    c.playGame(m);\n    \/\/ split the output into an array of lines\n    String[] lines = gameLog.toString().split(\"\\n\");\n    \/\/ check that it's the correct number of lines\n    assertEquals(13, lines.length);\n    \/\/ check that the last 6 lines are correct\n    String lastMsg = String.join(\"\\n\",\n        Arrays.copyOfRange(lines, lines.length - 6, lines.length));\n    assertEquals(\"Game quit! Ending game state:\\n\"\n        + \"   |   |  \\n\"\n        + \"-----------\\n\"\n        + \"   |   |  \\n\"\n        + \"-----------\\n\"\n        + \"   |   |  \", lastMsg);\n    \/\/ note no trailing \\n here, because of the earlier split\n  }\n\n  @Test\n  public void testTieGame() {\n    TicTacToe m = new TicTacToeModel();\n    \/\/ note the entire sequence of user inputs for the entire game is in this one string:\n    StringReader input = new StringReader(\"2 2 1 1 3 3 1 2 1 3 2 3 2 1 3 1 3 2\");\n    StringBuilder gameLog = new StringBuilder();\n    TicTacToeController c = new TicTacToeConsoleController(input, gameLog);\n    c.playGame(m);\n    String[] lines = gameLog.toString().split(\"\\n\");\n    assertEquals(60, lines.length);\n    assertEquals(\"Game is over! Tie game.\", lines[lines.length - 1]);\n  }\n\n  @Test(expected = IllegalStateException.class)\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void testFailingAppendable() {\n    TicTacToe m = new TicTacToeModel();\n    StringReader input = new StringReader(\"2 2 1 1 3 3 1 2 1 3 2 3 2 1 3 1 3 2\");\n    Appendable gameLog = new FailingAppendable();\n    TicTacToeController c = new TicTacToeConsoleController(input, gameLog);\n    c.playGame(m);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\exercise-1030\\test\\TicTacToeControllerTest.java","mask_span":[3516,3824],"topics":["testing","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0006] der strategy that first tries one and then, if it fails, tries the other:\n\nclass TryTwo implements TicTacToeStrategy {\n  TicTacToeStrategy first, second;\n  public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n    Coord ans = this.first.chooseMove(model, forWhom);\n    if (ans != null) return ans; \/\/ the first strategy succeeded\n    return this.second.chooseMove(model, forWhom);\n  }\n}\nIf we fill in the question-marks in AnyOpenCorner with return null, as we effectively did with AnyOpenSquare, then our full second strategy is simply new TryTwo(new AnyOpenCorner(), new AnyOpenSquare()). We can continue implementing the other strategy components (blocking an opponent, or going for an immediate win), and combining them with TryTwo. (These other components need the forWhom argument —try\n<\/Context>","code_prefix":"<CodePrefix>\nimport org.junit.Test;\n\nimport cs3500.tictactoe.Player;\nimport cs3500.tictactoe.TicTacToe;\nimport cs3500.tictactoe.TicTacToeModel;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\n\/**\n * Test cases for the tic tac toe model. Verifying that game state is properly managed, and\n * all game actions are properly validated.\n *\/\npublic class TicTacToeModelTest {\n\n  private TicTacToe ttt1 = new TicTacToeModel();\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void testHorizontalWin() {\n    ttt1.move(0, 0); \/\/ X takes upper left\n    assertFalse(ttt1.isGameOver());\n    ttt1.move(1, 0); \/\/ O takes middle left\n    ttt1.move(0, 1); \/\/ X takes upper middle\n    assertNull(ttt1.getWinner());\n    ttt1.move(2, 0); \/\/ O takes lower left\n    ttt1.move(0, 2); \/\/ X takes upper right\n    assertTrue(ttt1.isGameOver());\n    assertEquals(Player.X, ttt1.getWinner());\n    assertEquals(\" X | X | X\\n\"\n                          + \"-----------\\n\"\n                          + \" O |   |  \\n\"\n                          + \"-----------\\n\"\n                          + \" O |   |  \", ttt1.toString());\n  }\n\n  @Test\n  public void testDiagonalWin() {\n    diagonalWinHelper();\n    assertTrue(ttt1.isGameOver());\n    assertEquals(Player.O, ttt1.getWinner());\n    assertEquals(\" X | X | O\\n\"\n            + \"-----------\\n\"\n            + \" X | O |  \\n\"\n            + \"-----------\\n\"\n            + \" O |   |  \", ttt1.toString());\n  }\n\n  \/\/ set up situation where game is over, O wins on the diagonal, board is not full\n  private void diagonalWinHelper() {\n    ttt1.move(0, 0); \/\/ X takes upper left\n    assertFalse(ttt1.isGameOver());\n    ttt1.move(2, 0); \/\/ O takes lower left\n    ttt1.move(1, 0); \/\/ X takes middle left\n    assertNull(ttt1.getWinner());\n    ttt1.move(1, 1); \/\/ O takes center\n    ttt1.move(0, 1); \/\/ X takes upper middle\n    ttt1.move(0, 2); \/\/ O takes upper right\n  }\n\n  @Test\n  public void testInvalidMove() {\n    ttt1.move(0, 0);\n    assertEquals(Player.O, ttt1.getTurn());\n    assertEquals(Player.X, ttt1.getMarkAt(0, 0));\n    try {\n      ttt1.move(0, 0);\n      fail(\"Invalid move should have thrown exception\");\n    } catch (IllegalArgumentException iae) {\n      \/\/assertEquals(\"Position occupied\", iae.getMessage());\n      assertTrue(iae.getMessage().length() > 0);\n    }\n    try {\n      ttt1.move(-1, 0);\n      fail(\"Invalid move should have thrown exception\");\n    } catch (IllegalArgumentException iae) {\n      \/\/assertEquals(\"Position occupied\", iae.getMessage());\n      assertTrue(iae.getMessage().length() > 0);\n    }\n  }\n\n  @Test(expected = IllegalStateException.class)\n  public void testMoveAttemptAfterGameOver() {\n    diagonalWinHelper();\n    ttt1.move(2, 2); \/\/ 2,2 is an empty position\n  }\n\n  @Test\n  public void testCatsGame() {\n    ttt1.move(0, 0);\n    assertEquals(Player.O, ttt1.getTurn());\n    ttt1.move(1, 1);\n    assertEquals(Player.X, ttt1.getTurn());\n    ttt1.move(0, 2);\n    ttt1.move(0, 1);\n    ttt1.move(2, 1);\n    ttt1.move(1, 0);\n    ttt1.move(1, 2);\n    ttt1.move(2, 2);\n    ttt1.move(2, 0);\n    assertTrue(ttt1.isGameOver());\n    assertNull(ttt1.getWinner());\n    assertEquals( \" X | O | X\\n\"\n            + \"-----------\\n\"\n            + \" O | O | X\\n\"\n            + \"-----------\\n\"\n            + \" X | X | O\", ttt1.toString());\n  }\n\n  @Test(expected = IllegalArgumentException.class)\n  public void testInvalidGetMarkAtRow() {\n    ttt1.getMarkAt(-12, 0);\n  }\n\n  @Test(expected = IllegalArgumentException.class)\n  public void testInvalidGetMarkAtCol() {\n    ttt1.getMarkAt(0, -30);\n  }\n\n  @Test\n  public void testGetBoard() {\n    diagonalWinHelper();\n    Player[][] bd = ttt1.getBoard();\n    assertEquals(Player.X, bd[0][0]);\n    assertEquals(Player.O, bd[1][1]);\n    assertEquals(Player.X, bd[0][1]);\n\n    \/\/ attempt to cheat by mutating board returned by getBoard()\n    \/\/ check correct preconditions\n    assertEquals(Player.O, bd[2][0]);\n    assertEquals(Player.O, ttt1.getMarkAt(2, 0));\n    bd[2][0] = Player.X;  \/\/ mutate\n    \/\/ check correct post conditions\n    assertEquals(Player.O, ttt1.getMarkAt(2, 0));\n    Player[][] bd2 = ttt1.getBoard();\n    assertEquals(Player.O, bd2[2][0]);\n  }\n\n  \/\/ TODO: test case where board is full AND there is a winner\n}\n<\/CodeSuffix>","target":"<Target>\npublic void testMove() {\n    ttt1.move(0, 0);\n    assertEquals(Player.O, ttt1.getTurn());\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\exercise-1030\\test\\TicTacToeModelTest.java","mask_span":[584,677],"topics":["strategy","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0006] der strategy that first tries one and then, if it fails, tries the other:\n\nclass TryTwo implements TicTacToeStrategy {\n  TicTacToeStrategy first, second;\n  public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n    Coord ans = this.first.chooseMove(model, forWhom);\n    if (ans != null) return ans; \/\/ the first strategy succeeded\n    return this.second.chooseMove(model, forWhom);\n  }\n}\nIf we fill in the question-marks in AnyOpenCorner with return null, as we effectively did with AnyOpenSquare, then our full second strategy is simply new TryTwo(new AnyOpenCorner(), new AnyOpenSquare()). We can continue implementing the other strategy components (blocking an opponent, or going for an immediate win), and combining them with TryTwo. (These other components need the forWhom argument —try\n<\/Context>","code_prefix":"<CodePrefix>\nimport org.junit.Test;\n\nimport cs3500.tictactoe.Player;\nimport cs3500.tictactoe.TicTacToe;\nimport cs3500.tictactoe.TicTacToeModel;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\n\/**\n * Test cases for the tic tac toe model. Verifying that game state is properly managed, and\n * all game actions are properly validated.\n *\/\npublic class TicTacToeModelTest {\n\n  private TicTacToe ttt1 = new TicTacToeModel();\n\n  @Test\n  public void testMove() {\n    ttt1.move(0, 0);\n    assertEquals(Player.O, ttt1.getTurn());\n  }\n\n  @Test\n  public void testHorizontalWin() {\n    ttt1.move(0, 0); \/\/ X takes upper left\n    assertFalse(ttt1.isGameOver());\n    ttt1.move(1, 0); \/\/ O takes middle left\n    ttt1.move(0, 1); \/\/ X takes upper middle\n    assertNull(ttt1.getWinner());\n    ttt1.move(2, 0); \/\/ O takes lower left\n    ttt1.move(0, 2); \/\/ X takes upper right\n    assertTrue(ttt1.isGameOver());\n    assertEquals(Player.X, ttt1.getWinner());\n    assertEquals(\" X | X | X\\n\"\n                          + \"-----------\\n\"\n                          + \" O |   |  \\n\"\n                          + \"-----------\\n\"\n                          + \" O |   |  \", ttt1.toString());\n  }\n\n  @Test\n  public void testDiagonalWin() {\n    diagonalWinHelper();\n    assertTrue(ttt1.isGameOver());\n    assertEquals(Player.O, ttt1.getWinner());\n    assertEquals(\" X | X | O\\n\"\n            + \"-----------\\n\"\n            + \" X | O |  \\n\"\n            + \"-----------\\n\"\n            + \" O |   |  \", ttt1.toString());\n  }\n\n  \/\/ set up situation where game is over, O wins on the diagonal, board is not full\n  private void diagonalWinHelper() {\n    ttt1.move(0, 0); \/\/ X takes upper left\n    assertFalse(ttt1.isGameOver());\n    ttt1.move(2, 0); \/\/ O takes lower left\n    ttt1.move(1, 0); \/\/ X takes middle left\n    assertNull(ttt1.getWinner());\n    ttt1.move(1, 1); \/\/ O takes center\n    ttt1.move(0, 1); \/\/ X takes upper middle\n    ttt1.move(0, 2); \/\/ O takes upper right\n  }\n\n  @Test\n  public void testInvalidMove() {\n    ttt1.move(0, 0);\n    assertEquals(Player.O, ttt1.getTurn());\n    assertEquals(Player.X, ttt1.getMarkAt(0, 0));\n    try {\n      ttt1.move(0, 0);\n      fail(\"Invalid move should have thrown exception\");\n    } catch (IllegalArgumentException iae) {\n      \/\/assertEquals(\"Position occupied\", iae.getMessage());\n      assertTrue(iae.getMessage().length() > 0);\n    }\n    try {\n      ttt1.move(-1, 0);\n      fail(\"Invalid move should have thrown exception\");\n    } catch (IllegalArgumentException iae) {\n      \/\/assertEquals(\"Position occupied\", iae.getMessage());\n      assertTrue(iae.getMessage().length() > 0);\n    }\n  }\n\n  @Test(expected = IllegalStateException.class)\n  public void testMoveAttemptAfterGameOver() {\n    diagonalWinHelper();\n    ttt1.move(2, 2); \/\/ 2,2 is an empty position\n  }\n\n  @Test\n  public void testCatsGame() {\n    ttt1.move(0, 0);\n    assertEquals(Player.O, ttt1.getTurn());\n    ttt1.move(1, 1);\n    assertEquals(Player.X, ttt1.getTurn());\n    ttt1.move(0, 2);\n    ttt1.move(0, 1);\n    ttt1.move(2, 1);\n    ttt1.move(1, 0);\n    ttt1.move(1, 2);\n    ttt1.move(2, 2);\n    ttt1.move(2, 0);\n    assertTrue(ttt1.isGameOver());\n    assertNull(ttt1.getWinner());\n    assertEquals( \" X | O | X\\n\"\n            + \"-----------\\n\"\n            + \" O | O | X\\n\"\n            + \"-----------\\n\"\n            + \" X | X | O\", ttt1.toString());\n  }\n\n  @Test(expected = IllegalArgumentException.class)\n  public void testInvalidGetMarkAtRow() {\n    ttt1.getMarkAt(-12, 0);\n  }\n\n  @Test(expected = IllegalArgumentException.class)\n  public void testInvalidGetMarkAtCol() {\n    ttt1.getMarkAt(0, -30);\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/\/ TODO: test case where board is full AND there is a winner\n}\n<\/CodeSuffix>","target":"<Target>\npublic void testGetBoard() {\n    diagonalWinHelper();\n    Player[][] bd = ttt1.getBoard();\n    assertEquals(Player.X, bd[0][0]);\n    assertEquals(Player.O, bd[1][1]);\n    assertEquals(Player.X, bd[0][1]);\n\n    \/\/ attempt to cheat by mutating board returned by getBoard()\n    \/\/ check correct preconditions\n    assertEquals(Player.O, bd[2][0]);\n    assertEquals(Player.O, ttt1.getMarkAt(2, 0));\n    bd[2][0] = Player.X;  \/\/ mutate\n    \/\/ check correct post conditions\n    assertEquals(Player.O, ttt1.getMarkAt(2, 0));\n    Player[][] bd2 = ttt1.getBoard();\n    assertEquals(Player.O, bd2[2][0]);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\exercise-1030\\test\\TicTacToeModelTest.java","mask_span":[3754,4351],"topics":["strategy","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0023] given cell position. Because some cells may be empty of tokens, we need some way to distinguish empty cells from player numbers. The wrapped integer type Integer includes null, so we use Integer instead of int for the result with null representing empty cells.\n\nAdditionally, we will include a convenience method3 for asking whether a particular column is full.\n\n\/**\n * Gets the player whose token is at the given column and row. The\n * coordinates are zero-based and start in the lower left. Returns\n * {@code null} if there is no token in the given position.\n *\n * @param x the column coordinate ({@code 0 <= x < width})\n * @param y the row coordinate ({@code 0 <= y < height})\n * @return the player in the given position, or {@code null}\n * @throws IndexOutOfBoundsException if (x, y) is out of bo\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n\/**\n * Represents a single game of Tic Tac Toe. Three in a row down\/across\/diagonally to win; X goes\n * first.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n  protected final Player[][] board;\n  private Player turn;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void move(int row, int col) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(row, col);\n    if (board[row][col] != null) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[row][col] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (Player[] row : board) {\n      if (Arrays.stream(row).anyMatch(Objects::isNull)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (Player player : Player.values()) {\n      \/\/ check horizontals\n      for (Player[] row : board) {\n        if(Arrays.stream(row).allMatch(mark -> mark == player)) {\n          return player;\n        }\n      }\n      \/\/ check verticals\n      for (int col = 0; col < board[0].length; col++) {\n        if (board[0][col] == player && board[1][col] == player && board[2][col] == player) {\n          return player;\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n        return player;\n      }\n      if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n        return player;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int row = 0; row < board.length; row++) {\n      ret[row] = Arrays.copyOf(board[row], board[row].length);\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int row, int col) {\n    validateRowCol(row, col);\n    return board[row][col];\n  }\n\n  \/\/NOTE: Could be made non-static as well.\n  \/\/Made static here to show that there is no dynamic information needed. However, it can't be used\n  \/\/outside of this class due to it being private.\n  private static void validateRowCol(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + row + \",\" + col);\n    }\n  }\n\n  @Override\n  public String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard())\n        .map(row -> \" \" + Arrays.stream(row)\n            .map(player -> player == null ? \" \" : player.toString())\n            .collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\invariants-1030-starter\\src\\cs3500\\tictactoe\\TicTacToeModel.java","mask_span":[343,423],"topics":["strategy","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0023] given cell position. Because some cells may be empty of tokens, we need some way to distinguish empty cells from player numbers. The wrapped integer type Integer includes null, so we use Integer instead of int for the result with null representing empty cells.\n\nAdditionally, we will include a convenience method3 for asking whether a particular column is full.\n\n\/**\n * Gets the player whose token is at the given column and row. The\n * coordinates are zero-based and start in the lower left. Returns\n * {@code null} if there is no token in the given position.\n *\n * @param x the column coordinate ({@code 0 <= x < width})\n * @param y the row coordinate ({@code 0 <= y < height})\n * @return the player in the given position, or {@code null}\n * @throws IndexOutOfBoundsException if (x, y) is out of bo\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n\/**\n * Represents a single game of Tic Tac Toe. Three in a row down\/across\/diagonally to win; X goes\n * first.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n  protected final Player[][] board;\n  private Player turn;\n\n  public TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n\n  @Override\n  public void move(int row, int col) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(row, col);\n    if (board[row][col] != null) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[row][col] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (Player[] row : board) {\n      if (Arrays.stream(row).anyMatch(Objects::isNull)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (Player player : Player.values()) {\n      \/\/ check horizontals\n      for (Player[] row : board) {\n        if(Arrays.stream(row).allMatch(mark -> mark == player)) {\n          return player;\n        }\n      }\n      \/\/ check verticals\n      for (int col = 0; col < board[0].length; col++) {\n        if (board[0][col] == player && board[1][col] == player && board[2][col] == player) {\n          return player;\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n        return player;\n      }\n      if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n        return player;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int row = 0; row < board.length; row++) {\n      ret[row] = Arrays.copyOf(board[row], board[row].length);\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int row, int col) {\n    validateRowCol(row, col);\n    return board[row][col];\n  }\n\n  \/\/NOTE: Could be made non-static as well.\n  \/\/Made static here to show that there is no dynamic information needed. However, it can't be used\n  \/\/outside of this class due to it being private.\n  private static void validateRowCol(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + row + \",\" + col);\n    }\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard())\n        .map(row -> \" \" + Arrays.stream(row)\n            .map(player -> player == null ? \" \" : player.toString())\n            .collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\invariants-1030-starter\\src\\cs3500\\tictactoe\\TicTacToeModel.java","mask_span":[2634,3533],"topics":["strategy","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\n\/**\n * In this representation, player X is 1 and player O is 2.\n *\/\npublic class TicTacToeModelVersionOne implements TicTacToe {\n\n  protected final int[][] board;\n  private int turn;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void move(int row, int col) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(row, col);\n    if (board[row][col] != 0) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[row][col] = turn;\n    turn = (turn%2) + 1;\n  }\n\n  @Override\n  public Player getTurn() {\n    return getPlayerForInt(turn);\n  }\n\n  private Player getPlayerForInt(int player) {\n    switch(player) {\n      case 0:\n        return null;\n      case 1:\n        return Player.X;\n      case 2:\n        return Player.O;\n    }\n    throw new RuntimeException(\"Unknown turn value\");\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (int[] row : board) {\n      if (Arrays.stream(row).anyMatch(cell -> cell == 0)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (int player : new int[] {1, 2}) {\n      \/\/ check horizontals\n      for (int[] row : board) {\n        if(Arrays.stream(row).allMatch(mark -> mark == player)) {\n          return getPlayerForInt(player);\n        }\n      }\n      \/\/ check verticals\n      for (int col = 0; col < board[0].length; col++) {\n        if (board[0][col] == player && board[1][col] == player && board[2][col] == player) {\n          return getPlayerForInt(player);\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n        return getPlayerForInt(player);\n      }\n      if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n        return getPlayerForInt(player);\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int row = 0; row < board.length; row++) {\n      for(int col = 0; col < board[0].length; col++) {\n        ret[row][col] = getPlayerForInt(board[row][col]);\n      }\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int row, int col) {\n    validateRowCol(row, col);\n    return getPlayerForInt(board[row][col]);\n  }\n\n  \/\/NOTE: Could be made non-static as well.\n  \/\/Made static here to show that there is no dynamic information needed. However, it can't be used\n  \/\/outside of this class due to it being private.\n  private static void validateRowCol(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + row + \",\" + col);\n    }\n  }\n\n  @Override\n  public String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard())\n        .map(row -> \" \" + Arrays.stream(row)\n            .map(player -> player == null ? \" \" : player.toString())\n            .collect(Collectors.joining(\" | \")))\n        .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeModelVersionOne() {\n    board = new int[3][3];\n    turn = 1;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\invariants-1030-starter\\src\\cs3500\\tictactoe\\TicTacToeModelVersionOne.java","mask_span":[275,355],"topics":["strategy","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\n\/**\n * In this representation, player X is 1 and player O is 2.\n *\/\npublic class TicTacToeModelVersionOne implements TicTacToe {\n\n  protected final int[][] board;\n  private int turn;\n\n  public TicTacToeModelVersionOne() {\n    board = new int[3][3];\n    turn = 1;\n  }\n\n  @Override\n  public void move(int row, int col) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(row, col);\n    if (board[row][col] != 0) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[row][col] = turn;\n    turn = (turn%2) + 1;\n  }\n\n  @Override\n  public Player getTurn() {\n    return getPlayerForInt(turn);\n  }\n\n  private Player getPlayerForInt(int player) {\n    switch(player) {\n      case 0:\n        return null;\n      case 1:\n        return Player.X;\n      case 2:\n        return Player.O;\n    }\n    throw new RuntimeException(\"Unknown turn value\");\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (int[] row : board) {\n      if (Arrays.stream(row).anyMatch(cell -> cell == 0)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (int player : new int[] {1, 2}) {\n      \/\/ check horizontals\n      for (int[] row : board) {\n        if(Arrays.stream(row).allMatch(mark -> mark == player)) {\n          return getPlayerForInt(player);\n        }\n      }\n      \/\/ check verticals\n      for (int col = 0; col < board[0].length; col++) {\n        if (board[0][col] == player && board[1][col] == player && board[2][col] == player) {\n          return getPlayerForInt(player);\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n        return getPlayerForInt(player);\n      }\n      if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n        return getPlayerForInt(player);\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int row = 0; row < board.length; row++) {\n      for(int col = 0; col < board[0].length; col++) {\n        ret[row][col] = getPlayerForInt(board[row][col]);\n      }\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int row, int col) {\n    validateRowCol(row, col);\n    return getPlayerForInt(board[row][col]);\n  }\n\n  \/\/NOTE: Could be made non-static as well.\n  \/\/Made static here to show that there is no dynamic information needed. However, it can't be used\n  \/\/outside of this class due to it being private.\n  private static void validateRowCol(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + row + \",\" + col);\n    }\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard())\n        .map(row -> \" \" + Arrays.stream(row)\n            .map(player -> player == null ? \" \" : player.toString())\n            .collect(Collectors.joining(\" | \")))\n        .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\invariants-1030-starter\\src\\cs3500\\tictactoe\\TicTacToeModelVersionOne.java","mask_span":[2937,3834],"topics":["strategy","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0001]  of Integers that will let us use the positions to access the cell contents.\n\nSome of these methods return simple quantities that don’t change, so for those we can just store each in a field:\n\npublic int width;\npublic int height;\npublic int goal;\npublic int players;\nClearly we need to represent the state of the game grid, in particular which tokens are where. Since the grid is essentially a two-dimensional matrix, we can use an array of arrays or list of lists. In general this choice is arbitrary (except for the effects of locality), but in this case columns may make more sense, because we can use shorter lists to represent not-yet-full columns and grow them as necessary.\n\npublic List<List<Integer>> columns;\nFinally, we need state in order to be able to tell the client who the current play\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0023] given cell position. Because some cells may be empty of tokens, we need some way to distinguish empty cells from player numbers. The wrapped integer type Integer includes null, so we use Integer instead of int for the result with null representing empty cells.\n\nAdditionally, we will include a convenience method3 for asking whether a particular column is full.\n\n\/**\n * Gets the player whose token is at the given column and row. The\n * coordinates are zero-based and start in the lower left. Returns\n * {@code null} if there is no token in the given position.\n *\n * @param x the column coordinate ({@code 0 <= x < width})\n * @param y the row coordinate ({@code 0 <= y < height})\n * @return the player in the given position, or {@code null}\n * @throws IndexOutOfBoundsException if (x, y) is out of bo\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0014]  a copy of the grid (which need not be the same type as what we use internally):\n\n\/**\n * Returns a two-dimensional array representing the state of the\n * grid. The first index is the column and the second the row.\n * The resulting array is newly allocated and unconnected to the model;\n * thus, mutating it will have no effect on the model or subsequent\n * calls to {@code getGrid}.\n *\n * @return a copy of the grid\n *\/\nPlayer[][] getGrid();\nAlternatively, rather than return some representation of the grid, we could provide some means of querying it:\n\n\/**\n * Returns the {@link Player} whose mark is in the cell at the given\n * coordinates, or {@code null} if that cell is empty.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @return a {@code Player} or {@code \n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0001] o you in the starter code. You will fill in the fields and remaining method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe game grid cells are numbered by row and column starting from 0. For example, the upper left position is row 0, column 0 (or [0][0] in the 2D array returned by getBoard()), the upper middle position is row 0, column 1 ([0][1]), the lower right is [2][2].\n\n2 Testing\nWe have supplied you with some basic JUnit tests as part of the starter code. Use these to verify that your implementation is correct, and write additional tests of your own.\n\n3 Notes to Keep in Mind\nAvoid duplicating code as much as possible. Consider using non-public methods as means of creating reusable pieces of functionality.\nBe sure to use access modifiers, \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n\/**\n * Implementation of a basic 3x3 game of TicTacToe. Game can end in a stalemate as well,\n * which is indicated by getWinner() returning null.\n *\/\npublic class TicTacToeModelVersionTwo implements TicTacToe {\n\n  \/\/ The top left corner is 0,0. Grid is indexed by rows first, then columns.\n  private List<List<Player>> grid;\n  private Player turn;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard()).map(\n            row -> \" \" + Arrays.stream(row).map(\n                p -> p == null ? \" \" : p.toString()).collect(Collectors.joining(\" | \")))\n        .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n\n  @Override\n  public void move(int row, int col) {\n    if(isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    if(row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Bad row\/col\");\n    }\n    if(grid.get(row).get(col) != null) {\n      throw new IllegalArgumentException(\"Already placed mark here\");\n    }\n    grid.get(row).set(col, turn);\n    if(turn == Player.X) {\n      turn = Player.O;\n    } else {\n      turn = Player.X;\n    }\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    \/\/every spot on board is filled\n    \/\/or a winner\n    return isBoardFull() || isWinner();\n  }\n\n  private boolean isWinner() {\n    return isThreeInARow() != null || isThreeInACol() != null || isThreeInADiagonal() != null;\n  }\n\n  \/\/Slight change from class plan here: notice we will eventually need the winner\n  \/\/so we instead have methods to GET the possible winner. Then for isGameOver, we only\n  \/\/need to check if those winners are not null for the game to be over.\n  private Player isThreeInARow() {\n    for(int row = 0; row < 3; row++) {\n      Player mark = grid.get(row).get(0);\n      if (mark != null\n          && grid.get(row).get(0) == mark\n          && grid.get(row).get(1) == mark\n          && grid.get(row).get(2) == mark) {\n        return mark;\n      }\n    }\n    return null;\n  }\n\n  private Player isThreeInACol() {\n    for(int col = 0; col < 3; col++) {\n      Player mark = grid.get(0).get(col);\n      if (mark != null\n          && grid.get(0).get(col) == mark\n          && grid.get(1).get(col) == mark\n          && grid.get(2).get(col) == mark) {\n        return mark;\n      }\n    }\n    return null;\n  }\n\n  private Player isThreeInADiagonal() {\n    Player mark = grid.get(0).get(0);\n    if (mark != null && grid.get(1).get(1) == mark && grid.get(2).get(2) == mark) {\n      return mark;\n    }\n    mark = grid.get(0).get(2);\n    if (mark != null && grid.get(1).get(1) == mark && grid.get(2).get(0) == mark) {\n      return mark;\n    }\n    return null;\n  }\n\n  private boolean isBoardFull() {\n    for(int row = 0; row < 3; row++) {\n      for(int col = 0; col < 3; col++) {\n        if (grid.get(row).get(col) == null) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  @Override\n  public Player getWinner() {\n    Player winner = isThreeInARow();\n    if(winner != null) return winner;\n\n    winner = isThreeInACol();\n    if(winner != null) return winner;\n\n    return isThreeInADiagonal();\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    \/\/create the grid\n    Player[][] copy = new Player[3][3];\n    \/\/put the contents of the grid into the new copy\n    for(int row = 0; row < copy.length; row++) {\n      for(int col = 0; col < copy[0].length; col++) {\n        copy[row][col] = grid.get(row).get(col);\n      }\n    }\n    \/\/return the new copy\n    return copy;\n  }\n\n  @Override\n  public Player getMarkAt(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Bad row\/col\");\n    }\n    return grid.get(row).get(col);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeModelVersionTwo() {\n    this.grid = new ArrayList<>();\n    for(int row = 0; row < 3; row++) {\n      List<Player> rowList = new ArrayList<>();\n      for(int col = 0; col < 3; col++) {\n        rowList.add(null);\n      }\n      this.grid.add(rowList);\n    }\n    this.turn = Player.X;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\invariants-1030-starter\\src\\cs3500\\tictactoe\\TicTacToeModelVersionTwo.java","mask_span":[491,790],"topics":["testing","gui","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0001]  of Integers that will let us use the positions to access the cell contents.\n\nSome of these methods return simple quantities that don’t change, so for those we can just store each in a field:\n\npublic int width;\npublic int height;\npublic int goal;\npublic int players;\nClearly we need to represent the state of the game grid, in particular which tokens are where. Since the grid is essentially a two-dimensional matrix, we can use an array of arrays or list of lists. In general this choice is arbitrary (except for the effects of locality), but in this case columns may make more sense, because we can use shorter lists to represent not-yet-full columns and grow them as necessary.\n\npublic List<List<Integer>> columns;\nFinally, we need state in order to be able to tell the client who the current play\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0023] given cell position. Because some cells may be empty of tokens, we need some way to distinguish empty cells from player numbers. The wrapped integer type Integer includes null, so we use Integer instead of int for the result with null representing empty cells.\n\nAdditionally, we will include a convenience method3 for asking whether a particular column is full.\n\n\/**\n * Gets the player whose token is at the given column and row. The\n * coordinates are zero-based and start in the lower left. Returns\n * {@code null} if there is no token in the given position.\n *\n * @param x the column coordinate ({@code 0 <= x < width})\n * @param y the row coordinate ({@code 0 <= y < height})\n * @return the player in the given position, or {@code null}\n * @throws IndexOutOfBoundsException if (x, y) is out of bo\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0014]  a copy of the grid (which need not be the same type as what we use internally):\n\n\/**\n * Returns a two-dimensional array representing the state of the\n * grid. The first index is the column and the second the row.\n * The resulting array is newly allocated and unconnected to the model;\n * thus, mutating it will have no effect on the model or subsequent\n * calls to {@code getGrid}.\n *\n * @return a copy of the grid\n *\/\nPlayer[][] getGrid();\nAlternatively, rather than return some representation of the grid, we could provide some means of querying it:\n\n\/**\n * Returns the {@link Player} whose mark is in the cell at the given\n * coordinates, or {@code null} if that cell is empty.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @return a {@code Player} or {@code \n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0001] o you in the starter code. You will fill in the fields and remaining method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe game grid cells are numbered by row and column starting from 0. For example, the upper left position is row 0, column 0 (or [0][0] in the 2D array returned by getBoard()), the upper middle position is row 0, column 1 ([0][1]), the lower right is [2][2].\n\n2 Testing\nWe have supplied you with some basic JUnit tests as part of the starter code. Use these to verify that your implementation is correct, and write additional tests of your own.\n\n3 Notes to Keep in Mind\nAvoid duplicating code as much as possible. Consider using non-public methods as means of creating reusable pieces of functionality.\nBe sure to use access modifiers, \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n\/**\n * Implementation of a basic 3x3 game of TicTacToe. Game can end in a stalemate as well,\n * which is indicated by getWinner() returning null.\n *\/\npublic class TicTacToeModelVersionTwo implements TicTacToe {\n\n  \/\/ The top left corner is 0,0. Grid is indexed by rows first, then columns.\n  private List<List<Player>> grid;\n  private Player turn;\n\n  public TicTacToeModelVersionTwo() {\n    this.grid = new ArrayList<>();\n    for(int row = 0; row < 3; row++) {\n      List<Player> rowList = new ArrayList<>();\n      for(int col = 0; col < 3; col++) {\n        rowList.add(null);\n      }\n      this.grid.add(rowList);\n    }\n    this.turn = Player.X;\n  }\n\n  @Override\n  public String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard()).map(\n            row -> \" \" + Arrays.stream(row).map(\n                p -> p == null ? \" \" : p.toString()).collect(Collectors.joining(\" | \")))\n        .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n\n  @Override\n  public void move(int row, int col) {\n    if(isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    if(row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Bad row\/col\");\n    }\n    if(grid.get(row).get(col) != null) {\n      throw new IllegalArgumentException(\"Already placed mark here\");\n    }\n    grid.get(row).set(col, turn);\n    if(turn == Player.X) {\n      turn = Player.O;\n    } else {\n      turn = Player.X;\n    }\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    \/\/every spot on board is filled\n    \/\/or a winner\n    return isBoardFull() || isWinner();\n  }\n\n  private boolean isWinner() {\n    return isThreeInARow() != null || isThreeInACol() != null || isThreeInADiagonal() != null;\n  }\n\n  \/\/Slight change from class plan here: notice we will eventually need the winner\n  \/\/so we instead have methods to GET the possible winner. Then for isGameOver, we only\n  \/\/need to check if those winners are not null for the game to be over.\n  private Player isThreeInARow() {\n    for(int row = 0; row < 3; row++) {\n      Player mark = grid.get(row).get(0);\n      if (mark != null\n          && grid.get(row).get(0) == mark\n          && grid.get(row).get(1) == mark\n          && grid.get(row).get(2) == mark) {\n        return mark;\n      }\n    }\n    return null;\n  }\n\n  private Player isThreeInACol() {\n    for(int col = 0; col < 3; col++) {\n      Player mark = grid.get(0).get(col);\n      if (mark != null\n          && grid.get(0).get(col) == mark\n          && grid.get(1).get(col) == mark\n          && grid.get(2).get(col) == mark) {\n        return mark;\n      }\n    }\n    return null;\n  }\n\n  private Player isThreeInADiagonal() {\n    Player mark = grid.get(0).get(0);\n    if (mark != null && grid.get(1).get(1) == mark && grid.get(2).get(2) == mark) {\n      return mark;\n    }\n    mark = grid.get(0).get(2);\n    if (mark != null && grid.get(1).get(1) == mark && grid.get(2).get(0) == mark) {\n      return mark;\n    }\n    return null;\n  }\n\n  private boolean isBoardFull() {\n    for(int row = 0; row < 3; row++) {\n      for(int col = 0; col < 3; col++) {\n        if (grid.get(row).get(col) == null) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  @Override\n  public Player getWinner() {\n    Player winner = isThreeInARow();\n    if(winner != null) return winner;\n\n    winner = isThreeInACol();\n    if(winner != null) return winner;\n\n    return isThreeInADiagonal();\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    \/\/create the grid\n    Player[][] copy = new Player[3][3];\n    \/\/put the contents of the grid into the new copy\n    for(int row = 0; row < copy.length; row++) {\n      for(int col = 0; col < copy[0].length; col++) {\n        copy[row][col] = grid.get(row).get(col);\n      }\n    }\n    \/\/return the new copy\n    return copy;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic Player getMarkAt(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Bad row\/col\");\n    }\n    return grid.get(row).get(col);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\invariants-1030-starter\\src\\cs3500\\tictactoe\\TicTacToeModelVersionTwo.java","mask_span":[4603,4800],"topics":["testing","gui","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0023] given cell position. Because some cells may be empty of tokens, we need some way to distinguish empty cells from player numbers. The wrapped integer type Integer includes null, so we use Integer instead of int for the result with null representing empty cells.\n\nAdditionally, we will include a convenience method3 for asking whether a particular column is full.\n\n\/**\n * Gets the player whose token is at the given column and row. The\n * coordinates are zero-based and start in the lower left. Returns\n * {@code null} if there is no token in the given position.\n *\n * @param x the column coordinate ({@code 0 <= x < width})\n * @param y the row coordinate ({@code 0 <= y < height})\n * @return the player in the given position, or {@code null}\n * @throws IndexOutOfBoundsException if (x, y) is out of bo\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n\/**\n * Represents a single game of Tic Tac Toe. Three in a row down\/across\/diagonally to win; X goes\n * first.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n  protected final Player[][] board;\n  private Player turn;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void move(int row, int col) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(row, col);\n    if (board[row][col] != null) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[row][col] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (Player[] row : board) {\n      if (Arrays.stream(row).anyMatch(Objects::isNull)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (Player player : Player.values()) {\n      \/\/ check horizontals\n      for (Player[] row : board) {\n        if(Arrays.stream(row).allMatch(mark -> mark == player)) {\n          return player;\n        }\n      }\n      \/\/ check verticals\n      for (int col = 0; col < board[0].length; col++) {\n        if (board[0][col] == player && board[1][col] == player && board[2][col] == player) {\n          return player;\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n        return player;\n      }\n      if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n        return player;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int row = 0; row < board.length; row++) {\n      ret[row] = Arrays.copyOf(board[row], board[row].length);\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int row, int col) {\n    validateRowCol(row, col);\n    return board[row][col];\n  }\n\n  \/\/NOTE: Could be made non-static as well.\n  \/\/Made static here to show that there is no dynamic information needed. However, it can't be used\n  \/\/outside of this class due to it being private.\n  private static void validateRowCol(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + row + \",\" + col);\n    }\n  }\n\n  @Override\n  public String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard())\n        .map(row -> \" \" + Arrays.stream(row)\n            .map(player -> player == null ? \" \" : player.toString())\n            .collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\invariants-1335-starter\\src\\cs3500\\tictactoe\\TicTacToeModel.java","mask_span":[343,423],"topics":["strategy","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0023] given cell position. Because some cells may be empty of tokens, we need some way to distinguish empty cells from player numbers. The wrapped integer type Integer includes null, so we use Integer instead of int for the result with null representing empty cells.\n\nAdditionally, we will include a convenience method3 for asking whether a particular column is full.\n\n\/**\n * Gets the player whose token is at the given column and row. The\n * coordinates are zero-based and start in the lower left. Returns\n * {@code null} if there is no token in the given position.\n *\n * @param x the column coordinate ({@code 0 <= x < width})\n * @param y the row coordinate ({@code 0 <= y < height})\n * @return the player in the given position, or {@code null}\n * @throws IndexOutOfBoundsException if (x, y) is out of bo\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n\/**\n * Represents a single game of Tic Tac Toe. Three in a row down\/across\/diagonally to win; X goes\n * first.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n  protected final Player[][] board;\n  private Player turn;\n\n  public TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n\n  @Override\n  public void move(int row, int col) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(row, col);\n    if (board[row][col] != null) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[row][col] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (Player[] row : board) {\n      if (Arrays.stream(row).anyMatch(Objects::isNull)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (Player player : Player.values()) {\n      \/\/ check horizontals\n      for (Player[] row : board) {\n        if(Arrays.stream(row).allMatch(mark -> mark == player)) {\n          return player;\n        }\n      }\n      \/\/ check verticals\n      for (int col = 0; col < board[0].length; col++) {\n        if (board[0][col] == player && board[1][col] == player && board[2][col] == player) {\n          return player;\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n        return player;\n      }\n      if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n        return player;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int row = 0; row < board.length; row++) {\n      ret[row] = Arrays.copyOf(board[row], board[row].length);\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int row, int col) {\n    validateRowCol(row, col);\n    return board[row][col];\n  }\n\n  \/\/NOTE: Could be made non-static as well.\n  \/\/Made static here to show that there is no dynamic information needed. However, it can't be used\n  \/\/outside of this class due to it being private.\n  private static void validateRowCol(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + row + \",\" + col);\n    }\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard())\n        .map(row -> \" \" + Arrays.stream(row)\n            .map(player -> player == null ? \" \" : player.toString())\n            .collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\invariants-1335-starter\\src\\cs3500\\tictactoe\\TicTacToeModel.java","mask_span":[2634,3533],"topics":["strategy","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\n\/**\n * In this representation, player X is 1 and player O is 2.\n *\/\npublic class TicTacToeModelVersionOne implements TicTacToe {\n\n  protected final int[][] board;\n  private int turn;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void move(int row, int col) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(row, col);\n    if (board[row][col] != 0) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[row][col] = turn;\n    turn = (turn%2) + 1;\n  }\n\n  @Override\n  public Player getTurn() {\n    return getPlayerForInt(turn);\n  }\n\n  private Player getPlayerForInt(int player) {\n    switch(player) {\n      case 0:\n        return null;\n      case 1:\n        return Player.X;\n      case 2:\n        return Player.O;\n    }\n    throw new RuntimeException(\"Unknown turn value\");\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (int[] row : board) {\n      if (Arrays.stream(row).anyMatch(cell -> cell == 0)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (int player : new int[] {1, 2}) {\n      \/\/ check horizontals\n      for (int[] row : board) {\n        if(Arrays.stream(row).allMatch(mark -> mark == player)) {\n          return getPlayerForInt(player);\n        }\n      }\n      \/\/ check verticals\n      for (int col = 0; col < board[0].length; col++) {\n        if (board[0][col] == player && board[1][col] == player && board[2][col] == player) {\n          return getPlayerForInt(player);\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n        return getPlayerForInt(player);\n      }\n      if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n        return getPlayerForInt(player);\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int row = 0; row < board.length; row++) {\n      for(int col = 0; col < board[0].length; col++) {\n        ret[row][col] = getPlayerForInt(board[row][col]);\n      }\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int row, int col) {\n    validateRowCol(row, col);\n    return getPlayerForInt(board[row][col]);\n  }\n\n  \/\/NOTE: Could be made non-static as well.\n  \/\/Made static here to show that there is no dynamic information needed. However, it can't be used\n  \/\/outside of this class due to it being private.\n  private static void validateRowCol(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + row + \",\" + col);\n    }\n  }\n\n  @Override\n  public String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard())\n        .map(row -> \" \" + Arrays.stream(row)\n            .map(player -> player == null ? \" \" : player.toString())\n            .collect(Collectors.joining(\" | \")))\n        .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeModelVersionOne() {\n    board = new int[3][3];\n    turn = 1;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\invariants-1335-starter\\src\\cs3500\\tictactoe\\TicTacToeModelVersionOne.java","mask_span":[275,355],"topics":["strategy","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\n\/**\n * In this representation, player X is 1 and player O is 2.\n *\/\npublic class TicTacToeModelVersionOne implements TicTacToe {\n\n  protected final int[][] board;\n  private int turn;\n\n  public TicTacToeModelVersionOne() {\n    board = new int[3][3];\n    turn = 1;\n  }\n\n  @Override\n  public void move(int row, int col) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(row, col);\n    if (board[row][col] != 0) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[row][col] = turn;\n    turn = (turn%2) + 1;\n  }\n\n  @Override\n  public Player getTurn() {\n    return getPlayerForInt(turn);\n  }\n\n  private Player getPlayerForInt(int player) {\n    switch(player) {\n      case 0:\n        return null;\n      case 1:\n        return Player.X;\n      case 2:\n        return Player.O;\n    }\n    throw new RuntimeException(\"Unknown turn value\");\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (int[] row : board) {\n      if (Arrays.stream(row).anyMatch(cell -> cell == 0)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (int player : new int[] {1, 2}) {\n      \/\/ check horizontals\n      for (int[] row : board) {\n        if(Arrays.stream(row).allMatch(mark -> mark == player)) {\n          return getPlayerForInt(player);\n        }\n      }\n      \/\/ check verticals\n      for (int col = 0; col < board[0].length; col++) {\n        if (board[0][col] == player && board[1][col] == player && board[2][col] == player) {\n          return getPlayerForInt(player);\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n        return getPlayerForInt(player);\n      }\n      if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n        return getPlayerForInt(player);\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int row = 0; row < board.length; row++) {\n      for(int col = 0; col < board[0].length; col++) {\n        ret[row][col] = getPlayerForInt(board[row][col]);\n      }\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int row, int col) {\n    validateRowCol(row, col);\n    return getPlayerForInt(board[row][col]);\n  }\n\n  \/\/NOTE: Could be made non-static as well.\n  \/\/Made static here to show that there is no dynamic information needed. However, it can't be used\n  \/\/outside of this class due to it being private.\n  private static void validateRowCol(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + row + \",\" + col);\n    }\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard())\n        .map(row -> \" \" + Arrays.stream(row)\n            .map(player -> player == null ? \" \" : player.toString())\n            .collect(Collectors.joining(\" | \")))\n        .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\invariants-1335-starter\\src\\cs3500\\tictactoe\\TicTacToeModelVersionOne.java","mask_span":[2937,3834],"topics":["strategy","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0001]  of Integers that will let us use the positions to access the cell contents.\n\nSome of these methods return simple quantities that don’t change, so for those we can just store each in a field:\n\npublic int width;\npublic int height;\npublic int goal;\npublic int players;\nClearly we need to represent the state of the game grid, in particular which tokens are where. Since the grid is essentially a two-dimensional matrix, we can use an array of arrays or list of lists. In general this choice is arbitrary (except for the effects of locality), but in this case columns may make more sense, because we can use shorter lists to represent not-yet-full columns and grow them as necessary.\n\npublic List<List<Integer>> columns;\nFinally, we need state in order to be able to tell the client who the current play\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0023] given cell position. Because some cells may be empty of tokens, we need some way to distinguish empty cells from player numbers. The wrapped integer type Integer includes null, so we use Integer instead of int for the result with null representing empty cells.\n\nAdditionally, we will include a convenience method3 for asking whether a particular column is full.\n\n\/**\n * Gets the player whose token is at the given column and row. The\n * coordinates are zero-based and start in the lower left. Returns\n * {@code null} if there is no token in the given position.\n *\n * @param x the column coordinate ({@code 0 <= x < width})\n * @param y the row coordinate ({@code 0 <= y < height})\n * @return the player in the given position, or {@code null}\n * @throws IndexOutOfBoundsException if (x, y) is out of bo\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0014]  a copy of the grid (which need not be the same type as what we use internally):\n\n\/**\n * Returns a two-dimensional array representing the state of the\n * grid. The first index is the column and the second the row.\n * The resulting array is newly allocated and unconnected to the model;\n * thus, mutating it will have no effect on the model or subsequent\n * calls to {@code getGrid}.\n *\n * @return a copy of the grid\n *\/\nPlayer[][] getGrid();\nAlternatively, rather than return some representation of the grid, we could provide some means of querying it:\n\n\/**\n * Returns the {@link Player} whose mark is in the cell at the given\n * coordinates, or {@code null} if that cell is empty.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @return a {@code Player} or {@code \n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0001] o you in the starter code. You will fill in the fields and remaining method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe game grid cells are numbered by row and column starting from 0. For example, the upper left position is row 0, column 0 (or [0][0] in the 2D array returned by getBoard()), the upper middle position is row 0, column 1 ([0][1]), the lower right is [2][2].\n\n2 Testing\nWe have supplied you with some basic JUnit tests as part of the starter code. Use these to verify that your implementation is correct, and write additional tests of your own.\n\n3 Notes to Keep in Mind\nAvoid duplicating code as much as possible. Consider using non-public methods as means of creating reusable pieces of functionality.\nBe sure to use access modifiers, \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n\/**\n * Implementation of a basic 3x3 game of TicTacToe. Game can end in a stalemate as well,\n * which is indicated by getWinner() returning null.\n *\/\npublic class TicTacToeModelVersionTwo implements TicTacToe {\n\n  \/\/ The top left corner is 0,0. Grid is indexed by rows first, then columns.\n  private List<List<Player>> grid;\n  private Player turn;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard()).map(\n            row -> \" \" + Arrays.stream(row).map(\n                p -> p == null ? \" \" : p.toString()).collect(Collectors.joining(\" | \")))\n        .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n\n  @Override\n  public void move(int row, int col) {\n    if(isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    if(row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Bad row\/col\");\n    }\n    if(grid.get(row).get(col) != null) {\n      throw new IllegalArgumentException(\"Already placed mark here\");\n    }\n    grid.get(row).set(col, turn);\n    if(turn == Player.X) {\n      turn = Player.O;\n    } else {\n      turn = Player.X;\n    }\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    \/\/every spot on board is filled\n    \/\/or a winner\n    return isBoardFull() || isWinner();\n  }\n\n  private boolean isWinner() {\n    return isThreeInARow() != null || isThreeInACol() != null || isThreeInADiagonal() != null;\n  }\n\n  \/\/Slight change from class plan here: notice we will eventually need the winner\n  \/\/so we instead have methods to GET the possible winner. Then for isGameOver, we only\n  \/\/need to check if those winners are not null for the game to be over.\n  private Player isThreeInARow() {\n    for(int row = 0; row < 3; row++) {\n      Player mark = grid.get(row).get(0);\n      if (mark != null\n          && grid.get(row).get(0) == mark\n          && grid.get(row).get(1) == mark\n          && grid.get(row).get(2) == mark) {\n        return mark;\n      }\n    }\n    return null;\n  }\n\n  private Player isThreeInACol() {\n    for(int col = 0; col < 3; col++) {\n      Player mark = grid.get(0).get(col);\n      if (mark != null\n          && grid.get(0).get(col) == mark\n          && grid.get(1).get(col) == mark\n          && grid.get(2).get(col) == mark) {\n        return mark;\n      }\n    }\n    return null;\n  }\n\n  private Player isThreeInADiagonal() {\n    Player mark = grid.get(0).get(0);\n    if (mark != null && grid.get(1).get(1) == mark && grid.get(2).get(2) == mark) {\n      return mark;\n    }\n    mark = grid.get(0).get(2);\n    if (mark != null && grid.get(1).get(1) == mark && grid.get(2).get(0) == mark) {\n      return mark;\n    }\n    return null;\n  }\n\n  private boolean isBoardFull() {\n    for(int row = 0; row < 3; row++) {\n      for(int col = 0; col < 3; col++) {\n        if (grid.get(row).get(col) == null) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  @Override\n  public Player getWinner() {\n    Player winner = isThreeInARow();\n    if(winner != null) return winner;\n\n    winner = isThreeInACol();\n    if(winner != null) return winner;\n\n    return isThreeInADiagonal();\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    \/\/create the grid\n    Player[][] copy = new Player[3][3];\n    \/\/put the contents of the grid into the new copy\n    for(int row = 0; row < copy.length; row++) {\n      for(int col = 0; col < copy[0].length; col++) {\n        copy[row][col] = grid.get(row).get(col);\n      }\n    }\n    \/\/return the new copy\n    return copy;\n  }\n\n  @Override\n  public Player getMarkAt(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Bad row\/col\");\n    }\n    return grid.get(row).get(col);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeModelVersionTwo() {\n    this.grid = new ArrayList<>();\n    for(int row = 0; row < 3; row++) {\n      List<Player> rowList = new ArrayList<>();\n      for(int col = 0; col < 3; col++) {\n        rowList.add(null);\n      }\n      this.grid.add(rowList);\n    }\n    this.turn = Player.X;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\invariants-1335-starter\\src\\cs3500\\tictactoe\\TicTacToeModelVersionTwo.java","mask_span":[491,790],"topics":["testing","gui","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0001]  of Integers that will let us use the positions to access the cell contents.\n\nSome of these methods return simple quantities that don’t change, so for those we can just store each in a field:\n\npublic int width;\npublic int height;\npublic int goal;\npublic int players;\nClearly we need to represent the state of the game grid, in particular which tokens are where. Since the grid is essentially a two-dimensional matrix, we can use an array of arrays or list of lists. In general this choice is arbitrary (except for the effects of locality), but in this case columns may make more sense, because we can use shorter lists to represent not-yet-full columns and grow them as necessary.\n\npublic List<List<Integer>> columns;\nFinally, we need state in order to be able to tell the client who the current play\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0023] given cell position. Because some cells may be empty of tokens, we need some way to distinguish empty cells from player numbers. The wrapped integer type Integer includes null, so we use Integer instead of int for the result with null representing empty cells.\n\nAdditionally, we will include a convenience method3 for asking whether a particular column is full.\n\n\/**\n * Gets the player whose token is at the given column and row. The\n * coordinates are zero-based and start in the lower left. Returns\n * {@code null} if there is no token in the given position.\n *\n * @param x the column coordinate ({@code 0 <= x < width})\n * @param y the row coordinate ({@code 0 <= y < height})\n * @return the player in the given position, or {@code null}\n * @throws IndexOutOfBoundsException if (x, y) is out of bo\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0014]  a copy of the grid (which need not be the same type as what we use internally):\n\n\/**\n * Returns a two-dimensional array representing the state of the\n * grid. The first index is the column and the second the row.\n * The resulting array is newly allocated and unconnected to the model;\n * thus, mutating it will have no effect on the model or subsequent\n * calls to {@code getGrid}.\n *\n * @return a copy of the grid\n *\/\nPlayer[][] getGrid();\nAlternatively, rather than return some representation of the grid, we could provide some means of querying it:\n\n\/**\n * Returns the {@link Player} whose mark is in the cell at the given\n * coordinates, or {@code null} if that cell is empty.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @return a {@code Player} or {@code \n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0001] o you in the starter code. You will fill in the fields and remaining method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe game grid cells are numbered by row and column starting from 0. For example, the upper left position is row 0, column 0 (or [0][0] in the 2D array returned by getBoard()), the upper middle position is row 0, column 1 ([0][1]), the lower right is [2][2].\n\n2 Testing\nWe have supplied you with some basic JUnit tests as part of the starter code. Use these to verify that your implementation is correct, and write additional tests of your own.\n\n3 Notes to Keep in Mind\nAvoid duplicating code as much as possible. Consider using non-public methods as means of creating reusable pieces of functionality.\nBe sure to use access modifiers, \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n\/**\n * Implementation of a basic 3x3 game of TicTacToe. Game can end in a stalemate as well,\n * which is indicated by getWinner() returning null.\n *\/\npublic class TicTacToeModelVersionTwo implements TicTacToe {\n\n  \/\/ The top left corner is 0,0. Grid is indexed by rows first, then columns.\n  private List<List<Player>> grid;\n  private Player turn;\n\n  public TicTacToeModelVersionTwo() {\n    this.grid = new ArrayList<>();\n    for(int row = 0; row < 3; row++) {\n      List<Player> rowList = new ArrayList<>();\n      for(int col = 0; col < 3; col++) {\n        rowList.add(null);\n      }\n      this.grid.add(rowList);\n    }\n    this.turn = Player.X;\n  }\n\n  @Override\n  public String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard()).map(\n            row -> \" \" + Arrays.stream(row).map(\n                p -> p == null ? \" \" : p.toString()).collect(Collectors.joining(\" | \")))\n        .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n\n  @Override\n  public void move(int row, int col) {\n    if(isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    if(row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Bad row\/col\");\n    }\n    if(grid.get(row).get(col) != null) {\n      throw new IllegalArgumentException(\"Already placed mark here\");\n    }\n    grid.get(row).set(col, turn);\n    if(turn == Player.X) {\n      turn = Player.O;\n    } else {\n      turn = Player.X;\n    }\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    \/\/every spot on board is filled\n    \/\/or a winner\n    return isBoardFull() || isWinner();\n  }\n\n  private boolean isWinner() {\n    return isThreeInARow() != null || isThreeInACol() != null || isThreeInADiagonal() != null;\n  }\n\n  \/\/Slight change from class plan here: notice we will eventually need the winner\n  \/\/so we instead have methods to GET the possible winner. Then for isGameOver, we only\n  \/\/need to check if those winners are not null for the game to be over.\n  private Player isThreeInARow() {\n    for(int row = 0; row < 3; row++) {\n      Player mark = grid.get(row).get(0);\n      if (mark != null\n          && grid.get(row).get(0) == mark\n          && grid.get(row).get(1) == mark\n          && grid.get(row).get(2) == mark) {\n        return mark;\n      }\n    }\n    return null;\n  }\n\n  private Player isThreeInACol() {\n    for(int col = 0; col < 3; col++) {\n      Player mark = grid.get(0).get(col);\n      if (mark != null\n          && grid.get(0).get(col) == mark\n          && grid.get(1).get(col) == mark\n          && grid.get(2).get(col) == mark) {\n        return mark;\n      }\n    }\n    return null;\n  }\n\n  private Player isThreeInADiagonal() {\n    Player mark = grid.get(0).get(0);\n    if (mark != null && grid.get(1).get(1) == mark && grid.get(2).get(2) == mark) {\n      return mark;\n    }\n    mark = grid.get(0).get(2);\n    if (mark != null && grid.get(1).get(1) == mark && grid.get(2).get(0) == mark) {\n      return mark;\n    }\n    return null;\n  }\n\n  private boolean isBoardFull() {\n    for(int row = 0; row < 3; row++) {\n      for(int col = 0; col < 3; col++) {\n        if (grid.get(row).get(col) == null) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  @Override\n  public Player getWinner() {\n    Player winner = isThreeInARow();\n    if(winner != null) return winner;\n\n    winner = isThreeInACol();\n    if(winner != null) return winner;\n\n    return isThreeInADiagonal();\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    \/\/create the grid\n    Player[][] copy = new Player[3][3];\n    \/\/put the contents of the grid into the new copy\n    for(int row = 0; row < copy.length; row++) {\n      for(int col = 0; col < copy[0].length; col++) {\n        copy[row][col] = grid.get(row).get(col);\n      }\n    }\n    \/\/return the new copy\n    return copy;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic Player getMarkAt(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Bad row\/col\");\n    }\n    return grid.get(row).get(col);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\invariants-1335-starter\\src\\cs3500\\tictactoe\\TicTacToeModelVersionTwo.java","mask_span":[4603,4800],"topics":["testing","gui","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0003] n\nAll examples in this lecture follow a common design. The model state (interface IModel and implementation Model) consists of a single String and offers methods to get and update it. All views (coupled with controllers wherever applicable) expose functionality to interactively show this string, and to update it.\n\n3 Text-based UI\nIn the TextUI directory we show a text-based user interface. The IView interface encapsulates all the methods that a view’s client would need to call: note how they correspond roughly to the “things” that a controller would need to tell the view to do. The TextView class implements this interface. It transmits all messages to a PrintStream object provided to it through its constructor. Similar to the design in Lecture 8 this allows us to test the view using any su\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0002] user interfaces. We start with poorly-designed but working code, and improve it in three stages. Initially, the code for the view will directly manipulate the model. Our first incremental improvement will decouple the view from the model so that it need not — and in fact cannot — do so. Our second improvement will add a new feature to the view, and add the ability to control that in the controller. Finally, our third improvement will generalize the controller to make its UI triggers more customizable.\n\nThe code for this lecture is available at the top of this page, as the MVC code link. The second link provides code for a program with an incomplete GUI. It is recommended that you complete this exercise to practice with GUIs. Finally the third link provides a solution for this GUI.\n\n2 Desig\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n<\/Context>","code_prefix":"<CodePrefix>\nimport view.GUIView;\nimport view.ViewActions;\n\npublic class GUIController implements ViewActions {\n\n  private final IModel model;\n  private final GUIView view;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void displayText(String text) {\n    model.setString(text);\n    view.displayText(model.getString());\n    view.clearInput();\n    view.refresh();\n  }\n\n  @Override\n  public void exitProgram() {\n    System.exit(0);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic GUIController(IModel model, GUIView view) {\n    this.model = model;\n    this.view = view;\n    view.setViewActions(this);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\keycommands-1030\\src\\GUIController.java","mask_span":[163,294],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0003] n\nAll examples in this lecture follow a common design. The model state (interface IModel and implementation Model) consists of a single String and offers methods to get and update it. All views (coupled with controllers wherever applicable) expose functionality to interactively show this string, and to update it.\n\n3 Text-based UI\nIn the TextUI directory we show a text-based user interface. The IView interface encapsulates all the methods that a view’s client would need to call: note how they correspond roughly to the “things” that a controller would need to tell the view to do. The TextView class implements this interface. It transmits all messages to a PrintStream object provided to it through its constructor. Similar to the design in Lecture 8 this allows us to test the view using any su\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0002] user interfaces. We start with poorly-designed but working code, and improve it in three stages. Initially, the code for the view will directly manipulate the model. Our first incremental improvement will decouple the view from the model so that it need not — and in fact cannot — do so. Our second improvement will add a new feature to the view, and add the ability to control that in the controller. Finally, our third improvement will generalize the controller to make its UI triggers more customizable.\n\nThe code for this lecture is available at the top of this page, as the MVC code link. The second link provides code for a program with an incomplete GUI. It is recommended that you complete this exercise to practice with GUIs. Finally the third link provides a solution for this GUI.\n\n2 Desig\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n<\/Context>","code_prefix":"<CodePrefix>\nimport view.EchoFrame;\nimport view.GUIView;\n\npublic class MVCExampleTextUI {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String []args) {\n        IModel model = new Model();\n        GUIView view = new EchoFrame(); \/\/This view no longer needs the model.\n        GUIController controller = new GUIController(model, view); \/\/constructor sets up everything\n        \/\/alternatively, expose a method that sets the ViewActions and sets the view to be visible\n\n        \/*\n         * \/\/ OLD WAY!\n        IModel model = new Model();\n        IView view = new TextView(System.out);\n        IController controller = new TextController(model,System.in,view);\n        controller.runProgram();\n         *\/\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\keycommands-1030\\src\\MVCExampleTextUI.java","mask_span":[81,679],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0012]  } catch (InputMismatchException ime) {\n      ...\n    }\n    break;\n}\nThe possibilities are now endless! We can support similar higher-level drawing text commands. Every such text commands adds a new case to our switch statement. The number of lines of code in each case statement depends on the complexity of the text command (e.g. the square text-command added 13 lines of code). As a result, the switch statement quickly grows in size. Moreover the go method is increasingly incohesive.\n\n4 The Command Design Pattern\nIn order to make each case statement shorter, we can put all its code into a separate helper method. Since all the helper methods operate on the model, we pass the model object to them. Also since some of the text command require additional input, we pass the additional input to e\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0015] acingTurtleModel m) {\n    m.trace(this.d);\n  }\n\n  ...\n\n}\nNow we can change the logic of our controller to:\n\nTake a one-word command from the user.\nCreate the corresponding TracingTurtleCommand object..\nExecute the command object.\nString in = s.next();\ntry {\n  switch (in) {\n    case \"q\":\n    case \"quit\":\n      return;\n   case \"show\":\n     for (Line l : m.getLines()) {\n        System.out.println(l);\n     }\n     break;\n   case \"move\":\n      cmd = new Move(s.nextDouble());\n      break;\n   case \"trace\":\n      cmd = new Trace(s.nextDouble());\n      break;\n   case \"turn\":\n      cmd = new Turn(s.nextDouble());\n      break;\n   case \"square\":\n      cmd = new Square(s.nextDouble());\n      break;\n   default:\n      System.out.println(String.format(\"Unknown command %s\", in));\n      cmd = null;\n      bre\n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.InputStream;\nimport java.util.Scanner;\n\npublic class TextController implements IController{\n    private Scanner in;\n    private IView view;\n    private IModel model;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic void runProgram() {\n        boolean quit = false;\n\n        while (!quit) {\n            \/\/tell view to show the string so far.\n            view.showString(this.model.getString());\n            \/\/tell view to show options\n            view.showOptions();\n            \/\/accept user input\n            String option = in.next();\n            switch (option) {\n                case \"E\":\n                    \/\/ask for string input\n                    view.showStringEntry();\n                    in.nextLine();\n                    String input = in.nextLine();\n                    \/\/give to model\n                    model.setString(input);\n                    break;\n                case \"Q\":\n                    quit = true;\n                    break;\n                default:\n                    view.showOptionError();\n            }\n        }\n    }\n\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TextController(IModel model,InputStream in,IView view) {\n        this.model = model;\n        this.view = view;\n        this.in = new Scanner(in);\n\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\keycommands-1030\\src\\TextController.java","mask_span":[186,345],"topics":["observer","command","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0020] en again using Java’s new lambda syntax (see Streamlining the code further below).\n\n\/**\n * Represents the printing of a sequence of lines to output\n *\/\nclass PrintInteraction implements Interaction {\n  String[] lines;\n  PrintInteraction(String... lines) {\n    this.lines = lines;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    for (String line : lines) {\n      out.append(line).append(\"\\n\");\n    }\n  }\n}\n\/**\n * Represents a user providing the program with  an input\n *\/\nclass InputInteraction implements Interaction {\n  String input;\n  InputInteraction(String input) {\n    this.input = input;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    in.append(input);\n  }\n}\nFor example, the following array of Interactions represents two inputs to our Calculator and the\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.PrintStream;\n\npublic class TextView implements IView {\n    private PrintStream out;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic void showString(String s) {\n        out.println(\"String: \"+s);\n    }\n\n    public void showOptions() {\n        \/\/print the UI\n        out.println(\"Menu: \");\n        out.println(\"E: Enter a string\");\n        out.println(\"Q: Quit the program\");\n        out.print(\"Enter your choice: \");\n    }\n\n    public void showStringEntry() {\n        out.print(\"\\nEnter the string to be echoed: \");\n    }\n\n    public void showOptionError() {\n        out.print(\"\\nInvalid option. Please try again.\");\n    }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TextView(PrintStream out) {\n        this.out = out;\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\keycommands-1030\\src\\TextView.java","mask_span":[104,168],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0020] en again using Java’s new lambda syntax (see Streamlining the code further below).\n\n\/**\n * Represents the printing of a sequence of lines to output\n *\/\nclass PrintInteraction implements Interaction {\n  String[] lines;\n  PrintInteraction(String... lines) {\n    this.lines = lines;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    for (String line : lines) {\n      out.append(line).append(\"\\n\");\n    }\n  }\n}\n\/**\n * Represents a user providing the program with  an input\n *\/\nclass InputInteraction implements Interaction {\n  String input;\n  InputInteraction(String input) {\n    this.input = input;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    in.append(input);\n  }\n}\nFor example, the following array of Interactions represents two inputs to our Calculator and the\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.PrintStream;\n\npublic class TextView implements IView {\n    private PrintStream out;\n\n    public TextView(PrintStream out) {\n        this.out = out;\n    }\n\n    public void showString(String s) {\n        out.println(\"String: \"+s);\n    }\n\n    public void showOptions() {\n        \/\/print the UI\n        out.println(\"Menu: \");\n        out.println(\"E: Enter a string\");\n        out.println(\"Q: Quit the program\");\n        out.print(\"Enter your choice: \");\n    }\n\n    public void showStringEntry() {\n        out.print(\"\\nEnter the string to be echoed: \");\n    }\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void showOptionError() {\n        out.print(\"\\nInvalid option. Please try again.\");\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\keycommands-1030\\src\\TextView.java","mask_span":[575,670],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n<\/Context>","code_prefix":"<CodePrefix>\npackage view;\n\nimport java.awt.Color;\nimport java.awt.FlowLayout;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\nimport javax.swing.JFrame;\n\npublic class EchoFrame extends JFrame implements GUIView {\n\n  private final EchoPanel echoPanel;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public String getInput() {\n    return echoPanel.getInput();\n  }\n\n  @Override\n  public void displayText(String string) {\n    echoPanel.displayText(string);\n  }\n\n  @Override\n  public void clearInput() {\n    echoPanel.clearInput();\n  }\n\n  @Override\n  public void setViewActions(ViewActions actions) {\n    echoPanel.setViewActions(actions);\n    this.addKeyListener(new KeyListener() {\n      @Override\n      public void keyTyped(KeyEvent e) {\n        if(e.getKeyChar() == 'x') {\n          actions.exitProgram();\n        }\n      }\n\n      @Override\n      public void keyPressed(KeyEvent e) {\n\n      }\n\n      @Override\n      public void keyReleased(KeyEvent e) {\n\n      }\n    });\n    this.setVisible(true);\n  }\n\n  @Override\n  public void refresh() {\n    this.requestFocus();\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic EchoFrame() {\n    super();\n    this.setSize(700, 300);\n    this.setLocation(600, 500);\n\n    \/\/To put the frame in the middle of the screen, use\n    \/\/this.setLocationRelativeTo(null);\n\n    this.setDefaultCloseOperation(EXIT_ON_CLOSE);\n    this.setBackground(Color.MAGENTA);\n\n    \/\/Set the manager so everything is added in a line if possible\n    this.setLayout(new FlowLayout());\n\n    echoPanel = new EchoPanel();\n    this.add(echoPanel);\n\n    this.pack();\n    this.setVisible(true);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\keycommands-1030\\src\\view\\EchoFrame.java","mask_span":[261,755],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0007] y a function that gets called when something interesting occurs. In our case, the clicking of different buttons should trigger a callback. In the jargon of Swing, clicking on buttons triggers their action, and so we must supply a function object that implements the ActionListener interface. (Other controls have additional events besides “actions”.) For convenience, Swing allows us to label each button with a so-called action command, which is a String of our choosing: when the ActionListener’s callback is invoked, it will be given an ActionEvent object that knows the action command of the button that was clicked. In this way, we can use a single listener to listen to multiple buttons at once, and distinguish them by means of this command string. See the calls to setActionCommand and setAct\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0043] e key, String featureName) {\n    this.keyComponent.getInputMap().put(key, featureName);\n  }\n\n  public void addFeatures(Features features) {\n    this.keyComponent.addFeatures(features);\n  }\n}\n\n\/\/ NOTE: Neither does this class!  It only refers to Features.\nclass KeyComponent extends JPanel {\n  List<Features> featureListeners = new ArrayList<>();\n\n  \/\/ Includes this new feature listener in responding to keys\n  void addFeatures(Features f) { this.featureListeners.add(f); }\n\n  KeyComponent() {\n    \/\/ Install action command -> Feature callback associations\n    this.getActionMap().put(\"makeCaps\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.makeUppercase();\n      }\n    });\n    this.getActionMap().put(\"restoreLowe\n<\/Context>","code_prefix":"<CodePrefix>\npackage view;\n\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\nimport javax.swing.*;\n\npublic class EchoPanel extends JPanel {\n\n  private JLabel echoLabel;\n  private JTextField inputField;\n\n  private final JButton echoButton;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic String getInput() {\n    return inputField.getText();\n  }\n\n  public void displayText(String string) {\n    echoLabel.setText(string);\n  }\n\n  public void clearInput() {\n    inputField.setText(\"\");\n  }\n\n  public void setViewActions(ViewActions actions) {\n    echoButton.addActionListener(new EchoActionListener(actions));\n  }\n\n  class EchoActionListener implements ActionListener {\n\n    private ViewActions actions;\n\n    public EchoActionListener(ViewActions actions) {\n      this.actions = actions;\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n      actions.displayText(EchoPanel.this.getInput());\n      \/\/If we want access to the field itself\n      \/\/actions.displayText(EchoPanel.this.textInput.getText());\n    }\n  }\n}\n\n\n<\/CodeSuffix>","target":"<Target>\npublic EchoPanel() {\n    super();\n\n    this.echoLabel = new JLabel(\"Echo text!\");\n    this.add(echoLabel);\n\n    this.inputField = new JTextField(20);\n    this.add(inputField);\n\n    echoButton = new JButton(\"Echo!\");\n    echoButton.setActionCommand(\"echo\");\n    \/\/echoButton.addActionListener(this); \/\/This no longer works! So how do we add the listener?! (Observer pattern)\n    this.add(echoButton);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\keycommands-1030\\src\\view\\EchoPanel.java","mask_span":[254,657],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0007] y a function that gets called when something interesting occurs. In our case, the clicking of different buttons should trigger a callback. In the jargon of Swing, clicking on buttons triggers their action, and so we must supply a function object that implements the ActionListener interface. (Other controls have additional events besides “actions”.) For convenience, Swing allows us to label each button with a so-called action command, which is a String of our choosing: when the ActionListener’s callback is invoked, it will be given an ActionEvent object that knows the action command of the button that was clicked. In this way, we can use a single listener to listen to multiple buttons at once, and distinguish them by means of this command string. See the calls to setActionCommand and setAct\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0043] e key, String featureName) {\n    this.keyComponent.getInputMap().put(key, featureName);\n  }\n\n  public void addFeatures(Features features) {\n    this.keyComponent.addFeatures(features);\n  }\n}\n\n\/\/ NOTE: Neither does this class!  It only refers to Features.\nclass KeyComponent extends JPanel {\n  List<Features> featureListeners = new ArrayList<>();\n\n  \/\/ Includes this new feature listener in responding to keys\n  void addFeatures(Features f) { this.featureListeners.add(f); }\n\n  KeyComponent() {\n    \/\/ Install action command -> Feature callback associations\n    this.getActionMap().put(\"makeCaps\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.makeUppercase();\n      }\n    });\n    this.getActionMap().put(\"restoreLowe\n<\/Context>","code_prefix":"<CodePrefix>\npackage view;\n\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\nimport javax.swing.*;\n\npublic class EchoPanel extends JPanel {\n\n  private JLabel echoLabel;\n  private JTextField inputField;\n\n  private final JButton echoButton;\n\n  public EchoPanel() {\n    super();\n\n    this.echoLabel = new JLabel(\"Echo text!\");\n    this.add(echoLabel);\n\n    this.inputField = new JTextField(20);\n    this.add(inputField);\n\n    echoButton = new JButton(\"Echo!\");\n    echoButton.setActionCommand(\"echo\");\n    \/\/echoButton.addActionListener(this); \/\/This no longer works! So how do we add the listener?! (Observer pattern)\n    this.add(echoButton);\n  }\n\n  public String getInput() {\n    return inputField.getText();\n  }\n\n  public void displayText(String string) {\n    echoLabel.setText(string);\n  }\n\n  public void clearInput() {\n    inputField.setText(\"\");\n  }\n\n  public void setViewActions(ViewActions actions) {\n    echoButton.addActionListener(new EchoActionListener(actions));\n  }\n\n  class EchoActionListener implements ActionListener {\n\n    private ViewActions actions;\n\n    public EchoActionListener(ViewActions actions) {\n      this.actions = actions;\n    }\n\n    @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n}\n\n\n<\/CodeSuffix>","target":"<Target>\npublic void actionPerformed(ActionEvent e) {\n      actions.displayText(EchoPanel.this.getInput());\n      \/\/If we want access to the field itself\n      \/\/actions.displayText(EchoPanel.this.textInput.getText());\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\keycommands-1030\\src\\view\\EchoPanel.java","mask_span":[1189,1404],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0044] rcase\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.restoreLowercase();\n      }\n    });\n    this.getActionMap().put(\"toggleColor\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.toggleColor();\n      }\n    });\n    ...\n  }\n}\n\n\/\/ NOTE: Only the Controller needs to know how to implement Features.\npublic class Controller implements Features {\n  private IModel model;\n  private IView view;\n\n  ...\n\n  \/\/ These are the high-level event handlers we care about:\n  @Override\n  public void toggleColor() {\n    view.toggleColor();\n  }\n\n  @Override\n  public void makeUppercase() {\n    String text = model.getString();\n    text = text.toUpperCa\n<\/Context>","code_prefix":"<CodePrefix>\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\nimport model.IModel;\nimport view.IGUIView;\nimport view.ViewActions;\n\npublic class GUIController implements ViewActions {\n\n  private final IModel model;\n  private final IGUIView view;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void displayText(String text) {\n    model.setString(text);\n    view.displayText(model.getString());\n    view.clearInput();\n    view.refresh();\n  }\n\n  @Override\n  public void exitProgram() {\n    System.exit(0);\n  }\n\n  public void runProgram() {\n    view.setViewActions(this);\n    view.makeVisible();\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic GUIController(IModel model, IGUIView view) {\n    this.model = model;\n    this.view = view;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\keycommands-1335\\src\\GUIController.java","mask_span":[260,361],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0044] rcase\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.restoreLowercase();\n      }\n    });\n    this.getActionMap().put(\"toggleColor\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.toggleColor();\n      }\n    });\n    ...\n  }\n}\n\n\/\/ NOTE: Only the Controller needs to know how to implement Features.\npublic class Controller implements Features {\n  private IModel model;\n  private IView view;\n\n  ...\n\n  \/\/ These are the high-level event handlers we care about:\n  @Override\n  public void toggleColor() {\n    view.toggleColor();\n  }\n\n  @Override\n  public void makeUppercase() {\n    String text = model.getString();\n    text = text.toUpperCa\n<\/Context>","code_prefix":"<CodePrefix>\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\nimport model.IModel;\nimport view.IGUIView;\nimport view.ViewActions;\n\npublic class GUIController implements ViewActions {\n\n  private final IModel model;\n  private final IGUIView view;\n\n  public GUIController(IModel model, IGUIView view) {\n    this.model = model;\n    this.view = view;\n  }\n\n\n  @Override\n  public void displayText(String text) {\n    model.setString(text);\n    view.displayText(model.getString());\n    view.clearInput();\n    view.refresh();\n  }\n\n  @Override\n  public void exitProgram() {\n    System.exit(0);\n  }\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void runProgram() {\n    view.setViewActions(this);\n    view.makeVisible();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\keycommands-1335\\src\\GUIController.java","mask_span":[602,687],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0003] n\nAll examples in this lecture follow a common design. The model state (interface IModel and implementation Model) consists of a single String and offers methods to get and update it. All views (coupled with controllers wherever applicable) expose functionality to interactively show this string, and to update it.\n\n3 Text-based UI\nIn the TextUI directory we show a text-based user interface. The IView interface encapsulates all the methods that a view’s client would need to call: note how they correspond roughly to the “things” that a controller would need to tell the view to do. The TextView class implements this interface. It transmits all messages to a PrintStream object provided to it through its constructor. Similar to the design in Lecture 8 this allows us to test the view using any su\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0002] user interfaces. We start with poorly-designed but working code, and improve it in three stages. Initially, the code for the view will directly manipulate the model. Our first incremental improvement will decouple the view from the model so that it need not — and in fact cannot — do so. Our second improvement will add a new feature to the view, and add the ability to control that in the controller. Finally, our third improvement will generalize the controller to make its UI triggers more customizable.\n\nThe code for this lecture is available at the top of this page, as the MVC code link. The second link provides code for a program with an incomplete GUI. It is recommended that you complete this exercise to practice with GUIs. Finally the third link provides a solution for this GUI.\n\n2 Desig\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n<\/Context>","code_prefix":"<CodePrefix>\nimport model.IModel;\nimport model.Model;\nimport view.EchoFrame;\nimport view.IGUIView;\n\npublic class MVCExampleTextUI {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String []args) {\n        IModel model = new Model();\n        IGUIView view = new EchoFrame(model);\n        GUIController controller = new GUIController(model, view);\n        controller.runProgram();\n        \/\/So... when do we make the view visible?\n\n        \/*\n        IModel model = new Model();\n        IView view = new TextView(System.out);\n        IController controller = new TextController(model,System.in,view);\n        controller.runProgram();\n         *\/\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\keycommands-1335\\src\\MVCExampleTextUI.java","mask_span":[123,616],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0012]  } catch (InputMismatchException ime) {\n      ...\n    }\n    break;\n}\nThe possibilities are now endless! We can support similar higher-level drawing text commands. Every such text commands adds a new case to our switch statement. The number of lines of code in each case statement depends on the complexity of the text command (e.g. the square text-command added 13 lines of code). As a result, the switch statement quickly grows in size. Moreover the go method is increasingly incohesive.\n\n4 The Command Design Pattern\nIn order to make each case statement shorter, we can put all its code into a separate helper method. Since all the helper methods operate on the model, we pass the model object to them. Also since some of the text command require additional input, we pass the additional input to e\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0015] acingTurtleModel m) {\n    m.trace(this.d);\n  }\n\n  ...\n\n}\nNow we can change the logic of our controller to:\n\nTake a one-word command from the user.\nCreate the corresponding TracingTurtleCommand object..\nExecute the command object.\nString in = s.next();\ntry {\n  switch (in) {\n    case \"q\":\n    case \"quit\":\n      return;\n   case \"show\":\n     for (Line l : m.getLines()) {\n        System.out.println(l);\n     }\n     break;\n   case \"move\":\n      cmd = new Move(s.nextDouble());\n      break;\n   case \"trace\":\n      cmd = new Trace(s.nextDouble());\n      break;\n   case \"turn\":\n      cmd = new Turn(s.nextDouble());\n      break;\n   case \"square\":\n      cmd = new Square(s.nextDouble());\n      break;\n   default:\n      System.out.println(String.format(\"Unknown command %s\", in));\n      cmd = null;\n      bre\n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.InputStream;\nimport java.util.Scanner;\n\nimport model.IModel;\n\npublic class TextController implements IController{\n    private Scanner in;\n    private IView view;\n    private IModel model;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic void runProgram() {\n        boolean quit = false;\n\n        while (!quit) {\n            \/\/tell view to show the string so far.\n            view.showString(this.model.getString());\n            \/\/tell view to show options\n            view.showOptions();\n            \/\/accept user input\n            String option = in.next();\n            switch (option) {\n                case \"E\":\n                    \/\/ask for string input\n                    view.showStringEntry();\n                    in.nextLine();\n                    String input = in.nextLine();\n                    \/\/give to model\n                    model.setString(input);\n                    break;\n                case \"Q\":\n                    quit = true;\n                    break;\n                default:\n                    view.showOptionError();\n            }\n        }\n    }\n\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TextController(IModel model,InputStream in,IView view) {\n        this.model = model;\n        this.view = view;\n        this.in = new Scanner(in);\n\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\keycommands-1335\\src\\TextController.java","mask_span":[208,367],"topics":["observer","command","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0020] en again using Java’s new lambda syntax (see Streamlining the code further below).\n\n\/**\n * Represents the printing of a sequence of lines to output\n *\/\nclass PrintInteraction implements Interaction {\n  String[] lines;\n  PrintInteraction(String... lines) {\n    this.lines = lines;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    for (String line : lines) {\n      out.append(line).append(\"\\n\");\n    }\n  }\n}\n\/**\n * Represents a user providing the program with  an input\n *\/\nclass InputInteraction implements Interaction {\n  String input;\n  InputInteraction(String input) {\n    this.input = input;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    in.append(input);\n  }\n}\nFor example, the following array of Interactions represents two inputs to our Calculator and the\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.PrintStream;\n\npublic class TextView implements IView {\n    private PrintStream out;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic void showString(String s) {\n        out.println(\"String: \"+s);\n    }\n\n    public void showOptions() {\n        \/\/print the UI\n        out.println(\"Menu: \");\n        out.println(\"E: Enter a string\");\n        out.println(\"Q: Quit the program\");\n        out.print(\"Enter your choice: \");\n    }\n\n    public void showStringEntry() {\n        out.print(\"\\nEnter the string to be echoed: \");\n    }\n\n    public void showOptionError() {\n        out.print(\"\\nInvalid option. Please try again.\");\n    }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TextView(PrintStream out) {\n        this.out = out;\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\keycommands-1335\\src\\TextView.java","mask_span":[104,168],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0020] en again using Java’s new lambda syntax (see Streamlining the code further below).\n\n\/**\n * Represents the printing of a sequence of lines to output\n *\/\nclass PrintInteraction implements Interaction {\n  String[] lines;\n  PrintInteraction(String... lines) {\n    this.lines = lines;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    for (String line : lines) {\n      out.append(line).append(\"\\n\");\n    }\n  }\n}\n\/**\n * Represents a user providing the program with  an input\n *\/\nclass InputInteraction implements Interaction {\n  String input;\n  InputInteraction(String input) {\n    this.input = input;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    in.append(input);\n  }\n}\nFor example, the following array of Interactions represents two inputs to our Calculator and the\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.PrintStream;\n\npublic class TextView implements IView {\n    private PrintStream out;\n\n    public TextView(PrintStream out) {\n        this.out = out;\n    }\n\n    public void showString(String s) {\n        out.println(\"String: \"+s);\n    }\n\n    public void showOptions() {\n        \/\/print the UI\n        out.println(\"Menu: \");\n        out.println(\"E: Enter a string\");\n        out.println(\"Q: Quit the program\");\n        out.print(\"Enter your choice: \");\n    }\n\n    public void showStringEntry() {\n        out.print(\"\\nEnter the string to be echoed: \");\n    }\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void showOptionError() {\n        out.print(\"\\nInvalid option. Please try again.\");\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\keycommands-1335\\src\\TextView.java","mask_span":[575,670],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n<\/Context>","code_prefix":"<CodePrefix>\npackage view;\n\nimport java.awt.*;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\nimport javax.swing.*;\n\nimport model.IModel;\n\npublic class EchoFrame extends JFrame implements IGUIView {\n\n  private EchoPanel echoPanel;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public String getInput() {\n    return echoPanel.getInput();\n  }\n\n  @Override\n  public void displayText(String text) {\n    echoPanel.displayText(text);\n  }\n\n  @Override\n  public void clearInput() {\n    echoPanel.clearInput();\n  }\n\n  @Override\n  public void setViewActions(ViewActions actions) {\n    echoPanel.setViewActions(actions);\n    this.addKeyListener(new KeyListener() {\n      @Override\n      public void keyTyped(KeyEvent e) {\n        if(e.getKeyChar() == 'x') {\n          actions.exitProgram();\n        }\n      }\n\n      @Override\n      public void keyPressed(KeyEvent e) {\n        \/\/doing nothing on purpose\n      }\n\n      @Override\n      public void keyReleased(KeyEvent e) {\n        \/\/doing nothing on purpose\n      }\n    });\n  }\n\n  @Override\n  public void makeVisible() {\n    this.setVisible(true);\n  }\n\n  @Override\n  public void refresh() {\n    this.repaint();\n    this.requestFocus();\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic EchoFrame(IModel model) {\n    super();\n\n    \/\/Manage the frame\n    this.setSize(500, 150);\n    this.setLocation(300, 500);\n    this.setDefaultCloseOperation(EXIT_ON_CLOSE);\n    this.setBackground(Color.MAGENTA);\n\n    \/\/Change the LayoutManager\n    this.setLayout(new FlowLayout());\n\n    \/\/Construct your components\n    this.echoPanel = new EchoPanel(model);\n    this.add(echoPanel);\n\n    \/\/Compact the frame so everything just fits\n    this.pack();\n    this.setVisible(true);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\keycommands-1335\\src\\view\\EchoFrame.java","mask_span":[241,727],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n<\/Context>","code_prefix":"<CodePrefix>\npackage view;\n\nimport java.awt.*;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\nimport javax.swing.*;\n\nimport model.IModel;\n\npublic class EchoFrame extends JFrame implements IGUIView {\n\n  private EchoPanel echoPanel;\n  public EchoFrame(IModel model) {\n    super();\n\n    \/\/Manage the frame\n    this.setSize(500, 150);\n    this.setLocation(300, 500);\n    this.setDefaultCloseOperation(EXIT_ON_CLOSE);\n    this.setBackground(Color.MAGENTA);\n\n    \/\/Change the LayoutManager\n    this.setLayout(new FlowLayout());\n\n    \/\/Construct your components\n    this.echoPanel = new EchoPanel(model);\n    this.add(echoPanel);\n\n    \/\/Compact the frame so everything just fits\n    this.pack();\n    this.setVisible(true);\n  }\n\n  @Override\n  public String getInput() {\n    return echoPanel.getInput();\n  }\n\n  @Override\n  public void displayText(String text) {\n    echoPanel.displayText(text);\n  }\n\n  @Override\n  public void clearInput() {\n    echoPanel.clearInput();\n  }\n\n  @Override\n  public void setViewActions(ViewActions actions) {\n    echoPanel.setViewActions(actions);\n    this.addKeyListener(new KeyListener() {\n      @Override\n      public void keyTyped(KeyEvent e) {\n        if(e.getKeyChar() == 'x') {\n          actions.exitProgram();\n        }\n      }\n\n      @Override\n      public void keyPressed(KeyEvent e) {\n        \/\/doing nothing on purpose\n      }\n\n      @Override\n      public void keyReleased(KeyEvent e) {\n        \/\/doing nothing on purpose\n      }\n    });\n  }\n\n  @Override\n  public void makeVisible() {\n    this.setVisible(true);\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void refresh() {\n    this.repaint();\n    this.requestFocus();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\keycommands-1335\\src\\view\\EchoFrame.java","mask_span":[1572,1644],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0043] e key, String featureName) {\n    this.keyComponent.getInputMap().put(key, featureName);\n  }\n\n  public void addFeatures(Features features) {\n    this.keyComponent.addFeatures(features);\n  }\n}\n\n\/\/ NOTE: Neither does this class!  It only refers to Features.\nclass KeyComponent extends JPanel {\n  List<Features> featureListeners = new ArrayList<>();\n\n  \/\/ Includes this new feature listener in responding to keys\n  void addFeatures(Features f) { this.featureListeners.add(f); }\n\n  KeyComponent() {\n    \/\/ Install action command -> Feature callback associations\n    this.getActionMap().put(\"makeCaps\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.makeUppercase();\n      }\n    });\n    this.getActionMap().put(\"restoreLowe\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n<\/Context>","code_prefix":"<CodePrefix>\npackage view;\n\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\nimport javax.swing.*;\n\nimport model.IModel;\n\npublic class EchoPanel extends JPanel {\n\n  private final JTextField textInput;\n  private final JLabel echoLabel;\n  private JButton echoButton;\n\n  \/\/private final IModel model; \/\/Used to be needed, but no longer as there is no listener here.\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic String getInput() {\n    return textInput.getText();\n  }\n\n  public void displayText(String text) {\n    echoLabel.setText(text);\n  }\n\n  public void clearInput() {\n    textInput.setText(\"\");\n  }\n\n  public void setViewActions(ViewActions actions) {\n    echoButton.addActionListener(new EchoActionListener(actions));\n    textInput.addKeyListener(new KeyListener() {\n      @Override\n      public void keyTyped(KeyEvent e) {\n        if(e.getKeyChar() == 'x') {\n          actions.exitProgram();\n        }\n      }\n\n      @Override\n      public void keyPressed(KeyEvent e) {\n\n      }\n\n      @Override\n      public void keyReleased(KeyEvent e) {\n\n      }\n    });\n    \/*\n    echoButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        actions.displayText(textInput.getText());\n      }\n    });\n     *\/\n  }\n\n  class EchoActionListener implements ActionListener {\n\n    private ViewActions actions;\n\n    public EchoActionListener(ViewActions actions) {\n      this.actions = actions;\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n      actions.displayText(textInput.getText());\n    }\n  }\n\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic EchoPanel(IModel model) {\n    super();\n\n    \/\/this.model = model;\n\n    \/\/By default, panels have a FlowLayout\n\n    echoLabel = new JLabel(\"Echo text here!\");\n    this.add(echoLabel);\n\n    textInput = new JTextField(20);\n    this.add(textInput);\n\n    echoButton = new JButton(\"Echo!\");\n    echoButton.setActionCommand(\"echo\");\n    \/\/echoButton.addActionListener(this); \/\/This isn't a listener. So who do we pass in? And where?\n    this.add(echoButton);\n\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\keycommands-1335\\src\\view\\EchoPanel.java","mask_span":[445,908],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0043] e key, String featureName) {\n    this.keyComponent.getInputMap().put(key, featureName);\n  }\n\n  public void addFeatures(Features features) {\n    this.keyComponent.addFeatures(features);\n  }\n}\n\n\/\/ NOTE: Neither does this class!  It only refers to Features.\nclass KeyComponent extends JPanel {\n  List<Features> featureListeners = new ArrayList<>();\n\n  \/\/ Includes this new feature listener in responding to keys\n  void addFeatures(Features f) { this.featureListeners.add(f); }\n\n  KeyComponent() {\n    \/\/ Install action command -> Feature callback associations\n    this.getActionMap().put(\"makeCaps\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.makeUppercase();\n      }\n    });\n    this.getActionMap().put(\"restoreLowe\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n<\/Context>","code_prefix":"<CodePrefix>\npackage view;\n\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\nimport javax.swing.*;\n\nimport model.IModel;\n\npublic class EchoPanel extends JPanel {\n\n  private final JTextField textInput;\n  private final JLabel echoLabel;\n  private JButton echoButton;\n\n  \/\/private final IModel model; \/\/Used to be needed, but no longer as there is no listener here.\n\n  public EchoPanel(IModel model) {\n    super();\n\n    \/\/this.model = model;\n\n    \/\/By default, panels have a FlowLayout\n\n    echoLabel = new JLabel(\"Echo text here!\");\n    this.add(echoLabel);\n\n    textInput = new JTextField(20);\n    this.add(textInput);\n\n    echoButton = new JButton(\"Echo!\");\n    echoButton.setActionCommand(\"echo\");\n    \/\/echoButton.addActionListener(this); \/\/This isn't a listener. So who do we pass in? And where?\n    this.add(echoButton);\n\n  }\n\n  public String getInput() {\n    return textInput.getText();\n  }\n\n  public void displayText(String text) {\n    echoLabel.setText(text);\n  }\n\n  public void clearInput() {\n    textInput.setText(\"\");\n  }\n\n  public void setViewActions(ViewActions actions) {\n    echoButton.addActionListener(new EchoActionListener(actions));\n    textInput.addKeyListener(new KeyListener() {\n      @Override\n      public void keyTyped(KeyEvent e) {\n        if(e.getKeyChar() == 'x') {\n          actions.exitProgram();\n        }\n      }\n\n      @Override\n      public void keyPressed(KeyEvent e) {\n\n      }\n\n      @Override\n      public void keyReleased(KeyEvent e) {\n\n      }\n    });\n    \/*\n    echoButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        actions.displayText(textInput.getText());\n      }\n    });\n     *\/\n  }\n\n  class EchoActionListener implements ActionListener {\n\n    private ViewActions actions;\n\n    public EchoActionListener(ViewActions actions) {\n      this.actions = actions;\n    }\n\n    @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void actionPerformed(ActionEvent e) {\n      actions.displayText(textInput.getText());\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\keycommands-1335\\src\\view\\EchoPanel.java","mask_span":[1978,2076],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n<\/Context>","code_prefix":"<CodePrefix>\nimport java.awt.Color;\nimport java.awt.FlowLayout;\nimport java.awt.event.ActionListener;\n\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JTextField;\n\npublic class EchoFrame extends JFrame implements GUIView {\n\n  private final EchoPanel echoPanel;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public String getInput() {\n    return echoPanel.getInput();\n  }\n\n  @Override\n  public void displayText(String string) {\n    echoPanel.displayText(string);\n  }\n\n  @Override\n  public void clearInput() {\n    echoPanel.clearInput();\n  }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic EchoFrame(IModel model) {\n    super();\n    this.setSize(700, 300);\n    this.setLocation(600, 500);\n\n    \/\/To put the frame in the middle of the screen, use\n    \/\/this.setLocationRelativeTo(null);\n\n    this.setDefaultCloseOperation(EXIT_ON_CLOSE);\n    this.setBackground(Color.MAGENTA);\n\n    \/\/Set the manager so everything is added in a line if possible\n    this.setLayout(new FlowLayout());\n\n    echoPanel = new EchoPanel(model);\n    this.add(echoPanel);\n\n    this.pack();\n    this.setVisible(true);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\listeners-1030\\src\\EchoFrame.java","mask_span":[303,814],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0007] y a function that gets called when something interesting occurs. In our case, the clicking of different buttons should trigger a callback. In the jargon of Swing, clicking on buttons triggers their action, and so we must supply a function object that implements the ActionListener interface. (Other controls have additional events besides “actions”.) For convenience, Swing allows us to label each button with a so-called action command, which is a String of our choosing: when the ActionListener’s callback is invoked, it will be given an ActionEvent object that knows the action command of the button that was clicked. In this way, we can use a single listener to listen to multiple buttons at once, and distinguish them by means of this command string. See the calls to setActionCommand and setAct\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0043] e key, String featureName) {\n    this.keyComponent.getInputMap().put(key, featureName);\n  }\n\n  public void addFeatures(Features features) {\n    this.keyComponent.addFeatures(features);\n  }\n}\n\n\/\/ NOTE: Neither does this class!  It only refers to Features.\nclass KeyComponent extends JPanel {\n  List<Features> featureListeners = new ArrayList<>();\n\n  \/\/ Includes this new feature listener in responding to keys\n  void addFeatures(Features f) { this.featureListeners.add(f); }\n\n  KeyComponent() {\n    \/\/ Install action command -> Feature callback associations\n    this.getActionMap().put(\"makeCaps\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.makeUppercase();\n      }\n    });\n    this.getActionMap().put(\"restoreLowe\n<\/Context>","code_prefix":"<CodePrefix>\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\nimport javax.swing.*;\n\npublic class EchoPanel extends JPanel {\n\n  private JLabel echoLabel;\n  private JTextField inputField;\n\n  private final JButton echoButton;\n  private final JButton exitButton;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic String getInput() {\n    return inputField.getText();\n  }\n\n  public void displayText(String string) {\n    echoLabel.setText(string);\n  }\n\n  public void clearInput() {\n    inputField.setText(\"\");\n  }\n}\n\n\n<\/CodeSuffix>","target":"<Target>\npublic EchoPanel(IModel model) {\n    super();\n\n    this.echoLabel = new JLabel(\"Echo text!\");\n    this.add(echoLabel);\n\n    this.inputField = new JTextField(20);\n    this.add(inputField);\n\n    echoButton = new JButton(\"Echo!\");\n    echoButton.setActionCommand(\"echo\");\n    \/\/echoButton.addActionListener(this); \/\/This no longer works! So how do we add the listener?! (Observer pattern)\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"exit\");\n    \/\/exitButton.addActionListener(this); \/\/This no longer works! So how do we add the listener?! (Observer pattern)\n    this.add(exitButton);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\listeners-1030\\src\\EchoPanel.java","mask_span":[275,913],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0012] w v) {\n    this.model = m;\n    this.view = v;\n    view.setListener(this);\n    view.display();\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n      case \"Echo Button\": ...  \/\/ same code as before, but now\n      case \"Exit Button\": ...  \/\/ it's extracted out of the view\n    }\n  }\n}\nThe controller is now the only part of the system that has mutable access to the model. Because it requested that the view register itself as the listener for the buttons, the controller gets called exactly when necessary, and it can decide what mutations to perform on the model. The view doesn’t even know that it’s received a controller object: as far as it’s aware, the controller is simply a random ActionListener. (Note: It is overly simplified to have the Con\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0044] rcase\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.restoreLowercase();\n      }\n    });\n    this.getActionMap().put(\"toggleColor\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.toggleColor();\n      }\n    });\n    ...\n  }\n}\n\n\/\/ NOTE: Only the Controller needs to know how to implement Features.\npublic class Controller implements Features {\n  private IModel model;\n  private IView view;\n\n  ...\n\n  \/\/ These are the high-level event handlers we care about:\n  @Override\n  public void toggleColor() {\n    view.toggleColor();\n  }\n\n  @Override\n  public void makeUppercase() {\n    String text = model.getString();\n    text = text.toUpperCa\n<\/Context>","code_prefix":"<CodePrefix>\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\n\/**\n * As we saw, this is bad design. This is tied to ActionListener, meaning it's tied\n * to a view with buttons in Swing. If we change that view, this controller must change.\n * But how do we solve this issue? (Observer Pattern)\n *\/\npublic class GUIController implements ActionListener {\n\n  private final IModel model;\n  private final GUIView view;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/\/REACTS to an ActionEvent, like a button click\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n      case \"echo\":\n        String input = view.getInput();\n        model.setString(input);\n        view.displayText(model.getString());\n        view.clearInput();\n        break;\n      case \"exit\":\n        System.exit(0);\n      default:\n        new RuntimeException(\"Unknown action command: \" + e.getActionCommand());\n    }\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic GUIController(IModel model, GUIView view) {\n    this.model = model;\n    this.view = view;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\listeners-1030\\src\\GUIController.java","mask_span":[428,528],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0002] user interfaces. We start with poorly-designed but working code, and improve it in three stages. Initially, the code for the view will directly manipulate the model. Our first incremental improvement will decouple the view from the model so that it need not — and in fact cannot — do so. Our second improvement will add a new feature to the view, and add the ability to control that in the controller. Finally, our third improvement will generalize the controller to make its UI triggers more customizable.\n\nThe code for this lecture is available at the top of this page, as the MVC code link. The second link provides code for a program with an incomplete GUI. It is recommended that you complete this exercise to practice with GUIs. Finally the third link provides a solution for this GUI.\n\n2 Desig\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0003] n\nAll examples in this lecture follow a common design. The model state (interface IModel and implementation Model) consists of a single String and offers methods to get and update it. All views (coupled with controllers wherever applicable) expose functionality to interactively show this string, and to update it.\n\n3 Text-based UI\nIn the TextUI directory we show a text-based user interface. The IView interface encapsulates all the methods that a view’s client would need to call: note how they correspond roughly to the “things” that a controller would need to tell the view to do. The TextView class implements this interface. It transmits all messages to a PrintStream object provided to it through its constructor. Similar to the design in Lecture 8 this allows us to test the view using any su\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n<\/Context>","code_prefix":"<CodePrefix>\n\npublic class MVCExampleTextUI {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String []args) {\n        IModel model = new Model();\n        EchoFrame view = new EchoFrame(model); \/\/BAD: Not the interface type!! How do we fix?\n        GUIController controller = new GUIController(model, view);\n        view.setVisible(true);\n\n        \/*\n         * \/\/ OLD WAY!\n        IModel model = new Model();\n        IView view = new TextView(System.out);\n        IController controller = new TextController(model,System.in,view);\n        controller.runProgram();\n         *\/\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\listeners-1030\\src\\MVCExampleTextUI.java","mask_span":[37,549],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0012]  } catch (InputMismatchException ime) {\n      ...\n    }\n    break;\n}\nThe possibilities are now endless! We can support similar higher-level drawing text commands. Every such text commands adds a new case to our switch statement. The number of lines of code in each case statement depends on the complexity of the text command (e.g. the square text-command added 13 lines of code). As a result, the switch statement quickly grows in size. Moreover the go method is increasingly incohesive.\n\n4 The Command Design Pattern\nIn order to make each case statement shorter, we can put all its code into a separate helper method. Since all the helper methods operate on the model, we pass the model object to them. Also since some of the text command require additional input, we pass the additional input to e\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0015] acingTurtleModel m) {\n    m.trace(this.d);\n  }\n\n  ...\n\n}\nNow we can change the logic of our controller to:\n\nTake a one-word command from the user.\nCreate the corresponding TracingTurtleCommand object..\nExecute the command object.\nString in = s.next();\ntry {\n  switch (in) {\n    case \"q\":\n    case \"quit\":\n      return;\n   case \"show\":\n     for (Line l : m.getLines()) {\n        System.out.println(l);\n     }\n     break;\n   case \"move\":\n      cmd = new Move(s.nextDouble());\n      break;\n   case \"trace\":\n      cmd = new Trace(s.nextDouble());\n      break;\n   case \"turn\":\n      cmd = new Turn(s.nextDouble());\n      break;\n   case \"square\":\n      cmd = new Square(s.nextDouble());\n      break;\n   default:\n      System.out.println(String.format(\"Unknown command %s\", in));\n      cmd = null;\n      bre\n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.InputStream;\nimport java.util.Scanner;\n\npublic class TextController implements IController{\n    private Scanner in;\n    private IView view;\n    private IModel model;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic void runProgram() {\n        boolean quit = false;\n\n        while (!quit) {\n            \/\/tell view to show the string so far.\n            view.showString(this.model.getString());\n            \/\/tell view to show options\n            view.showOptions();\n            \/\/accept user input\n            String option = in.next();\n            switch (option) {\n                case \"E\":\n                    \/\/ask for string input\n                    view.showStringEntry();\n                    in.nextLine();\n                    String input = in.nextLine();\n                    \/\/give to model\n                    model.setString(input);\n                    break;\n                case \"Q\":\n                    quit = true;\n                    break;\n                default:\n                    view.showOptionError();\n            }\n        }\n    }\n\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TextController(IModel model,InputStream in,IView view) {\n        this.model = model;\n        this.view = view;\n        this.in = new Scanner(in);\n\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\listeners-1030\\src\\TextController.java","mask_span":[186,345],"topics":["observer","command","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0020] en again using Java’s new lambda syntax (see Streamlining the code further below).\n\n\/**\n * Represents the printing of a sequence of lines to output\n *\/\nclass PrintInteraction implements Interaction {\n  String[] lines;\n  PrintInteraction(String... lines) {\n    this.lines = lines;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    for (String line : lines) {\n      out.append(line).append(\"\\n\");\n    }\n  }\n}\n\/**\n * Represents a user providing the program with  an input\n *\/\nclass InputInteraction implements Interaction {\n  String input;\n  InputInteraction(String input) {\n    this.input = input;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    in.append(input);\n  }\n}\nFor example, the following array of Interactions represents two inputs to our Calculator and the\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.PrintStream;\n\npublic class TextView implements IView {\n    private PrintStream out;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic void showString(String s) {\n        out.println(\"String: \"+s);\n    }\n\n    public void showOptions() {\n        \/\/print the UI\n        out.println(\"Menu: \");\n        out.println(\"E: Enter a string\");\n        out.println(\"Q: Quit the program\");\n        out.print(\"Enter your choice: \");\n    }\n\n    public void showStringEntry() {\n        out.print(\"\\nEnter the string to be echoed: \");\n    }\n\n    public void showOptionError() {\n        out.print(\"\\nInvalid option. Please try again.\");\n    }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TextView(PrintStream out) {\n        this.out = out;\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\listeners-1030\\src\\TextView.java","mask_span":[104,168],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0020] en again using Java’s new lambda syntax (see Streamlining the code further below).\n\n\/**\n * Represents the printing of a sequence of lines to output\n *\/\nclass PrintInteraction implements Interaction {\n  String[] lines;\n  PrintInteraction(String... lines) {\n    this.lines = lines;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    for (String line : lines) {\n      out.append(line).append(\"\\n\");\n    }\n  }\n}\n\/**\n * Represents a user providing the program with  an input\n *\/\nclass InputInteraction implements Interaction {\n  String input;\n  InputInteraction(String input) {\n    this.input = input;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    in.append(input);\n  }\n}\nFor example, the following array of Interactions represents two inputs to our Calculator and the\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.PrintStream;\n\npublic class TextView implements IView {\n    private PrintStream out;\n\n    public TextView(PrintStream out) {\n        this.out = out;\n    }\n\n    public void showString(String s) {\n        out.println(\"String: \"+s);\n    }\n\n    public void showOptions() {\n        \/\/print the UI\n        out.println(\"Menu: \");\n        out.println(\"E: Enter a string\");\n        out.println(\"Q: Quit the program\");\n        out.print(\"Enter your choice: \");\n    }\n\n    public void showStringEntry() {\n        out.print(\"\\nEnter the string to be echoed: \");\n    }\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void showOptionError() {\n        out.print(\"\\nInvalid option. Please try again.\");\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\listeners-1030\\src\\TextView.java","mask_span":[575,670],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0015]  or more directions. Or a JSplitPanel, which surrounds two panels and produces a split-screen effect. Or a JGridPanel, or others... Each of these classes obeys a fairly sophisticated interface (all the methods of the base JPanel class), and then does two things: it provides some new functionality of its own, and delegates the rest of the functionality to inner panels. Visually, each surrounding panel decorates the inner ones by adding borders, scrollbars, splitters, etc. Just as with the strategy pattern, each class is responsible for one fragment of functionality: the complete functionality comes about by composing several decorators together around some base object.\n\nUnlike strategies, where there can often be useful strategies that do not need to delegate at all; decorators are all abou\n<\/Context>","code_prefix":"<CodePrefix>\nimport java.awt.*;\n\nimport javax.swing.*;\n\npublic class EchoFrame extends JFrame {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic EchoFrame(IModel model) {\n    super();\n\n    \/\/Manage the frame\n    this.setSize(500, 150);\n    this.setLocation(300, 500);\n    this.setDefaultCloseOperation(EXIT_ON_CLOSE);\n    this.setBackground(Color.MAGENTA);\n\n    \/\/Change the LayoutManager\n    this.setLayout(new FlowLayout());\n\n    \/\/Construct your components\n    this.add(new EchoPanel(model));\n\n    \/\/Compact the frame so everything just fits\n    this.pack();\n    this.setVisible(true);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\listeners-1335\\src\\EchoFrame.java","mask_span":[86,540],"topics":["observer","strategy","gui","decorator","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0007] y a function that gets called when something interesting occurs. In our case, the clicking of different buttons should trigger a callback. In the jargon of Swing, clicking on buttons triggers their action, and so we must supply a function object that implements the ActionListener interface. (Other controls have additional events besides “actions”.) For convenience, Swing allows us to label each button with a so-called action command, which is a String of our choosing: when the ActionListener’s callback is invoked, it will be given an ActionEvent object that knows the action command of the button that was clicked. In this way, we can use a single listener to listen to multiple buttons at once, and distinguish them by means of this command string. See the calls to setActionCommand and setAct\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0043] e key, String featureName) {\n    this.keyComponent.getInputMap().put(key, featureName);\n  }\n\n  public void addFeatures(Features features) {\n    this.keyComponent.addFeatures(features);\n  }\n}\n\n\/\/ NOTE: Neither does this class!  It only refers to Features.\nclass KeyComponent extends JPanel {\n  List<Features> featureListeners = new ArrayList<>();\n\n  \/\/ Includes this new feature listener in responding to keys\n  void addFeatures(Features f) { this.featureListeners.add(f); }\n\n  KeyComponent() {\n    \/\/ Install action command -> Feature callback associations\n    this.getActionMap().put(\"makeCaps\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.makeUppercase();\n      }\n    });\n    this.getActionMap().put(\"restoreLowe\n<\/Context>","code_prefix":"<CodePrefix>\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\nimport javax.swing.*;\n\npublic class EchoPanel extends JPanel {\n\n  private final JTextField textInput;\n  private final JLabel echoLabel;\n\n  private final IModel model;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/\/JOptionPane.showMessageDialog(this, \"Hurray\");\n    \/*\n    JFrame frame = new JFrame(\"Hurray!\");\n    frame.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n    frame.setVisible(true);\n     *\/\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic EchoPanel(IModel model) {\n    super();\n\n    this.model = model;\n\n    \/\/By default, panels have a FlowLayout\n\n    echoLabel = new JLabel(\"Echo text here!\");\n    this.add(echoLabel);\n\n    textInput = new JTextField(20);\n    this.add(textInput);\n\n    JButton echoButton = new JButton(\"Echo!\");\n    echoButton.setActionCommand(\"echo\");\n    echoButton.addActionListener(this);\n    this.add(echoButton);\n\n    JButton exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"exit\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\listeners-1335\\src\\EchoPanel.java","mask_span":[244,806],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0012] w v) {\n    this.model = m;\n    this.view = v;\n    view.setListener(this);\n    view.display();\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n      case \"Echo Button\": ...  \/\/ same code as before, but now\n      case \"Exit Button\": ...  \/\/ it's extracted out of the view\n    }\n  }\n}\nThe controller is now the only part of the system that has mutable access to the model. Because it requested that the view register itself as the listener for the buttons, the controller gets called exactly when necessary, and it can decide what mutations to perform on the model. The view doesn’t even know that it’s received a controller object: as far as it’s aware, the controller is simply a random ActionListener. (Note: It is overly simplified to have the Con\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n<\/Context>","code_prefix":"<CodePrefix>\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class GUIController implements ActionListener {\n\n  private final IModel model;\n  private final IGUIView view;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n      case \"echo\":\n        String input = view.getInput();\n        model.setString(input);\n        view.displayText(model.getString());\n        view.clearInput();\n        break;\n      case \"exit\":\n        System.exit(0);\n    }\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic GUIController(IModel model, IGUIView view) {\n    this.model = model;\n    this.view = view;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\listeners-1335\\src\\GUIController.java","mask_span":[194,295],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0003] n\nAll examples in this lecture follow a common design. The model state (interface IModel and implementation Model) consists of a single String and offers methods to get and update it. All views (coupled with controllers wherever applicable) expose functionality to interactively show this string, and to update it.\n\n3 Text-based UI\nIn the TextUI directory we show a text-based user interface. The IView interface encapsulates all the methods that a view’s client would need to call: note how they correspond roughly to the “things” that a controller would need to tell the view to do. The TextView class implements this interface. It transmits all messages to a PrintStream object provided to it through its constructor. Similar to the design in Lecture 8 this allows us to test the view using any su\n<\/Context>","code_prefix":"<CodePrefix>\nimport javax.swing.*;\n\npublic class MVCExampleTextUI {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String []args) {\n        IModel model = new Model();\n        IGUIView view = new EchoFrame(model);\n        GUIController controller = new GUIController(model, view);\n        \/\/So... when do we make the view visible?\n        \/*\n        IModel model = new Model();\n        IView view = new TextView(System.out);\n        IController controller = new TextController(model,System.in,view);\n        controller.runProgram();\n         *\/\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\listeners-1335\\src\\MVCExampleTextUI.java","mask_span":[59,518],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0012]  } catch (InputMismatchException ime) {\n      ...\n    }\n    break;\n}\nThe possibilities are now endless! We can support similar higher-level drawing text commands. Every such text commands adds a new case to our switch statement. The number of lines of code in each case statement depends on the complexity of the text command (e.g. the square text-command added 13 lines of code). As a result, the switch statement quickly grows in size. Moreover the go method is increasingly incohesive.\n\n4 The Command Design Pattern\nIn order to make each case statement shorter, we can put all its code into a separate helper method. Since all the helper methods operate on the model, we pass the model object to them. Also since some of the text command require additional input, we pass the additional input to e\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0015] acingTurtleModel m) {\n    m.trace(this.d);\n  }\n\n  ...\n\n}\nNow we can change the logic of our controller to:\n\nTake a one-word command from the user.\nCreate the corresponding TracingTurtleCommand object..\nExecute the command object.\nString in = s.next();\ntry {\n  switch (in) {\n    case \"q\":\n    case \"quit\":\n      return;\n   case \"show\":\n     for (Line l : m.getLines()) {\n        System.out.println(l);\n     }\n     break;\n   case \"move\":\n      cmd = new Move(s.nextDouble());\n      break;\n   case \"trace\":\n      cmd = new Trace(s.nextDouble());\n      break;\n   case \"turn\":\n      cmd = new Turn(s.nextDouble());\n      break;\n   case \"square\":\n      cmd = new Square(s.nextDouble());\n      break;\n   default:\n      System.out.println(String.format(\"Unknown command %s\", in));\n      cmd = null;\n      bre\n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.InputStream;\nimport java.util.Scanner;\n\npublic class TextController implements IController{\n    private Scanner in;\n    private IView view;\n    private IModel model;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic void runProgram() {\n        boolean quit = false;\n\n        while (!quit) {\n            \/\/tell view to show the string so far.\n            view.showString(this.model.getString());\n            \/\/tell view to show options\n            view.showOptions();\n            \/\/accept user input\n            String option = in.next();\n            switch (option) {\n                case \"E\":\n                    \/\/ask for string input\n                    view.showStringEntry();\n                    in.nextLine();\n                    String input = in.nextLine();\n                    \/\/give to model\n                    model.setString(input);\n                    break;\n                case \"Q\":\n                    quit = true;\n                    break;\n                default:\n                    view.showOptionError();\n            }\n        }\n    }\n\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TextController(IModel model,InputStream in,IView view) {\n        this.model = model;\n        this.view = view;\n        this.in = new Scanner(in);\n\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\listeners-1335\\src\\TextController.java","mask_span":[186,345],"topics":["observer","command","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0020] en again using Java’s new lambda syntax (see Streamlining the code further below).\n\n\/**\n * Represents the printing of a sequence of lines to output\n *\/\nclass PrintInteraction implements Interaction {\n  String[] lines;\n  PrintInteraction(String... lines) {\n    this.lines = lines;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    for (String line : lines) {\n      out.append(line).append(\"\\n\");\n    }\n  }\n}\n\/**\n * Represents a user providing the program with  an input\n *\/\nclass InputInteraction implements Interaction {\n  String input;\n  InputInteraction(String input) {\n    this.input = input;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    in.append(input);\n  }\n}\nFor example, the following array of Interactions represents two inputs to our Calculator and the\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.PrintStream;\n\npublic class TextView implements IView {\n    private PrintStream out;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic void showString(String s) {\n        out.println(\"String: \"+s);\n    }\n\n    public void showOptions() {\n        \/\/print the UI\n        out.println(\"Menu: \");\n        out.println(\"E: Enter a string\");\n        out.println(\"Q: Quit the program\");\n        out.print(\"Enter your choice: \");\n    }\n\n    public void showStringEntry() {\n        out.print(\"\\nEnter the string to be echoed: \");\n    }\n\n    public void showOptionError() {\n        out.print(\"\\nInvalid option. Please try again.\");\n    }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TextView(PrintStream out) {\n        this.out = out;\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\listeners-1335\\src\\TextView.java","mask_span":[104,168],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0020] en again using Java’s new lambda syntax (see Streamlining the code further below).\n\n\/**\n * Represents the printing of a sequence of lines to output\n *\/\nclass PrintInteraction implements Interaction {\n  String[] lines;\n  PrintInteraction(String... lines) {\n    this.lines = lines;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    for (String line : lines) {\n      out.append(line).append(\"\\n\");\n    }\n  }\n}\n\/**\n * Represents a user providing the program with  an input\n *\/\nclass InputInteraction implements Interaction {\n  String input;\n  InputInteraction(String input) {\n    this.input = input;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    in.append(input);\n  }\n}\nFor example, the following array of Interactions represents two inputs to our Calculator and the\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.PrintStream;\n\npublic class TextView implements IView {\n    private PrintStream out;\n\n    public TextView(PrintStream out) {\n        this.out = out;\n    }\n\n    public void showString(String s) {\n        out.println(\"String: \"+s);\n    }\n\n    public void showOptions() {\n        \/\/print the UI\n        out.println(\"Menu: \");\n        out.println(\"E: Enter a string\");\n        out.println(\"Q: Quit the program\");\n        out.print(\"Enter your choice: \");\n    }\n\n    public void showStringEntry() {\n        out.print(\"\\nEnter the string to be echoed: \");\n    }\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void showOptionError() {\n        out.print(\"\\nInvalid option. Please try again.\");\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\listeners-1335\\src\\TextView.java","mask_span":[575,670],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0044] rcase\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.restoreLowercase();\n      }\n    });\n    this.getActionMap().put(\"toggleColor\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.toggleColor();\n      }\n    });\n    ...\n  }\n}\n\n\/\/ NOTE: Only the Controller needs to know how to implement Features.\npublic class Controller implements Features {\n  private IModel model;\n  private IView view;\n\n  ...\n\n  \/\/ These are the high-level event handlers we care about:\n  @Override\n  public void toggleColor() {\n    view.toggleColor();\n  }\n\n  @Override\n  public void makeUppercase() {\n    String text = model.getString();\n    text = text.toUpperCa\n<\/Context>","code_prefix":"<CodePrefix>\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\nimport model.IModel;\nimport view.IGUIView;\nimport view.ViewActions;\n\npublic class GUIController implements ViewActions {\n\n  private final IModel model;\n  private final IGUIView view;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void displayText(String text) {\n    model.setString(text);\n    view.displayText(model.getString());\n    view.clearInput();\n  }\n\n  @Override\n  public void exitProgram() {\n    System.exit(0);\n  }\n\n  public void runProgram() {\n    view.setViewActions(this);\n    view.makeVisible();\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic GUIController(IModel model, IGUIView view) {\n    this.model = model;\n    this.view = view;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\observer-1335\\src\\GUIController.java","mask_span":[260,361],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0044] rcase\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.restoreLowercase();\n      }\n    });\n    this.getActionMap().put(\"toggleColor\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.toggleColor();\n      }\n    });\n    ...\n  }\n}\n\n\/\/ NOTE: Only the Controller needs to know how to implement Features.\npublic class Controller implements Features {\n  private IModel model;\n  private IView view;\n\n  ...\n\n  \/\/ These are the high-level event handlers we care about:\n  @Override\n  public void toggleColor() {\n    view.toggleColor();\n  }\n\n  @Override\n  public void makeUppercase() {\n    String text = model.getString();\n    text = text.toUpperCa\n<\/Context>","code_prefix":"<CodePrefix>\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\nimport model.IModel;\nimport view.IGUIView;\nimport view.ViewActions;\n\npublic class GUIController implements ViewActions {\n\n  private final IModel model;\n  private final IGUIView view;\n\n  public GUIController(IModel model, IGUIView view) {\n    this.model = model;\n    this.view = view;\n  }\n\n\n  @Override\n  public void displayText(String text) {\n    model.setString(text);\n    view.displayText(model.getString());\n    view.clearInput();\n  }\n\n  @Override\n  public void exitProgram() {\n    System.exit(0);\n  }\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void runProgram() {\n    view.setViewActions(this);\n    view.makeVisible();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\observer-1335\\src\\GUIController.java","mask_span":[582,667],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0003] n\nAll examples in this lecture follow a common design. The model state (interface IModel and implementation Model) consists of a single String and offers methods to get and update it. All views (coupled with controllers wherever applicable) expose functionality to interactively show this string, and to update it.\n\n3 Text-based UI\nIn the TextUI directory we show a text-based user interface. The IView interface encapsulates all the methods that a view’s client would need to call: note how they correspond roughly to the “things” that a controller would need to tell the view to do. The TextView class implements this interface. It transmits all messages to a PrintStream object provided to it through its constructor. Similar to the design in Lecture 8 this allows us to test the view using any su\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0002] user interfaces. We start with poorly-designed but working code, and improve it in three stages. Initially, the code for the view will directly manipulate the model. Our first incremental improvement will decouple the view from the model so that it need not — and in fact cannot — do so. Our second improvement will add a new feature to the view, and add the ability to control that in the controller. Finally, our third improvement will generalize the controller to make its UI triggers more customizable.\n\nThe code for this lecture is available at the top of this page, as the MVC code link. The second link provides code for a program with an incomplete GUI. It is recommended that you complete this exercise to practice with GUIs. Finally the third link provides a solution for this GUI.\n\n2 Desig\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n<\/Context>","code_prefix":"<CodePrefix>\nimport model.IModel;\nimport model.Model;\nimport view.EchoFrame;\nimport view.IGUIView;\n\npublic class MVCExampleTextUI {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String []args) {\n        IModel model = new Model();\n        IGUIView view = new EchoFrame(model);\n        GUIController controller = new GUIController(model, view);\n        \/\/So... when do we make the view visible?\n\n        \/*\n        IModel model = new Model();\n        IView view = new TextView(System.out);\n        IController controller = new TextController(model,System.in,view);\n        controller.runProgram();\n         *\/\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\observer-1335\\src\\MVCExampleTextUI.java","mask_span":[123,583],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0012]  } catch (InputMismatchException ime) {\n      ...\n    }\n    break;\n}\nThe possibilities are now endless! We can support similar higher-level drawing text commands. Every such text commands adds a new case to our switch statement. The number of lines of code in each case statement depends on the complexity of the text command (e.g. the square text-command added 13 lines of code). As a result, the switch statement quickly grows in size. Moreover the go method is increasingly incohesive.\n\n4 The Command Design Pattern\nIn order to make each case statement shorter, we can put all its code into a separate helper method. Since all the helper methods operate on the model, we pass the model object to them. Also since some of the text command require additional input, we pass the additional input to e\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0015] acingTurtleModel m) {\n    m.trace(this.d);\n  }\n\n  ...\n\n}\nNow we can change the logic of our controller to:\n\nTake a one-word command from the user.\nCreate the corresponding TracingTurtleCommand object..\nExecute the command object.\nString in = s.next();\ntry {\n  switch (in) {\n    case \"q\":\n    case \"quit\":\n      return;\n   case \"show\":\n     for (Line l : m.getLines()) {\n        System.out.println(l);\n     }\n     break;\n   case \"move\":\n      cmd = new Move(s.nextDouble());\n      break;\n   case \"trace\":\n      cmd = new Trace(s.nextDouble());\n      break;\n   case \"turn\":\n      cmd = new Turn(s.nextDouble());\n      break;\n   case \"square\":\n      cmd = new Square(s.nextDouble());\n      break;\n   default:\n      System.out.println(String.format(\"Unknown command %s\", in));\n      cmd = null;\n      bre\n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.InputStream;\nimport java.util.Scanner;\n\nimport model.IModel;\n\npublic class TextController implements IController{\n    private Scanner in;\n    private IView view;\n    private IModel model;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic void runProgram() {\n        boolean quit = false;\n\n        while (!quit) {\n            \/\/tell view to show the string so far.\n            view.showString(this.model.getString());\n            \/\/tell view to show options\n            view.showOptions();\n            \/\/accept user input\n            String option = in.next();\n            switch (option) {\n                case \"E\":\n                    \/\/ask for string input\n                    view.showStringEntry();\n                    in.nextLine();\n                    String input = in.nextLine();\n                    \/\/give to model\n                    model.setString(input);\n                    break;\n                case \"Q\":\n                    quit = true;\n                    break;\n                default:\n                    view.showOptionError();\n            }\n        }\n    }\n\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TextController(IModel model,InputStream in,IView view) {\n        this.model = model;\n        this.view = view;\n        this.in = new Scanner(in);\n\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\observer-1335\\src\\TextController.java","mask_span":[208,367],"topics":["observer","command","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0020] en again using Java’s new lambda syntax (see Streamlining the code further below).\n\n\/**\n * Represents the printing of a sequence of lines to output\n *\/\nclass PrintInteraction implements Interaction {\n  String[] lines;\n  PrintInteraction(String... lines) {\n    this.lines = lines;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    for (String line : lines) {\n      out.append(line).append(\"\\n\");\n    }\n  }\n}\n\/**\n * Represents a user providing the program with  an input\n *\/\nclass InputInteraction implements Interaction {\n  String input;\n  InputInteraction(String input) {\n    this.input = input;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    in.append(input);\n  }\n}\nFor example, the following array of Interactions represents two inputs to our Calculator and the\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.PrintStream;\n\npublic class TextView implements IView {\n    private PrintStream out;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic void showString(String s) {\n        out.println(\"String: \"+s);\n    }\n\n    public void showOptions() {\n        \/\/print the UI\n        out.println(\"Menu: \");\n        out.println(\"E: Enter a string\");\n        out.println(\"Q: Quit the program\");\n        out.print(\"Enter your choice: \");\n    }\n\n    public void showStringEntry() {\n        out.print(\"\\nEnter the string to be echoed: \");\n    }\n\n    public void showOptionError() {\n        out.print(\"\\nInvalid option. Please try again.\");\n    }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TextView(PrintStream out) {\n        this.out = out;\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\observer-1335\\src\\TextView.java","mask_span":[104,168],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0020] en again using Java’s new lambda syntax (see Streamlining the code further below).\n\n\/**\n * Represents the printing of a sequence of lines to output\n *\/\nclass PrintInteraction implements Interaction {\n  String[] lines;\n  PrintInteraction(String... lines) {\n    this.lines = lines;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    for (String line : lines) {\n      out.append(line).append(\"\\n\");\n    }\n  }\n}\n\/**\n * Represents a user providing the program with  an input\n *\/\nclass InputInteraction implements Interaction {\n  String input;\n  InputInteraction(String input) {\n    this.input = input;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    in.append(input);\n  }\n}\nFor example, the following array of Interactions represents two inputs to our Calculator and the\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.PrintStream;\n\npublic class TextView implements IView {\n    private PrintStream out;\n\n    public TextView(PrintStream out) {\n        this.out = out;\n    }\n\n    public void showString(String s) {\n        out.println(\"String: \"+s);\n    }\n\n    public void showOptions() {\n        \/\/print the UI\n        out.println(\"Menu: \");\n        out.println(\"E: Enter a string\");\n        out.println(\"Q: Quit the program\");\n        out.print(\"Enter your choice: \");\n    }\n\n    public void showStringEntry() {\n        out.print(\"\\nEnter the string to be echoed: \");\n    }\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void showOptionError() {\n        out.print(\"\\nInvalid option. Please try again.\");\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\observer-1335\\src\\TextView.java","mask_span":[575,670],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n<\/Context>","code_prefix":"<CodePrefix>\npackage view;\n\nimport java.awt.*;\n\nimport javax.swing.*;\n\nimport model.IModel;\n\npublic class EchoFrame extends JFrame implements IGUIView {\n\n  private EchoPanel echoPanel;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public String getInput() {\n    return echoPanel.getInput();\n  }\n\n  @Override\n  public void displayText(String text) {\n    echoPanel.displayText(text);\n  }\n\n  @Override\n  public void clearInput() {\n    echoPanel.clearInput();\n  }\n\n  @Override\n  public void setViewActions(ViewActions actions) {\n    echoPanel.setViewActions(actions);\n  }\n\n  @Override\n  public void makeVisible() {\n    this.setVisible(true);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic EchoFrame(IModel model) {\n    super();\n\n    \/\/Manage the frame\n    this.setSize(500, 150);\n    this.setLocation(300, 500);\n    this.setDefaultCloseOperation(EXIT_ON_CLOSE);\n    this.setBackground(Color.MAGENTA);\n\n    \/\/Change the LayoutManager\n    this.setLayout(new FlowLayout());\n\n    \/\/Construct your components\n    this.echoPanel = new EchoPanel(model);\n    this.add(echoPanel);\n\n    \/\/Compact the frame so everything just fits\n    this.pack();\n    this.setVisible(true);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\observer-1335\\src\\view\\EchoFrame.java","mask_span":[174,660],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0007] y a function that gets called when something interesting occurs. In our case, the clicking of different buttons should trigger a callback. In the jargon of Swing, clicking on buttons triggers their action, and so we must supply a function object that implements the ActionListener interface. (Other controls have additional events besides “actions”.) For convenience, Swing allows us to label each button with a so-called action command, which is a String of our choosing: when the ActionListener’s callback is invoked, it will be given an ActionEvent object that knows the action command of the button that was clicked. In this way, we can use a single listener to listen to multiple buttons at once, and distinguish them by means of this command string. See the calls to setActionCommand and setAct\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0043] e key, String featureName) {\n    this.keyComponent.getInputMap().put(key, featureName);\n  }\n\n  public void addFeatures(Features features) {\n    this.keyComponent.addFeatures(features);\n  }\n}\n\n\/\/ NOTE: Neither does this class!  It only refers to Features.\nclass KeyComponent extends JPanel {\n  List<Features> featureListeners = new ArrayList<>();\n\n  \/\/ Includes this new feature listener in responding to keys\n  void addFeatures(Features f) { this.featureListeners.add(f); }\n\n  KeyComponent() {\n    \/\/ Install action command -> Feature callback associations\n    this.getActionMap().put(\"makeCaps\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.makeUppercase();\n      }\n    });\n    this.getActionMap().put(\"restoreLowe\n<\/Context>","code_prefix":"<CodePrefix>\npackage view;\n\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\nimport javax.swing.*;\n\nimport model.IModel;\n\npublic class EchoPanel extends JPanel {\n\n  private final JTextField textInput;\n  private final JLabel echoLabel;\n  private JButton echoButton, exitButton;\n\n  \/\/private final IModel model; \/\/Used to be needed, but no longer as there is no listener here.\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic String getInput() {\n    return textInput.getText();\n  }\n\n  public void displayText(String text) {\n    echoLabel.setText(text);\n  }\n\n  public void clearInput() {\n    textInput.setText(\"\");\n  }\n\n  public void setViewActions(ViewActions actions) {\n    echoButton.addActionListener(new EchoActionListener(actions));\n    exitButton.addActionListener(\n        (ActionEvent evt) -> { actions.exitProgram();}\n    );\n  }\n\n  class EchoActionListener implements ActionListener {\n\n    private ViewActions actions;\n\n    public EchoActionListener(ViewActions actions) {\n      this.actions = actions;\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n      actions.displayText(textInput.getText());\n    }\n  }\n\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic EchoPanel(IModel model) {\n    super();\n\n    \/\/this.model = model;\n\n    \/\/By default, panels have a FlowLayout\n\n    echoLabel = new JLabel(\"Echo text here!\");\n    this.add(echoLabel);\n\n    textInput = new JTextField(20);\n    this.add(textInput);\n\n    echoButton = new JButton(\"Echo!\");\n    echoButton.setActionCommand(\"echo\");\n    \/\/echoButton.addActionListener(this); \/\/This isn't a listener. So who do we pass in? And where?\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"exit\");\n    \/\/exitButton.addActionListener(this); \/\/This isn't a listener. So who do we pass in? And where?\n    this.add(exitButton);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\observer-1335\\src\\view\\EchoPanel.java","mask_span":[390,1058],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0007] y a function that gets called when something interesting occurs. In our case, the clicking of different buttons should trigger a callback. In the jargon of Swing, clicking on buttons triggers their action, and so we must supply a function object that implements the ActionListener interface. (Other controls have additional events besides “actions”.) For convenience, Swing allows us to label each button with a so-called action command, which is a String of our choosing: when the ActionListener’s callback is invoked, it will be given an ActionEvent object that knows the action command of the button that was clicked. In this way, we can use a single listener to listen to multiple buttons at once, and distinguish them by means of this command string. See the calls to setActionCommand and setAct\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0043] e key, String featureName) {\n    this.keyComponent.getInputMap().put(key, featureName);\n  }\n\n  public void addFeatures(Features features) {\n    this.keyComponent.addFeatures(features);\n  }\n}\n\n\/\/ NOTE: Neither does this class!  It only refers to Features.\nclass KeyComponent extends JPanel {\n  List<Features> featureListeners = new ArrayList<>();\n\n  \/\/ Includes this new feature listener in responding to keys\n  void addFeatures(Features f) { this.featureListeners.add(f); }\n\n  KeyComponent() {\n    \/\/ Install action command -> Feature callback associations\n    this.getActionMap().put(\"makeCaps\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.makeUppercase();\n      }\n    });\n    this.getActionMap().put(\"restoreLowe\n<\/Context>","code_prefix":"<CodePrefix>\npackage view;\n\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\nimport javax.swing.*;\n\nimport model.IModel;\n\npublic class EchoPanel extends JPanel {\n\n  private final JTextField textInput;\n  private final JLabel echoLabel;\n  private JButton echoButton, exitButton;\n\n  \/\/private final IModel model; \/\/Used to be needed, but no longer as there is no listener here.\n\n  public EchoPanel(IModel model) {\n    super();\n\n    \/\/this.model = model;\n\n    \/\/By default, panels have a FlowLayout\n\n    echoLabel = new JLabel(\"Echo text here!\");\n    this.add(echoLabel);\n\n    textInput = new JTextField(20);\n    this.add(textInput);\n\n    echoButton = new JButton(\"Echo!\");\n    echoButton.setActionCommand(\"echo\");\n    \/\/echoButton.addActionListener(this); \/\/This isn't a listener. So who do we pass in? And where?\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"exit\");\n    \/\/exitButton.addActionListener(this); \/\/This isn't a listener. So who do we pass in? And where?\n    this.add(exitButton);\n  }\n\n  public String getInput() {\n    return textInput.getText();\n  }\n\n  public void displayText(String text) {\n    echoLabel.setText(text);\n  }\n\n  public void clearInput() {\n    textInput.setText(\"\");\n  }\n\n  public void setViewActions(ViewActions actions) {\n    echoButton.addActionListener(new EchoActionListener(actions));\n    exitButton.addActionListener(\n        (ActionEvent evt) -> { actions.exitProgram();}\n    );\n  }\n\n  class EchoActionListener implements ActionListener {\n\n    private ViewActions actions;\n\n    public EchoActionListener(ViewActions actions) {\n      this.actions = actions;\n    }\n\n    @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void actionPerformed(ActionEvent e) {\n      actions.displayText(textInput.getText());\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\observer-1335\\src\\view\\EchoPanel.java","mask_span":[1680,1778],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0003] n\nAll examples in this lecture follow a common design. The model state (interface IModel and implementation Model) consists of a single String and offers methods to get and update it. All views (coupled with controllers wherever applicable) expose functionality to interactively show this string, and to update it.\n\n3 Text-based UI\nIn the TextUI directory we show a text-based user interface. The IView interface encapsulates all the methods that a view’s client would need to call: note how they correspond roughly to the “things” that a controller would need to tell the view to do. The TextView class implements this interface. It transmits all messages to a PrintStream object provided to it through its constructor. Similar to the design in Lecture 8 this allows us to test the view using any su\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0002] user interfaces. We start with poorly-designed but working code, and improve it in three stages. Initially, the code for the view will directly manipulate the model. Our first incremental improvement will decouple the view from the model so that it need not — and in fact cannot — do so. Our second improvement will add a new feature to the view, and add the ability to control that in the controller. Finally, our third improvement will generalize the controller to make its UI triggers more customizable.\n\nThe code for this lecture is available at the top of this page, as the MVC code link. The second link provides code for a program with an incomplete GUI. It is recommended that you complete this exercise to practice with GUIs. Finally the third link provides a solution for this GUI.\n\n2 Desig\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n<\/Context>","code_prefix":"<CodePrefix>\nimport view.GUIView;\nimport view.ViewActions;\n\n\npublic class GUIController implements ViewActions {\n\n  private final IModel model;\n  private final GUIView view;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void displayText(String text) {\n    model.setString(text);\n    view.displayText(model.getString());\n    view.clearInput();\n  }\n\n  @Override\n  public void exitProgram() {\n    System.exit(0);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic GUIController(IModel model, GUIView view) {\n    this.model = model;\n    this.view = view;\n    view.setViewActions(this);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\observers-1030\\src\\GUIController.java","mask_span":[164,295],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0003] n\nAll examples in this lecture follow a common design. The model state (interface IModel and implementation Model) consists of a single String and offers methods to get and update it. All views (coupled with controllers wherever applicable) expose functionality to interactively show this string, and to update it.\n\n3 Text-based UI\nIn the TextUI directory we show a text-based user interface. The IView interface encapsulates all the methods that a view’s client would need to call: note how they correspond roughly to the “things” that a controller would need to tell the view to do. The TextView class implements this interface. It transmits all messages to a PrintStream object provided to it through its constructor. Similar to the design in Lecture 8 this allows us to test the view using any su\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0002] user interfaces. We start with poorly-designed but working code, and improve it in three stages. Initially, the code for the view will directly manipulate the model. Our first incremental improvement will decouple the view from the model so that it need not — and in fact cannot — do so. Our second improvement will add a new feature to the view, and add the ability to control that in the controller. Finally, our third improvement will generalize the controller to make its UI triggers more customizable.\n\nThe code for this lecture is available at the top of this page, as the MVC code link. The second link provides code for a program with an incomplete GUI. It is recommended that you complete this exercise to practice with GUIs. Finally the third link provides a solution for this GUI.\n\n2 Desig\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n<\/Context>","code_prefix":"<CodePrefix>\nimport view.EchoFrame;\nimport view.GUIView;\n\npublic class MVCExampleTextUI {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String []args) {\n        IModel model = new Model();\n        GUIView view = new EchoFrame(); \/\/This view no longer needs the model.\n        GUIController controller = new GUIController(model, view); \/\/constructor sets up everything\n        \/\/alternatively, expose a method that sets the ViewActions and sets the view to be visible\n\n        \/*\n         * \/\/ OLD WAY!\n        IModel model = new Model();\n        IView view = new TextView(System.out);\n        IController controller = new TextController(model,System.in,view);\n        controller.runProgram();\n         *\/\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\observers-1030\\src\\MVCExampleTextUI.java","mask_span":[81,679],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0012]  } catch (InputMismatchException ime) {\n      ...\n    }\n    break;\n}\nThe possibilities are now endless! We can support similar higher-level drawing text commands. Every such text commands adds a new case to our switch statement. The number of lines of code in each case statement depends on the complexity of the text command (e.g. the square text-command added 13 lines of code). As a result, the switch statement quickly grows in size. Moreover the go method is increasingly incohesive.\n\n4 The Command Design Pattern\nIn order to make each case statement shorter, we can put all its code into a separate helper method. Since all the helper methods operate on the model, we pass the model object to them. Also since some of the text command require additional input, we pass the additional input to e\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0015] acingTurtleModel m) {\n    m.trace(this.d);\n  }\n\n  ...\n\n}\nNow we can change the logic of our controller to:\n\nTake a one-word command from the user.\nCreate the corresponding TracingTurtleCommand object..\nExecute the command object.\nString in = s.next();\ntry {\n  switch (in) {\n    case \"q\":\n    case \"quit\":\n      return;\n   case \"show\":\n     for (Line l : m.getLines()) {\n        System.out.println(l);\n     }\n     break;\n   case \"move\":\n      cmd = new Move(s.nextDouble());\n      break;\n   case \"trace\":\n      cmd = new Trace(s.nextDouble());\n      break;\n   case \"turn\":\n      cmd = new Turn(s.nextDouble());\n      break;\n   case \"square\":\n      cmd = new Square(s.nextDouble());\n      break;\n   default:\n      System.out.println(String.format(\"Unknown command %s\", in));\n      cmd = null;\n      bre\n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.InputStream;\nimport java.util.Scanner;\n\npublic class TextController implements IController{\n    private Scanner in;\n    private IView view;\n    private IModel model;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic void runProgram() {\n        boolean quit = false;\n\n        while (!quit) {\n            \/\/tell view to show the string so far.\n            view.showString(this.model.getString());\n            \/\/tell view to show options\n            view.showOptions();\n            \/\/accept user input\n            String option = in.next();\n            switch (option) {\n                case \"E\":\n                    \/\/ask for string input\n                    view.showStringEntry();\n                    in.nextLine();\n                    String input = in.nextLine();\n                    \/\/give to model\n                    model.setString(input);\n                    break;\n                case \"Q\":\n                    quit = true;\n                    break;\n                default:\n                    view.showOptionError();\n            }\n        }\n    }\n\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TextController(IModel model,InputStream in,IView view) {\n        this.model = model;\n        this.view = view;\n        this.in = new Scanner(in);\n\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\observers-1030\\src\\TextController.java","mask_span":[186,345],"topics":["observer","command","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0020] en again using Java’s new lambda syntax (see Streamlining the code further below).\n\n\/**\n * Represents the printing of a sequence of lines to output\n *\/\nclass PrintInteraction implements Interaction {\n  String[] lines;\n  PrintInteraction(String... lines) {\n    this.lines = lines;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    for (String line : lines) {\n      out.append(line).append(\"\\n\");\n    }\n  }\n}\n\/**\n * Represents a user providing the program with  an input\n *\/\nclass InputInteraction implements Interaction {\n  String input;\n  InputInteraction(String input) {\n    this.input = input;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    in.append(input);\n  }\n}\nFor example, the following array of Interactions represents two inputs to our Calculator and the\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.PrintStream;\n\npublic class TextView implements IView {\n    private PrintStream out;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic void showString(String s) {\n        out.println(\"String: \"+s);\n    }\n\n    public void showOptions() {\n        \/\/print the UI\n        out.println(\"Menu: \");\n        out.println(\"E: Enter a string\");\n        out.println(\"Q: Quit the program\");\n        out.print(\"Enter your choice: \");\n    }\n\n    public void showStringEntry() {\n        out.print(\"\\nEnter the string to be echoed: \");\n    }\n\n    public void showOptionError() {\n        out.print(\"\\nInvalid option. Please try again.\");\n    }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TextView(PrintStream out) {\n        this.out = out;\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\observers-1030\\src\\TextView.java","mask_span":[104,168],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0020] en again using Java’s new lambda syntax (see Streamlining the code further below).\n\n\/**\n * Represents the printing of a sequence of lines to output\n *\/\nclass PrintInteraction implements Interaction {\n  String[] lines;\n  PrintInteraction(String... lines) {\n    this.lines = lines;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    for (String line : lines) {\n      out.append(line).append(\"\\n\");\n    }\n  }\n}\n\/**\n * Represents a user providing the program with  an input\n *\/\nclass InputInteraction implements Interaction {\n  String input;\n  InputInteraction(String input) {\n    this.input = input;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    in.append(input);\n  }\n}\nFor example, the following array of Interactions represents two inputs to our Calculator and the\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.PrintStream;\n\npublic class TextView implements IView {\n    private PrintStream out;\n\n    public TextView(PrintStream out) {\n        this.out = out;\n    }\n\n    public void showString(String s) {\n        out.println(\"String: \"+s);\n    }\n\n    public void showOptions() {\n        \/\/print the UI\n        out.println(\"Menu: \");\n        out.println(\"E: Enter a string\");\n        out.println(\"Q: Quit the program\");\n        out.print(\"Enter your choice: \");\n    }\n\n    public void showStringEntry() {\n        out.print(\"\\nEnter the string to be echoed: \");\n    }\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void showOptionError() {\n        out.print(\"\\nInvalid option. Please try again.\");\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\observers-1030\\src\\TextView.java","mask_span":[575,670],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n<\/Context>","code_prefix":"<CodePrefix>\npackage view;\n\nimport java.awt.Color;\nimport java.awt.FlowLayout;\n\nimport javax.swing.JFrame;\n\npublic class EchoFrame extends JFrame implements GUIView {\n\n  private final EchoPanel echoPanel;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public String getInput() {\n    return echoPanel.getInput();\n  }\n\n  @Override\n  public void displayText(String string) {\n    echoPanel.displayText(string);\n  }\n\n  @Override\n  public void clearInput() {\n    echoPanel.clearInput();\n  }\n\n  @Override\n  public void setViewActions(ViewActions actions) {\n    echoPanel.setViewActions(actions);\n    this.setVisible(true);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic EchoFrame() {\n    super();\n    this.setSize(700, 300);\n    this.setLocation(600, 500);\n\n    \/\/To put the frame in the middle of the screen, use\n    \/\/this.setLocationRelativeTo(null);\n\n    this.setDefaultCloseOperation(EXIT_ON_CLOSE);\n    this.setBackground(Color.MAGENTA);\n\n    \/\/Set the manager so everything is added in a line if possible\n    this.setLayout(new FlowLayout());\n\n    echoPanel = new EchoPanel();\n    this.add(echoPanel);\n\n    this.pack();\n    this.setVisible(true);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\observers-1030\\src\\view\\EchoFrame.java","mask_span":[194,688],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n<\/Context>","code_prefix":"<CodePrefix>\npackage view;\n\nimport java.awt.Color;\nimport java.awt.FlowLayout;\n\nimport javax.swing.JFrame;\n\npublic class EchoFrame extends JFrame implements GUIView {\n\n  private final EchoPanel echoPanel;\n  public EchoFrame() {\n    super();\n    this.setSize(700, 300);\n    this.setLocation(600, 500);\n\n    \/\/To put the frame in the middle of the screen, use\n    \/\/this.setLocationRelativeTo(null);\n\n    this.setDefaultCloseOperation(EXIT_ON_CLOSE);\n    this.setBackground(Color.MAGENTA);\n\n    \/\/Set the manager so everything is added in a line if possible\n    this.setLayout(new FlowLayout());\n\n    echoPanel = new EchoPanel();\n    this.add(echoPanel);\n\n    this.pack();\n    this.setVisible(true);\n  }\n\n  @Override\n  public String getInput() {\n    return echoPanel.getInput();\n  }\n\n  @Override\n  public void displayText(String string) {\n    echoPanel.displayText(string);\n  }\n\n  @Override\n  public void clearInput() {\n    echoPanel.clearInput();\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void setViewActions(ViewActions actions) {\n    echoPanel.setViewActions(actions);\n    this.setVisible(true);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\observers-1030\\src\\view\\EchoFrame.java","mask_span":[952,1071],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0007] y a function that gets called when something interesting occurs. In our case, the clicking of different buttons should trigger a callback. In the jargon of Swing, clicking on buttons triggers their action, and so we must supply a function object that implements the ActionListener interface. (Other controls have additional events besides “actions”.) For convenience, Swing allows us to label each button with a so-called action command, which is a String of our choosing: when the ActionListener’s callback is invoked, it will be given an ActionEvent object that knows the action command of the button that was clicked. In this way, we can use a single listener to listen to multiple buttons at once, and distinguish them by means of this command string. See the calls to setActionCommand and setAct\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0043] e key, String featureName) {\n    this.keyComponent.getInputMap().put(key, featureName);\n  }\n\n  public void addFeatures(Features features) {\n    this.keyComponent.addFeatures(features);\n  }\n}\n\n\/\/ NOTE: Neither does this class!  It only refers to Features.\nclass KeyComponent extends JPanel {\n  List<Features> featureListeners = new ArrayList<>();\n\n  \/\/ Includes this new feature listener in responding to keys\n  void addFeatures(Features f) { this.featureListeners.add(f); }\n\n  KeyComponent() {\n    \/\/ Install action command -> Feature callback associations\n    this.getActionMap().put(\"makeCaps\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.makeUppercase();\n      }\n    });\n    this.getActionMap().put(\"restoreLowe\n<\/Context>","code_prefix":"<CodePrefix>\npackage view;\n\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\nimport javax.swing.*;\n\npublic class EchoPanel extends JPanel {\n\n  private JLabel echoLabel;\n  private JTextField inputField;\n\n  private final JButton echoButton;\n  private final JButton exitButton;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic String getInput() {\n    return inputField.getText();\n  }\n\n  public void displayText(String string) {\n    echoLabel.setText(string);\n  }\n\n  public void clearInput() {\n    inputField.setText(\"\");\n  }\n\n  public void setViewActions(ViewActions actions) {\n    echoButton.addActionListener(new EchoActionListener(actions));\n\n    \/\/ActionListeners are function objects, so we can replace them with lambdas\n    exitButton.addActionListener( (evt) -> { actions.exitProgram(); } );\n  }\n\n  class EchoActionListener implements ActionListener {\n\n    private ViewActions actions;\n\n    public EchoActionListener(ViewActions actions) {\n      this.actions = actions;\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n      actions.displayText(EchoPanel.this.getInput());\n      \/\/If we want access to the field itself\n      \/\/actions.displayText(EchoPanel.this.textInput.getText());\n    }\n  }\n}\n\n\n<\/CodeSuffix>","target":"<Target>\npublic EchoPanel() {\n    super();\n\n    this.echoLabel = new JLabel(\"Echo text!\");\n    this.add(echoLabel);\n\n    this.inputField = new JTextField(20);\n    this.add(inputField);\n\n    echoButton = new JButton(\"Echo!\");\n    echoButton.setActionCommand(\"echo\");\n    \/\/echoButton.addActionListener(this); \/\/This no longer works! So how do we add the listener?! (Observer pattern)\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"exit\");\n    \/\/exitButton.addActionListener(this); \/\/This no longer works! So how do we add the listener?! (Observer pattern)\n    this.add(exitButton);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\observers-1030\\src\\view\\EchoPanel.java","mask_span":[290,916],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0007] y a function that gets called when something interesting occurs. In our case, the clicking of different buttons should trigger a callback. In the jargon of Swing, clicking on buttons triggers their action, and so we must supply a function object that implements the ActionListener interface. (Other controls have additional events besides “actions”.) For convenience, Swing allows us to label each button with a so-called action command, which is a String of our choosing: when the ActionListener’s callback is invoked, it will be given an ActionEvent object that knows the action command of the button that was clicked. In this way, we can use a single listener to listen to multiple buttons at once, and distinguish them by means of this command string. See the calls to setActionCommand and setAct\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0043] e key, String featureName) {\n    this.keyComponent.getInputMap().put(key, featureName);\n  }\n\n  public void addFeatures(Features features) {\n    this.keyComponent.addFeatures(features);\n  }\n}\n\n\/\/ NOTE: Neither does this class!  It only refers to Features.\nclass KeyComponent extends JPanel {\n  List<Features> featureListeners = new ArrayList<>();\n\n  \/\/ Includes this new feature listener in responding to keys\n  void addFeatures(Features f) { this.featureListeners.add(f); }\n\n  KeyComponent() {\n    \/\/ Install action command -> Feature callback associations\n    this.getActionMap().put(\"makeCaps\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.makeUppercase();\n      }\n    });\n    this.getActionMap().put(\"restoreLowe\n<\/Context>","code_prefix":"<CodePrefix>\npackage view;\n\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\nimport javax.swing.*;\n\npublic class EchoPanel extends JPanel {\n\n  private JLabel echoLabel;\n  private JTextField inputField;\n\n  private final JButton echoButton;\n  private final JButton exitButton;\n\n  public EchoPanel() {\n    super();\n\n    this.echoLabel = new JLabel(\"Echo text!\");\n    this.add(echoLabel);\n\n    this.inputField = new JTextField(20);\n    this.add(inputField);\n\n    echoButton = new JButton(\"Echo!\");\n    echoButton.setActionCommand(\"echo\");\n    \/\/echoButton.addActionListener(this); \/\/This no longer works! So how do we add the listener?! (Observer pattern)\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"exit\");\n    \/\/exitButton.addActionListener(this); \/\/This no longer works! So how do we add the listener?! (Observer pattern)\n    this.add(exitButton);\n  }\n\n  public String getInput() {\n    return inputField.getText();\n  }\n\n  public void displayText(String string) {\n    echoLabel.setText(string);\n  }\n\n  public void clearInput() {\n    inputField.setText(\"\");\n  }\n\n  public void setViewActions(ViewActions actions) {\n    echoButton.addActionListener(new EchoActionListener(actions));\n\n    \/\/ActionListeners are function objects, so we can replace them with lambdas\n    exitButton.addActionListener( (evt) -> { actions.exitProgram(); } );\n  }\n\n  class EchoActionListener implements ActionListener {\n\n    private ViewActions actions;\n\n    public EchoActionListener(ViewActions actions) {\n      this.actions = actions;\n    }\n\n    @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n}\n\n\n<\/CodeSuffix>","target":"<Target>\npublic void actionPerformed(ActionEvent e) {\n      actions.displayText(EchoPanel.this.getInput());\n      \/\/If we want access to the field itself\n      \/\/actions.displayText(EchoPanel.this.textInput.getText());\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\observers-1030\\src\\view\\EchoPanel.java","mask_span":[1602,1817],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0000] Lecture 11: The Perils of Inheritance\nJava source (.zip)\nOverview of the lecture\nThis lecture compares inheritance and composition as two ways to reuse existing code. Many solutions to design problems can be loosely framed as replacing one of these ways with the other.\n\nThe IntSet interface is a simplified API for working with sets of integers—it has nearly the bare minimum of methods. Now, suppose we wanted to instrument an IntSet to find out how many times elements are added (which isn’t the same as the size). The InstrumentedIntSet interface extends IntSet with an additional operation, which lets the client find out the count of add operations.\n\nNow, suppose we wanted to implement InstrumentedIntSet based on an existing IntSet implementation that someone else wrote and maintains (IntSet\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0001] 1, in this case—no peeking), and that we don’t want to look at or mess with. The InstrumentedIntSet1 class is our first attempt to do this by inheriting from IntSet1 and overriding the relevant methods to have them count as well. This looks good, but when we test it (see InstrumentedIntSetTest), we find that one of the tests fails.1 Why do the tests fail? You may need to look at IntSet1 to figure it out.\n\nOnce we’ve figured out why they fail, we give it another go with the InstrumentedIntSet2 class, which compensates for what was going on in our first attempt. If InstrumentedIntSet2 extended IntSet1, the same IntSet implementation as before, it would pass the tests. Alas! Unbeknownst to us, the maintainer of IntSet1 decided to tweak the implementation in a (supposedly) innocuous way, and t\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0003] ’t screw things up.\nThe IntSet4 class takes an even more conservative approach: IntSet4 is final, which prohibits extension altogether. This is almost always the right thing to do when you write a class: unless you are designing and documenting for extension, make the class final. That way, no clients of your class can depend on implementation details leaking out via inheritance, as happened with IntSet1 and IntSet2.\n\nMaking IntSet4 final poses a problem for implementing InstrumentedIntSet4, because it can no longer use subclassing to just override some methods and silently inherit the others. So instead, InstrumentedIntSet4 takes a different tack: the delegate pattern. Instead of inheritance, it uses object composition, which means that it has a field holding the IntSet object that it wan\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0002] hat change having cancelled out our compensation, InstrumentedIntSet2 also fails one of the tests. Again, can you see why? Here’s IntSet2 in case you need it.\n\nThe next two versions show two different solutions to our problem.\n\nIn IntSet3, the author made a defensive change so that subclasses cannot interfere with how its own methods are implemented. This looks substantially the same as IntSet2 from the outside, but there are actually two substantive changes:\n\nInstead of duplicating the (admittedly tiny) code between add() and addAll(), IntSet3 factors that out into a private method that subclasses can’t touch.\nIntSet3 is properly documented for extension, which means that InstrumentedIntSet3 can now safely extend it, knowing (because it’s documented!) that overriding IntSet3’s methods won\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\n\/**\n * An integer set that is instrumented to count the number of times an\n * element is added. It works by extending {@link IntSet1}, which\n * provides the basic set operations. It then overrides both {@link #add(int)}\n * and {@link IntSet#addAll(int...)} in order update the count in both cases.\n *\/\npublic class InstrumentedIntSet1\n  extends IntSet1\n  implements InstrumentedIntSet\n{\n  private int addCount = 0;\n\n  @Override\n  public int getAddCount() {\n    return addCount;\n  }\n\n  @Override\n  public void add(int value) {\n    super.add(value);\n\n    \/\/ Update the count for the one element we added:\n    ++addCount;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void addAll(int... values) {\n    super.addAll(values);\n\n    \/\/ Update the count for all the elements we added:\n    \/\/addCount += values.length;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1030\\src\\cs3500\\lec10\\InstrumentedIntSet1.java","mask_span":[661,815],"topics":["gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0000] Lecture 11: The Perils of Inheritance\nJava source (.zip)\nOverview of the lecture\nThis lecture compares inheritance and composition as two ways to reuse existing code. Many solutions to design problems can be loosely framed as replacing one of these ways with the other.\n\nThe IntSet interface is a simplified API for working with sets of integers—it has nearly the bare minimum of methods. Now, suppose we wanted to instrument an IntSet to find out how many times elements are added (which isn’t the same as the size). The InstrumentedIntSet interface extends IntSet with an additional operation, which lets the client find out the count of add operations.\n\nNow, suppose we wanted to implement InstrumentedIntSet based on an existing IntSet implementation that someone else wrote and maintains (IntSet\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0001] 1, in this case—no peeking), and that we don’t want to look at or mess with. The InstrumentedIntSet1 class is our first attempt to do this by inheriting from IntSet1 and overriding the relevant methods to have them count as well. This looks good, but when we test it (see InstrumentedIntSetTest), we find that one of the tests fails.1 Why do the tests fail? You may need to look at IntSet1 to figure it out.\n\nOnce we’ve figured out why they fail, we give it another go with the InstrumentedIntSet2 class, which compensates for what was going on in our first attempt. If InstrumentedIntSet2 extended IntSet1, the same IntSet implementation as before, it would pass the tests. Alas! Unbeknownst to us, the maintainer of IntSet1 decided to tweak the implementation in a (supposedly) innocuous way, and t\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0002] hat change having cancelled out our compensation, InstrumentedIntSet2 also fails one of the tests. Again, can you see why? Here’s IntSet2 in case you need it.\n\nThe next two versions show two different solutions to our problem.\n\nIn IntSet3, the author made a defensive change so that subclasses cannot interfere with how its own methods are implemented. This looks substantially the same as IntSet2 from the outside, but there are actually two substantive changes:\n\nInstead of duplicating the (admittedly tiny) code between add() and addAll(), IntSet3 factors that out into a private method that subclasses can’t touch.\nIntSet3 is properly documented for extension, which means that InstrumentedIntSet3 can now safely extend it, knowing (because it’s documented!) that overriding IntSet3’s methods won\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0003] ’t screw things up.\nThe IntSet4 class takes an even more conservative approach: IntSet4 is final, which prohibits extension altogether. This is almost always the right thing to do when you write a class: unless you are designing and documenting for extension, make the class final. That way, no clients of your class can depend on implementation details leaking out via inheritance, as happened with IntSet1 and IntSet2.\n\nMaking IntSet4 final poses a problem for implementing InstrumentedIntSet4, because it can no longer use subclassing to just override some methods and silently inherit the others. So instead, InstrumentedIntSet4 takes a different tack: the delegate pattern. Instead of inheritance, it uses object composition, which means that it has a field holding the IntSet object that it wan\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\n\/**\n * An integer set that is instrumented to count the number of times an\n * element is added. It works by extending {@link IntSet2}, which\n * provides the basic set operations. It then overrides both {@link #add(int)}\n * and {@link IntSet#addAll(int...)} in order update the count in both cases.\n *\/\npublic class InstrumentedIntSet2\n  extends IntSet2\n  implements InstrumentedIntSet\n{\n  private int addCount = 0;\n\n  @Override\n  public int getAddCount() {\n    return addCount;\n  }\n\n  @Override\n  public void add(int value) {\n    super.add(value);\n\n    \/\/ Update the count for the one element we added:\n    ++addCount;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void addAll(int... values) {\n    super.addAll(values);\n    \/\/ Don't need to update the count because apparently super.addAll() calls\n    \/\/ super.add();\n    addCount += values.length;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1030\\src\\cs3500\\lec10\\InstrumentedIntSet2.java","mask_span":[661,855],"topics":["gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0000] Lecture 11: The Perils of Inheritance\nJava source (.zip)\nOverview of the lecture\nThis lecture compares inheritance and composition as two ways to reuse existing code. Many solutions to design problems can be loosely framed as replacing one of these ways with the other.\n\nThe IntSet interface is a simplified API for working with sets of integers—it has nearly the bare minimum of methods. Now, suppose we wanted to instrument an IntSet to find out how many times elements are added (which isn’t the same as the size). The InstrumentedIntSet interface extends IntSet with an additional operation, which lets the client find out the count of add operations.\n\nNow, suppose we wanted to implement InstrumentedIntSet based on an existing IntSet implementation that someone else wrote and maintains (IntSet\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0001] 1, in this case—no peeking), and that we don’t want to look at or mess with. The InstrumentedIntSet1 class is our first attempt to do this by inheriting from IntSet1 and overriding the relevant methods to have them count as well. This looks good, but when we test it (see InstrumentedIntSetTest), we find that one of the tests fails.1 Why do the tests fail? You may need to look at IntSet1 to figure it out.\n\nOnce we’ve figured out why they fail, we give it another go with the InstrumentedIntSet2 class, which compensates for what was going on in our first attempt. If InstrumentedIntSet2 extended IntSet1, the same IntSet implementation as before, it would pass the tests. Alas! Unbeknownst to us, the maintainer of IntSet1 decided to tweak the implementation in a (supposedly) innocuous way, and t\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0002] hat change having cancelled out our compensation, InstrumentedIntSet2 also fails one of the tests. Again, can you see why? Here’s IntSet2 in case you need it.\n\nThe next two versions show two different solutions to our problem.\n\nIn IntSet3, the author made a defensive change so that subclasses cannot interfere with how its own methods are implemented. This looks substantially the same as IntSet2 from the outside, but there are actually two substantive changes:\n\nInstead of duplicating the (admittedly tiny) code between add() and addAll(), IntSet3 factors that out into a private method that subclasses can’t touch.\nIntSet3 is properly documented for extension, which means that InstrumentedIntSet3 can now safely extend it, knowing (because it’s documented!) that overriding IntSet3’s methods won\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0003] ’t screw things up.\nThe IntSet4 class takes an even more conservative approach: IntSet4 is final, which prohibits extension altogether. This is almost always the right thing to do when you write a class: unless you are designing and documenting for extension, make the class final. That way, no clients of your class can depend on implementation details leaking out via inheritance, as happened with IntSet1 and IntSet2.\n\nMaking IntSet4 final poses a problem for implementing InstrumentedIntSet4, because it can no longer use subclassing to just override some methods and silently inherit the others. So instead, InstrumentedIntSet4 takes a different tack: the delegate pattern. Instead of inheritance, it uses object composition, which means that it has a field holding the IntSet object that it wan\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\n\/**\n * An integer set that is instrumented to count the number of times an\n * element is added. This time it works because the superclass never calls\n * methods that the subclass might override, <b>and<\/b> as the implementor of\n * the subclass, we can be confident of this because the superclass {@link\n * IntSet3} documents this fact.\n *\/\npublic class InstrumentedIntSet3\n  extends IntSet3\n  implements InstrumentedIntSet\n{\n  private int addCount = 0;\n\n  @Override\n  public int getAddCount() {\n    return addCount;\n  }\n\n  @Override\n  public void add(int value) {\n    super.add(value);\n    ++addCount;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void addAll(int... values) {\n    super.addAll(values);\n    addCount += values.length;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1030\\src\\cs3500\\lec10\\InstrumentedIntSet3.java","mask_span":[644,740],"topics":["gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0003] ’t screw things up.\nThe IntSet4 class takes an even more conservative approach: IntSet4 is final, which prohibits extension altogether. This is almost always the right thing to do when you write a class: unless you are designing and documenting for extension, make the class final. That way, no clients of your class can depend on implementation details leaking out via inheritance, as happened with IntSet1 and IntSet2.\n\nMaking IntSet4 final poses a problem for implementing InstrumentedIntSet4, because it can no longer use subclassing to just override some methods and silently inherit the others. So instead, InstrumentedIntSet4 takes a different tack: the delegate pattern. Instead of inheritance, it uses object composition, which means that it has a field holding the IntSet object that it wan\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0005] at we saw early on in the course. The tests for different InstrumentedIntSet implementations are always the same, and we extend the abstract base class eight times to test our different attempts at implementing InstrumentedIntSet.\n\n2It could even change the delegate dynamically if that’s what we wanted.\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0004] ts to instrument. Then InstrumentedIntSet4 forwards method calls to the delegate rather than handling them itself, adding the instrumentation functionality where needed:\n\nThe delegate pattern\n\nA disadvantage of this approach is inconvenience, since it now requires writing a stub for every method, even those that we formerly inherited unchanged. But an advantage of object composition is increased flexibility, because InstrumentedIntSet4 can take an object of any IntSet implementation in its constructor and delegate to that rather than fixing one IntSet implementation to inherit from.2 This flexibility is demonstrated by the test classes Test1Using1 through Test1Using4 at the bottom of InstrumentedIntSetTest.\n\n1InstrumentedIntSetTest uses the factory method–based abstract testing approach th\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0000] Lecture 11: The Perils of Inheritance\nJava source (.zip)\nOverview of the lecture\nThis lecture compares inheritance and composition as two ways to reuse existing code. Many solutions to design problems can be loosely framed as replacing one of these ways with the other.\n\nThe IntSet interface is a simplified API for working with sets of integers—it has nearly the bare minimum of methods. Now, suppose we wanted to instrument an IntSet to find out how many times elements are added (which isn’t the same as the size). The InstrumentedIntSet interface extends IntSet with an additional operation, which lets the client find out the count of add operations.\n\nNow, suppose we wanted to implement InstrumentedIntSet based on an existing IntSet implementation that someone else wrote and maintains (IntSet\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\nimport java.util.Objects;\n\n\/**\n * In this case, the author of {@link IntSet4} decided to avoid the\n * inheritance problem by making {@code IntSet4} final. That means we cannot\n * extend it, so instead we use the delegate pattern. The idea is that\n * instead of extending {@code IntSet4}, we keep one in a field. Then we can\n * implement our {@link InstrumentedIntSet} by delegating method calls to the\n * delegate (that is, letting the delegate do the work), and we can extend\n * the functionality by doing other things in our wrapper methods besides\n * delegating (such as updating the count).\n *\n * <p>One disadvantage of this approach is that we now have to write a shim\n * for every method, even if all it does is delegate, whereas inheritance\n * would have included all the non-overridden methods for us. An advantage is\n * the increase in flexibility, since we can now do things such as instrument\n * an existing {@link IntSet} without having to know its implementation.\n * Since the delegate is a field, we could also do things like change it at\n * will. (This class doesn't support that at this point, but it wouldn't be\n * difficult to add.)\n *\/\npublic class InstrumentedIntSet4 implements InstrumentedIntSet {\n  private int addCount = 0;\n  private final IntSet delegate;\n\n  \/**\n   * Constructs a new instrumented integer set.\n   *\/\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/**\n   * Constructs an instrumented integer set on top of an existing\n   * {@link IntSet}.\n   *\n   * @param base the integer set to instrument (non-null)\n   *\/\n  public InstrumentedIntSet4(IntSet base) {\n    Objects.requireNonNull(base, \"base cannot be null\");\n    delegate = base;\n  }\n\n  \/**\n   * Returns the count of how many times an element has been added to the set.\n   *\n   * @return the count of added elements\n   *\/\n  public int getAddCount() {\n    return addCount;\n  }\n\n  @Override\n  public void add(int value) {\n    delegate.add(value);\n    ++addCount;\n  }\n\n  @Override\n  public void addAll(int... values) {\n    delegate.addAll(values);\n    addCount += values.length;\n  }\n\n  @Override\n  public void remove(int value) {\n    delegate.remove(value);\n  }\n\n  @Override\n  public boolean member(int value) {\n    return delegate.member(value);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic InstrumentedIntSet4() {\n    delegate = new IntSet4();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1030\\src\\cs3500\\lec10\\InstrumentedIntSet4.java","mask_span":[1367,1431],"topics":["mvc","gui","factory"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0003] ’t screw things up.\nThe IntSet4 class takes an even more conservative approach: IntSet4 is final, which prohibits extension altogether. This is almost always the right thing to do when you write a class: unless you are designing and documenting for extension, make the class final. That way, no clients of your class can depend on implementation details leaking out via inheritance, as happened with IntSet1 and IntSet2.\n\nMaking IntSet4 final poses a problem for implementing InstrumentedIntSet4, because it can no longer use subclassing to just override some methods and silently inherit the others. So instead, InstrumentedIntSet4 takes a different tack: the delegate pattern. Instead of inheritance, it uses object composition, which means that it has a field holding the IntSet object that it wan\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0005] at we saw early on in the course. The tests for different InstrumentedIntSet implementations are always the same, and we extend the abstract base class eight times to test our different attempts at implementing InstrumentedIntSet.\n\n2It could even change the delegate dynamically if that’s what we wanted.\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0004] ts to instrument. Then InstrumentedIntSet4 forwards method calls to the delegate rather than handling them itself, adding the instrumentation functionality where needed:\n\nThe delegate pattern\n\nA disadvantage of this approach is inconvenience, since it now requires writing a stub for every method, even those that we formerly inherited unchanged. But an advantage of object composition is increased flexibility, because InstrumentedIntSet4 can take an object of any IntSet implementation in its constructor and delegate to that rather than fixing one IntSet implementation to inherit from.2 This flexibility is demonstrated by the test classes Test1Using1 through Test1Using4 at the bottom of InstrumentedIntSetTest.\n\n1InstrumentedIntSetTest uses the factory method–based abstract testing approach th\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0000] Lecture 11: The Perils of Inheritance\nJava source (.zip)\nOverview of the lecture\nThis lecture compares inheritance and composition as two ways to reuse existing code. Many solutions to design problems can be loosely framed as replacing one of these ways with the other.\n\nThe IntSet interface is a simplified API for working with sets of integers—it has nearly the bare minimum of methods. Now, suppose we wanted to instrument an IntSet to find out how many times elements are added (which isn’t the same as the size). The InstrumentedIntSet interface extends IntSet with an additional operation, which lets the client find out the count of add operations.\n\nNow, suppose we wanted to implement InstrumentedIntSet based on an existing IntSet implementation that someone else wrote and maintains (IntSet\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\nimport java.util.Objects;\n\n\/**\n * In this case, the author of {@link IntSet4} decided to avoid the\n * inheritance problem by making {@code IntSet4} final. That means we cannot\n * extend it, so instead we use the delegate pattern. The idea is that\n * instead of extending {@code IntSet4}, we keep one in a field. Then we can\n * implement our {@link InstrumentedIntSet} by delegating method calls to the\n * delegate (that is, letting the delegate do the work), and we can extend\n * the functionality by doing other things in our wrapper methods besides\n * delegating (such as updating the count).\n *\n * <p>One disadvantage of this approach is that we now have to write a shim\n * for every method, even if all it does is delegate, whereas inheritance\n * would have included all the non-overridden methods for us. An advantage is\n * the increase in flexibility, since we can now do things such as instrument\n * an existing {@link IntSet} without having to know its implementation.\n * Since the delegate is a field, we could also do things like change it at\n * will. (This class doesn't support that at this point, but it wouldn't be\n * difficult to add.)\n *\/\npublic class InstrumentedIntSet4 implements InstrumentedIntSet {\n  private int addCount = 0;\n  private final IntSet delegate;\n\n  \/**\n   * Constructs a new instrumented integer set.\n   *\/\n  public InstrumentedIntSet4() {\n    delegate = new IntSet4();\n  }\n\n  \/**\n   * Constructs an instrumented integer set on top of an existing\n   * {@link IntSet}.\n   *\n   * @param base the integer set to instrument (non-null)\n   *\/\n  public InstrumentedIntSet4(IntSet base) {\n    Objects.requireNonNull(base, \"base cannot be null\");\n    delegate = base;\n  }\n\n  \/**\n   * Returns the count of how many times an element has been added to the set.\n   *\n   * @return the count of added elements\n   *\/\n  public int getAddCount() {\n    return addCount;\n  }\n\n  @Override\n  public void add(int value) {\n    delegate.add(value);\n    ++addCount;\n  }\n\n  @Override\n  public void addAll(int... values) {\n    delegate.addAll(values);\n    addCount += values.length;\n  }\n\n  @Override\n  public void remove(int value) {\n    delegate.remove(value);\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic boolean member(int value) {\n    return delegate.member(value);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1030\\src\\cs3500\\lec10\\InstrumentedIntSet4.java","mask_span":[2211,2284],"topics":["mvc","gui","factory"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0014] (Object) and Object.hashCode(). (Never override one without the other—we’ll talk about this soon.) The default implementations inherited from Object use reference equality and a hash function compatible with reference equality. This most often makes sense for distinguishing stateful objects, since two objects that currently have the same state can change in the future. However, for immutable value objects like DurationImpl, if we construct two objects representing the same length of time, those values are essentially equal. Thus, it makes sense to override equals to define extensional equality, and hashCode to compute hash codes using the same values that are compared by equals. Here’s a first attempt:\n\n@Override\npublic boolean equals(Object o) {\n  \/\/ Fast path for reference equality:\n  if\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n\/**\n * An implementation of {@link IntSet} using the Collections Framework's\n * {@link HashSet}. Yes, this is silly, but it's the quickest route to the\n * point of the demonstration.\n *\n * @see InstrumentedIntSet1\n *\/\npublic class IntSet1 implements IntSet {\n  private final Set<Integer> set = new HashSet<>();\n\n  @Override\n  public void add(int value) {\n    set.add(value);\n  }\n\n  \/\/ addAll() is implemented in terms of add() in order avoid code duplication.\n  \/\/ In this example the implementation of add() is minuscule, but in a real\n  \/\/ implementation it might be complicated, and we wouldn't want to repeat\n  \/\/ it in addAll() as well.\n  @Override\n  public void addAll(int... values) {\n    for (int i : values) {\n      add(i);\n    }\n  }\n\n  @Override\n  public void remove(int value) {\n    set.remove(value);\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic boolean member(int value) {\n    return set.contains(value);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1030\\src\\cs3500\\lec10\\IntSet1.java","mask_span":[904,974],"topics":["gui","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0014] (Object) and Object.hashCode(). (Never override one without the other—we’ll talk about this soon.) The default implementations inherited from Object use reference equality and a hash function compatible with reference equality. This most often makes sense for distinguishing stateful objects, since two objects that currently have the same state can change in the future. However, for immutable value objects like DurationImpl, if we construct two objects representing the same length of time, those values are essentially equal. Thus, it makes sense to override equals to define extensional equality, and hashCode to compute hash codes using the same values that are compared by equals. Here’s a first attempt:\n\n@Override\npublic boolean equals(Object o) {\n  \/\/ Fast path for reference equality:\n  if\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n\/**\n * An implementation of {@link IntSet} using the Collections Framework's\n * {@link HashSet}. Yes, this is silly, but it's the quickest route to the\n * point of the demonstration.\n *\n * @see InstrumentedIntSet2\n *\/\npublic class IntSet2 implements IntSet {\n  private final Set<Integer> set = new HashSet<>();\n\n  @Override\n  public void add(int value) {\n    set.add(value);\n  }\n\n  \/\/ In version 2, addAll() is not implemented in terms of add(). Subclasses\n  \/\/ were overriding add() and causing trouble, so we decided to give in and\n  \/\/ duplicate the code between add() and addAll(). This is okay, because\n  \/\/ as the implementor of this class we are free to change the implementation\n  \/\/ so long as we don't change the interface... right?\n  @Override\n  public void addAll(int... values) {\n    for (int i : values) {\n      set.add(i);\n    }\n  }\n\n  @Override\n  public void remove(int value) {\n    set.remove(value);\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic boolean member(int value) {\n    return set.contains(value);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1030\\src\\cs3500\\lec10\\IntSet2.java","mask_span":[1009,1079],"topics":["gui","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0014] (Object) and Object.hashCode(). (Never override one without the other—we’ll talk about this soon.) The default implementations inherited from Object use reference equality and a hash function compatible with reference equality. This most often makes sense for distinguishing stateful objects, since two objects that currently have the same state can change in the future. However, for immutable value objects like DurationImpl, if we construct two objects representing the same length of time, those values are essentially equal. Thus, it makes sense to override equals to define extensional equality, and hashCode to compute hash codes using the same values that are compared by equals. Here’s a first attempt:\n\n@Override\npublic boolean equals(Object o) {\n  \/\/ Fast path for reference equality:\n  if\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n\/**\n * One way to fix the problems with {@link InstrumentedIntSet1} and {@link\n * InstrumentedIntSet2} is to make sure that the superclass ({@code IntSet3})\n * doesn't call any methods that the subclass ({@link InstrumentedIntSet3})\n * can override. Thus, instead of having {@link #addAll(int...)} call {@link\n * #add}, we factor out the common functionality into a private method {@link\n * #_add(int)} and have both public methods call that.\n *\n * <p>Since our class allows extension (i.e., isn't final), we need to\n * <i>document<\/i> what it means to subclass it. In this case we might write\n * something like this:\n *\n * <p><b>Inheritance note:<\/b> It is safe for subclasses to override any and\n * all methods of this class, since none of the methods calls a public method\n * that might be overridden.\n *\n * @see InstrumentedIntSet3\n *\/\npublic class IntSet3 implements IntSet {\n  private final Set<Integer> set = new HashSet<>();\n\n  \/\/ Here's the private method to factor out add() and addAll()'s common code:\n  private void _add(int value) {\n    set.add(value);\n  }\n\n  \/\/ Now add() is implemented using _add():\n  @Override\n  public void add(int value) {\n    _add(value);\n  }\n\n  \/\/ And so is addAll():\n  @Override\n  public void addAll(int... values) {\n    for (int i : values) {\n      _add(i);\n    }\n  }\n\n  @Override\n  public void remove(int value) {\n    set.remove(value);\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic boolean member(int value) {\n    return set.contains(value);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1030\\src\\cs3500\\lec10\\IntSet3.java","mask_span":[1468,1538],"topics":["gui","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0014] (Object) and Object.hashCode(). (Never override one without the other—we’ll talk about this soon.) The default implementations inherited from Object use reference equality and a hash function compatible with reference equality. This most often makes sense for distinguishing stateful objects, since two objects that currently have the same state can change in the future. However, for immutable value objects like DurationImpl, if we construct two objects representing the same length of time, those values are essentially equal. Thus, it makes sense to override equals to define extensional equality, and hashCode to compute hash codes using the same values that are compared by equals. Here’s a first attempt:\n\n@Override\npublic boolean equals(Object o) {\n  \/\/ Fast path for reference equality:\n  if\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n\/**\n * Another way to fix the problems with {@link InstrumentedIntSet1} and {@link\n * InstrumentedIntSet2} is to make sure that any methods called by other\n * methods of the class are final, which prevents subclasses from messing\n * with them. The easy way to do this is to make this whole class final,\n * which makes inheritance not a concern. Unless we design our class for\n * extension and document how to extend it, making the class final is the\n * right thing to do. It may inconvenience someone who wants to extend our\n * class, but they can always use delegation.\n *\n * @see InstrumentedIntSet4\n *\/\npublic final class IntSet4 implements IntSet {\n  private final Set<Integer> set = new HashSet<>();\n\n  @Override\n  public void add(int value) {\n    set.add(value);\n  }\n\n  @Override\n  public void addAll(int... values) {\n    for (int i : values) {\n      add(i);\n    }\n  }\n\n  @Override\n  public void remove(int value) {\n    set.remove(value);\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic boolean member(int value) {\n    return set.contains(value);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1030\\src\\cs3500\\lec10\\IntSet4.java","mask_span":[1036,1106],"topics":["gui","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0004] ts to instrument. Then InstrumentedIntSet4 forwards method calls to the delegate rather than handling them itself, adding the instrumentation functionality where needed:\n\nThe delegate pattern\n\nA disadvantage of this approach is inconvenience, since it now requires writing a stub for every method, even those that we formerly inherited unchanged. But an advantage of object composition is increased flexibility, because InstrumentedIntSet4 can take an object of any IntSet implementation in its constructor and delegate to that rather than fixing one IntSet implementation to inherit from.2 This flexibility is demonstrated by the test classes Test1Using1 through Test1Using4 at the bottom of InstrumentedIntSetTest.\n\n1InstrumentedIntSetTest uses the factory method–based abstract testing approach th\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0001] 1, in this case—no peeking), and that we don’t want to look at or mess with. The InstrumentedIntSet1 class is our first attempt to do this by inheriting from IntSet1 and overriding the relevant methods to have them count as well. This looks good, but when we test it (see InstrumentedIntSetTest), we find that one of the tests fails.1 Why do the tests fail? You may need to look at IntSet1 to figure it out.\n\nOnce we’ve figured out why they fail, we give it another go with the InstrumentedIntSet2 class, which compensates for what was going on in our first attempt. If InstrumentedIntSet2 extended IntSet1, the same IntSet implementation as before, it would pass the tests. Alas! Unbeknownst to us, the maintainer of IntSet1 decided to tweak the implementation in a (supposedly) innocuous way, and t\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0005] at we saw early on in the course. The tests for different InstrumentedIntSet implementations are always the same, and we extend the abstract base class eight times to test our different attempts at implementing InstrumentedIntSet.\n\n2It could even change the delegate dynamically if that’s what we wanted.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\n\/**\n * Tests for instrumented integer sets. All four implementations ought to\n * pass the same tests (if they are correct, which two of them aren't).\n * We use the factory method pattern to allow the abstract base class to\n * define the tests once, and then each four subclasses overrides the factory\n * method to return an instance of the class to test.\n *\/\npublic abstract class InstrumentedIntSetTest {\n  protected abstract InstrumentedIntSet factory();\n\n  @Test\n  public final\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public final void testAddAll() {\n    InstrumentedIntSet set = factory();\n\n    set.addAll(1, 2, 3);\n    assertEquals(3, set.getAddCount());\n  }\n\n  \/**\n   * One of these tests fails. Can you figure out why?\n   *\/\n  public static final class Test1 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet1();\n    }\n  }\n\n  \/**\n   * One of these tests <i>still<\/i> fails. Can you figure out why?\n   *\/\n  public static final class Test2 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet2();\n    }\n  }\n\n  \/**\n   * These should succeed.\n   *\/\n  public static final class Test3 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet3();\n    }\n  }\n\n  \/**\n   * These should succeed.\n   *\/\n  public static final class Test4 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4();\n    }\n  }\n\n  \/**\n   * Here we see that with the delegate pattern approach, we can use any\n   * implementation of {@link IntSet}, even one that caused us trouble before\n   * ({@link IntSet1}) as the delegate. No inheritance, no problem.\n   *\n   * <p>Here the delegate is an {@link IntSet1}.\n   *\/\n  public static final class Test4Using1 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4(new IntSet1());\n    }\n  }\n\n  \/**\n   * Here the delegate is an {@link IntSet2}.\n   *\/\n  public static final class Test4Using2 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4(new IntSet2());\n    }\n  }\n\n  \/**\n   * Here the delegate is an {@link IntSet3}.\n   *\/\n  public static final class Test4Using3 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4(new IntSet3());\n    }\n  }\n\n  \/**\n   * Here the delegate is an {@link IntSet4}.\n   *\/\n  public static final class Test4Using4 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4(new IntSet4());\n    }\n  }\n  public static final class Test4Using4Using4 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4(new InstrumentedIntSet4(new IntSet4()));\n    }\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\nvoid testAdd() {\n    InstrumentedIntSet set = factory();\n\n    set.add(1);\n    set.add(2);\n    set.add(3);\n    assertEquals(3, set.getAddCount());\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1030\\test\\cs3500\\lec10\\InstrumentedIntSetTest.java","mask_span":[574,723],"topics":["testing","factory"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0004] ts to instrument. Then InstrumentedIntSet4 forwards method calls to the delegate rather than handling them itself, adding the instrumentation functionality where needed:\n\nThe delegate pattern\n\nA disadvantage of this approach is inconvenience, since it now requires writing a stub for every method, even those that we formerly inherited unchanged. But an advantage of object composition is increased flexibility, because InstrumentedIntSet4 can take an object of any IntSet implementation in its constructor and delegate to that rather than fixing one IntSet implementation to inherit from.2 This flexibility is demonstrated by the test classes Test1Using1 through Test1Using4 at the bottom of InstrumentedIntSetTest.\n\n1InstrumentedIntSetTest uses the factory method–based abstract testing approach th\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0001] 1, in this case—no peeking), and that we don’t want to look at or mess with. The InstrumentedIntSet1 class is our first attempt to do this by inheriting from IntSet1 and overriding the relevant methods to have them count as well. This looks good, but when we test it (see InstrumentedIntSetTest), we find that one of the tests fails.1 Why do the tests fail? You may need to look at IntSet1 to figure it out.\n\nOnce we’ve figured out why they fail, we give it another go with the InstrumentedIntSet2 class, which compensates for what was going on in our first attempt. If InstrumentedIntSet2 extended IntSet1, the same IntSet implementation as before, it would pass the tests. Alas! Unbeknownst to us, the maintainer of IntSet1 decided to tweak the implementation in a (supposedly) innocuous way, and t\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0005] at we saw early on in the course. The tests for different InstrumentedIntSet implementations are always the same, and we extend the abstract base class eight times to test our different attempts at implementing InstrumentedIntSet.\n\n2It could even change the delegate dynamically if that’s what we wanted.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\n\/**\n * Tests for instrumented integer sets. All four implementations ought to\n * pass the same tests (if they are correct, which two of them aren't).\n * We use the factory method pattern to allow the abstract base class to\n * define the tests once, and then each four subclasses overrides the factory\n * method to return an instance of the class to test.\n *\/\npublic abstract class InstrumentedIntSetTest {\n  protected abstract InstrumentedIntSet factory();\n\n  @Test\n  public final void testAdd() {\n    InstrumentedIntSet set = factory();\n\n    set.add(1);\n    set.add(2);\n    set.add(3);\n    assertEquals(3, set.getAddCount());\n  }\n\n  @Test\n  public final void testAddAll() {\n    InstrumentedIntSet set = factory();\n\n    set.addAll(1, 2, 3);\n    assertEquals(3, set.getAddCount());\n  }\n\n  \/**\n   * One of these tests fails. Can you figure out why?\n   *\/\n  public static final class Test1 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet1();\n    }\n  }\n\n  \/**\n   * One of these tests <i>still<\/i> fails. Can you figure out why?\n   *\/\n  public static final class Test2 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet2();\n    }\n  }\n\n  \/**\n   * These should succeed.\n   *\/\n  public static final class Test3 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet3();\n    }\n  }\n\n  \/**\n   * These should succeed.\n   *\/\n  public static final class Test4 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4();\n    }\n  }\n\n  \/**\n   * Here we see that with the delegate pattern approach, we can use any\n   * implementation of {@link IntSet}, even one that caused us trouble before\n   * ({@link IntSet1}) as the delegate. No inheritance, no problem.\n   *\n   * <p>Here the delegate is an {@link IntSet1}.\n   *\/\n  public static final class Test4Using1 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4(new IntSet1());\n    }\n  }\n\n  \/**\n   * Here the delegate is an {@link IntSet2}.\n   *\/\n  public static final class Test4Using2 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4(new IntSet2());\n    }\n  }\n\n  \/**\n   * Here the delegate is an {@link IntSet3}.\n   *\/\n  public static final class Test4Using3 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4(new IntSet3());\n    }\n  }\n\n  \/**\n   * Here the delegate is an {@link IntSet4}.\n   *\/\n  public static final class Test4Using4 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4(new IntSet4());\n    }\n  }\n  public static final class Test4Using4Using4 extends InstrumentedIntSetTest {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n}\n\n<\/CodeSuffix>","target":"<Target>\nprotected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4(new InstrumentedIntSet4(new IntSet4()));\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1030\\test\\cs3500\\lec10\\InstrumentedIntSetTest.java","mask_span":[3025,3149],"topics":["testing","factory"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0000] Lecture 11: The Perils of Inheritance\nJava source (.zip)\nOverview of the lecture\nThis lecture compares inheritance and composition as two ways to reuse existing code. Many solutions to design problems can be loosely framed as replacing one of these ways with the other.\n\nThe IntSet interface is a simplified API for working with sets of integers—it has nearly the bare minimum of methods. Now, suppose we wanted to instrument an IntSet to find out how many times elements are added (which isn’t the same as the size). The InstrumentedIntSet interface extends IntSet with an additional operation, which lets the client find out the count of add operations.\n\nNow, suppose we wanted to implement InstrumentedIntSet based on an existing IntSet implementation that someone else wrote and maintains (IntSet\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0001] 1, in this case—no peeking), and that we don’t want to look at or mess with. The InstrumentedIntSet1 class is our first attempt to do this by inheriting from IntSet1 and overriding the relevant methods to have them count as well. This looks good, but when we test it (see InstrumentedIntSetTest), we find that one of the tests fails.1 Why do the tests fail? You may need to look at IntSet1 to figure it out.\n\nOnce we’ve figured out why they fail, we give it another go with the InstrumentedIntSet2 class, which compensates for what was going on in our first attempt. If InstrumentedIntSet2 extended IntSet1, the same IntSet implementation as before, it would pass the tests. Alas! Unbeknownst to us, the maintainer of IntSet1 decided to tweak the implementation in a (supposedly) innocuous way, and t\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0003] ’t screw things up.\nThe IntSet4 class takes an even more conservative approach: IntSet4 is final, which prohibits extension altogether. This is almost always the right thing to do when you write a class: unless you are designing and documenting for extension, make the class final. That way, no clients of your class can depend on implementation details leaking out via inheritance, as happened with IntSet1 and IntSet2.\n\nMaking IntSet4 final poses a problem for implementing InstrumentedIntSet4, because it can no longer use subclassing to just override some methods and silently inherit the others. So instead, InstrumentedIntSet4 takes a different tack: the delegate pattern. Instead of inheritance, it uses object composition, which means that it has a field holding the IntSet object that it wan\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0002] hat change having cancelled out our compensation, InstrumentedIntSet2 also fails one of the tests. Again, can you see why? Here’s IntSet2 in case you need it.\n\nThe next two versions show two different solutions to our problem.\n\nIn IntSet3, the author made a defensive change so that subclasses cannot interfere with how its own methods are implemented. This looks substantially the same as IntSet2 from the outside, but there are actually two substantive changes:\n\nInstead of duplicating the (admittedly tiny) code between add() and addAll(), IntSet3 factors that out into a private method that subclasses can’t touch.\nIntSet3 is properly documented for extension, which means that InstrumentedIntSet3 can now safely extend it, knowing (because it’s documented!) that overriding IntSet3’s methods won\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\n\/**\n * An integer set that is instrumented to count the number of times an\n * element is added. It works by extending {@link IntSet1}, which\n * provides the basic set operations. It then overrides both {@link #add(int)}\n * and {@link IntSet#addAll(int...)} in order update the count in both cases.\n *\/\npublic class InstrumentedIntSet1\n  extends IntSet1\n  implements InstrumentedIntSet\n{\n  private int addCount = 0;\n\n  @Override\n  public int getAddCount() {\n    return addCount;\n  }\n\n  @Override\n  public void add(int value) {\n    super.add(value);\n\n    \/\/ Update the count for the one element we added:\n    ++addCount;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void addAll(int... values) {\n    super.addAll(values);\n\n    \/\/ Update the count for all the elements we added:\n    \/\/addCount += values.length;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1335\\src\\cs3500\\lec10\\InstrumentedIntSet1.java","mask_span":[661,815],"topics":["gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0000] Lecture 11: The Perils of Inheritance\nJava source (.zip)\nOverview of the lecture\nThis lecture compares inheritance and composition as two ways to reuse existing code. Many solutions to design problems can be loosely framed as replacing one of these ways with the other.\n\nThe IntSet interface is a simplified API for working with sets of integers—it has nearly the bare minimum of methods. Now, suppose we wanted to instrument an IntSet to find out how many times elements are added (which isn’t the same as the size). The InstrumentedIntSet interface extends IntSet with an additional operation, which lets the client find out the count of add operations.\n\nNow, suppose we wanted to implement InstrumentedIntSet based on an existing IntSet implementation that someone else wrote and maintains (IntSet\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0001] 1, in this case—no peeking), and that we don’t want to look at or mess with. The InstrumentedIntSet1 class is our first attempt to do this by inheriting from IntSet1 and overriding the relevant methods to have them count as well. This looks good, but when we test it (see InstrumentedIntSetTest), we find that one of the tests fails.1 Why do the tests fail? You may need to look at IntSet1 to figure it out.\n\nOnce we’ve figured out why they fail, we give it another go with the InstrumentedIntSet2 class, which compensates for what was going on in our first attempt. If InstrumentedIntSet2 extended IntSet1, the same IntSet implementation as before, it would pass the tests. Alas! Unbeknownst to us, the maintainer of IntSet1 decided to tweak the implementation in a (supposedly) innocuous way, and t\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0002] hat change having cancelled out our compensation, InstrumentedIntSet2 also fails one of the tests. Again, can you see why? Here’s IntSet2 in case you need it.\n\nThe next two versions show two different solutions to our problem.\n\nIn IntSet3, the author made a defensive change so that subclasses cannot interfere with how its own methods are implemented. This looks substantially the same as IntSet2 from the outside, but there are actually two substantive changes:\n\nInstead of duplicating the (admittedly tiny) code between add() and addAll(), IntSet3 factors that out into a private method that subclasses can’t touch.\nIntSet3 is properly documented for extension, which means that InstrumentedIntSet3 can now safely extend it, knowing (because it’s documented!) that overriding IntSet3’s methods won\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0003] ’t screw things up.\nThe IntSet4 class takes an even more conservative approach: IntSet4 is final, which prohibits extension altogether. This is almost always the right thing to do when you write a class: unless you are designing and documenting for extension, make the class final. That way, no clients of your class can depend on implementation details leaking out via inheritance, as happened with IntSet1 and IntSet2.\n\nMaking IntSet4 final poses a problem for implementing InstrumentedIntSet4, because it can no longer use subclassing to just override some methods and silently inherit the others. So instead, InstrumentedIntSet4 takes a different tack: the delegate pattern. Instead of inheritance, it uses object composition, which means that it has a field holding the IntSet object that it wan\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\n\/**\n * An integer set that is instrumented to count the number of times an\n * element is added. It works by extending {@link IntSet2}, which\n * provides the basic set operations. It then overrides both {@link #add(int)}\n * and {@link IntSet#addAll(int...)} in order update the count in both cases.\n *\/\npublic class InstrumentedIntSet2\n  extends IntSet2\n  implements InstrumentedIntSet\n{\n  private int addCount = 0;\n\n  @Override\n  public int getAddCount() {\n    return addCount;\n  }\n\n  @Override\n  public void add(int value) {\n    super.add(value);\n\n    \/\/ Update the count for the one element we added:\n    ++addCount;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void addAll(int... values) {\n    super.addAll(values);\n    \/\/ Don't need to update the count because apparently super.addAll() calls\n    \/\/ super.add();\n    addCount += values.length;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1335\\src\\cs3500\\lec10\\InstrumentedIntSet2.java","mask_span":[661,855],"topics":["gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0000] Lecture 11: The Perils of Inheritance\nJava source (.zip)\nOverview of the lecture\nThis lecture compares inheritance and composition as two ways to reuse existing code. Many solutions to design problems can be loosely framed as replacing one of these ways with the other.\n\nThe IntSet interface is a simplified API for working with sets of integers—it has nearly the bare minimum of methods. Now, suppose we wanted to instrument an IntSet to find out how many times elements are added (which isn’t the same as the size). The InstrumentedIntSet interface extends IntSet with an additional operation, which lets the client find out the count of add operations.\n\nNow, suppose we wanted to implement InstrumentedIntSet based on an existing IntSet implementation that someone else wrote and maintains (IntSet\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0001] 1, in this case—no peeking), and that we don’t want to look at or mess with. The InstrumentedIntSet1 class is our first attempt to do this by inheriting from IntSet1 and overriding the relevant methods to have them count as well. This looks good, but when we test it (see InstrumentedIntSetTest), we find that one of the tests fails.1 Why do the tests fail? You may need to look at IntSet1 to figure it out.\n\nOnce we’ve figured out why they fail, we give it another go with the InstrumentedIntSet2 class, which compensates for what was going on in our first attempt. If InstrumentedIntSet2 extended IntSet1, the same IntSet implementation as before, it would pass the tests. Alas! Unbeknownst to us, the maintainer of IntSet1 decided to tweak the implementation in a (supposedly) innocuous way, and t\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0002] hat change having cancelled out our compensation, InstrumentedIntSet2 also fails one of the tests. Again, can you see why? Here’s IntSet2 in case you need it.\n\nThe next two versions show two different solutions to our problem.\n\nIn IntSet3, the author made a defensive change so that subclasses cannot interfere with how its own methods are implemented. This looks substantially the same as IntSet2 from the outside, but there are actually two substantive changes:\n\nInstead of duplicating the (admittedly tiny) code between add() and addAll(), IntSet3 factors that out into a private method that subclasses can’t touch.\nIntSet3 is properly documented for extension, which means that InstrumentedIntSet3 can now safely extend it, knowing (because it’s documented!) that overriding IntSet3’s methods won\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0003] ’t screw things up.\nThe IntSet4 class takes an even more conservative approach: IntSet4 is final, which prohibits extension altogether. This is almost always the right thing to do when you write a class: unless you are designing and documenting for extension, make the class final. That way, no clients of your class can depend on implementation details leaking out via inheritance, as happened with IntSet1 and IntSet2.\n\nMaking IntSet4 final poses a problem for implementing InstrumentedIntSet4, because it can no longer use subclassing to just override some methods and silently inherit the others. So instead, InstrumentedIntSet4 takes a different tack: the delegate pattern. Instead of inheritance, it uses object composition, which means that it has a field holding the IntSet object that it wan\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\n\/**\n * An integer set that is instrumented to count the number of times an\n * element is added. This time it works because the superclass never calls\n * methods that the subclass might override, <b>and<\/b> as the implementor of\n * the subclass, we can be confident of this because the superclass {@link\n * IntSet3} documents this fact.\n *\/\npublic class InstrumentedIntSet3\n  extends IntSet3\n  implements InstrumentedIntSet\n{\n  private int addCount = 0;\n\n  @Override\n  public int getAddCount() {\n    return addCount;\n  }\n\n  @Override\n  public void add(int value) {\n    super.add(value);\n    ++addCount;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void addAll(int... values) {\n    super.addAll(values);\n    addCount += values.length;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1335\\src\\cs3500\\lec10\\InstrumentedIntSet3.java","mask_span":[644,740],"topics":["gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0003] ’t screw things up.\nThe IntSet4 class takes an even more conservative approach: IntSet4 is final, which prohibits extension altogether. This is almost always the right thing to do when you write a class: unless you are designing and documenting for extension, make the class final. That way, no clients of your class can depend on implementation details leaking out via inheritance, as happened with IntSet1 and IntSet2.\n\nMaking IntSet4 final poses a problem for implementing InstrumentedIntSet4, because it can no longer use subclassing to just override some methods and silently inherit the others. So instead, InstrumentedIntSet4 takes a different tack: the delegate pattern. Instead of inheritance, it uses object composition, which means that it has a field holding the IntSet object that it wan\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0005] at we saw early on in the course. The tests for different InstrumentedIntSet implementations are always the same, and we extend the abstract base class eight times to test our different attempts at implementing InstrumentedIntSet.\n\n2It could even change the delegate dynamically if that’s what we wanted.\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0004] ts to instrument. Then InstrumentedIntSet4 forwards method calls to the delegate rather than handling them itself, adding the instrumentation functionality where needed:\n\nThe delegate pattern\n\nA disadvantage of this approach is inconvenience, since it now requires writing a stub for every method, even those that we formerly inherited unchanged. But an advantage of object composition is increased flexibility, because InstrumentedIntSet4 can take an object of any IntSet implementation in its constructor and delegate to that rather than fixing one IntSet implementation to inherit from.2 This flexibility is demonstrated by the test classes Test1Using1 through Test1Using4 at the bottom of InstrumentedIntSetTest.\n\n1InstrumentedIntSetTest uses the factory method–based abstract testing approach th\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0000] Lecture 11: The Perils of Inheritance\nJava source (.zip)\nOverview of the lecture\nThis lecture compares inheritance and composition as two ways to reuse existing code. Many solutions to design problems can be loosely framed as replacing one of these ways with the other.\n\nThe IntSet interface is a simplified API for working with sets of integers—it has nearly the bare minimum of methods. Now, suppose we wanted to instrument an IntSet to find out how many times elements are added (which isn’t the same as the size). The InstrumentedIntSet interface extends IntSet with an additional operation, which lets the client find out the count of add operations.\n\nNow, suppose we wanted to implement InstrumentedIntSet based on an existing IntSet implementation that someone else wrote and maintains (IntSet\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\nimport java.util.Objects;\n\n\/**\n * In this case, the author of {@link IntSet4} decided to avoid the\n * inheritance problem by making {@code IntSet4} final. That means we cannot\n * extend it, so instead we use the delegate pattern. The idea is that\n * instead of extending {@code IntSet4}, we keep one in a field. Then we can\n * implement our {@link InstrumentedIntSet} by delegating method calls to the\n * delegate (that is, letting the delegate do the work), and we can extend\n * the functionality by doing other things in our wrapper methods besides\n * delegating (such as updating the count).\n *\n * <p>One disadvantage of this approach is that we now have to write a shim\n * for every method, even if all it does is delegate, whereas inheritance\n * would have included all the non-overridden methods for us. An advantage is\n * the increase in flexibility, since we can now do things such as instrument\n * an existing {@link IntSet} without having to know its implementation.\n * Since the delegate is a field, we could also do things like change it at\n * will. (This class doesn't support that at this point, but it wouldn't be\n * difficult to add.)\n *\/\npublic class InstrumentedIntSet4 implements InstrumentedIntSet {\n  private int addCount = 0;\n  private final IntSet delegate;\n\n  \/**\n   * Constructs a new instrumented integer set.\n   *\/\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/**\n   * Constructs an instrumented integer set on top of an existing\n   * {@link IntSet}.\n   *\n   * @param base the integer set to instrument (non-null)\n   *\/\n  public InstrumentedIntSet4(IntSet base) {\n    Objects.requireNonNull(base, \"base cannot be null\");\n    delegate = base;\n  }\n\n  \/**\n   * Returns the count of how many times an element has been added to the set.\n   *\n   * @return the count of added elements\n   *\/\n  public int getAddCount() {\n    return addCount;\n  }\n\n  @Override\n  public void add(int value) {\n    delegate.add(value);\n    ++addCount;\n  }\n\n  @Override\n  public void addAll(int... values) {\n    delegate.addAll(values);\n    addCount += values.length;\n  }\n\n  @Override\n  public void remove(int value) {\n    delegate.remove(value);\n  }\n\n  @Override\n  public boolean member(int value) {\n    return delegate.member(value);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic InstrumentedIntSet4() {\n    delegate = new IntSet4();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1335\\src\\cs3500\\lec10\\InstrumentedIntSet4.java","mask_span":[1367,1431],"topics":["mvc","gui","factory"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0003] ’t screw things up.\nThe IntSet4 class takes an even more conservative approach: IntSet4 is final, which prohibits extension altogether. This is almost always the right thing to do when you write a class: unless you are designing and documenting for extension, make the class final. That way, no clients of your class can depend on implementation details leaking out via inheritance, as happened with IntSet1 and IntSet2.\n\nMaking IntSet4 final poses a problem for implementing InstrumentedIntSet4, because it can no longer use subclassing to just override some methods and silently inherit the others. So instead, InstrumentedIntSet4 takes a different tack: the delegate pattern. Instead of inheritance, it uses object composition, which means that it has a field holding the IntSet object that it wan\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0005] at we saw early on in the course. The tests for different InstrumentedIntSet implementations are always the same, and we extend the abstract base class eight times to test our different attempts at implementing InstrumentedIntSet.\n\n2It could even change the delegate dynamically if that’s what we wanted.\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0004] ts to instrument. Then InstrumentedIntSet4 forwards method calls to the delegate rather than handling them itself, adding the instrumentation functionality where needed:\n\nThe delegate pattern\n\nA disadvantage of this approach is inconvenience, since it now requires writing a stub for every method, even those that we formerly inherited unchanged. But an advantage of object composition is increased flexibility, because InstrumentedIntSet4 can take an object of any IntSet implementation in its constructor and delegate to that rather than fixing one IntSet implementation to inherit from.2 This flexibility is demonstrated by the test classes Test1Using1 through Test1Using4 at the bottom of InstrumentedIntSetTest.\n\n1InstrumentedIntSetTest uses the factory method–based abstract testing approach th\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0000] Lecture 11: The Perils of Inheritance\nJava source (.zip)\nOverview of the lecture\nThis lecture compares inheritance and composition as two ways to reuse existing code. Many solutions to design problems can be loosely framed as replacing one of these ways with the other.\n\nThe IntSet interface is a simplified API for working with sets of integers—it has nearly the bare minimum of methods. Now, suppose we wanted to instrument an IntSet to find out how many times elements are added (which isn’t the same as the size). The InstrumentedIntSet interface extends IntSet with an additional operation, which lets the client find out the count of add operations.\n\nNow, suppose we wanted to implement InstrumentedIntSet based on an existing IntSet implementation that someone else wrote and maintains (IntSet\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\nimport java.util.Objects;\n\n\/**\n * In this case, the author of {@link IntSet4} decided to avoid the\n * inheritance problem by making {@code IntSet4} final. That means we cannot\n * extend it, so instead we use the delegate pattern. The idea is that\n * instead of extending {@code IntSet4}, we keep one in a field. Then we can\n * implement our {@link InstrumentedIntSet} by delegating method calls to the\n * delegate (that is, letting the delegate do the work), and we can extend\n * the functionality by doing other things in our wrapper methods besides\n * delegating (such as updating the count).\n *\n * <p>One disadvantage of this approach is that we now have to write a shim\n * for every method, even if all it does is delegate, whereas inheritance\n * would have included all the non-overridden methods for us. An advantage is\n * the increase in flexibility, since we can now do things such as instrument\n * an existing {@link IntSet} without having to know its implementation.\n * Since the delegate is a field, we could also do things like change it at\n * will. (This class doesn't support that at this point, but it wouldn't be\n * difficult to add.)\n *\/\npublic class InstrumentedIntSet4 implements InstrumentedIntSet {\n  private int addCount = 0;\n  private final IntSet delegate;\n\n  \/**\n   * Constructs a new instrumented integer set.\n   *\/\n  public InstrumentedIntSet4() {\n    delegate = new IntSet4();\n  }\n\n  \/**\n   * Constructs an instrumented integer set on top of an existing\n   * {@link IntSet}.\n   *\n   * @param base the integer set to instrument (non-null)\n   *\/\n  public InstrumentedIntSet4(IntSet base) {\n    Objects.requireNonNull(base, \"base cannot be null\");\n    delegate = base;\n  }\n\n  \/**\n   * Returns the count of how many times an element has been added to the set.\n   *\n   * @return the count of added elements\n   *\/\n  public int getAddCount() {\n    return addCount;\n  }\n\n  @Override\n  public void add(int value) {\n    delegate.add(value);\n    ++addCount;\n  }\n\n  @Override\n  public void addAll(int... values) {\n    delegate.addAll(values);\n    addCount += values.length;\n  }\n\n  @Override\n  public void remove(int value) {\n    delegate.remove(value);\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic boolean member(int value) {\n    return delegate.member(value);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1335\\src\\cs3500\\lec10\\InstrumentedIntSet4.java","mask_span":[2211,2284],"topics":["mvc","gui","factory"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0014] (Object) and Object.hashCode(). (Never override one without the other—we’ll talk about this soon.) The default implementations inherited from Object use reference equality and a hash function compatible with reference equality. This most often makes sense for distinguishing stateful objects, since two objects that currently have the same state can change in the future. However, for immutable value objects like DurationImpl, if we construct two objects representing the same length of time, those values are essentially equal. Thus, it makes sense to override equals to define extensional equality, and hashCode to compute hash codes using the same values that are compared by equals. Here’s a first attempt:\n\n@Override\npublic boolean equals(Object o) {\n  \/\/ Fast path for reference equality:\n  if\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n\/**\n * An implementation of {@link IntSet} using the Collections Framework's\n * {@link HashSet}. Yes, this is silly, but it's the quickest route to the\n * point of the demonstration.\n *\n * @see InstrumentedIntSet1\n *\/\npublic class IntSet1 implements IntSet {\n  private final Set<Integer> set = new HashSet<>();\n\n  @Override\n  public void add(int value) {\n    set.add(value);\n  }\n\n  \/\/ addAll() is implemented in terms of add() in order avoid code duplication.\n  \/\/ In this example the implementation of add() is minuscule, but in a real\n  \/\/ implementation it might be complicated, and we wouldn't want to repeat\n  \/\/ it in addAll() as well.\n  @Override\n  public void addAll(int... values) {\n    for (int i : values) {\n      add(i);\n    }\n  }\n\n  @Override\n  public void remove(int value) {\n    set.remove(value);\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic boolean member(int value) {\n    return set.contains(value);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1335\\src\\cs3500\\lec10\\IntSet1.java","mask_span":[904,974],"topics":["gui","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0014] (Object) and Object.hashCode(). (Never override one without the other—we’ll talk about this soon.) The default implementations inherited from Object use reference equality and a hash function compatible with reference equality. This most often makes sense for distinguishing stateful objects, since two objects that currently have the same state can change in the future. However, for immutable value objects like DurationImpl, if we construct two objects representing the same length of time, those values are essentially equal. Thus, it makes sense to override equals to define extensional equality, and hashCode to compute hash codes using the same values that are compared by equals. Here’s a first attempt:\n\n@Override\npublic boolean equals(Object o) {\n  \/\/ Fast path for reference equality:\n  if\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n\/**\n * An implementation of {@link IntSet} using the Collections Framework's\n * {@link HashSet}. Yes, this is silly, but it's the quickest route to the\n * point of the demonstration.\n *\n * @see InstrumentedIntSet2\n *\/\npublic class IntSet2 implements IntSet {\n  private final Set<Integer> set = new HashSet<>();\n\n  @Override\n  public void add(int value) {\n    set.add(value);\n  }\n\n  \/\/ In version 2, addAll() is not implemented in terms of add(). Subclasses\n  \/\/ were overriding add() and causing trouble, so we decided to give in and\n  \/\/ duplicate the code between add() and addAll(). This is okay, because\n  \/\/ as the implementor of this class we are free to change the implementation\n  \/\/ so long as we don't change the interface... right?\n  @Override\n  public void addAll(int... values) {\n    for (int i : values) {\n      set.add(i);\n    }\n  }\n\n  @Override\n  public void remove(int value) {\n    set.remove(value);\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic boolean member(int value) {\n    return set.contains(value);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1335\\src\\cs3500\\lec10\\IntSet2.java","mask_span":[1009,1079],"topics":["gui","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0014] (Object) and Object.hashCode(). (Never override one without the other—we’ll talk about this soon.) The default implementations inherited from Object use reference equality and a hash function compatible with reference equality. This most often makes sense for distinguishing stateful objects, since two objects that currently have the same state can change in the future. However, for immutable value objects like DurationImpl, if we construct two objects representing the same length of time, those values are essentially equal. Thus, it makes sense to override equals to define extensional equality, and hashCode to compute hash codes using the same values that are compared by equals. Here’s a first attempt:\n\n@Override\npublic boolean equals(Object o) {\n  \/\/ Fast path for reference equality:\n  if\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n\/**\n * One way to fix the problems with {@link InstrumentedIntSet1} and {@link\n * InstrumentedIntSet2} is to make sure that the superclass ({@code IntSet3})\n * doesn't call any methods that the subclass ({@link InstrumentedIntSet3})\n * can override. Thus, instead of having {@link #addAll(int...)} call {@link\n * #add}, we factor out the common functionality into a private method {@link\n * #_add(int)} and have both public methods call that.\n *\n * <p>Since our class allows extension (i.e., isn't final), we need to\n * <i>document<\/i> what it means to subclass it. In this case we might write\n * something like this:\n *\n * <p><b>Inheritance note:<\/b> It is safe for subclasses to override any and\n * all methods of this class, since none of the methods calls a public method\n * that might be overridden.\n *\n * @see InstrumentedIntSet3\n *\/\npublic class IntSet3 implements IntSet {\n  private final Set<Integer> set = new HashSet<>();\n\n  \/\/ Here's the private method to factor out add() and addAll()'s common code:\n  private void _add(int value) {\n    set.add(value);\n  }\n\n  \/\/ Now add() is implemented using _add():\n  @Override\n  public void add(int value) {\n    _add(value);\n  }\n\n  \/\/ And so is addAll():\n  @Override\n  public void addAll(int... values) {\n    for (int i : values) {\n      _add(i);\n    }\n  }\n\n  @Override\n  public void remove(int value) {\n    set.remove(value);\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic boolean member(int value) {\n    return set.contains(value);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1335\\src\\cs3500\\lec10\\IntSet3.java","mask_span":[1468,1538],"topics":["gui","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0009] set, we use adaptee’s unionWith method, passing it a singleton IntSet2 containing the int value:\n\n@Override\npublic void add(int value) {\n  adaptee.unionWith(IntSet2Impl.singleton(value));\n}\nThe remove and member methods are equally straightforward:\n\n@Override\npublic void remove(int value) {\n  adaptee.differenceFrom(IntSet2Impl.singleton(value));\n}\n\n@Override\npublic boolean member(int value) {\n  return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n}\nFinally, to implement the iterator method, we ask the adaptee for its elements in a list, since IntSet2 supports that, and then return an iterator over the list:\n\n@Override\npublic Iterator<Integer> iterator() {\n  return adaptee.asList().iterator();\n}\n3.1 A two-way adapter\nOur IntSet2ToIntSet1Adapter adapter lets us use an IntSet2 from prob\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0002] that implements IntSet1 and has a default constructor:\n\npublic class IntSet1Impl implements IntSet1 {\n  \/** Creates a new, empty integer set. *\/\n  public IntSet1Impl() { ... }\n\n  ...\n}\nThe other library, for probability computations (prob), declares set operations that work mostly with sets rather than elements:\n\npublic interface IntSet2 {\n  \/**\n   * Inserts the elements of {@code other} into this set.\n   *\/\n  void unionWith(IntSet2 other);\n\n  \/**\n   * Removes the elements of {@code other} from this set.\n   *\/\n  void differenceFrom(IntSet2 other);\n\n  \/**\n   * Checks whether this set is a superset of the {@code other} set.\n   *\/\n  boolean isSupersetOf(IntSet2 other);\n\n  \/**\n   * The contents of the set as a list of integers. Modifying the returned\n   * list will have no effect on this set.\n\n---\n[data\\raw\\notes\\Lecture 17 The Adapter Pattern.txt::chunk0005] ntSet1Impl by writing an adapter that wraps an IntSet1Impl and uses it as the representation of an IntSet2.\n\nWe start the adapter by extending IntSet1Impl:\n\npublic class IntSet2ToIntSet1Impl\n  extends IntSet1Impl implements IntSet2 {\n}\nFor the remaining methods, each is about implementing a method that takes a set in and translates it to the individual member operations that IntSet supports.\n\n@Override\npublic final void unionWith(IntSet2 other) {\n  for (int i : other.asList()) {\n    add(i);\n  }\n}\n\n@Override\npublic final void differenceFrom(IntSet2 other) {\n  for (int i : other.asList()) {\n    remove(i);\n  }\n}\n\n@Override\npublic final boolean isSupersetOf(IntSet2 other) {\n  for (int z : other.asList()) {\n    if (! member(z)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n@Override\npublic\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0014] (Object) and Object.hashCode(). (Never override one without the other—we’ll talk about this soon.) The default implementations inherited from Object use reference equality and a hash function compatible with reference equality. This most often makes sense for distinguishing stateful objects, since two objects that currently have the same state can change in the future. However, for immutable value objects like DurationImpl, if we construct two objects representing the same length of time, those values are essentially equal. Thus, it makes sense to override equals to define extensional equality, and hashCode to compute hash codes using the same values that are compared by equals. Here’s a first attempt:\n\n@Override\npublic boolean equals(Object o) {\n  \/\/ Fast path for reference equality:\n  if\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n\/**\n * Another way to fix the problems with {@link InstrumentedIntSet1} and {@link\n * InstrumentedIntSet2} is to make sure that any methods called by other\n * methods of the class are final, which prevents subclasses from messing\n * with them. The easy way to do this is to make this whole class final,\n * which makes inheritance not a concern. Unless we design our class for\n * extension and document how to extend it, making the class final is the\n * right thing to do. It may inconvenience someone who wants to extend our\n * class, but they can always use delegation.\n *\n * @see InstrumentedIntSet4\n *\/\npublic final class IntSet4 implements IntSet {\n  private final Set<Integer> set = new HashSet<>();\n\n  @Override\n  public void add(int value) {\n    set.add(value);\n  }\n\n  @Override\n  public void addAll(int... values) {\n    for (int i : values) {\n      add(i);\n    }\n  }\n\n  @Override\n  public void remove(int value) {\n    set.remove(value);\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic boolean member(int value) {\n    return set.contains(value);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1335\\src\\cs3500\\lec10\\IntSet4.java","mask_span":[1036,1106],"topics":["gui","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0004] ts to instrument. Then InstrumentedIntSet4 forwards method calls to the delegate rather than handling them itself, adding the instrumentation functionality where needed:\n\nThe delegate pattern\n\nA disadvantage of this approach is inconvenience, since it now requires writing a stub for every method, even those that we formerly inherited unchanged. But an advantage of object composition is increased flexibility, because InstrumentedIntSet4 can take an object of any IntSet implementation in its constructor and delegate to that rather than fixing one IntSet implementation to inherit from.2 This flexibility is demonstrated by the test classes Test1Using1 through Test1Using4 at the bottom of InstrumentedIntSetTest.\n\n1InstrumentedIntSetTest uses the factory method–based abstract testing approach th\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0001] 1, in this case—no peeking), and that we don’t want to look at or mess with. The InstrumentedIntSet1 class is our first attempt to do this by inheriting from IntSet1 and overriding the relevant methods to have them count as well. This looks good, but when we test it (see InstrumentedIntSetTest), we find that one of the tests fails.1 Why do the tests fail? You may need to look at IntSet1 to figure it out.\n\nOnce we’ve figured out why they fail, we give it another go with the InstrumentedIntSet2 class, which compensates for what was going on in our first attempt. If InstrumentedIntSet2 extended IntSet1, the same IntSet implementation as before, it would pass the tests. Alas! Unbeknownst to us, the maintainer of IntSet1 decided to tweak the implementation in a (supposedly) innocuous way, and t\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0005] at we saw early on in the course. The tests for different InstrumentedIntSet implementations are always the same, and we extend the abstract base class eight times to test our different attempts at implementing InstrumentedIntSet.\n\n2It could even change the delegate dynamically if that’s what we wanted.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\n\/**\n * Tests for instrumented integer sets. All four implementations ought to\n * pass the same tests (if they are correct, which two of them aren't).\n * We use the factory method pattern to allow the abstract base class to\n * define the tests once, and then each four subclasses overrides the factory\n * method to return an instance of the class to test.\n *\/\npublic abstract class InstrumentedIntSetTest {\n  protected abstract InstrumentedIntSet factory();\n\n  @Test\n  public final\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public final void testAddAll() {\n    InstrumentedIntSet set = factory();\n\n    set.addAll(1, 2, 3);\n    assertEquals(3, set.getAddCount());\n  }\n\n  \/**\n   * One of these tests fails. Can you figure out why?\n   *\/\n  public static final class Test1 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet1();\n    }\n  }\n\n  \/**\n   * One of these tests <i>still<\/i> fails. Can you figure out why?\n   *\/\n  public static final class Test2 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet2();\n    }\n  }\n\n  \/**\n   * These should succeed.\n   *\/\n  public static final class Test3 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet3();\n    }\n  }\n\n  \/**\n   * These should succeed.\n   *\/\n  public static final class Test4 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4();\n    }\n  }\n\n  \/**\n   * Here we see that with the delegate pattern approach, we can use any\n   * implementation of {@link IntSet}, even one that caused us trouble before\n   * ({@link IntSet1}) as the delegate. No inheritance, no problem.\n   *\n   * <p>Here the delegate is an {@link IntSet1}.\n   *\/\n  public static final class Test4Using1 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4(new IntSet1());\n    }\n  }\n\n  \/**\n   * Here the delegate is an {@link IntSet2}.\n   *\/\n  public static final class Test4Using2 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4(new IntSet2());\n    }\n  }\n\n  \/**\n   * Here the delegate is an {@link IntSet3}.\n   *\/\n  public static final class Test4Using3 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4(new IntSet3());\n    }\n  }\n\n  \/**\n   * Here the delegate is an {@link IntSet4}.\n   *\/\n  public static final class Test4Using4 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4(new IntSet4());\n    }\n  }\n  public static final class Test4Using4Using4 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4(new InstrumentedIntSet4(new IntSet4()));\n    }\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\nvoid testAdd() {\n    InstrumentedIntSet set = factory();\n\n    set.add(1);\n    set.add(2);\n    set.add(3);\n    assertEquals(3, set.getAddCount());\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1335\\test\\cs3500\\lec10\\InstrumentedIntSetTest.java","mask_span":[574,723],"topics":["testing","factory"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0004] ts to instrument. Then InstrumentedIntSet4 forwards method calls to the delegate rather than handling them itself, adding the instrumentation functionality where needed:\n\nThe delegate pattern\n\nA disadvantage of this approach is inconvenience, since it now requires writing a stub for every method, even those that we formerly inherited unchanged. But an advantage of object composition is increased flexibility, because InstrumentedIntSet4 can take an object of any IntSet implementation in its constructor and delegate to that rather than fixing one IntSet implementation to inherit from.2 This flexibility is demonstrated by the test classes Test1Using1 through Test1Using4 at the bottom of InstrumentedIntSetTest.\n\n1InstrumentedIntSetTest uses the factory method–based abstract testing approach th\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0001] 1, in this case—no peeking), and that we don’t want to look at or mess with. The InstrumentedIntSet1 class is our first attempt to do this by inheriting from IntSet1 and overriding the relevant methods to have them count as well. This looks good, but when we test it (see InstrumentedIntSetTest), we find that one of the tests fails.1 Why do the tests fail? You may need to look at IntSet1 to figure it out.\n\nOnce we’ve figured out why they fail, we give it another go with the InstrumentedIntSet2 class, which compensates for what was going on in our first attempt. If InstrumentedIntSet2 extended IntSet1, the same IntSet implementation as before, it would pass the tests. Alas! Unbeknownst to us, the maintainer of IntSet1 decided to tweak the implementation in a (supposedly) innocuous way, and t\n---\n[data\\raw\\notes\\Lecture 11 The Perils of Inheritanc.txt::chunk0005] at we saw early on in the course. The tests for different InstrumentedIntSet implementations are always the same, and we extend the abstract base class eight times to test our different attempts at implementing InstrumentedIntSet.\n\n2It could even change the delegate dynamically if that’s what we wanted.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.lec10;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\n\/**\n * Tests for instrumented integer sets. All four implementations ought to\n * pass the same tests (if they are correct, which two of them aren't).\n * We use the factory method pattern to allow the abstract base class to\n * define the tests once, and then each four subclasses overrides the factory\n * method to return an instance of the class to test.\n *\/\npublic abstract class InstrumentedIntSetTest {\n  protected abstract InstrumentedIntSet factory();\n\n  @Test\n  public final void testAdd() {\n    InstrumentedIntSet set = factory();\n\n    set.add(1);\n    set.add(2);\n    set.add(3);\n    assertEquals(3, set.getAddCount());\n  }\n\n  @Test\n  public final void testAddAll() {\n    InstrumentedIntSet set = factory();\n\n    set.addAll(1, 2, 3);\n    assertEquals(3, set.getAddCount());\n  }\n\n  \/**\n   * One of these tests fails. Can you figure out why?\n   *\/\n  public static final class Test1 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet1();\n    }\n  }\n\n  \/**\n   * One of these tests <i>still<\/i> fails. Can you figure out why?\n   *\/\n  public static final class Test2 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet2();\n    }\n  }\n\n  \/**\n   * These should succeed.\n   *\/\n  public static final class Test3 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet3();\n    }\n  }\n\n  \/**\n   * These should succeed.\n   *\/\n  public static final class Test4 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4();\n    }\n  }\n\n  \/**\n   * Here we see that with the delegate pattern approach, we can use any\n   * implementation of {@link IntSet}, even one that caused us trouble before\n   * ({@link IntSet1}) as the delegate. No inheritance, no problem.\n   *\n   * <p>Here the delegate is an {@link IntSet1}.\n   *\/\n  public static final class Test4Using1 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4(new IntSet1());\n    }\n  }\n\n  \/**\n   * Here the delegate is an {@link IntSet2}.\n   *\/\n  public static final class Test4Using2 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4(new IntSet2());\n    }\n  }\n\n  \/**\n   * Here the delegate is an {@link IntSet3}.\n   *\/\n  public static final class Test4Using3 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4(new IntSet3());\n    }\n  }\n\n  \/**\n   * Here the delegate is an {@link IntSet4}.\n   *\/\n  public static final class Test4Using4 extends InstrumentedIntSetTest {\n    protected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4(new IntSet4());\n    }\n  }\n  public static final class Test4Using4Using4 extends InstrumentedIntSetTest {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n}\n\n<\/CodeSuffix>","target":"<Target>\nprotected InstrumentedIntSet factory() {\n      return new InstrumentedIntSet4(new InstrumentedIntSet4(new IntSet4()));\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\reuse-1335\\test\\cs3500\\lec10\\InstrumentedIntSetTest.java","mask_span":[3025,3149],"topics":["testing","factory"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n<\/Context>","code_prefix":"<CodePrefix>\nimport java.awt.Color;\nimport java.awt.FlowLayout;\n\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JTextField;\n\npublic class EchoFrame extends JFrame {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic EchoFrame() {\n    super();\n    this.setSize(700, 300);\n    this.setLocation(600, 500);\n\n    \/\/To put the frame in the middle of the screen, use\n    \/\/this.setLocationRelativeTo(null);\n\n    this.setDefaultCloseOperation(EXIT_ON_CLOSE);\n    this.setBackground(Color.MAGENTA);\n\n    \/\/Set the manager so everything is added in a line if possible\n    this.setLayout(new FlowLayout());\n    this.add(new JLabel(\"Echo text!\"));\n    this.add(new JTextField(20));\n    this.add(new JButton(\"Echo!\"));\n\n    this.pack();\n    this.setVisible(true);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\swing-1030\\src\\EchoFrame.java","mask_span":[209,754],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n<\/Context>","code_prefix":"<CodePrefix>\nimport javax.swing.JFrame;\n\npublic class MVCExampleTextUI {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String []args) {\n        new EchoFrame();\n        \/*\n        IModel model = new Model();\n        IView view = new TextView(System.out);\n        IController controller = new TextController(model,System.in,view);\n        controller.runProgram();\n         *\/\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\swing-1030\\src\\MVCExampleTextUI.java","mask_span":[64,349],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0012]  } catch (InputMismatchException ime) {\n      ...\n    }\n    break;\n}\nThe possibilities are now endless! We can support similar higher-level drawing text commands. Every such text commands adds a new case to our switch statement. The number of lines of code in each case statement depends on the complexity of the text command (e.g. the square text-command added 13 lines of code). As a result, the switch statement quickly grows in size. Moreover the go method is increasingly incohesive.\n\n4 The Command Design Pattern\nIn order to make each case statement shorter, we can put all its code into a separate helper method. Since all the helper methods operate on the model, we pass the model object to them. Also since some of the text command require additional input, we pass the additional input to e\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0015] acingTurtleModel m) {\n    m.trace(this.d);\n  }\n\n  ...\n\n}\nNow we can change the logic of our controller to:\n\nTake a one-word command from the user.\nCreate the corresponding TracingTurtleCommand object..\nExecute the command object.\nString in = s.next();\ntry {\n  switch (in) {\n    case \"q\":\n    case \"quit\":\n      return;\n   case \"show\":\n     for (Line l : m.getLines()) {\n        System.out.println(l);\n     }\n     break;\n   case \"move\":\n      cmd = new Move(s.nextDouble());\n      break;\n   case \"trace\":\n      cmd = new Trace(s.nextDouble());\n      break;\n   case \"turn\":\n      cmd = new Turn(s.nextDouble());\n      break;\n   case \"square\":\n      cmd = new Square(s.nextDouble());\n      break;\n   default:\n      System.out.println(String.format(\"Unknown command %s\", in));\n      cmd = null;\n      bre\n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.InputStream;\nimport java.util.Scanner;\n\npublic class TextController implements IController{\n    private Scanner in;\n    private IView view;\n    private IModel model;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic void runProgram() {\n        boolean quit = false;\n\n        while (!quit) {\n            \/\/tell view to show the string so far.\n            view.showString(this.model.getString());\n            \/\/tell view to show options\n            view.showOptions();\n            \/\/accept user input\n            String option = in.next();\n            switch (option) {\n                case \"E\":\n                    \/\/ask for string input\n                    view.showStringEntry();\n                    in.nextLine();\n                    String input = in.nextLine();\n                    \/\/give to model\n                    model.setString(input);\n                    break;\n                case \"Q\":\n                    quit = true;\n                    break;\n                default:\n                    view.showOptionError();\n            }\n        }\n    }\n\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TextController(IModel model,InputStream in,IView view) {\n        this.model = model;\n        this.view = view;\n        this.in = new Scanner(in);\n\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\swing-1030\\src\\TextController.java","mask_span":[186,345],"topics":["observer","command","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0020] en again using Java’s new lambda syntax (see Streamlining the code further below).\n\n\/**\n * Represents the printing of a sequence of lines to output\n *\/\nclass PrintInteraction implements Interaction {\n  String[] lines;\n  PrintInteraction(String... lines) {\n    this.lines = lines;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    for (String line : lines) {\n      out.append(line).append(\"\\n\");\n    }\n  }\n}\n\/**\n * Represents a user providing the program with  an input\n *\/\nclass InputInteraction implements Interaction {\n  String input;\n  InputInteraction(String input) {\n    this.input = input;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    in.append(input);\n  }\n}\nFor example, the following array of Interactions represents two inputs to our Calculator and the\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.PrintStream;\n\npublic class TextView implements IView {\n    private PrintStream out;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic void showString(String s) {\n        out.println(\"String: \"+s);\n    }\n\n    public void showOptions() {\n        \/\/print the UI\n        out.println(\"Menu: \");\n        out.println(\"E: Enter a string\");\n        out.println(\"Q: Quit the program\");\n        out.print(\"Enter your choice: \");\n    }\n\n    public void showStringEntry() {\n        out.print(\"\\nEnter the string to be echoed: \");\n    }\n\n    public void showOptionError() {\n        out.print(\"\\nInvalid option. Please try again.\");\n    }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TextView(PrintStream out) {\n        this.out = out;\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\swing-1030\\src\\TextView.java","mask_span":[104,168],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0020] en again using Java’s new lambda syntax (see Streamlining the code further below).\n\n\/**\n * Represents the printing of a sequence of lines to output\n *\/\nclass PrintInteraction implements Interaction {\n  String[] lines;\n  PrintInteraction(String... lines) {\n    this.lines = lines;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    for (String line : lines) {\n      out.append(line).append(\"\\n\");\n    }\n  }\n}\n\/**\n * Represents a user providing the program with  an input\n *\/\nclass InputInteraction implements Interaction {\n  String input;\n  InputInteraction(String input) {\n    this.input = input;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    in.append(input);\n  }\n}\nFor example, the following array of Interactions represents two inputs to our Calculator and the\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.PrintStream;\n\npublic class TextView implements IView {\n    private PrintStream out;\n\n    public TextView(PrintStream out) {\n        this.out = out;\n    }\n\n    public void showString(String s) {\n        out.println(\"String: \"+s);\n    }\n\n    public void showOptions() {\n        \/\/print the UI\n        out.println(\"Menu: \");\n        out.println(\"E: Enter a string\");\n        out.println(\"Q: Quit the program\");\n        out.print(\"Enter your choice: \");\n    }\n\n    public void showStringEntry() {\n        out.print(\"\\nEnter the string to be echoed: \");\n    }\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void showOptionError() {\n        out.print(\"\\nInvalid option. Please try again.\");\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\swing-1030\\src\\TextView.java","mask_span":[575,670],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n<\/Context>","code_prefix":"<CodePrefix>\nimport java.awt.*;\n\nimport javax.swing.*;\n\npublic class EchoFrame extends JFrame {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic EchoFrame() {\n    super();\n\n    \/\/Manage the frame\n    this.setSize(500, 150);\n    this.setLocation(300, 500);\n    this.setDefaultCloseOperation(EXIT_ON_CLOSE);\n    this.setBackground(Color.MAGENTA);\n\n    \/\/Change the LayoutManager\n    this.setLayout(new FlowLayout());\n\n    \/\/Construct your components\n    JLabel echoLabel = new JLabel(\"Echo text here!\");\n    this.add(echoLabel);\n\n    JTextField textInput = new JTextField(20);\n    this.add(textInput);\n\n    JButton echoButton = new JButton(\"Echo!\");\n    this.add(echoButton);\n\n    \/\/Compact the frame so everything just fits\n    this.pack();\n    this.setVisible(true);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\swing-1335\\src\\EchoFrame.java","mask_span":[86,718],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n<\/Context>","code_prefix":"<CodePrefix>\nimport javax.swing.*;\n\npublic class MVCExampleTextUI {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String []args) {\n        new EchoFrame();\n        \/*\n        IModel model = new Model();\n        IView view = new TextView(System.out);\n        IController controller = new TextController(model,System.in,view);\n        controller.runProgram();\n         *\/\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\swing-1335\\src\\MVCExampleTextUI.java","mask_span":[59,344],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0012]  } catch (InputMismatchException ime) {\n      ...\n    }\n    break;\n}\nThe possibilities are now endless! We can support similar higher-level drawing text commands. Every such text commands adds a new case to our switch statement. The number of lines of code in each case statement depends on the complexity of the text command (e.g. the square text-command added 13 lines of code). As a result, the switch statement quickly grows in size. Moreover the go method is increasingly incohesive.\n\n4 The Command Design Pattern\nIn order to make each case statement shorter, we can put all its code into a separate helper method. Since all the helper methods operate on the model, we pass the model object to them. Also since some of the text command require additional input, we pass the additional input to e\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0015] acingTurtleModel m) {\n    m.trace(this.d);\n  }\n\n  ...\n\n}\nNow we can change the logic of our controller to:\n\nTake a one-word command from the user.\nCreate the corresponding TracingTurtleCommand object..\nExecute the command object.\nString in = s.next();\ntry {\n  switch (in) {\n    case \"q\":\n    case \"quit\":\n      return;\n   case \"show\":\n     for (Line l : m.getLines()) {\n        System.out.println(l);\n     }\n     break;\n   case \"move\":\n      cmd = new Move(s.nextDouble());\n      break;\n   case \"trace\":\n      cmd = new Trace(s.nextDouble());\n      break;\n   case \"turn\":\n      cmd = new Turn(s.nextDouble());\n      break;\n   case \"square\":\n      cmd = new Square(s.nextDouble());\n      break;\n   default:\n      System.out.println(String.format(\"Unknown command %s\", in));\n      cmd = null;\n      bre\n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.InputStream;\nimport java.util.Scanner;\n\npublic class TextController implements IController{\n    private Scanner in;\n    private IView view;\n    private IModel model;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic void runProgram() {\n        boolean quit = false;\n\n        while (!quit) {\n            \/\/tell view to show the string so far.\n            view.showString(this.model.getString());\n            \/\/tell view to show options\n            view.showOptions();\n            \/\/accept user input\n            String option = in.next();\n            switch (option) {\n                case \"E\":\n                    \/\/ask for string input\n                    view.showStringEntry();\n                    in.nextLine();\n                    String input = in.nextLine();\n                    \/\/give to model\n                    model.setString(input);\n                    break;\n                case \"Q\":\n                    quit = true;\n                    break;\n                default:\n                    view.showOptionError();\n            }\n        }\n    }\n\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TextController(IModel model,InputStream in,IView view) {\n        this.model = model;\n        this.view = view;\n        this.in = new Scanner(in);\n\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\swing-1335\\src\\TextController.java","mask_span":[186,345],"topics":["observer","command","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0020] en again using Java’s new lambda syntax (see Streamlining the code further below).\n\n\/**\n * Represents the printing of a sequence of lines to output\n *\/\nclass PrintInteraction implements Interaction {\n  String[] lines;\n  PrintInteraction(String... lines) {\n    this.lines = lines;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    for (String line : lines) {\n      out.append(line).append(\"\\n\");\n    }\n  }\n}\n\/**\n * Represents a user providing the program with  an input\n *\/\nclass InputInteraction implements Interaction {\n  String input;\n  InputInteraction(String input) {\n    this.input = input;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    in.append(input);\n  }\n}\nFor example, the following array of Interactions represents two inputs to our Calculator and the\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.PrintStream;\n\npublic class TextView implements IView {\n    private PrintStream out;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic void showString(String s) {\n        out.println(\"String: \"+s);\n    }\n\n    public void showOptions() {\n        \/\/print the UI\n        out.println(\"Menu: \");\n        out.println(\"E: Enter a string\");\n        out.println(\"Q: Quit the program\");\n        out.print(\"Enter your choice: \");\n    }\n\n    public void showStringEntry() {\n        out.print(\"\\nEnter the string to be echoed: \");\n    }\n\n    public void showOptionError() {\n        out.print(\"\\nInvalid option. Please try again.\");\n    }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TextView(PrintStream out) {\n        this.out = out;\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\swing-1335\\src\\TextView.java","mask_span":[104,168],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0020] en again using Java’s new lambda syntax (see Streamlining the code further below).\n\n\/**\n * Represents the printing of a sequence of lines to output\n *\/\nclass PrintInteraction implements Interaction {\n  String[] lines;\n  PrintInteraction(String... lines) {\n    this.lines = lines;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    for (String line : lines) {\n      out.append(line).append(\"\\n\");\n    }\n  }\n}\n\/**\n * Represents a user providing the program with  an input\n *\/\nclass InputInteraction implements Interaction {\n  String input;\n  InputInteraction(String input) {\n    this.input = input;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    in.append(input);\n  }\n}\nFor example, the following array of Interactions represents two inputs to our Calculator and the\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n<\/Context>","code_prefix":"<CodePrefix>\nimport java.io.PrintStream;\n\npublic class TextView implements IView {\n    private PrintStream out;\n\n    public TextView(PrintStream out) {\n        this.out = out;\n    }\n\n    public void showString(String s) {\n        out.println(\"String: \"+s);\n    }\n\n    public void showOptions() {\n        \/\/print the UI\n        out.println(\"Menu: \");\n        out.println(\"E: Enter a string\");\n        out.println(\"Q: Quit the program\");\n        out.print(\"Enter your choice: \");\n    }\n\n    public void showStringEntry() {\n        out.print(\"\\nEnter the string to be echoed: \");\n    }\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void showOptionError() {\n        out.print(\"\\nInvalid option. Please try again.\");\n    }\n<\/Target>","meta":{"source":"data\\raw\\code\\swing-1335\\src\\TextView.java","mask_span":[575,670],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0002] ts single argument. (This array contains the zero or more command line parameters that we use when running the program. We’ll come back to this in a later lecture.) Since this is a method, we have to stick it in some class, but the name of that class isn’t special; instead, we’ll tell Java which class to find our main method in.\n\npublic class OurMainClass {\n  public static void main(String[] args) {\n    ...\n  }\n}\nIn IntelliJ, once you’ve written such a class, a green \"Play\" triangle will appear next to the class name, indicating you can run the program via this class. (Under the hood, IntelliJ is passing the name of this class as a command line parameter to Java, so that it knows which class’s main to call.)\nOur initial implementation is going to be very simple: it will read two numbers, a\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0001] could run on its own: we’ve relied on the tester library to kick things off for us. To write a more typical program, Java relies on a particular convention to find the entry point for the program, i.e. the initial piece of code to run. We need a\n\nfunction — because at the instant our program starts, we don’t have any objects constructed yet\nwith a well-known name — because otherwise how would Java know what to call?\nwith a well-known signature — or else how could Java call it correctly?\nthat returns nothing — since no one would be listening for the return value anyway\nSince Java doesn’t have functions, per se, we’ll need to use a static method instead. To make sure the name is visible, the method must be public. By convention, the method must be named main, and it must take a String[] as i\n---\n[data\\raw\\notes\\Lecture 8 Controllers and Mock Obje.txt::chunk0020] en again using Java’s new lambda syntax (see Streamlining the code further below).\n\n\/**\n * Represents the printing of a sequence of lines to output\n *\/\nclass PrintInteraction implements Interaction {\n  String[] lines;\n  PrintInteraction(String... lines) {\n    this.lines = lines;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    for (String line : lines) {\n      out.append(line).append(\"\\n\");\n    }\n  }\n}\n\/**\n * Represents a user providing the program with  an input\n *\/\nclass InputInteraction implements Interaction {\n  String input;\n  InputInteraction(String input) {\n    this.input = input;\n  }\n  public void apply(StringBuilder in, StringBuilder out) {\n    in.append(input);\n  }\n}\nFor example, the following array of Interactions represents two inputs to our Calculator and the\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n<\/Context>","code_prefix":"<CodePrefix>\npublic class Main {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    System.out.println(\"Hello world\");\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\tictactoeWithLists\\tictactoe-1335\\src\\Main.java","mask_span":[23,106],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0001]  of Integers that will let us use the positions to access the cell contents.\n\nSome of these methods return simple quantities that don’t change, so for those we can just store each in a field:\n\npublic int width;\npublic int height;\npublic int goal;\npublic int players;\nClearly we need to represent the state of the game grid, in particular which tokens are where. Since the grid is essentially a two-dimensional matrix, we can use an array of arrays or list of lists. In general this choice is arbitrary (except for the effects of locality), but in this case columns may make more sense, because we can use shorter lists to represent not-yet-full columns and grow them as necessary.\n\npublic List<List<Integer>> columns;\nFinally, we need state in order to be able to tell the client who the current play\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0023] given cell position. Because some cells may be empty of tokens, we need some way to distinguish empty cells from player numbers. The wrapped integer type Integer includes null, so we use Integer instead of int for the result with null representing empty cells.\n\nAdditionally, we will include a convenience method3 for asking whether a particular column is full.\n\n\/**\n * Gets the player whose token is at the given column and row. The\n * coordinates are zero-based and start in the lower left. Returns\n * {@code null} if there is no token in the given position.\n *\n * @param x the column coordinate ({@code 0 <= x < width})\n * @param y the row coordinate ({@code 0 <= y < height})\n * @return the player in the given position, or {@code null}\n * @throws IndexOutOfBoundsException if (x, y) is out of bo\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0014]  a copy of the grid (which need not be the same type as what we use internally):\n\n\/**\n * Returns a two-dimensional array representing the state of the\n * grid. The first index is the column and the second the row.\n * The resulting array is newly allocated and unconnected to the model;\n * thus, mutating it will have no effect on the model or subsequent\n * calls to {@code getGrid}.\n *\n * @return a copy of the grid\n *\/\nPlayer[][] getGrid();\nAlternatively, rather than return some representation of the grid, we could provide some means of querying it:\n\n\/**\n * Returns the {@link Player} whose mark is in the cell at the given\n * coordinates, or {@code null} if that cell is empty.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @return a {@code Player} or {@code \n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n\/**\n * Implementation of a basic 3x3 game of TicTacToe. Game can end in a stalemate as well,\n * which is indicated by getWinner() returning null.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n\n  \/\/ The top left corner is 0,0. Grid is indexed by rows first, then columns.\n  private List<List<Player>> grid;\n  private Player turn;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard()).map(\n      row -> \" \" + Arrays.stream(row).map(\n        p -> p == null ? \" \" : p.toString()).collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n\n  @Override\n  public void move(int row, int col) {\n    if(isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    if(row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Bad row\/col\");\n    }\n    if(grid.get(row).get(col) != null) {\n      throw new IllegalArgumentException(\"Already placed mark here\");\n    }\n    grid.get(row).set(col, turn);\n    if(turn == Player.X) {\n      turn = Player.O;\n    } else {\n      turn = Player.X;\n    }\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    \/\/every spot on board is filled\n    \/\/or a winner\n    return isBoardFull() || isWinner();\n  }\n\n  private boolean isWinner() {\n    return isThreeInARow() != null || isThreeInACol() != null || isThreeInADiagonal() != null;\n  }\n\n  \/\/Slight change from class plan here: notice we will eventually need the winner\n  \/\/so we instead have methods to GET the possible winner. Then for isGameOver, we only\n  \/\/need to check if those winners are not null for the game to be over.\n  private Player isThreeInARow() {\n    for(int row = 0; row < 3; row++) {\n      Player mark = grid.get(row).get(0);\n      if (mark != null\n          && grid.get(row).get(0) == mark\n          && grid.get(row).get(1) == mark\n          && grid.get(row).get(2) == mark) {\n        return mark;\n      }\n    }\n    return null;\n  }\n\n  private Player isThreeInACol() {\n    for(int col = 0; col < 3; col++) {\n      Player mark = grid.get(0).get(col);\n      if (mark != null\n          && grid.get(0).get(col) == mark\n          && grid.get(1).get(col) == mark\n          && grid.get(2).get(col) == mark) {\n        return mark;\n      }\n    }\n    return null;\n  }\n\n  private Player isThreeInADiagonal() {\n    Player mark = grid.get(0).get(0);\n    if (mark != null && grid.get(1).get(1) == mark && grid.get(2).get(2) == mark) {\n      return mark;\n    }\n    mark = grid.get(0).get(2);\n    if (mark != null && grid.get(1).get(1) == mark && grid.get(2).get(0) == mark) {\n      return mark;\n    }\n    return null;\n  }\n\n  private boolean isBoardFull() {\n    for(int row = 0; row < 3; row++) {\n      for(int col = 0; col < 3; col++) {\n        if (grid.get(row).get(col) == null) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  @Override\n  public Player getWinner() {\n    Player winner = isThreeInARow();\n    if(winner != null) return winner;\n\n    winner = isThreeInACol();\n    if(winner != null) return winner;\n\n    return isThreeInADiagonal();\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    \/\/create the grid\n    Player[][] copy = new Player[3][3];\n    \/\/put the contents of the grid into the new copy\n    for(int row = 0; row < copy.length; row++) {\n      for(int col = 0; col < copy[0].length; col++) {\n        copy[row][col] = grid.get(row).get(col);\n      }\n    }\n    \/\/return the new copy\n    return copy;\n  }\n\n  @Override\n  public Player getMarkAt(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Bad row\/col\");\n    }\n    return grid.get(row).get(col);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeModel() {\n    this.grid = new ArrayList<>();\n    for(int row = 0; row < 3; row++) {\n      List<Player> rowList = new ArrayList<>();\n      for(int col = 0; col < 3; col++) {\n        rowList.add(null);\n      }\n      this.grid.add(rowList);\n    }\n    this.turn = Player.X;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\tictactoeWithLists\\tictactoe-1335\\src\\cs3500\\tictactoe\\TicTacToeModel.java","mask_span":[481,770],"topics":["gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 12 Encapsulation and Class.txt::chunk0001]  of Integers that will let us use the positions to access the cell contents.\n\nSome of these methods return simple quantities that don’t change, so for those we can just store each in a field:\n\npublic int width;\npublic int height;\npublic int goal;\npublic int players;\nClearly we need to represent the state of the game grid, in particular which tokens are where. Since the grid is essentially a two-dimensional matrix, we can use an array of arrays or list of lists. In general this choice is arbitrary (except for the effects of locality), but in this case columns may make more sense, because we can use shorter lists to represent not-yet-full columns and grow them as necessary.\n\npublic List<List<Integer>> columns;\nFinally, we need state in order to be able to tell the client who the current play\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0023] given cell position. Because some cells may be empty of tokens, we need some way to distinguish empty cells from player numbers. The wrapped integer type Integer includes null, so we use Integer instead of int for the result with null representing empty cells.\n\nAdditionally, we will include a convenience method3 for asking whether a particular column is full.\n\n\/**\n * Gets the player whose token is at the given column and row. The\n * coordinates are zero-based and start in the lower left. Returns\n * {@code null} if there is no token in the given position.\n *\n * @param x the column coordinate ({@code 0 <= x < width})\n * @param y the row coordinate ({@code 0 <= y < height})\n * @return the player in the given position, or {@code null}\n * @throws IndexOutOfBoundsException if (x, y) is out of bo\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0014]  a copy of the grid (which need not be the same type as what we use internally):\n\n\/**\n * Returns a two-dimensional array representing the state of the\n * grid. The first index is the column and the second the row.\n * The resulting array is newly allocated and unconnected to the model;\n * thus, mutating it will have no effect on the model or subsequent\n * calls to {@code getGrid}.\n *\n * @return a copy of the grid\n *\/\nPlayer[][] getGrid();\nAlternatively, rather than return some representation of the grid, we could provide some means of querying it:\n\n\/**\n * Returns the {@link Player} whose mark is in the cell at the given\n * coordinates, or {@code null} if that cell is empty.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @return a {@code Player} or {@code \n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n\/**\n * Implementation of a basic 3x3 game of TicTacToe. Game can end in a stalemate as well,\n * which is indicated by getWinner() returning null.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n\n  \/\/ The top left corner is 0,0. Grid is indexed by rows first, then columns.\n  private List<List<Player>> grid;\n  private Player turn;\n\n  public TicTacToeModel() {\n    this.grid = new ArrayList<>();\n    for(int row = 0; row < 3; row++) {\n      List<Player> rowList = new ArrayList<>();\n      for(int col = 0; col < 3; col++) {\n        rowList.add(null);\n      }\n      this.grid.add(rowList);\n    }\n    this.turn = Player.X;\n  }\n\n  @Override\n  public String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard()).map(\n      row -> \" \" + Arrays.stream(row).map(\n        p -> p == null ? \" \" : p.toString()).collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n\n  @Override\n  public void move(int row, int col) {\n    if(isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    if(row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Bad row\/col\");\n    }\n    if(grid.get(row).get(col) != null) {\n      throw new IllegalArgumentException(\"Already placed mark here\");\n    }\n    grid.get(row).set(col, turn);\n    if(turn == Player.X) {\n      turn = Player.O;\n    } else {\n      turn = Player.X;\n    }\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    \/\/every spot on board is filled\n    \/\/or a winner\n    return isBoardFull() || isWinner();\n  }\n\n  private boolean isWinner() {\n    return isThreeInARow() != null || isThreeInACol() != null || isThreeInADiagonal() != null;\n  }\n\n  \/\/Slight change from class plan here: notice we will eventually need the winner\n  \/\/so we instead have methods to GET the possible winner. Then for isGameOver, we only\n  \/\/need to check if those winners are not null for the game to be over.\n  private Player isThreeInARow() {\n    for(int row = 0; row < 3; row++) {\n      Player mark = grid.get(row).get(0);\n      if (mark != null\n          && grid.get(row).get(0) == mark\n          && grid.get(row).get(1) == mark\n          && grid.get(row).get(2) == mark) {\n        return mark;\n      }\n    }\n    return null;\n  }\n\n  private Player isThreeInACol() {\n    for(int col = 0; col < 3; col++) {\n      Player mark = grid.get(0).get(col);\n      if (mark != null\n          && grid.get(0).get(col) == mark\n          && grid.get(1).get(col) == mark\n          && grid.get(2).get(col) == mark) {\n        return mark;\n      }\n    }\n    return null;\n  }\n\n  private Player isThreeInADiagonal() {\n    Player mark = grid.get(0).get(0);\n    if (mark != null && grid.get(1).get(1) == mark && grid.get(2).get(2) == mark) {\n      return mark;\n    }\n    mark = grid.get(0).get(2);\n    if (mark != null && grid.get(1).get(1) == mark && grid.get(2).get(0) == mark) {\n      return mark;\n    }\n    return null;\n  }\n\n  private boolean isBoardFull() {\n    for(int row = 0; row < 3; row++) {\n      for(int col = 0; col < 3; col++) {\n        if (grid.get(row).get(col) == null) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  @Override\n  public Player getWinner() {\n    Player winner = isThreeInARow();\n    if(winner != null) return winner;\n\n    winner = isThreeInACol();\n    if(winner != null) return winner;\n\n    return isThreeInADiagonal();\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    \/\/create the grid\n    Player[][] copy = new Player[3][3];\n    \/\/put the contents of the grid into the new copy\n    for(int row = 0; row < copy.length; row++) {\n      for(int col = 0; col < copy[0].length; col++) {\n        copy[row][col] = grid.get(row).get(col);\n      }\n    }\n    \/\/return the new copy\n    return copy;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic Player getMarkAt(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Bad row\/col\");\n    }\n    return grid.get(row).get(col);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\tictactoeWithLists\\tictactoe-1335\\src\\cs3500\\tictactoe\\TicTacToeModel.java","mask_span":[4571,4768],"topics":["gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0006] der strategy that first tries one and then, if it fails, tries the other:\n\nclass TryTwo implements TicTacToeStrategy {\n  TicTacToeStrategy first, second;\n  public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n    Coord ans = this.first.chooseMove(model, forWhom);\n    if (ans != null) return ans; \/\/ the first strategy succeeded\n    return this.second.chooseMove(model, forWhom);\n  }\n}\nIf we fill in the question-marks in AnyOpenCorner with return null, as we effectively did with AnyOpenSquare, then our full second strategy is simply new TryTwo(new AnyOpenCorner(), new AnyOpenSquare()). We can continue implementing the other strategy components (blocking an opponent, or going for an immediate win), and combining them with TryTwo. (These other components need the forWhom argument —try\n<\/Context>","code_prefix":"<CodePrefix>\nimport org.junit.Test;\n\nimport cs3500.tictactoe.Player;\nimport cs3500.tictactoe.TicTacToe;\nimport cs3500.tictactoe.TicTacToeModel;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\n\/**\n * Test cases for the tic tac toe model. Verifying that game state is properly managed, and\n * all game actions are properly validated.\n *\/\npublic class TicTacToeModelTest {\n\n  private TicTacToe ttt1 = new TicTacToeModel();\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void testHorizontalWin() {\n    ttt1.move(0, 0); \/\/ X takes upper left\n    assertFalse(ttt1.isGameOver());\n    ttt1.move(1, 0); \/\/ O takes middle left\n    ttt1.move(0, 1); \/\/ X takes upper middle\n    assertNull(ttt1.getWinner());\n    ttt1.move(2, 0); \/\/ O takes lower left\n    ttt1.move(0, 2); \/\/ X takes upper right\n    assertTrue(ttt1.isGameOver());\n    assertEquals(Player.X, ttt1.getWinner());\n    assertEquals(\" X | X | X\\n\"\n                          + \"-----------\\n\"\n                          + \" O |   |  \\n\"\n                          + \"-----------\\n\"\n                          + \" O |   |  \", ttt1.toString());\n  }\n\n  @Test\n  public void testDiagonalWin() {\n    diagonalWinHelper();\n    assertTrue(ttt1.isGameOver());\n    assertEquals(Player.O, ttt1.getWinner());\n    assertEquals(\" X | X | O\\n\"\n            + \"-----------\\n\"\n            + \" X | O |  \\n\"\n            + \"-----------\\n\"\n            + \" O |   |  \", ttt1.toString());\n  }\n\n  \/\/ set up situation where game is over, O wins on the diagonal, board is not full\n  private void diagonalWinHelper() {\n    ttt1.move(0, 0); \/\/ X takes upper left\n    assertFalse(ttt1.isGameOver());\n    ttt1.move(2, 0); \/\/ O takes lower left\n    ttt1.move(1, 0); \/\/ X takes middle left\n    assertNull(ttt1.getWinner());\n    ttt1.move(1, 1); \/\/ O takes center\n    ttt1.move(0, 1); \/\/ X takes upper middle\n    ttt1.move(0, 2); \/\/ O takes upper right\n  }\n\n  @Test\n  public void testInvalidMove() {\n    ttt1.move(0, 0);\n    assertEquals(Player.O, ttt1.getTurn());\n    assertEquals(Player.X, ttt1.getMarkAt(0, 0));\n    try {\n      ttt1.move(0, 0);\n      fail(\"Invalid move should have thrown exception\");\n    } catch (IllegalArgumentException iae) {\n      \/\/assertEquals(\"Position occupied\", iae.getMessage());\n      assertTrue(iae.getMessage().length() > 0);\n    }\n    try {\n      ttt1.move(-1, 0);\n      fail(\"Invalid move should have thrown exception\");\n    } catch (IllegalArgumentException iae) {\n      \/\/assertEquals(\"Position occupied\", iae.getMessage());\n      assertTrue(iae.getMessage().length() > 0);\n    }\n  }\n\n  @Test(expected = IllegalStateException.class)\n  public void testMoveAttemptAfterGameOver() {\n    diagonalWinHelper();\n    ttt1.move(2, 2); \/\/ 2,2 is an empty position\n  }\n\n  @Test\n  public void testCatsGame() {\n    ttt1.move(0, 0);\n    assertEquals(Player.O, ttt1.getTurn());\n    ttt1.move(1, 1);\n    assertEquals(Player.X, ttt1.getTurn());\n    ttt1.move(0, 2);\n    ttt1.move(0, 1);\n    ttt1.move(2, 1);\n    ttt1.move(1, 0);\n    ttt1.move(1, 2);\n    ttt1.move(2, 2);\n    ttt1.move(2, 0);\n    assertTrue(ttt1.isGameOver());\n    assertNull(ttt1.getWinner());\n    assertEquals( \" X | O | X\\n\"\n            + \"-----------\\n\"\n            + \" O | O | X\\n\"\n            + \"-----------\\n\"\n            + \" X | X | O\", ttt1.toString());\n  }\n\n  @Test(expected = IllegalArgumentException.class)\n  public void testInvalidGetMarkAtRow() {\n    ttt1.getMarkAt(-12, 0);\n  }\n\n  @Test(expected = IllegalArgumentException.class)\n  public void testInvalidGetMarkAtCol() {\n    ttt1.getMarkAt(0, -30);\n  }\n\n  @Test\n  public void testGetBoard() {\n    diagonalWinHelper();\n    Player[][] bd = ttt1.getBoard();\n    assertEquals(Player.X, bd[0][0]);\n    assertEquals(Player.O, bd[1][1]);\n    assertEquals(Player.X, bd[0][1]);\n\n    \/\/ attempt to cheat by mutating board returned by getBoard()\n    \/\/ check correct preconditions\n    assertEquals(Player.O, bd[2][0]);\n    assertEquals(Player.O, ttt1.getMarkAt(2, 0));\n    bd[2][0] = Player.X;  \/\/ mutate\n    \/\/ check correct post conditions\n    assertEquals(Player.O, ttt1.getMarkAt(2, 0));\n    Player[][] bd2 = ttt1.getBoard();\n    assertEquals(Player.O, bd2[2][0]);\n  }\n\n  \/\/ TODO: test case where board is full AND there is a winner\n}\n<\/CodeSuffix>","target":"<Target>\npublic void testMove() {\n    ttt1.move(0, 0);\n    assertEquals(Player.O, ttt1.getTurn());\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\tictactoeWithLists\\tictactoe-1335\\test\\TicTacToeModelTest.java","mask_span":[584,677],"topics":["strategy","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0006] der strategy that first tries one and then, if it fails, tries the other:\n\nclass TryTwo implements TicTacToeStrategy {\n  TicTacToeStrategy first, second;\n  public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n    Coord ans = this.first.chooseMove(model, forWhom);\n    if (ans != null) return ans; \/\/ the first strategy succeeded\n    return this.second.chooseMove(model, forWhom);\n  }\n}\nIf we fill in the question-marks in AnyOpenCorner with return null, as we effectively did with AnyOpenSquare, then our full second strategy is simply new TryTwo(new AnyOpenCorner(), new AnyOpenSquare()). We can continue implementing the other strategy components (blocking an opponent, or going for an immediate win), and combining them with TryTwo. (These other components need the forWhom argument —try\n<\/Context>","code_prefix":"<CodePrefix>\nimport org.junit.Test;\n\nimport cs3500.tictactoe.Player;\nimport cs3500.tictactoe.TicTacToe;\nimport cs3500.tictactoe.TicTacToeModel;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\n\/**\n * Test cases for the tic tac toe model. Verifying that game state is properly managed, and\n * all game actions are properly validated.\n *\/\npublic class TicTacToeModelTest {\n\n  private TicTacToe ttt1 = new TicTacToeModel();\n\n  @Test\n  public void testMove() {\n    ttt1.move(0, 0);\n    assertEquals(Player.O, ttt1.getTurn());\n  }\n\n  @Test\n  public void testHorizontalWin() {\n    ttt1.move(0, 0); \/\/ X takes upper left\n    assertFalse(ttt1.isGameOver());\n    ttt1.move(1, 0); \/\/ O takes middle left\n    ttt1.move(0, 1); \/\/ X takes upper middle\n    assertNull(ttt1.getWinner());\n    ttt1.move(2, 0); \/\/ O takes lower left\n    ttt1.move(0, 2); \/\/ X takes upper right\n    assertTrue(ttt1.isGameOver());\n    assertEquals(Player.X, ttt1.getWinner());\n    assertEquals(\" X | X | X\\n\"\n                          + \"-----------\\n\"\n                          + \" O |   |  \\n\"\n                          + \"-----------\\n\"\n                          + \" O |   |  \", ttt1.toString());\n  }\n\n  @Test\n  public void testDiagonalWin() {\n    diagonalWinHelper();\n    assertTrue(ttt1.isGameOver());\n    assertEquals(Player.O, ttt1.getWinner());\n    assertEquals(\" X | X | O\\n\"\n            + \"-----------\\n\"\n            + \" X | O |  \\n\"\n            + \"-----------\\n\"\n            + \" O |   |  \", ttt1.toString());\n  }\n\n  \/\/ set up situation where game is over, O wins on the diagonal, board is not full\n  private void diagonalWinHelper() {\n    ttt1.move(0, 0); \/\/ X takes upper left\n    assertFalse(ttt1.isGameOver());\n    ttt1.move(2, 0); \/\/ O takes lower left\n    ttt1.move(1, 0); \/\/ X takes middle left\n    assertNull(ttt1.getWinner());\n    ttt1.move(1, 1); \/\/ O takes center\n    ttt1.move(0, 1); \/\/ X takes upper middle\n    ttt1.move(0, 2); \/\/ O takes upper right\n  }\n\n  @Test\n  public void testInvalidMove() {\n    ttt1.move(0, 0);\n    assertEquals(Player.O, ttt1.getTurn());\n    assertEquals(Player.X, ttt1.getMarkAt(0, 0));\n    try {\n      ttt1.move(0, 0);\n      fail(\"Invalid move should have thrown exception\");\n    } catch (IllegalArgumentException iae) {\n      \/\/assertEquals(\"Position occupied\", iae.getMessage());\n      assertTrue(iae.getMessage().length() > 0);\n    }\n    try {\n      ttt1.move(-1, 0);\n      fail(\"Invalid move should have thrown exception\");\n    } catch (IllegalArgumentException iae) {\n      \/\/assertEquals(\"Position occupied\", iae.getMessage());\n      assertTrue(iae.getMessage().length() > 0);\n    }\n  }\n\n  @Test(expected = IllegalStateException.class)\n  public void testMoveAttemptAfterGameOver() {\n    diagonalWinHelper();\n    ttt1.move(2, 2); \/\/ 2,2 is an empty position\n  }\n\n  @Test\n  public void testCatsGame() {\n    ttt1.move(0, 0);\n    assertEquals(Player.O, ttt1.getTurn());\n    ttt1.move(1, 1);\n    assertEquals(Player.X, ttt1.getTurn());\n    ttt1.move(0, 2);\n    ttt1.move(0, 1);\n    ttt1.move(2, 1);\n    ttt1.move(1, 0);\n    ttt1.move(1, 2);\n    ttt1.move(2, 2);\n    ttt1.move(2, 0);\n    assertTrue(ttt1.isGameOver());\n    assertNull(ttt1.getWinner());\n    assertEquals( \" X | O | X\\n\"\n            + \"-----------\\n\"\n            + \" O | O | X\\n\"\n            + \"-----------\\n\"\n            + \" X | X | O\", ttt1.toString());\n  }\n\n  @Test(expected = IllegalArgumentException.class)\n  public void testInvalidGetMarkAtRow() {\n    ttt1.getMarkAt(-12, 0);\n  }\n\n  @Test(expected = IllegalArgumentException.class)\n  public void testInvalidGetMarkAtCol() {\n    ttt1.getMarkAt(0, -30);\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/\/ TODO: test case where board is full AND there is a winner\n}\n<\/CodeSuffix>","target":"<Target>\npublic void testGetBoard() {\n    diagonalWinHelper();\n    Player[][] bd = ttt1.getBoard();\n    assertEquals(Player.X, bd[0][0]);\n    assertEquals(Player.O, bd[1][1]);\n    assertEquals(Player.X, bd[0][1]);\n\n    \/\/ attempt to cheat by mutating board returned by getBoard()\n    \/\/ check correct preconditions\n    assertEquals(Player.O, bd[2][0]);\n    assertEquals(Player.O, ttt1.getMarkAt(2, 0));\n    bd[2][0] = Player.X;  \/\/ mutate\n    \/\/ check correct post conditions\n    assertEquals(Player.O, ttt1.getMarkAt(2, 0));\n    Player[][] bd2 = ttt1.getBoard();\n    assertEquals(Player.O, bd2[2][0]);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\tictactoeWithLists\\tictactoe-1335\\test\\TicTacToeModelTest.java","mask_span":[3754,4351],"topics":["strategy","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\n\/**\n * Run a Tic Tac Toe game interactively.\n *\/\npublic class Main {\n  \/**\n   * Run a Tic Tac Toe game interactively.\n   *\/\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    \/\/ Old News: console-based game:\n    \/\/new TicTacToeConsoleController(new InputStreamReader(System.in),\n    \/\/    System.out).playGame(new TicTacToeModel());\n\n    \/\/ New Hotness: Graphical User Interface:\n    \/\/ 1. Create an instance of the model.\n    \/\/ 2. Create an instance of the view.\n    \/\/ 3. Create an instance of the controller, passing the view to its constructor.\n    \/\/ 4. Call playGame() on the controller.\n\n    TicTacToe model = new TicTacToeModel();\n    TTTView view = new TTTFrame(model);\n    TicTacToeController controller = new TTTGUIController(view);\n    controller.playGame(model);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\tttview-1030\\src\\cs3500\\tictactoe\\Main.java","mask_span":[153,803],"topics":["gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.io.IOException;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class TicTacToeConsoleController implements TicTacToeController {\n\n  private final Appendable out;\n  private final Scanner scan;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void playGame(TicTacToe m) {\n    try {\n      appendStateAndPrompt(m);\n      Integer mvRow = null;\n      Integer mvCol = null;\n      String tok = \"\";\n      while (!m.isGameOver()) {\n        tok = scan.next();\n        if (tok.equalsIgnoreCase(\"q\")) {\n          break;\n        }\n        try {\n          int v = Integer.parseInt(tok);\n          if (mvRow == null) {\n            mvRow = v;\n          } else {\n            mvCol = v;\n            m.move(mvRow - 1, mvCol - 1);\n            if(m.isGameOver()) {\n              out.append(m.toString()).append(\"\\n\");\n              out.append(\"Game is over! \");\n              if(m.getWinner() != null) {\n                out.append(m.getWinner().toString() + \" wins.\\n\");\n              } else {\n                out.append(\"Tie game.\\n\");\n              }\n              break;\n            }\n            appendStateAndPrompt(m);\n            mvRow = mvCol = null;\n          }\n        } catch (NumberFormatException nfe) {\n          out.append(\"Not a valid number: \" + tok).append(\"\\n\");\n        } catch (IllegalArgumentException iae) {\n          out.append(\"Not a valid move: \" + mvRow + \", \" + mvCol).append(\"\\n\");\n          mvRow = mvCol = null;\n        }\n      }\n      if (!m.isGameOver() && tok.equalsIgnoreCase(\"q\")) {\n        out.append(\"Game quit! Ending game state:\\n\" + m.toString() + \"\\n\");\n      } else if (!m.isGameOver()) {\n        throw new IllegalStateException(\"Ran out of inputs\");\n      }\n    } catch (IOException ioe) {\n      scan.close();\n      throw new IllegalStateException(\"append failed\", ioe);\n    } catch (NoSuchElementException e) {\n      throw new IllegalStateException(\"failed to read from readable\");\n    }\n    scan.close();\n  }\n\n  private void appendStateAndPrompt(TicTacToe m) throws IOException {\n    out.append(m.toString()).append(\"\\n\");\n    out.append(\"Enter a move for \" + m.getTurn().toString()).append(\":\\n\");\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeConsoleController(Readable in, Appendable out) {\n    if (in == null || out == null) {\n      throw new IllegalArgumentException(\"Readable and Appendable can't be null\");\n    }\n    this.out = out;\n    scan = new Scanner(in);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\tttview-1030\\src\\cs3500\\tictactoe\\TicTacToeConsoleController.java","mask_span":[262,504],"topics":["gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n\/**\n * Represents a single game of Tic Tac Toe. Three in a row down\/across\/diagonally to win; X goes\n * first.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n  private final Player[][] board;\n  private Player turn;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void move(int r, int c) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(r, c);\n    if (board[r][c] != null) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[r][c] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (Player[] row : board) {\n      if (Arrays.stream(row).anyMatch(Objects::isNull)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (Player p : Player.values()) {\n      \/\/ check horizontals\n      for (Player[] row : board) {\n        if(Arrays.stream(row).allMatch(m -> m == p)) {\n          return p;\n        }\n      }\n      \/\/ check verticals\n      for (int i = 0; i < board[0].length; i++) {\n        if (board[0][i] == p && board[1][i] == p && board[2][i] == p) {\n          return p;\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == p && board[1][1] == p && board[2][2] == p) {\n        return p;\n      }\n      if (board[0][2] == p && board[1][1] == p && board[2][0] == p) {\n        return p;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int r = 0; r < board.length; r++) {\n      ret[r] = Arrays.copyOf(board[r], board[r].length);\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int r, int c) {\n    validateRowCol(r, c);\n    return board[r][c];\n  }\n\n  private static void validateRowCol(int r, int c) {\n    if (r < 0 || r > 2 || c < 0 || c > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + r + \",\" + c);\n    }\n  }\n\n  @Override\n  public String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard()).map(\n      row -> \" \" + Arrays.stream(row).map(\n        p -> p == null ? \" \" : p.toString()).collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\tttview-1030\\src\\cs3500\\tictactoe\\TicTacToeModel.java","mask_span":[341,421],"topics":["strategy","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n\/**\n * Represents a single game of Tic Tac Toe. Three in a row down\/across\/diagonally to win; X goes\n * first.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n  private final Player[][] board;\n  private Player turn;\n\n  public TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n\n  @Override\n  public void move(int r, int c) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(r, c);\n    if (board[r][c] != null) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[r][c] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (Player[] row : board) {\n      if (Arrays.stream(row).anyMatch(Objects::isNull)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (Player p : Player.values()) {\n      \/\/ check horizontals\n      for (Player[] row : board) {\n        if(Arrays.stream(row).allMatch(m -> m == p)) {\n          return p;\n        }\n      }\n      \/\/ check verticals\n      for (int i = 0; i < board[0].length; i++) {\n        if (board[0][i] == p && board[1][i] == p && board[2][i] == p) {\n          return p;\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == p && board[1][1] == p && board[2][2] == p) {\n        return p;\n      }\n      if (board[0][2] == p && board[1][1] == p && board[2][0] == p) {\n        return p;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int r = 0; r < board.length; r++) {\n      ret[r] = Arrays.copyOf(board[r], board[r].length);\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int r, int c) {\n    validateRowCol(r, c);\n    return board[r][c];\n  }\n\n  private static void validateRowCol(int r, int c) {\n    if (r < 0 || r > 2 || c < 0 || c > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + r + \",\" + c);\n    }\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard()).map(\n      row -> \" \" + Arrays.stream(row).map(\n        p -> p == null ? \" \" : p.toString()).collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\tttview-1030\\src\\cs3500\\tictactoe\\TicTacToeModel.java","mask_span":[2288,3153],"topics":["strategy","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\nimport javax.swing.*;\n\npublic class TTTFrame extends JFrame implements TTTView {\n\n  private TTTPanel panel;\n\n  public TTTFrame(ReadonlyTTTModel model) {\n    super();\n    setSize(900, 900);\n    setDefaultCloseOperation(EXIT_ON_CLOSE);\n    panel = new TTTPanel(model);\n    this.add(panel);\n\n  }\n\n  @Override\n  public void refresh() {\n    this.repaint();\n  }\n\n  @Override\n  public void makeVisible() {\n    this.setVisible(true);\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void subscribe(ViewActions observer) {\n    this.panel.subscribe(observer);\n    this.addKeyListener(new KeyListener() {\n      @Override\n      public void keyTyped(KeyEvent e) {\n        if(e.getKeyChar() == 'q') {\n          observer.quit();\n        }\n      }\n\n      @Override\n      public void keyPressed(KeyEvent e) {\n\n      }\n\n      @Override\n      public void keyReleased(KeyEvent e) {\n\n      }\n    });\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\tttview-1030\\src\\cs3500\\tictactoe\\TTTFrame.java","mask_span":[540,954],"topics":["observer","gui","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\npublic class TTTGUIController implements TicTacToeController, ViewActions {\n\n  private TicTacToe model;\n  private TTTView view;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void playGame(TicTacToe m) {\n    this.model = m;\n    this.view.subscribe(this);\n    this.view.makeVisible();\n  }\n\n  @Override\n  public void placeMark(int row, int col) {\n    model.move(row, col);\n    view.refresh();\n  }\n\n  @Override\n  public void quit() {\n    System.exit(0);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TTTGUIController(TTTView view) {\n    if (view == null) {\n      throw new IllegalArgumentException(\"Bad view\");\n    }\n    this.view = view;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\tttview-1030\\src\\cs3500\\tictactoe\\TTTGUIController.java","mask_span":[158,307],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0002] t extends JPanel and overrides paintComponent that draws the game board and game status. Status includes indicating whose turn it is, and if the game is over, who won (or if it was a tie).\na class that extends MouseAdapter and overrides mouseClicked to capture a click on the game board and pass it to the controller.\nYou will also need to fill in the parts of the main method in Main.java as noted in the comments in that method.\n\n2 Testing\nTest your view by running it, inspecting the view, clicking on the game board and playing the game. No automated tests here.\n\n3 Notes to Keep in Mind\nYou will likely want to refer to the sample code on graphical programs, such as the Turtle Graphics example (see the \"solution code\" link).\nSubmit your zip containing only your src directory to In-class Exerc\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0046]  extends JPanel, and override its paintComponent method to draw whatever you want, just to confirm that it works.\n\nNext, enhance the IView interface so you can pass the relevant information from the model, through the controller, into the view and into your TurtlePanel class. Once you’ve connected the pieces, use this information in your paintComponent implementation to draw the turtle’s trace.\n\nThe links at the top of the lecture include a “solution” implementation; do not to look at that until you’ve tried to implement this yourself.\n\nThe IView interface contains one method for setting up an event listener. What is its signature? Does it seem like a high-level event to you, or a low-level one? If you think it’s too low-level, can you think of a better, higher-level signature to use? If y\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.awt.*;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.NoninvertibleTransformException;\nimport java.awt.geom.Point2D;\n\nimport javax.swing.*;\n\npublic class TTTPanel extends JPanel {\n\n  private final ReadonlyTTTModel model;\n\n  public TTTPanel(ReadonlyTTTModel model) {\n    super();\n    \/\/Check if it's null and throw an IAE\n    this.model = model;\n  }\n\n  @Override\n  protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n    Graphics2D g2d = (Graphics2D)g.create();\n\n    g2d.setColor(Color.BLACK);\n    int height = this.getHeight();\n    int width = this.getWidth();\n\n    g2d.transform(getXformForLogicalToPhysical());\n\n    drawLine(g2d, 1, 0, 1, 3);\n    drawLine(g2d, 2, 0, 2, 3);\n    drawLine(g2d, 0, 1, 3, 1);\n    drawLine(g2d, 0, 2, 3, 2);\n\n    drawBoard(g2d);\n  }\n\n  private void drawLine(Graphics2D g2d, int row, int col, int endRow, int endCol) {\n    AffineTransform modelToLogical = getXFormForModelToLogical();\n    Point2D src = modelToLogical.transform(new Point(col, row), null);\n    Point2D dst = modelToLogical.transform(new Point(endCol, endRow), null);\n\n    g2d.drawLine((int)src.getX(),\n        (int)src.getY(),\n        (int)dst.getX(),\n        (int)dst.getY());\n  }\n\n  \/\/Works, but lines are too big and look ugly. Let's not use.\n  private AffineTransform getXFormForModelToPhysical() {\n    AffineTransform xform = new AffineTransform();\n    xform.scale(getWidth() \/ 3, getHeight() \/ 3);\n    return xform;\n  }\n\n  private Dimension getLogicalDimensions() {\n    return new Dimension(30, 30);\n  }\n\n  private AffineTransform getXFormForModelToLogical() {\n    AffineTransform xform = new AffineTransform();\n    xform.scale(getLogicalDimensions().getWidth() \/ 3,\n        getLogicalDimensions().getHeight() \/ 3);\n    return xform;\n  }\n\n  private AffineTransform getXformForLogicalToPhysical() {\n    AffineTransform xform = new AffineTransform();\n    xform.scale(this.getWidth() \/ getLogicalDimensions().getWidth(),\n        this.getHeight() \/ getLogicalDimensions().getHeight());\n    return xform;\n  }\n\n  private void drawOval(Graphics2D g2d, int row, int col, int width, int height) {\n    AffineTransform modelToLogical = getXFormForModelToLogical();\n    Point2D src = modelToLogical.transform(new Point(col, row), null);\n    Point2D dst = modelToLogical.transform(new Point(width, height), null);\n\n    g2d.drawOval((int)src.getX(),\n        (int)src.getY(),\n        (int)dst.getX(),\n        (int)dst.getY());\n  }\n\n  private void drawBoard(Graphics2D g2d) {\n    for(int row = 0; row < 3; row++) {\n      for(int col = 0; col < 3; col++) {\n        Player mark = model.getMarkAt(row, col);\n\n        if(mark == null) {\n          continue;\n        }\n\n        switch(mark) {\n          case X:\n            drawLine(g2d, row, col, row+1, col+1);\n            drawLine(g2d, row, col+1, row+1, col);\n            break;\n          case O:\n            drawOval(g2d, row, col, 1, 1);\n            break;\n        }\n      }\n    }\n  }\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\nclass TTTMouseListener extends MouseAdapter {\n\n    private ViewActions observer;\n\n    public TTTMouseListener(ViewActions observer) {\n      this.observer = observer;\n    }\n\n    public void mouseClicked(MouseEvent evt) {\n      Point2D physical = evt.getPoint();\n\n      try {\n        AffineTransform physicalToLogical = getXformForLogicalToPhysical();\n        physicalToLogical.invert();\n\n        AffineTransform logicalToModel = getXFormForModelToLogical();\n        logicalToModel.invert();\n\n        Point2D logical = physicalToLogical.transform(physical, null);\n        Point2D model = logicalToModel.transform(logical, null);\n        observer.placeMark((int) model.getY(), (int) model.getX());\n      } catch (NoninvertibleTransformException ex) {\n        throw new RuntimeException(ex);\n      }\n    }\n\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void subscribe(ViewActions observer) {\n    this.addMouseListener(new TTTMouseListener(observer));\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\tttview-1030\\src\\cs3500\\tictactoe\\TTTPanel.java","mask_span":[3064,3172],"topics":["observer","gui","adapter","decorator","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\n\/**\n * Run a Tic Tac Toe game interactively.\n *\/\npublic class Main {\n  \/**\n   * Run a Tic Tac Toe game interactively.\n   *\/\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    \/\/ Old News: console-based game:\n    \/\/new TicTacToeConsoleController(new InputStreamReader(System.in),\n    \/\/    System.out).playGame(new TicTacToeModel());\n\n    \/\/ New Hotness: Graphical User Interface:\n    \/\/ 1. Create an instance of the model.\n    TicTacToe model = new TicTacToeModel();\n    \/\/ 2. Create an instance of the view.\n    TTTView view = new TTTFrame(model);\n    \/\/ 3. Create an instance of the controller, passing the view to its constructor.\n    TicTacToeController controller = new TTTGUIController(view);\n    \/\/ 4. Call playGame() on the controller.\n    controller.playGame(model);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\tttview-1335\\src\\cs3500\\tictactoe\\Main.java","mask_span":[153,802],"topics":["gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.io.IOException;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class TicTacToeConsoleController implements TicTacToeController {\n\n  private final Appendable out;\n  private final Scanner scan;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void playGame(TicTacToe m) {\n    try {\n      appendStateAndPrompt(m);\n      Integer mvRow = null;\n      Integer mvCol = null;\n      String tok = \"\";\n      while (!m.isGameOver()) {\n        tok = scan.next();\n        if (tok.equalsIgnoreCase(\"q\")) {\n          break;\n        }\n        try {\n          int v = Integer.parseInt(tok);\n          if (mvRow == null) {\n            mvRow = v;\n          } else {\n            mvCol = v;\n            m.move(mvRow - 1, mvCol - 1);\n            if(m.isGameOver()) {\n              out.append(m.toString()).append(\"\\n\");\n              out.append(\"Game is over! \");\n              if(m.getWinner() != null) {\n                out.append(m.getWinner().toString() + \" wins.\\n\");\n              } else {\n                out.append(\"Tie game.\\n\");\n              }\n              break;\n            }\n            appendStateAndPrompt(m);\n            mvRow = mvCol = null;\n          }\n        } catch (NumberFormatException nfe) {\n          out.append(\"Not a valid number: \" + tok).append(\"\\n\");\n        } catch (IllegalArgumentException iae) {\n          out.append(\"Not a valid move: \" + mvRow + \", \" + mvCol).append(\"\\n\");\n          mvRow = mvCol = null;\n        }\n      }\n      if (!m.isGameOver() && tok.equalsIgnoreCase(\"q\")) {\n        out.append(\"Game quit! Ending game state:\\n\" + m.toString() + \"\\n\");\n      } else if (!m.isGameOver()) {\n        throw new IllegalStateException(\"Ran out of inputs\");\n      }\n    } catch (IOException ioe) {\n      scan.close();\n      throw new IllegalStateException(\"append failed\", ioe);\n    } catch (NoSuchElementException e) {\n      throw new IllegalStateException(\"failed to read from readable\");\n    }\n    scan.close();\n  }\n\n  private void appendStateAndPrompt(TicTacToe m) throws IOException {\n    out.append(m.toString()).append(\"\\n\");\n    out.append(\"Enter a move for \" + m.getTurn().toString()).append(\":\\n\");\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeConsoleController(Readable in, Appendable out) {\n    if (in == null || out == null) {\n      throw new IllegalArgumentException(\"Readable and Appendable can't be null\");\n    }\n    this.out = out;\n    scan = new Scanner(in);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\tttview-1335\\src\\cs3500\\tictactoe\\TicTacToeConsoleController.java","mask_span":[262,504],"topics":["gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n\/**\n * Represents a single game of Tic Tac Toe. Three in a row down\/across\/diagonally to win; X goes\n * first.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n  private final Player[][] board;\n  private Player turn;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void move(int r, int c) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(r, c);\n    if (board[r][c] != null) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[r][c] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (Player[] row : board) {\n      if (Arrays.stream(row).anyMatch(Objects::isNull)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (Player p : Player.values()) {\n      \/\/ check horizontals\n      for (Player[] row : board) {\n        if(Arrays.stream(row).allMatch(m -> m == p)) {\n          return p;\n        }\n      }\n      \/\/ check verticals\n      for (int i = 0; i < board[0].length; i++) {\n        if (board[0][i] == p && board[1][i] == p && board[2][i] == p) {\n          return p;\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == p && board[1][1] == p && board[2][2] == p) {\n        return p;\n      }\n      if (board[0][2] == p && board[1][1] == p && board[2][0] == p) {\n        return p;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int r = 0; r < board.length; r++) {\n      ret[r] = Arrays.copyOf(board[r], board[r].length);\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int r, int c) {\n    validateRowCol(r, c);\n    return board[r][c];\n  }\n\n  private static void validateRowCol(int r, int c) {\n    if (r < 0 || r > 2 || c < 0 || c > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + r + \",\" + c);\n    }\n  }\n\n  @Override\n  public String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard()).map(\n      row -> \" \" + Arrays.stream(row).map(\n        p -> p == null ? \" \" : p.toString()).collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\tttview-1335\\src\\cs3500\\tictactoe\\TicTacToeModel.java","mask_span":[341,421],"topics":["strategy","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n\/**\n * Represents a single game of Tic Tac Toe. Three in a row down\/across\/diagonally to win; X goes\n * first.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n  private final Player[][] board;\n  private Player turn;\n\n  public TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n\n  @Override\n  public void move(int r, int c) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(r, c);\n    if (board[r][c] != null) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[r][c] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (Player[] row : board) {\n      if (Arrays.stream(row).anyMatch(Objects::isNull)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (Player p : Player.values()) {\n      \/\/ check horizontals\n      for (Player[] row : board) {\n        if(Arrays.stream(row).allMatch(m -> m == p)) {\n          return p;\n        }\n      }\n      \/\/ check verticals\n      for (int i = 0; i < board[0].length; i++) {\n        if (board[0][i] == p && board[1][i] == p && board[2][i] == p) {\n          return p;\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == p && board[1][1] == p && board[2][2] == p) {\n        return p;\n      }\n      if (board[0][2] == p && board[1][1] == p && board[2][0] == p) {\n        return p;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int r = 0; r < board.length; r++) {\n      ret[r] = Arrays.copyOf(board[r], board[r].length);\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int r, int c) {\n    validateRowCol(r, c);\n    return board[r][c];\n  }\n\n  private static void validateRowCol(int r, int c) {\n    if (r < 0 || r > 2 || c < 0 || c > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + r + \",\" + c);\n    }\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard()).map(\n      row -> \" \" + Arrays.stream(row).map(\n        p -> p == null ? \" \" : p.toString()).collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\tttview-1335\\src\\cs3500\\tictactoe\\TicTacToeModel.java","mask_span":[2288,3153],"topics":["strategy","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0046]  extends JPanel, and override its paintComponent method to draw whatever you want, just to confirm that it works.\n\nNext, enhance the IView interface so you can pass the relevant information from the model, through the controller, into the view and into your TurtlePanel class. Once you’ve connected the pieces, use this information in your paintComponent implementation to draw the turtle’s trace.\n\nThe links at the top of the lecture include a “solution” implementation; do not to look at that until you’ve tried to implement this yourself.\n\nThe IView interface contains one method for setting up an event listener. What is its signature? Does it seem like a high-level event to you, or a low-level one? If you think it’s too low-level, can you think of a better, higher-level signature to use? If y\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport javax.swing.JFrame;\n\npublic class TTTFrame extends JFrame implements TTTView {\n\n  public TTTFrame(ReadonlyTTTModel model) {\n    super();\n    this.setSize(900, 900);\n    this.setDefaultCloseOperation(EXIT_ON_CLOSE);\n    TTTPanel panel = new TTTPanel(model);\n    this.add(panel);\n  }\n\n  @Override\n  public void refresh() {\n    this.repaint();\n  }\n\n  @Override\n  public void makeVisible() {\n    this.setVisible(true);\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void subscribe(ViewActions observer) {\n    this.panel.subscribe(observer);\n    \/\/TODO: Add KeyListener here\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\tttview-1335\\src\\cs3500\\tictactoe\\TTTFrame.java","mask_span":[468,586],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\npublic class TTTGUIController implements TicTacToeController, ViewActions {\n\n  private TicTacToe model;\n  private TTTView view;\n\n  private int row, col;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void playGame(TicTacToe m) {\n    \/\/check if model is null and throw IAE if so\n    this.model = m;\n    this.view.subscribe(this);\n    this.view.makeVisible();\n  }\n\n  @Override\n  public void click(int row, int col) {\n    this.row = row;\n    this.col = col;\n  }\n\n  @Override\n  public void confirm() {\n    model.move(row, col);\n    row = -1;\n    col = -1;\n    view.refresh();\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TTTGUIController(TTTView view) {\n    \/\/Check if view is null and throw IAE if so\n    this.view = view;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\tttview-1335\\src\\cs3500\\tictactoe\\TTTGUIController.java","mask_span":[183,296],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\npublic class TTTGUIController implements TicTacToeController, ViewActions {\n\n  private TicTacToe model;\n  private TTTView view;\n\n  private int row, col;\n\n  public TTTGUIController(TTTView view) {\n    \/\/Check if view is null and throw IAE if so\n    this.view = view;\n  }\n\n  @Override\n  public void playGame(TicTacToe m) {\n    \/\/check if model is null and throw IAE if so\n    this.model = m;\n    this.view.subscribe(this);\n    this.view.makeVisible();\n  }\n\n  @Override\n  public void click(int row, int col) {\n    this.row = row;\n    this.col = col;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void confirm() {\n    model.move(row, col);\n    row = -1;\n    col = -1;\n    view.refresh();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\tttview-1335\\src\\cs3500\\tictactoe\\TTTGUIController.java","mask_span":[593,694],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0046]  extends JPanel, and override its paintComponent method to draw whatever you want, just to confirm that it works.\n\nNext, enhance the IView interface so you can pass the relevant information from the model, through the controller, into the view and into your TurtlePanel class. Once you’ve connected the pieces, use this information in your paintComponent implementation to draw the turtle’s trace.\n\nThe links at the top of the lecture include a “solution” implementation; do not to look at that until you’ve tried to implement this yourself.\n\nThe IView interface contains one method for setting up an event listener. What is its signature? Does it seem like a high-level event to you, or a low-level one? If you think it’s too low-level, can you think of a better, higher-level signature to use? If y\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0002] t extends JPanel and overrides paintComponent that draws the game board and game status. Status includes indicating whose turn it is, and if the game is over, who won (or if it was a tie).\na class that extends MouseAdapter and overrides mouseClicked to capture a click on the game board and pass it to the controller.\nYou will also need to fill in the parts of the main method in Main.java as noted in the comments in that method.\n\n2 Testing\nTest your view by running it, inspecting the view, clicking on the game board and playing the game. No automated tests here.\n\n3 Notes to Keep in Mind\nYou will likely want to refer to the sample code on graphical programs, such as the Turtle Graphics example (see the \"solution code\" link).\nSubmit your zip containing only your src directory to In-class Exerc\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.awt.*;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Point2D;\n\nimport javax.swing.JPanel;\n\npublic class TTTPanel extends JPanel {\n\n  private final ReadonlyTTTModel model;\n\n  public TTTPanel(ReadonlyTTTModel model) {\n    \/\/Should check if it's null and if so, throw an IAE\n    this.model = model;\n  }\n\n  @Override\n  protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n    Graphics2D g2d = (Graphics2D)g.create();\n    \/\/Now we can draw stuff\n\n    g2d.transform(getLogicalToPhysicalXForm());\n\n    int width = this.getWidth();\n    int height = this.getHeight();\n\n    drawLine(g2d, 1, 0, 1, 3);\n    drawLine(g2d, 2, 0, 2, 3);\n    drawLine(g2d, 0, 1, 3, 1);\n    drawLine(g2d, 0, 2, 3, 2);\n\n    \/\/g2d.setColor(Color.RED);\n    \/\/g2d.drawLine(0,0, width, height);\n\n    \/\/drawMarks(g2d);\n  }\n\n  private void drawLine(Graphics2D g2d, int srcRow, int srcCol,\n                        int dstRow, int dstCol) {\n    AffineTransform modelToLogical = getModelToLogicalXForm();\n    Point2D src = modelToLogical.transform(new Point(srcCol, srcRow), null);\n    Point2D dst = modelToLogical.transform(new Point(dstCol, dstRow), null);\n\n    g2d.drawLine((int)src.getX(),\n        (int)src.getY(),\n        (int)dst.getX(),\n        (int)dst.getY());\n  }\n\n  private Dimension getLogicalDimensions() {\n    return new Dimension(30, 30);\n  }\n\n  private AffineTransform getLogicalToPhysicalXForm() {\n    AffineTransform xform = new AffineTransform();\n    xform.scale(this.getWidth() \/ getLogicalDimensions().getWidth(),\n        this.getHeight() \/ getLogicalDimensions().getHeight());\n    return xform;\n  }\n\n  private AffineTransform getModelToLogicalXForm() {\n    AffineTransform xform = new AffineTransform();\n    xform.scale(getLogicalDimensions().getWidth() \/ 3,\n        getLogicalDimensions().getHeight() \/ 3);\n    return xform;\n  }\n\n  private AffineTransform getModelToPhysicalXForm() {\n    AffineTransform xform = new AffineTransform();\n    xform.scale(this.getWidth()\/3, this.getHeight()\/3);\n    return xform;\n  }\n\n  private void drawMarks(Graphics2D g2d) {\n    for(int row = 0; row < 3; row++) {\n      for(int col = 0; col < 3; col++) {\n        int xPos = (col * this.getWidth())\/3;\n        int yPos = (row * this.getHeight())\/3;\n        g2d.drawOval(xPos, yPos, 30, 30);\n      }\n    }\n  }\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void subscribe(ViewActions observer) {\n    this.addMouseListener(new MouseListener() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        AffineTransform physicalToLogical = getLogicalToPhysicalXForm();\n        physicalToLogical.invert();\n      }\n\n      @Override\n      public void mousePressed(MouseEvent e) {\n\n      }\n\n      @Override\n      public void mouseReleased(MouseEvent e) {\n\n      }\n\n      @Override\n      public void mouseEntered(MouseEvent e) {\n\n      }\n\n      @Override\n      public void mouseExited(MouseEvent e) {\n\n      }\n    });\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\tttview-1335\\src\\cs3500\\tictactoe\\TTTPanel.java","mask_span":[2415,2992],"topics":["observer","gui","adapter","decorator","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\n\/**\n * Run a Tic Tac Toe game interactively.\n *\/\npublic class Main {\n  \/**\n   * Run a Tic Tac Toe game interactively.\n   *\/\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    \/\/ Old News: console-based game:\n    \/\/new TicTacToeConsoleController(new InputStreamReader(System.in),\n    \/\/    System.out).playGame(new TicTacToeModel());\n\n    \/\/ New Hotness: Graphical User Interface:\n    \/\/ 1. Create an instance of the model.\n    TicTacToe model = new TicTacToeModel();\n    \/\/ 2. Create an instance of the view.\n    TTTView view = new TTTFrame(model);\n    \/\/ 3. Create an instance of the controller, passing the view to its constructor.\n    TicTacToeController controller =\n        new TicTacToeGUIController(view);\n    \/\/ 4. Call playGame() on the controller.\n    controller.playGame(model);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\ttt-with-interaction\\src\\cs3500\\tictactoe\\Main.java","mask_span":[153,816],"topics":["gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.io.IOException;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class TicTacToeConsoleController implements TicTacToeController {\n\n  private final Appendable out;\n  private final Scanner scan;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void playGame(TicTacToe m) {\n    try {\n      appendStateAndPrompt(m);\n      Integer mvRow = null;\n      Integer mvCol = null;\n      String tok = \"\";\n      while (!m.isGameOver()) {\n        tok = scan.next();\n        if (tok.equalsIgnoreCase(\"q\")) {\n          break;\n        }\n        try {\n          int v = Integer.parseInt(tok);\n          if (mvRow == null) {\n            mvRow = v;\n          } else {\n            mvCol = v;\n            m.move(mvRow - 1, mvCol - 1);\n            if(m.isGameOver()) {\n              out.append(m.toString()).append(\"\\n\");\n              out.append(\"Game is over! \");\n              if(m.getWinner() != null) {\n                out.append(m.getWinner().toString() + \" wins.\\n\");\n              } else {\n                out.append(\"Tie game.\\n\");\n              }\n              break;\n            }\n            appendStateAndPrompt(m);\n            mvRow = mvCol = null;\n          }\n        } catch (NumberFormatException nfe) {\n          out.append(\"Not a valid number: \" + tok).append(\"\\n\");\n        } catch (IllegalArgumentException iae) {\n          out.append(\"Not a valid move: \" + mvRow + \", \" + mvCol).append(\"\\n\");\n          mvRow = mvCol = null;\n        }\n      }\n      if (!m.isGameOver() && tok.equalsIgnoreCase(\"q\")) {\n        out.append(\"Game quit! Ending game state:\\n\" + m.toString() + \"\\n\");\n      } else if (!m.isGameOver()) {\n        throw new IllegalStateException(\"Ran out of inputs\");\n      }\n    } catch (IOException ioe) {\n      scan.close();\n      throw new IllegalStateException(\"append failed\", ioe);\n    } catch (NoSuchElementException e) {\n      throw new IllegalStateException(\"failed to read from readable\");\n    }\n    scan.close();\n  }\n\n  private void appendStateAndPrompt(TicTacToe m) throws IOException {\n    out.append(m.toString()).append(\"\\n\");\n    out.append(\"Enter a move for \" + m.getTurn().toString()).append(\":\\n\");\n  }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeConsoleController(Readable in, Appendable out) {\n    if (in == null || out == null) {\n      throw new IllegalArgumentException(\"Readable and Appendable can't be null\");\n    }\n    this.out = out;\n    scan = new Scanner(in);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\ttt-with-interaction\\src\\cs3500\\tictactoe\\TicTacToeConsoleController.java","mask_span":[262,504],"topics":["gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\npublic class TicTacToeGUIController implements TicTacToeController, ViewActions {\n\n  private final TTTView view;\n  private TicTacToe model;\n  public TicTacToeGUIController(TTTView view) {\n    this.view = view;\n  }\n\n  @Override\n  public void playGame(TicTacToe m) {\n    this.model = m;\n    this.view.addClickListener(this);\n    this.view.makeVisible();\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void handleCellClick(int row, int col) {\n    try {\n      model.move(row, col);\n    } catch (IllegalArgumentException ex) {\n      \/\/tell the user somehow the arguments were wrong\n    } catch (IllegalStateException ex) {\n      \/\/tell the user somehow they made a mistake choosing a cell\n      \/\/or the game is over\n    }\n    view.refresh();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\ttt-with-interaction\\src\\cs3500\\tictactoe\\TicTacToeGUIController.java","mask_span":[398,747],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n\/**\n * Represents a single game of Tic Tac Toe. Three in a row down\/across\/diagonally to win; X goes\n * first.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n  private final Player[][] board;\n  private Player turn;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void move(int r, int c) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(r, c);\n    if (board[r][c] != null) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[r][c] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (Player[] row : board) {\n      if (Arrays.stream(row).anyMatch(Objects::isNull)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (Player p : Player.values()) {\n      \/\/ check horizontals\n      for (Player[] row : board) {\n        if(Arrays.stream(row).allMatch(m -> m == p)) {\n          return p;\n        }\n      }\n      \/\/ check verticals\n      for (int i = 0; i < board[0].length; i++) {\n        if (board[0][i] == p && board[1][i] == p && board[2][i] == p) {\n          return p;\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == p && board[1][1] == p && board[2][2] == p) {\n        return p;\n      }\n      if (board[0][2] == p && board[1][1] == p && board[2][0] == p) {\n        return p;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int r = 0; r < board.length; r++) {\n      ret[r] = Arrays.copyOf(board[r], board[r].length);\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int r, int c) {\n    validateRowCol(r, c);\n    return board[r][c];\n  }\n\n  private static void validateRowCol(int r, int c) {\n    if (r < 0 || r > 2 || c < 0 || c > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + r + \",\" + c);\n    }\n  }\n\n  @Override\n  public String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard()).map(\n      row -> \" \" + Arrays.stream(row).map(\n        p -> p == null ? \" \" : p.toString()).collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\ttt-with-interaction\\src\\cs3500\\tictactoe\\TicTacToeModel.java","mask_span":[341,421],"topics":["strategy","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n\/**\n * Represents a single game of Tic Tac Toe. Three in a row down\/across\/diagonally to win; X goes\n * first.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n  private final Player[][] board;\n  private Player turn;\n\n  public TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n\n  @Override\n  public void move(int r, int c) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(r, c);\n    if (board[r][c] != null) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[r][c] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (Player[] row : board) {\n      if (Arrays.stream(row).anyMatch(Objects::isNull)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (Player p : Player.values()) {\n      \/\/ check horizontals\n      for (Player[] row : board) {\n        if(Arrays.stream(row).allMatch(m -> m == p)) {\n          return p;\n        }\n      }\n      \/\/ check verticals\n      for (int i = 0; i < board[0].length; i++) {\n        if (board[0][i] == p && board[1][i] == p && board[2][i] == p) {\n          return p;\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == p && board[1][1] == p && board[2][2] == p) {\n        return p;\n      }\n      if (board[0][2] == p && board[1][1] == p && board[2][0] == p) {\n        return p;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int r = 0; r < board.length; r++) {\n      ret[r] = Arrays.copyOf(board[r], board[r].length);\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int r, int c) {\n    validateRowCol(r, c);\n    return board[r][c];\n  }\n\n  private static void validateRowCol(int r, int c) {\n    if (r < 0 || r > 2 || c < 0 || c > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + r + \",\" + c);\n    }\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard()).map(\n      row -> \" \" + Arrays.stream(row).map(\n        p -> p == null ? \" \" : p.toString()).collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\ttt-with-interaction\\src\\cs3500\\tictactoe\\TicTacToeModel.java","mask_span":[2288,3153],"topics":["strategy","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0002] t extends JPanel and overrides paintComponent that draws the game board and game status. Status includes indicating whose turn it is, and if the game is over, who won (or if it was a tie).\na class that extends MouseAdapter and overrides mouseClicked to capture a click on the game board and pass it to the controller.\nYou will also need to fill in the parts of the main method in Main.java as noted in the comments in that method.\n\n2 Testing\nTest your view by running it, inspecting the view, clicking on the game board and playing the game. No automated tests here.\n\n3 Notes to Keep in Mind\nYou will likely want to refer to the sample code on graphical programs, such as the Turtle Graphics example (see the \"solution code\" link).\nSubmit your zip containing only your src directory to In-class Exerc\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport javax.swing.*;\n\npublic class TTTFrame extends JFrame implements TTTView {\n\n  private TTTPanel panel;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void addClickListener(ViewActions observer) {\n    panel.addClickListener(observer);\n  }\n\n  @Override\n  public void refresh() {\n    this.repaint();\n  }\n\n  @Override\n  public void makeVisible() {\n    setVisible(true);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TTTFrame(ReadonlyTTTModel model) {\n    super();\n    setSize(800, 800);\n    setDefaultCloseOperation(EXIT_ON_CLOSE);\n    panel = new TTTPanel(model);\n    this.add(panel);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\ttt-with-interaction\\src\\cs3500\\tictactoe\\TTTFrame.java","mask_span":[138,318],"topics":["observer","gui","adapter","decorator","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0046]  extends JPanel, and override its paintComponent method to draw whatever you want, just to confirm that it works.\n\nNext, enhance the IView interface so you can pass the relevant information from the model, through the controller, into the view and into your TurtlePanel class. Once you’ve connected the pieces, use this information in your paintComponent implementation to draw the turtle’s trace.\n\nThe links at the top of the lecture include a “solution” implementation; do not to look at that until you’ve tried to implement this yourself.\n\nThe IView interface contains one method for setting up an event listener. What is its signature? Does it seem like a high-level event to you, or a low-level one? If you think it’s too low-level, can you think of a better, higher-level signature to use? If y\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0002] t extends JPanel and overrides paintComponent that draws the game board and game status. Status includes indicating whose turn it is, and if the game is over, who won (or if it was a tie).\na class that extends MouseAdapter and overrides mouseClicked to capture a click on the game board and pass it to the controller.\nYou will also need to fill in the parts of the main method in Main.java as noted in the comments in that method.\n\n2 Testing\nTest your view by running it, inspecting the view, clicking on the game board and playing the game. No automated tests here.\n\n3 Notes to Keep in Mind\nYou will likely want to refer to the sample code on graphical programs, such as the Turtle Graphics example (see the \"solution code\" link).\nSubmit your zip containing only your src directory to In-class Exerc\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport java.awt.*;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.NoninvertibleTransformException;\nimport java.awt.geom.Point2D;\n\nimport javax.swing.*;\n\npublic class TTTPanel extends JPanel {\n  private final ReadonlyTTTModel model;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n    Graphics2D g2d = (Graphics2D)g.create();\n\n    g2d.transform(transformFromLogicalToPhysical());\n\n    \/\/Two options:\n    \/\/Either set a stroke width so the lines for shapes\n    \/\/look nice\n    \/\/OR find a scalable constant to multiply every coordinate number by\n    \/\/to fit in the intermediate coordinates.\n    \/\/g2d.setStroke(new BasicStroke(0.05f));\n\n    drawBoardState(g2d);\n    drawGridLines(g2d);\n\n  }\n\n  private void drawGridLines(Graphics2D g2d) {\n    drawLine(g2d, new Point(1, 0), new Point(1, 3));\n    drawLine(g2d, new Point(2, 0), new Point(2, 3));\n    drawLine(g2d, new Point(0, 1), new Point(3, 1));\n    drawLine(g2d, new Point(0, 2), new Point(3, 2));\n  }\n\n\n\n  public Dimension getPreferredLogicalSize() {\n    return new Dimension(30, 30);\n  }\n\n  public Dimension getPreferredModelSize() {\n    return new Dimension(3, 3);\n  }\n\n  private AffineTransform transformFromLogicalToPhysical() {\n    AffineTransform xform = new AffineTransform();\n    Dimension preferred = this.getPreferredLogicalSize();\n    xform.scale(this.getWidth() \/ preferred.getWidth(),\n        this.getHeight() \/ preferred.getHeight());\n    return xform;\n  }\n\n  private AffineTransform transformModelToLogical() {\n    AffineTransform xform = new AffineTransform();\n    Dimension preferred = this.getPreferredLogicalSize();\n    Dimension preferredModel = this.getPreferredModelSize();\n    xform.scale(preferred.getWidth() \/ preferredModel.getWidth(),\n        preferred.getHeight() \/ preferredModel.getHeight());\n    return xform;\n  }\n\n  \/\/Draw the board state\n  private void drawBoardState(Graphics2D g2d) {\n    Player[][] board = model.getBoard();\n    for(int row = 0; row < board.length; row++) {\n      for(int col = 0; col < board[0].length; col++) {\n        if(board[row][col] != null) {\n          drawPlayer(g2d, row, col, board[row][col]);\n        }\n      }\n    }\n  }\n\n  private void drawPlayer(Graphics2D g2d, int row, int col, Player player) {\n    Color oldColor = g2d.getColor();\n\n    switch(player) {\n      case X:\n        g2d.setColor(Color.BLACK);\n        drawLine(g2d, new Point(col, row), new Point(col+1, row+1));\n        drawLine(g2d, new Point(col+1, row), new Point(col, row+1));\n        break;\n      case O:\n        g2d.setColor(Color.RED);\n        drawOval(g2d, new Point(col, row), 1, 1);\n        break;\n      default:\n        \/\/draw nothing\n        break;\n    }\n\n    g2d.setColor(oldColor);\n\n  }\n\n  private void drawLine(Graphics2D g2d, Point2D src, Point2D dst) {\n    Point2D logicalSrc = transformModelToLogical().transform(src, null);\n    Point2D logicalDst = transformModelToLogical().transform(dst, null);\n    g2d.drawLine((int)logicalSrc.getX(),\n        (int)logicalSrc.getY(),\n        (int)logicalDst.getX(),\n        (int)logicalDst.getY());\n  }\n\n  private void drawOval(Graphics2D g2d, Point leftCorner, int width, int height) {\n    Point2D logicalLeftCorner = transformModelToLogical().transform(leftCorner, null);\n    Point2D logicalDimensions = transformModelToLogical().transform(new Point(width, height), null);\n    g2d.drawOval((int)logicalLeftCorner.getX(), (int)logicalLeftCorner.getY(),\n        (int)logicalDimensions.getX(), (int)logicalDimensions.getY());\n  }\n\n\n\n  public void addClickListener(ViewActions observer) {\n    this.addMouseListener(new MouseListener() { \/\/anonymous class. Can do inner instead\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        try {\n          AffineTransform physicalToLogical = transformFromLogicalToPhysical();\n          physicalToLogical.invert();\n\n          AffineTransform logicalToModel = transformModelToLogical();\n          logicalToModel.invert();\n\n          Point2D evtPt = e.getPoint();\n          Point2D modelPt = physicalToLogical.transform(evtPt, null);\n          logicalToModel.transform(modelPt, modelPt);\n\n          observer.handleCellClick((int)modelPt.getY(),\n              (int)modelPt.getX());\n        } catch (NoninvertibleTransformException ex) {\n          throw new RuntimeException(ex);\n        }\n      }\n\n      @Override\n      public void mousePressed(MouseEvent e) {\n\n      }\n\n      @Override\n      public void mouseReleased(MouseEvent e) {\n\n      }\n\n      @Override\n      public void mouseEntered(MouseEvent e) {\n\n      }\n\n      @Override\n      public void mouseExited(MouseEvent e) {\n\n      }\n    });\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TTTPanel(ReadonlyTTTModel model) {\n    super();\n    this.model = model;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\ttt-with-interaction\\src\\cs3500\\tictactoe\\TTTPanel.java","mask_span":[344,426],"topics":["observer","gui","adapter","decorator","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0015] acingTurtleModel m) {\n    m.trace(this.d);\n  }\n\n  ...\n\n}\nNow we can change the logic of our controller to:\n\nTake a one-word command from the user.\nCreate the corresponding TracingTurtleCommand object..\nExecute the command object.\nString in = s.next();\ntry {\n  switch (in) {\n    case \"q\":\n    case \"quit\":\n      return;\n   case \"show\":\n     for (Line l : m.getLines()) {\n        System.out.println(l);\n     }\n     break;\n   case \"move\":\n      cmd = new Move(s.nextDouble());\n      break;\n   case \"trace\":\n      cmd = new Trace(s.nextDouble());\n      break;\n   case \"turn\":\n      cmd = new Turn(s.nextDouble());\n      break;\n   case \"square\":\n      cmd = new Square(s.nextDouble());\n      break;\n   default:\n      System.out.println(String.format(\"Unknown command %s\", in));\n      cmd = null;\n      bre\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control;\n\nimport java.util.List;\nimport java.util.Scanner;\n\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16. Edited by lnunez on 02\/05\/24.\n *\/\npublic class SimpleController {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    Scanner scan = new Scanner(System.in);\n    TracingTurtleModel model = new SmarterTurtle();\n    \/\/TODO: Add the controller into this method\n    while(scan.hasNext()) {\n      \/\/1. Read a command\n      \/\/String cmd = scan.next();\n      \/\/2. Process the command\n\n      switch(scan.next()) { \/\/Can make it lowercase\n        case \"Q\":\n        case \"q\":\n          return;\n        case \"move\":\n          model.move(scan.nextDouble());\n          break;\n        case \"trace\":\n          model.trace(scan.nextDouble());\n          break;\n        case \"square\":\n          double length = scan.nextDouble();\n          model.trace(length);\n          model.turn(90);\n          model.trace(length);\n          model.turn(90);\n          model.trace(length);\n          model.turn(90);\n          model.trace(length);\n          model.turn(90);\n      }\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-design-1030\\src\\cs3500\\turtle\\control\\SimpleController.java","mask_span":[293,1176],"topics":["command","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0003] \n\n\/**\n * This class represents a 2D position\n *\/\npublic final class Position2D {\n  private final double x;\n  private final double y;\n\n  \/**\n   * Initialize this object to the specified position\n   *\/\n  public Position2D(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  \/**\n   * Copy constructor\n   *\/\n  public Position2D(Position2D v) {\n    this(v.x, v.y);\n  }\n\n\n\n  public double getX() {\n    return x;\n  }\n\n  public double getY() {\n    return y;\n  }\n\n\n  @Override\n  public String toString() {\n    return String.format(\"(%f, %f)\", this.x, this.y);\n  }\n\n  @Override\n  public boolean equals(Object a) {\n    if (this == a) {\n      return true;\n    }\n    if (!(a instanceof Position2D)) {\n      return false;\n    }\n\n    Position2D that = (Position2D) a;\n\n    return ((Math.abs(this.x - that.x\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.model;\n\nimport java.util.Objects;\n\n\/**\n * This class represents a 2D position\n *\/\n\n\/\/VALUE CLASS: a class that exists to hold immutable values\n\/\/ Value class don't need an interface AND they should be final\npublic final class Position2D {\n  private final double x;\n\n  public double getX() {\n    return x;\n  }\n\n  public double getY() {\n    return y;\n  }\n\n  private final double y;\n\n  \/**\n   * Initialize this object to the specified position\n   *\/\n  public Position2D(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  \/**\n   * Copy constructor\n   *\/\n  public Position2D(Position2D v) {\n    this(v.x, v.y);\n  }\n\n  @Override\n  public String toString() {\n    return String.format(\"(%f, %f)\", this.x, this.y);\n  }\n\n  @Override\n  public boolean equals(Object a) {\n    if (this == a) {\n      return true;\n    }\n    if (!(a instanceof Position2D)) {\n      return false;\n    }\n\n    Position2D that = (Position2D) a;\n\n    return ((Math.abs(this.x - that.x) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-design-1030\\src\\cs3500\\turtle\\model\\Position2D.java","mask_span":[1047,1115],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.model;\n\nimport java.util.Objects;\nimport java.util.Stack;\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n  }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic SimpleTurtle() {\n    this(new Position2D(0, 0), 0);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-design-1030\\src\\cs3500\\turtle\\model\\SimpleTurtle.java","mask_span":[626,688],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.tracingmodel;\n\nimport java.util.Objects;\n\nimport cs3500.turtle.model.Position2D;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic final class Line {\n  public final Position2D start;\n  public final Position2D end;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public String toString() {\n    return String.format(\"%s--%s\", this.start.toString(), this.end.toString());\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (!(o instanceof Line)) {\n      return false;\n    }\n\n    Line line = (Line) o;\n\n    return (this.start.equals(line.start) && this.end.equals(line.end))\n            || (this.end.equals(line.start) && this.start.equals(line.end));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.start, this.end);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic Line(Position2D start, Position2D end) {\n    this.start = start;\n    this.end = end;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-design-1030\\src\\cs3500\\turtle\\tracingmodel\\Line.java","mask_span":[240,335],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.tracingmodel;\n\nimport java.util.Objects;\n\nimport cs3500.turtle.model.Position2D;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic final class Line {\n  public final Position2D start;\n  public final Position2D end;\n\n  public Line(Position2D start, Position2D end) {\n    this.start = start;\n    this.end = end;\n  }\n\n  @Override\n  public String toString() {\n    return String.format(\"%s--%s\", this.start.toString(), this.end.toString());\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (!(o instanceof Line)) {\n      return false;\n    }\n\n    Line line = (Line) o;\n\n    return (this.start.equals(line.start) && this.end.equals(line.end))\n            || (this.end.equals(line.start) && this.start.equals(line.end));\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic int hashCode() {\n    return Objects.hash(this.start, this.end);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-design-1030\\src\\cs3500\\turtle\\tracingmodel\\Line.java","mask_span":[811,885],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.tracingmodel;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.model.SimpleTurtle;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public List<Line> getLines() {\n    return new ArrayList<>(lines);\n  }\n\n  \/\/list of lines traced since this object was created\n  List<Line> lines;\n\n}\n\n\n\/*\n10\/03 : Misc topics (testing, toString, Pile abstractions, Readable\/Appendable)\n\n10\/05: Encapsulation and invariants\n\nHw3\n\n10\/10: columbus day\n\n10\/12: Design problem (Turtles) -- talk through modelling of nouns (get to positions, lines?, turtles, tracing turtles extend simple turtles), get up to Commands as an abstraction, but not undoable ones, set up keyboard map but don't do it yet\n\nHW4 due 10\/14\n\n10\/17: Inheritance and composition\n\n10\/19: Intro to performance, More about performance\n\nHw5 due\n\n10\/24: First exam\n\n10\/26: Design discussion of music  models\n\n10\/31: Class activity: GUI (bad, basic mvc examples), MIDI\n\n11\/02: Adapters\n\nHw6 due on 11\/7\n\n11\/07: Commands\n\n11\/09: Commands (Class activity: adapters (Turtles))\n\n11\/14: Strategy (and decorator?) patterns\n\n\n11\/16: XXX (Command\/Observer)\n\n11\/21: XXX (Singleton\/Iterator\/Proxy)\n\nHw7 due 11\/21\n\n11\/28: Intro to Javascript\n\n11\/30: Javascript inheritance and patterns\n\n12\/05: Exam review\n\n12\/07: Promises\/Android\n\n\n\nadapters, strategy - TicTacToe, command - move, turn, ...square, ...fractal, undoable?\n\n\n\n\nPosition2D exists\nTurtleModel interface exists\nSimpleTurtle exists\n\ntalk-through SimpleTurtle\n\nmotivate tracing\n\ndesign TracingTurtleModel -- is it a TurtleModel? yes, so extend interface\nimplement SmarterTurtle -- extend or delegate?  either way will work, but inheritance is simpler\n\nmotivate the command-line controller\n\ndesign the controller with hard-coded switch with hard-coded method calls (move, turn, trace)\n\nhave some simple tests\n\nadd a new square case\n\ntest??? introduce Commands\n\n\n *\/\n<\/CodeSuffix>","target":"<Target>\npublic SmarterTurtle() {\n    super();\n    lines = new ArrayList<>();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-design-1030\\src\\cs3500\\turtle\\tracingmodel\\SmarterTurtle.java","mask_span":[295,367],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.tracingmodel;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.model.SimpleTurtle;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/\/list of lines traced since this object was created\n  List<Line> lines;\n\n}\n\n\n\/*\n10\/03 : Misc topics (testing, toString, Pile abstractions, Readable\/Appendable)\n\n10\/05: Encapsulation and invariants\n\nHw3\n\n10\/10: columbus day\n\n10\/12: Design problem (Turtles) -- talk through modelling of nouns (get to positions, lines?, turtles, tracing turtles extend simple turtles), get up to Commands as an abstraction, but not undoable ones, set up keyboard map but don't do it yet\n\nHW4 due 10\/14\n\n10\/17: Inheritance and composition\n\n10\/19: Intro to performance, More about performance\n\nHw5 due\n\n10\/24: First exam\n\n10\/26: Design discussion of music  models\n\n10\/31: Class activity: GUI (bad, basic mvc examples), MIDI\n\n11\/02: Adapters\n\nHw6 due on 11\/7\n\n11\/07: Commands\n\n11\/09: Commands (Class activity: adapters (Turtles))\n\n11\/14: Strategy (and decorator?) patterns\n\n\n11\/16: XXX (Command\/Observer)\n\n11\/21: XXX (Singleton\/Iterator\/Proxy)\n\nHw7 due 11\/21\n\n11\/28: Intro to Javascript\n\n11\/30: Javascript inheritance and patterns\n\n12\/05: Exam review\n\n12\/07: Promises\/Android\n\n\n\nadapters, strategy - TicTacToe, command - move, turn, ...square, ...fractal, undoable?\n\n\n\n\nPosition2D exists\nTurtleModel interface exists\nSimpleTurtle exists\n\ntalk-through SimpleTurtle\n\nmotivate tracing\n\ndesign TracingTurtleModel -- is it a TurtleModel? yes, so extend interface\nimplement SmarterTurtle -- extend or delegate?  either way will work, but inheritance is simpler\n\nmotivate the command-line controller\n\ndesign the controller with hard-coded switch with hard-coded method calls (move, turn, trace)\n\nhave some simple tests\n\nadd a new square case\n\ntest??? introduce Commands\n\n\n *\/\n<\/CodeSuffix>","target":"<Target>\npublic List<Line> getLines() {\n    return new ArrayList<>(lines);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-design-1030\\src\\cs3500\\turtle\\tracingmodel\\SmarterTurtle.java","mask_span":[551,620],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle;\n\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.model.SimpleTurtle;\nimport cs3500.turtle.model.TurtleModel;\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\nimport static org.junit.Assert.*;\n\n\/**\n * Created by ashesh on 5\/23\/2016.\n *\/\npublic final class SmarterTurtleTest {\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void testDrawSomething() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    Position2D p1 = t.getPosition();\n    t.save();\n    t.turn(45);\n    t.trace(10);\n    t.retrieve();\n\n    t.save();\n    t.turn(135);\n    t.trace(10);\n    t.retrieve();\n\n    t.save();\n    t.turn(-90);\n    t.trace(10);\n    t.retrieve();\n\n      List<Line> actualLines = t.getLines();\n      List<Line> expectedLines = new ArrayList<>();\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(45.0)), 10.0 * Math.sin(Math.toRadians(45.0)))));\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(135.0)), 10.0 * Math.sin(Math.toRadians(135.0)))));\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(-90)), 10.0 * Math.sin(Math.toRadians(-90)))));\n\n      assertEquals(expectedLines.size(), actualLines.size());\n\n      for (int i = 0; i < expectedLines.size(); i++) {\n        assertEquals(expectedLines.get(i), actualLines.get(i));\n    }\n  }\n\n  @Test\n  public void testInit() {\n    TurtleModel t = new SimpleTurtle();\n\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testMove() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.move(10);\n    assertEquals(10.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTurnOnly() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.turn(10);\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n\n\n    t.turn(-100);\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTurnAndMove() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.turn(30);\n    t.move(10);\n    assertEquals(10.0 * Math.cos(Math.toRadians(30)), t.getPosition().getX(), 0.001);\n    assertEquals(10.0 * Math.sin(Math.toRadians(30)), t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTrace() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    t.trace(10);\n    List<Line> lines = t.getLines();\n    assertEquals(1, lines.size());\n    assertEquals(0.0, lines.get(0).start.getX(), 0.001);\n    assertEquals(0.0, lines.get(0).start.getY(), 0.001);\n    assertEquals(10.0, lines.get(0).end.getX(), 0.001);\n    assertEquals(0.0, lines.get(0).end.getY(), 0.001);\n  }\n\n  @Test\n  public void testMultipleTrace() {\n    TracingTurtleModel t = new SmarterTurtle();\n    List<Line> expectedLines = new ArrayList<>();\n    for (int i = 0; i < 10; i++) {\n      t.turn(90);\n      t.trace(10);\n      t.turn(-90);\n      t.trace(10);\n      t.turn(-90);\n      t.trace(10);\n      t.turn(90);\n      t.trace(10);\n      expectedLines.add(new Line(new Position2D(20 * i, 0),\n                                 new Position2D(20 * i, 10)));\n\n      expectedLines.add(new Line(new Position2D(20 * i, 10),\n                                 new Position2D(20 * i + 10, 10)));\n\n      expectedLines.add(new Line(new Position2D(20 * i + 10, 10),\n                                 new Position2D(20 * i + 10, 0)));\n\n      expectedLines.add(new Line(new Position2D(20 * i + 10, 0),\n                                 new Position2D(20 * i + 20, 0)));\n    }\n\n    List<Line> actualLines = t.getLines();\n    assertEquals(expectedLines.size(), actualLines.size());\n    for (int i = 0; i < expectedLines.size(); i++) {\n      assertEquals(expectedLines.get(i), actualLines.get(i));\n    }\n  }\n\n  @Test\n  public void testPush() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.move(10);\n    Position2D initPosition = t.getPosition();\n    t.save();\n    t.turn(90);\n    t.move(10);\n    t.retrieve();\n    Position2D finalPosition = t.getPosition();\n    assertEquals(initPosition.getX(), finalPosition.getX(), 0.01);\n    assertEquals(finalPosition.getY(), finalPosition.getY(), 0.01);\n  }\n\n}\n<\/CodeSuffix>","target":"<Target>\npublic void testOne() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    t.turn(60);\n    t.trace(19);\n    t.turn(-120);\n    t.trace(19);\n    t.turn(-120);\n    t.trace(19);\n    List<Line> tlines = t.getLines();\n\n    TracingTurtleModel t2 = new SmarterTurtle();\n\n    t2.trace(19);\n    t2.turn(120);\n    t2.trace(19);\n    t2.turn(120);\n    t2.trace(19);\n\n    List<Line> t2lines = t2.getLines();\n\n    assertEquals(tlines.size(), t2lines.size());\n\n    for (Line l : tlines) {\n      assertTrue(t2lines.contains(l));\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-design-1030\\test\\cs3500\\turtle\\SmarterTurtleTest.java","mask_span":[492,1015],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle;\n\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.model.SimpleTurtle;\nimport cs3500.turtle.model.TurtleModel;\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\nimport static org.junit.Assert.*;\n\n\/**\n * Created by ashesh on 5\/23\/2016.\n *\/\npublic final class SmarterTurtleTest {\n\n  @Test\n  public void testOne() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    t.turn(60);\n    t.trace(19);\n    t.turn(-120);\n    t.trace(19);\n    t.turn(-120);\n    t.trace(19);\n    List<Line> tlines = t.getLines();\n\n    TracingTurtleModel t2 = new SmarterTurtle();\n\n    t2.trace(19);\n    t2.turn(120);\n    t2.trace(19);\n    t2.turn(120);\n    t2.trace(19);\n\n    List<Line> t2lines = t2.getLines();\n\n    assertEquals(tlines.size(), t2lines.size());\n\n    for (Line l : tlines) {\n      assertTrue(t2lines.contains(l));\n    }\n  }\n\n  @Test\n  public void testDrawSomething() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    Position2D p1 = t.getPosition();\n    t.save();\n    t.turn(45);\n    t.trace(10);\n    t.retrieve();\n\n    t.save();\n    t.turn(135);\n    t.trace(10);\n    t.retrieve();\n\n    t.save();\n    t.turn(-90);\n    t.trace(10);\n    t.retrieve();\n\n      List<Line> actualLines = t.getLines();\n      List<Line> expectedLines = new ArrayList<>();\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(45.0)), 10.0 * Math.sin(Math.toRadians(45.0)))));\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(135.0)), 10.0 * Math.sin(Math.toRadians(135.0)))));\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(-90)), 10.0 * Math.sin(Math.toRadians(-90)))));\n\n      assertEquals(expectedLines.size(), actualLines.size());\n\n      for (int i = 0; i < expectedLines.size(); i++) {\n        assertEquals(expectedLines.get(i), actualLines.get(i));\n    }\n  }\n\n  @Test\n  public void testInit() {\n    TurtleModel t = new SimpleTurtle();\n\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testMove() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.move(10);\n    assertEquals(10.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTurnOnly() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.turn(10);\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n\n\n    t.turn(-100);\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTurnAndMove() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.turn(30);\n    t.move(10);\n    assertEquals(10.0 * Math.cos(Math.toRadians(30)), t.getPosition().getX(), 0.001);\n    assertEquals(10.0 * Math.sin(Math.toRadians(30)), t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTrace() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    t.trace(10);\n    List<Line> lines = t.getLines();\n    assertEquals(1, lines.size());\n    assertEquals(0.0, lines.get(0).start.getX(), 0.001);\n    assertEquals(0.0, lines.get(0).start.getY(), 0.001);\n    assertEquals(10.0, lines.get(0).end.getX(), 0.001);\n    assertEquals(0.0, lines.get(0).end.getY(), 0.001);\n  }\n\n  @Test\n  public void testMultipleTrace() {\n    TracingTurtleModel t = new SmarterTurtle();\n    List<Line> expectedLines = new ArrayList<>();\n    for (int i = 0; i < 10; i++) {\n      t.turn(90);\n      t.trace(10);\n      t.turn(-90);\n      t.trace(10);\n      t.turn(-90);\n      t.trace(10);\n      t.turn(90);\n      t.trace(10);\n      expectedLines.add(new Line(new Position2D(20 * i, 0),\n                                 new Position2D(20 * i, 10)));\n\n      expectedLines.add(new Line(new Position2D(20 * i, 10),\n                                 new Position2D(20 * i + 10, 10)));\n\n      expectedLines.add(new Line(new Position2D(20 * i + 10, 10),\n                                 new Position2D(20 * i + 10, 0)));\n\n      expectedLines.add(new Line(new Position2D(20 * i + 10, 0),\n                                 new Position2D(20 * i + 20, 0)));\n    }\n\n    List<Line> actualLines = t.getLines();\n    assertEquals(expectedLines.size(), actualLines.size());\n    for (int i = 0; i < expectedLines.size(); i++) {\n      assertEquals(expectedLines.get(i), actualLines.get(i));\n    }\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n<\/CodeSuffix>","target":"<Target>\npublic void testPush() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.move(10);\n    Position2D initPosition = t.getPosition();\n    t.save();\n    t.turn(90);\n    t.move(10);\n    t.retrieve();\n    Position2D finalPosition = t.getPosition();\n    assertEquals(initPosition.getX(), finalPosition.getX(), 0.01);\n    assertEquals(finalPosition.getY(), finalPosition.getY(), 0.01);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-design-1030\\test\\cs3500\\turtle\\SmarterTurtleTest.java","mask_span":[4771,5150],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0001] lative to current position and direction (as the turtle) instead of absolute Cartesian coordinates. For example, driving directions provide navigation relative to the current position and direction (“Drive 0.3 miles”, “Take left onto...”).\n\n1.1 Basic Design\nBased on the basic operations identified above for turtle model, we begin by designing an interface for the model of our program:\n\n\/**\n * This interface specifies the operations on a 2D turtle\n * <p>\n * A 2D turtle is characterized by a position (x,y) and a\n * heading (where it is looking).\n * <p>\n * It can be asked to draw the path it has moved using one of\n * the commands below.\n *\/\npublic interface TurtleModel {\n    \/**\n     * Move the turtle by the specified distance along its\n     * heading. Do not change heading\n     *\n     * @par\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0015] acingTurtleModel m) {\n    m.trace(this.d);\n  }\n\n  ...\n\n}\nNow we can change the logic of our controller to:\n\nTake a one-word command from the user.\nCreate the corresponding TracingTurtleCommand object..\nExecute the command object.\nString in = s.next();\ntry {\n  switch (in) {\n    case \"q\":\n    case \"quit\":\n      return;\n   case \"show\":\n     for (Line l : m.getLines()) {\n        System.out.println(l);\n     }\n     break;\n   case \"move\":\n      cmd = new Move(s.nextDouble());\n      break;\n   case \"trace\":\n      cmd = new Trace(s.nextDouble());\n      break;\n   case \"turn\":\n      cmd = new Turn(s.nextDouble());\n      break;\n   case \"square\":\n      cmd = new Square(s.nextDouble());\n      break;\n   default:\n      System.out.println(String.format(\"Unknown command %s\", in));\n      cmd = null;\n      bre\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control;\n\nimport java.util.List;\nimport java.util.Scanner;\n\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16. Edited by lnunez on 02\/05\/24.\n *\/\npublic class SimpleController {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    Scanner s = new Scanner(System.in);\n    TracingTurtleModel m = new SmarterTurtle();\n    \/\/TODO: Add the controller into this method\n\n    while(s.hasNext()) {\n      String cmd = s.next();\n      switch(cmd) {\n        case \"move\":\n          m.move(s.nextDouble());\n          break;\n        default:\n          System.out.println(\"Invalid command. Sad\");\n      }\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-design-1335\\src\\cs3500\\turtle\\control\\SimpleController.java","mask_span":[293,705],"topics":["command","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0003] \n\n\/**\n * This class represents a 2D position\n *\/\npublic final class Position2D {\n  private final double x;\n  private final double y;\n\n  \/**\n   * Initialize this object to the specified position\n   *\/\n  public Position2D(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  \/**\n   * Copy constructor\n   *\/\n  public Position2D(Position2D v) {\n    this(v.x, v.y);\n  }\n\n\n\n  public double getX() {\n    return x;\n  }\n\n  public double getY() {\n    return y;\n  }\n\n\n  @Override\n  public String toString() {\n    return String.format(\"(%f, %f)\", this.x, this.y);\n  }\n\n  @Override\n  public boolean equals(Object a) {\n    if (this == a) {\n      return true;\n    }\n    if (!(a instanceof Position2D)) {\n      return false;\n    }\n\n    Position2D that = (Position2D) a;\n\n    return ((Math.abs(this.x - that.x\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.model;\n\nimport java.util.Objects;\n\n\/**\n * This class represents a 2D position\n *\/\n\/\/Value class: a class that exists to hold and retrieve immutable values\npublic final class Position2D {\n  private final double x;\n\n  public double getX() {\n    return x;\n  }\n\n  public double getY() {\n    return y;\n  }\n\n  private final double y;\n\n  \/**\n   * Initialize this object to the specified position\n   *\/\n  public Position2D(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  \/**\n   * Copy constructor\n   *\/\n  public Position2D(Position2D v) {\n    this(v.x, v.y);\n  }\n\n  @Override\n  public String toString() {\n    return String.format(\"(%f, %f)\", this.x, this.y);\n  }\n\n  @Override\n  public boolean equals(Object a) {\n    if (this == a) {\n      return true;\n    }\n    if (!(a instanceof Position2D)) {\n      return false;\n    }\n\n    Position2D that = (Position2D) a;\n\n    return ((Math.abs(this.x - that.x) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-design-1335\\src\\cs3500\\turtle\\model\\Position2D.java","mask_span":[995,1063],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.model;\n\nimport java.util.Objects;\nimport java.util.Stack;\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n  }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic SimpleTurtle() {\n    this(new Position2D(0, 0), 0);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-design-1335\\src\\cs3500\\turtle\\model\\SimpleTurtle.java","mask_span":[626,688],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.tracingmodel;\n\nimport java.util.Objects;\n\nimport cs3500.turtle.model.Position2D;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic final class Line {\n  public final Position2D start;\n  public final Position2D end;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public String toString() {\n    return String.format(\"%s--%s\", this.start.toString(), this.end.toString());\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (!(o instanceof Line)) {\n      return false;\n    }\n\n    Line line = (Line) o;\n\n    return (this.start.equals(line.start) && this.end.equals(line.end))\n            || (this.end.equals(line.start) && this.start.equals(line.end));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.start, this.end);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic Line(Position2D start, Position2D end) {\n    this.start = start;\n    this.end = end;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-design-1335\\src\\cs3500\\turtle\\tracingmodel\\Line.java","mask_span":[240,335],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.tracingmodel;\n\nimport java.util.Objects;\n\nimport cs3500.turtle.model.Position2D;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic final class Line {\n  public final Position2D start;\n  public final Position2D end;\n\n  public Line(Position2D start, Position2D end) {\n    this.start = start;\n    this.end = end;\n  }\n\n  @Override\n  public String toString() {\n    return String.format(\"%s--%s\", this.start.toString(), this.end.toString());\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (!(o instanceof Line)) {\n      return false;\n    }\n\n    Line line = (Line) o;\n\n    return (this.start.equals(line.start) && this.end.equals(line.end))\n            || (this.end.equals(line.start) && this.start.equals(line.end));\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic int hashCode() {\n    return Objects.hash(this.start, this.end);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-design-1335\\src\\cs3500\\turtle\\tracingmodel\\Line.java","mask_span":[811,885],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.tracingmodel;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.model.SimpleTurtle;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    super.move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public List<Line> getLines() {\n    return new ArrayList<>(lines);\n  }\n\n  \/\/list of lines traced since this object was created\n  List<Line> lines;\n\n}\n\n\n\/*\n10\/03 : Misc topics (testing, toString, Pile abstractions, Readable\/Appendable)\n\n10\/05: Encapsulation and invariants\n\nHw3\n\n10\/10: columbus day\n\n10\/12: Design problem (Turtles) -- talk through modelling of nouns (get to positions, lines?, turtles, tracing turtles extend simple turtles), get up to Commands as an abstraction, but not undoable ones, set up keyboard map but don't do it yet\n\nHW4 due 10\/14\n\n10\/17: Inheritance and composition\n\n10\/19: Intro to performance, More about performance\n\nHw5 due\n\n10\/24: First exam\n\n10\/26: Design discussion of music  models\n\n10\/31: Class activity: GUI (bad, basic mvc examples), MIDI\n\n11\/02: Adapters\n\nHw6 due on 11\/7\n\n11\/07: Commands\n\n11\/09: Commands (Class activity: adapters (Turtles))\n\n11\/14: Strategy (and decorator?) patterns\n\n\n11\/16: XXX (Command\/Observer)\n\n11\/21: XXX (Singleton\/Iterator\/Proxy)\n\nHw7 due 11\/21\n\n11\/28: Intro to Javascript\n\n11\/30: Javascript inheritance and patterns\n\n12\/05: Exam review\n\n12\/07: Promises\/Android\n\n\n\nadapters, strategy - TicTacToe, command - move, turn, ...square, ...fractal, undoable?\n\n\n\n\nPosition2D exists\nTurtleModel interface exists\nSimpleTurtle exists\n\ntalk-through SimpleTurtle\n\nmotivate tracing\n\ndesign TracingTurtleModel -- is it a TurtleModel? yes, so extend interface\nimplement SmarterTurtle -- extend or delegate?  either way will work, but inheritance is simpler\n\nmotivate the command-line controller\n\ndesign the controller with hard-coded switch with hard-coded method calls (move, turn, trace)\n\nhave some simple tests\n\nadd a new square case\n\ntest??? introduce Commands\n\n\n *\/\n<\/CodeSuffix>","target":"<Target>\npublic SmarterTurtle() {\n    super();\n    lines = new ArrayList<>();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-design-1335\\src\\cs3500\\turtle\\tracingmodel\\SmarterTurtle.java","mask_span":[295,367],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.tracingmodel;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.model.SimpleTurtle;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    super.move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/\/list of lines traced since this object was created\n  List<Line> lines;\n\n}\n\n\n\/*\n10\/03 : Misc topics (testing, toString, Pile abstractions, Readable\/Appendable)\n\n10\/05: Encapsulation and invariants\n\nHw3\n\n10\/10: columbus day\n\n10\/12: Design problem (Turtles) -- talk through modelling of nouns (get to positions, lines?, turtles, tracing turtles extend simple turtles), get up to Commands as an abstraction, but not undoable ones, set up keyboard map but don't do it yet\n\nHW4 due 10\/14\n\n10\/17: Inheritance and composition\n\n10\/19: Intro to performance, More about performance\n\nHw5 due\n\n10\/24: First exam\n\n10\/26: Design discussion of music  models\n\n10\/31: Class activity: GUI (bad, basic mvc examples), MIDI\n\n11\/02: Adapters\n\nHw6 due on 11\/7\n\n11\/07: Commands\n\n11\/09: Commands (Class activity: adapters (Turtles))\n\n11\/14: Strategy (and decorator?) patterns\n\n\n11\/16: XXX (Command\/Observer)\n\n11\/21: XXX (Singleton\/Iterator\/Proxy)\n\nHw7 due 11\/21\n\n11\/28: Intro to Javascript\n\n11\/30: Javascript inheritance and patterns\n\n12\/05: Exam review\n\n12\/07: Promises\/Android\n\n\n\nadapters, strategy - TicTacToe, command - move, turn, ...square, ...fractal, undoable?\n\n\n\n\nPosition2D exists\nTurtleModel interface exists\nSimpleTurtle exists\n\ntalk-through SimpleTurtle\n\nmotivate tracing\n\ndesign TracingTurtleModel -- is it a TurtleModel? yes, so extend interface\nimplement SmarterTurtle -- extend or delegate?  either way will work, but inheritance is simpler\n\nmotivate the command-line controller\n\ndesign the controller with hard-coded switch with hard-coded method calls (move, turn, trace)\n\nhave some simple tests\n\nadd a new square case\n\ntest??? introduce Commands\n\n\n *\/\n<\/CodeSuffix>","target":"<Target>\npublic List<Line> getLines() {\n    return new ArrayList<>(lines);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-design-1335\\src\\cs3500\\turtle\\tracingmodel\\SmarterTurtle.java","mask_span":[557,626],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle;\n\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.model.SimpleTurtle;\nimport cs3500.turtle.model.TurtleModel;\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\nimport static org.junit.Assert.*;\n\n\/**\n * Created by ashesh on 5\/23\/2016.\n *\/\npublic final class SmarterTurtleTest {\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void testDrawSomething() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    Position2D p1 = t.getPosition();\n    t.save();\n    t.turn(45);\n    t.trace(10);\n    t.retrieve();\n\n    t.save();\n    t.turn(135);\n    t.trace(10);\n    t.retrieve();\n\n    t.save();\n    t.turn(-90);\n    t.trace(10);\n    t.retrieve();\n\n      List<Line> actualLines = t.getLines();\n      List<Line> expectedLines = new ArrayList<>();\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(45.0)), 10.0 * Math.sin(Math.toRadians(45.0)))));\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(135.0)), 10.0 * Math.sin(Math.toRadians(135.0)))));\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(-90)), 10.0 * Math.sin(Math.toRadians(-90)))));\n\n      assertEquals(expectedLines.size(), actualLines.size());\n\n      for (int i = 0; i < expectedLines.size(); i++) {\n        assertEquals(expectedLines.get(i), actualLines.get(i));\n    }\n  }\n\n  @Test\n  public void testInit() {\n    TurtleModel t = new SimpleTurtle();\n\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testMove() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.move(10);\n    assertEquals(10.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTurnOnly() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.turn(10);\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n\n\n    t.turn(-100);\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTurnAndMove() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.turn(30);\n    t.move(10);\n    assertEquals(10.0 * Math.cos(Math.toRadians(30)), t.getPosition().getX(), 0.001);\n    assertEquals(10.0 * Math.sin(Math.toRadians(30)), t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTrace() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    t.trace(10);\n    List<Line> lines = t.getLines();\n    assertEquals(1, lines.size());\n    assertEquals(0.0, lines.get(0).start.getX(), 0.001);\n    assertEquals(0.0, lines.get(0).start.getY(), 0.001);\n    assertEquals(10.0, lines.get(0).end.getX(), 0.001);\n    assertEquals(0.0, lines.get(0).end.getY(), 0.001);\n  }\n\n  @Test\n  public void testMultipleTrace() {\n    TracingTurtleModel t = new SmarterTurtle();\n    List<Line> expectedLines = new ArrayList<>();\n    for (int i = 0; i < 10; i++) {\n      t.turn(90);\n      t.trace(10);\n      t.turn(-90);\n      t.trace(10);\n      t.turn(-90);\n      t.trace(10);\n      t.turn(90);\n      t.trace(10);\n      expectedLines.add(new Line(new Position2D(20 * i, 0),\n                                 new Position2D(20 * i, 10)));\n\n      expectedLines.add(new Line(new Position2D(20 * i, 10),\n                                 new Position2D(20 * i + 10, 10)));\n\n      expectedLines.add(new Line(new Position2D(20 * i + 10, 10),\n                                 new Position2D(20 * i + 10, 0)));\n\n      expectedLines.add(new Line(new Position2D(20 * i + 10, 0),\n                                 new Position2D(20 * i + 20, 0)));\n    }\n\n    List<Line> actualLines = t.getLines();\n    assertEquals(expectedLines.size(), actualLines.size());\n    for (int i = 0; i < expectedLines.size(); i++) {\n      assertEquals(expectedLines.get(i), actualLines.get(i));\n    }\n  }\n\n  @Test\n  public void testPush() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.move(10);\n    Position2D initPosition = t.getPosition();\n    t.save();\n    t.turn(90);\n    t.move(10);\n    t.retrieve();\n    Position2D finalPosition = t.getPosition();\n    assertEquals(initPosition.getX(), finalPosition.getX(), 0.01);\n    assertEquals(finalPosition.getY(), finalPosition.getY(), 0.01);\n  }\n\n}\n<\/CodeSuffix>","target":"<Target>\npublic void testOne() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    t.turn(60);\n    t.trace(19);\n    t.turn(-120);\n    t.trace(19);\n    t.turn(-120);\n    t.trace(19);\n    List<Line> tlines = t.getLines();\n\n    TracingTurtleModel t2 = new SmarterTurtle();\n\n    t2.trace(19);\n    t2.turn(120);\n    t2.trace(19);\n    t2.turn(120);\n    t2.trace(19);\n\n    List<Line> t2lines = t2.getLines();\n\n    assertEquals(tlines.size(), t2lines.size());\n\n    for (Line l : tlines) {\n      assertTrue(t2lines.contains(l));\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-design-1335\\test\\cs3500\\turtle\\SmarterTurtleTest.java","mask_span":[492,1015],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle;\n\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.model.SimpleTurtle;\nimport cs3500.turtle.model.TurtleModel;\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\nimport static org.junit.Assert.*;\n\n\/**\n * Created by ashesh on 5\/23\/2016.\n *\/\npublic final class SmarterTurtleTest {\n\n  @Test\n  public void testOne() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    t.turn(60);\n    t.trace(19);\n    t.turn(-120);\n    t.trace(19);\n    t.turn(-120);\n    t.trace(19);\n    List<Line> tlines = t.getLines();\n\n    TracingTurtleModel t2 = new SmarterTurtle();\n\n    t2.trace(19);\n    t2.turn(120);\n    t2.trace(19);\n    t2.turn(120);\n    t2.trace(19);\n\n    List<Line> t2lines = t2.getLines();\n\n    assertEquals(tlines.size(), t2lines.size());\n\n    for (Line l : tlines) {\n      assertTrue(t2lines.contains(l));\n    }\n  }\n\n  @Test\n  public void testDrawSomething() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    Position2D p1 = t.getPosition();\n    t.save();\n    t.turn(45);\n    t.trace(10);\n    t.retrieve();\n\n    t.save();\n    t.turn(135);\n    t.trace(10);\n    t.retrieve();\n\n    t.save();\n    t.turn(-90);\n    t.trace(10);\n    t.retrieve();\n\n      List<Line> actualLines = t.getLines();\n      List<Line> expectedLines = new ArrayList<>();\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(45.0)), 10.0 * Math.sin(Math.toRadians(45.0)))));\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(135.0)), 10.0 * Math.sin(Math.toRadians(135.0)))));\n\n      expectedLines.add(new Line(\n              new Position2D(0, 0),\n              new Position2D(\n                      10.0 * Math.cos(Math.toRadians(-90)), 10.0 * Math.sin(Math.toRadians(-90)))));\n\n      assertEquals(expectedLines.size(), actualLines.size());\n\n      for (int i = 0; i < expectedLines.size(); i++) {\n        assertEquals(expectedLines.get(i), actualLines.get(i));\n    }\n  }\n\n  @Test\n  public void testInit() {\n    TurtleModel t = new SimpleTurtle();\n\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testMove() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.move(10);\n    assertEquals(10.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTurnOnly() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.turn(10);\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n\n\n    t.turn(-100);\n    assertEquals(0.0, t.getPosition().getX(), 0.001);\n    assertEquals(0.0, t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTurnAndMove() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.turn(30);\n    t.move(10);\n    assertEquals(10.0 * Math.cos(Math.toRadians(30)), t.getPosition().getX(), 0.001);\n    assertEquals(10.0 * Math.sin(Math.toRadians(30)), t.getPosition().getY(), 0.001);\n  }\n\n  @Test\n  public void testTrace() {\n    TracingTurtleModel t = new SmarterTurtle();\n\n    t.trace(10);\n    List<Line> lines = t.getLines();\n    assertEquals(1, lines.size());\n    assertEquals(0.0, lines.get(0).start.getX(), 0.001);\n    assertEquals(0.0, lines.get(0).start.getY(), 0.001);\n    assertEquals(10.0, lines.get(0).end.getX(), 0.001);\n    assertEquals(0.0, lines.get(0).end.getY(), 0.001);\n  }\n\n  @Test\n  public void testMultipleTrace() {\n    TracingTurtleModel t = new SmarterTurtle();\n    List<Line> expectedLines = new ArrayList<>();\n    for (int i = 0; i < 10; i++) {\n      t.turn(90);\n      t.trace(10);\n      t.turn(-90);\n      t.trace(10);\n      t.turn(-90);\n      t.trace(10);\n      t.turn(90);\n      t.trace(10);\n      expectedLines.add(new Line(new Position2D(20 * i, 0),\n                                 new Position2D(20 * i, 10)));\n\n      expectedLines.add(new Line(new Position2D(20 * i, 10),\n                                 new Position2D(20 * i + 10, 10)));\n\n      expectedLines.add(new Line(new Position2D(20 * i + 10, 10),\n                                 new Position2D(20 * i + 10, 0)));\n\n      expectedLines.add(new Line(new Position2D(20 * i + 10, 0),\n                                 new Position2D(20 * i + 20, 0)));\n    }\n\n    List<Line> actualLines = t.getLines();\n    assertEquals(expectedLines.size(), actualLines.size());\n    for (int i = 0; i < expectedLines.size(); i++) {\n      assertEquals(expectedLines.get(i), actualLines.get(i));\n    }\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n<\/CodeSuffix>","target":"<Target>\npublic void testPush() {\n    TurtleModel t = new SimpleTurtle();\n\n    t.move(10);\n    Position2D initPosition = t.getPosition();\n    t.save();\n    t.turn(90);\n    t.move(10);\n    t.retrieve();\n    Position2D finalPosition = t.getPosition();\n    assertEquals(initPosition.getX(), finalPosition.getX(), 0.01);\n    assertEquals(finalPosition.getY(), finalPosition.getY(), 0.01);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-design-1335\\test\\cs3500\\turtle\\SmarterTurtleTest.java","mask_span":[4771,5150],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0001] lative to current position and direction (as the turtle) instead of absolute Cartesian coordinates. For example, driving directions provide navigation relative to the current position and direction (“Drive 0.3 miles”, “Take left onto...”).\n\n1.1 Basic Design\nBased on the basic operations identified above for turtle model, we begin by designing an interface for the model of our program:\n\n\/**\n * This interface specifies the operations on a 2D turtle\n * <p>\n * A 2D turtle is characterized by a position (x,y) and a\n * heading (where it is looking).\n * <p>\n * It can be asked to draw the path it has moved using one of\n * the commands below.\n *\/\npublic interface TurtleModel {\n    \/**\n     * Move the turtle by the specified distance along its\n     * heading. Do not change heading\n     *\n     * @par\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle;\n\nimport java.util.List;\n\nimport cs3500.turtle.control.IController;\nimport cs3500.turtle.control.MVCCommandController;\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\nimport cs3500.turtle.view.IView;\nimport cs3500.turtle.view.TurtleGraphicsView;\n\n\/**\n * Created by ashesh on 10\/26\/2016.\n *\/\npublic class TurtleRunner {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    TracingTurtleModel model = new SmarterTurtle();\n    IView view = new TurtleGraphicsView();\n    IController controller = new MVCCommandController(model, view);\n    controller.startProgram();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\TurtleRunner.java","mask_span":[477,715],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0015] acingTurtleModel m) {\n    m.trace(this.d);\n  }\n\n  ...\n\n}\nNow we can change the logic of our controller to:\n\nTake a one-word command from the user.\nCreate the corresponding TracingTurtleCommand object..\nExecute the command object.\nString in = s.next();\ntry {\n  switch (in) {\n    case \"q\":\n    case \"quit\":\n      return;\n   case \"show\":\n     for (Line l : m.getLines()) {\n        System.out.println(l);\n     }\n     break;\n   case \"move\":\n      cmd = new Move(s.nextDouble());\n      break;\n   case \"trace\":\n      cmd = new Trace(s.nextDouble());\n      break;\n   case \"turn\":\n      cmd = new Turn(s.nextDouble());\n      break;\n   case \"square\":\n      cmd = new Square(s.nextDouble());\n      break;\n   default:\n      System.out.println(String.format(\"Unknown command %s\", in));\n      cmd = null;\n      bre\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0001] lative to current position and direction (as the turtle) instead of absolute Cartesian coordinates. For example, driving directions provide navigation relative to the current position and direction (“Drive 0.3 miles”, “Take left onto...”).\n\n1.1 Basic Design\nBased on the basic operations identified above for turtle model, we begin by designing an interface for the model of our program:\n\n\/**\n * This interface specifies the operations on a 2D turtle\n * <p>\n * A 2D turtle is characterized by a position (x,y) and a\n * heading (where it is looking).\n * <p>\n * It can be asked to draw the path it has moved using one of\n * the commands below.\n *\/\npublic interface TurtleModel {\n    \/**\n     * Move the turtle by the specified distance along its\n     * heading. Do not change heading\n     *\n     * @par\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control;\n\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.Scanner;\n\nimport cs3500.turtle.control.commands.Koch;\nimport cs3500.turtle.control.commands.Move;\nimport cs3500.turtle.control.commands.Square;\nimport cs3500.turtle.control.commands.Trace;\nimport cs3500.turtle.control.commands.Turn;\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class CommandController {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    Scanner s = new Scanner(System.in);\n    TracingTurtleModel m = new SmarterTurtle();\n    TracingTurtleCommand cmd = null;\n    while (s.hasNext()) {\n      String in = s.next();\n      try {\n        switch (in) {\n          case \"q\":\n          case \"quit\":\n            return;\n          case \"show\":\n            for (Line l : m.getLines()) {\n              System.out.println(l);\n            }\n            break;\n          case \"move\":\n            cmd = new Move(s.nextDouble());\n            break;\n          case \"trace\":\n            cmd = new Trace(s.nextDouble());\n            break;\n          case \"turn\":\n            cmd = new Turn(s.nextDouble());\n            break;\n          case \"square\":\n            cmd = new Square(s.nextDouble());\n            break;\n          case \"koch\":\n            cmd = new Koch(s.nextDouble(), s.nextInt());\n          default:\n            System.out.println(String.format(\"Unknown command %s\", in));\n            cmd = null;\n            break;\n        }\n        if (cmd != null) cmd.execute(m);\n      } catch (InputMismatchException ime) {\n        System.out.println(\"Bad length to \" + in);\n      }\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\control\\CommandController.java","mask_span":[568,1749],"topics":["command","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0019] Double()));\n    knownCommands.put(\"turn\",s->new Turn(s.nextDouble()));\n    knownCommands.put(\"trace\", s->new Trace(s.nextDouble()));\n    knownCommands.put(\"square\", s -> new Square(s.nextDouble()));\nThen our controller logic becomes:\n\nTake a one-word command from the user.\nFind if the command exists in the map. If so, execute the corresponding function object to get the command object.\nExecute the command object.\nThe second step above becomes a map lookup, instead of a switch statement!\n\nwhile(scan.hasNext()) {\n  TracingTurtleCommand c;\n  String in = scan.next();\n  if (in.equalsIgnoreCase(\"q\") || in.equalsIgnoreCase(\"quit\"))\n    return;\n  Function<Scanner, TracingTurtleCommand> cmd =\n  knownCommands.getOrDefault(in, null);\n  if (cmd == null) {\n    throw new IllegalArgumentException();\n  } \n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0000] Lecture 10: The Command Design Pattern\nJava source (.zip)\nObjectives of the lecture\nThis lecture starts by working out the design of a model and controller of a new small application in detail. It streamlines code in the controller in several iterations to introduce the command design pattern.\n\n1 Context of the example program\nThis lecture uses the example of turtle graphics. Turtle graphics uses the notion of a turtle moving on a 2D plane. At any point in time, the turtle occupies a fixed position on the plane, and points in some direction. The turtle has limited mobility: it is able to turn in its place, and move only in the direction that it is pointing.\n\nTurtle graphics is used to measure and draw in various applications. Many such applications find it convenient to specify movement re\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Stack;\nimport java.util.function.Function;\n\nimport cs3500.turtle.control.commands.Koch;\nimport cs3500.turtle.control.commands.Move;\nimport cs3500.turtle.control.commands.Square;\nimport cs3500.turtle.control.commands.Trace;\nimport cs3500.turtle.control.commands.Turn;\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class ExtensibleController {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    Scanner scan = new Scanner(System.in);\n    TracingTurtleModel m = new SmarterTurtle();\n    Stack<TracingTurtleCommand> commands = new Stack<>();\n\n    Map<String, Function<Scanner, TracingTurtleCommand>> knownCommands = new HashMap<>();\n    knownCommands.put(\"move\", (Scanner s) -> {\n      return new Move(s.nextDouble());\n    });\n    knownCommands.put(\"turn\", (Scanner s) -> {\n      return new Turn(s.nextDouble());\n    });\n    knownCommands.put(\"trace\", (Scanner s) -> {\n      return new Trace(s.nextDouble());\n    });\n    knownCommands.put(\"square\", (Scanner s) -> {\n      return new Square(s.nextDouble());\n    });\n    knownCommands.put(\"koch\", (Scanner s) -> {\n      return new Koch(s.nextDouble()\n              , s.nextInt())\n              ;\n    });\n    knownCommands.put(\"show\", (Scanner s) -> {\n      return (TracingTurtleModel model) -> {\n        for (Line l : model.getLines())\n          System.out.println(l);\n      };\n    });\n    while (scan.hasNext()) {\n      TracingTurtleCommand c;\n      String in = scan.next();\n      if (in.equalsIgnoreCase(\"q\") || in.equalsIgnoreCase(\"quit\"))\n        return;\n      Function<Scanner, TracingTurtleCommand> cmd = knownCommands.getOrDefault(in, null);\n      if (cmd == null) {\n        throw new IllegalArgumentException();\n      } else {\n        c = cmd.apply(scan);\n        commands.add(c);\n        c.execute(m);\n      }\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\control\\ExtensibleController.java","mask_span":[615,2039],"topics":["command","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0001] lative to current position and direction (as the turtle) instead of absolute Cartesian coordinates. For example, driving directions provide navigation relative to the current position and direction (“Drive 0.3 miles”, “Take left onto...”).\n\n1.1 Basic Design\nBased on the basic operations identified above for turtle model, we begin by designing an interface for the model of our program:\n\n\/**\n * This interface specifies the operations on a 2D turtle\n * <p>\n * A 2D turtle is characterized by a position (x,y) and a\n * heading (where it is looking).\n * <p>\n * It can be asked to draw the path it has moved using one of\n * the commands below.\n *\/\npublic interface TurtleModel {\n    \/**\n     * Move the turtle by the specified distance along its\n     * heading. Do not change heading\n     *\n     * @par\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control;\n\nimport cs3500.turtle.control.commands.Koch;\nimport cs3500.turtle.control.commands.Move;\nimport cs3500.turtle.control.commands.Retrieve;\nimport cs3500.turtle.control.commands.Save;\nimport cs3500.turtle.control.commands.Square;\nimport cs3500.turtle.control.commands.Trace;\nimport cs3500.turtle.control.commands.Turn;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\nimport cs3500.turtle.view.IView;\nimport cs3500.turtle.view.ViewActions;\n\nimport java.util.Scanner;\n\n\/**\n * This is a controller that is very similar to the\n * CommandController class. The main difference\n * is that the main is replaced with the controller\n * method processCommand\n *\/\npublic class MVCCommandController implements IController, ViewActions {\n  private TracingTurtleModel model;\n  private IView view;\n\n  public MVCCommandController(TracingTurtleModel model, IView view) {\n    this.model = model;\n    this.view = view;\n  }\n\n  @Override\n  public void startProgram() {\n    \/\/TODO: As the Observer, subscribe to the Subject\n    view.setViewActions(this);\n    view.makeVisible();\n  }\n\n  @Override\n  public String processCommand(String command) {\n    StringBuilder output = new StringBuilder();\n    Scanner s = new Scanner(command);\n    TracingTurtleCommand cmd = null;\n\n\n    while (s.hasNext()) {\n      String in = s.next();\n\n      switch (in) {\n        case \"move\":\n          cmd = new Move(s.nextDouble());\n          break;\n        case \"trace\":\n          cmd = new Trace(s.nextDouble());\n          break;\n        case \"turn\":\n          cmd = new Turn(s.nextDouble());\n          break;\n        case \"square\":\n          cmd = new Square(s.nextDouble());\n          break;\n        case \"koch\":\n          cmd = new Koch(s.nextDouble(), s.nextInt());\n          break;\n        case \"save\":\n          cmd = new Save();\n          break;\n        case \"retrieve\":\n          cmd = new Retrieve();\n          break;\n        default:\n          output.append(String.format(\"Unknown command %s\", in));\n          cmd = null;\n          break;\n      }\n      if (cmd != null) {\n        cmd.execute(model);\n        output.append(\"Successfully executed: \" + command);\n      }\n    }\n\n\n    return output.toString();\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void exitProgram() {\n    System.exit(0);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void executeCommand(String command) {\n    processCommand(command);\n    view.refresh();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\control\\MVCCommandController.java","mask_span":[2223,2320],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0010]    switch(in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            ...\n          }\n          break;\n        default:\n    \n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control;\n\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.Scanner;\n\nimport cs3500.turtle.tracingmodel.Line;\nimport cs3500.turtle.tracingmodel.SmarterTurtle;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class SimpleController {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    Scanner s = new Scanner(System.in);\n    TracingTurtleModel m = new SmarterTurtle();\n    while (s.hasNext()) {\n      String in = s.next();\n      switch (in) {\n        case \"q\":\n        case \"quit\":\n          return;\n        case \"show\":\n          for (Line l : m.getLines()) {\n            System.out.println(l);\n          }\n          break;\n        case \"move\":\n          try {\n            double d = s.nextDouble();\n            m.move(d);\n          } catch (InputMismatchException ime) {\n            System.out.println(\"Bad length to move\");\n          }\n          break;\n        case \"trace\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n          } catch (InputMismatchException ime) {\n            System.out.println(\"Bad length to trace\");\n          }\n          break;\n        case \"turn\":\n          try {\n            double d = s.nextDouble();\n            m.turn(d);\n          } catch (InputMismatchException ime) {\n            System.out.println(\"Bad length to turn\");\n          }\n          break;\n        case \"square\":\n          try {\n            double d = s.nextDouble();\n            m.trace(d);\n            m.turn(90);\n            m.trace(d);\n            m.turn(90);\n            m.trace(d);\n            m.turn(90);\n            m.trace(d);\n            m.turn(90);\n          } catch (InputMismatchException ime) {\n            System.out.println(\"Bad length to turn\");\n          }\n          break;\n        default:\n          System.out.println(String.format(\"Unknown command %s\", in));\n          break;\n      }\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\control\\SimpleController.java","mask_span":[344,1949],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0001] lative to current position and direction (as the turtle) instead of absolute Cartesian coordinates. For example, driving directions provide navigation relative to the current position and direction (“Drive 0.3 miles”, “Take left onto...”).\n\n1.1 Basic Design\nBased on the basic operations identified above for turtle model, we begin by designing an interface for the model of our program:\n\n\/**\n * This interface specifies the operations on a 2D turtle\n * <p>\n * A 2D turtle is characterized by a position (x,y) and a\n * heading (where it is looking).\n * <p>\n * It can be asked to draw the path it has moved using one of\n * the commands below.\n *\/\npublic interface TurtleModel {\n    \/**\n     * Move the turtle by the specified distance along its\n     * heading. Do not change heading\n     *\n     * @par\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * This command implements the \"Koch snowflake\".\n * The Koch snowflake is a recursively drawn figure.\n * It starts with an equilateral triangle whose\n * sides are of a given length.\n * <p>\n * Then, each segment is broken down into 4 segments:\n * go 1\/3rd length in the direction of the line,\n * turn 60 and go 1\/3rd length, then turn -120 and go\n * 1\/3rd length, and finally turn 60 and go 1\/3rd\n * length. Basically it converts\n * _____________ to\n * \/\\\n * \/  \\\n * ___\/    \\____\n *\/\npublic class Koch implements TracingTurtleCommand {\n\n  private double d;\n  private int depth;\n\n  public Koch(double distance, int depth) {\n    d = distance;\n    this.depth = depth;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\nprivate void drawKoch(double distance, int depth, TracingTurtleModel model) {\n    if (depth > 0) {\n      drawKoch(distance \/ 3, depth - 1, model);\n      model.turn(60);\n      drawKoch(distance \/ 3, depth - 1, model);\n      model.turn(-120);\n      drawKoch(distance \/ 3, depth - 1, model);\n      model.turn(60);\n      drawKoch(distance \/ 3, depth - 1, model);\n    } else {\n      model.trace(distance);\n    }\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel m) {\n    drawKoch(d, depth, m);\n    m.turn(-120);\n    drawKoch(d, depth, m);\n    m.turn(-120);\n    drawKoch(d, depth, m);\n    m.turn(-120);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\control\\commands\\Koch.java","mask_span":[836,1018],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0001] lative to current position and direction (as the turtle) instead of absolute Cartesian coordinates. For example, driving directions provide navigation relative to the current position and direction (“Drive 0.3 miles”, “Take left onto...”).\n\n1.1 Basic Design\nBased on the basic operations identified above for turtle model, we begin by designing an interface for the model of our program:\n\n\/**\n * This interface specifies the operations on a 2D turtle\n * <p>\n * A 2D turtle is characterized by a position (x,y) and a\n * heading (where it is looking).\n * <p>\n * It can be asked to draw the path it has moved using one of\n * the commands below.\n *\/\npublic interface TurtleModel {\n    \/**\n     * Move the turtle by the specified distance along its\n     * heading. Do not change heading\n     *\n     * @par\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class Move implements TracingTurtleCommand {\n  double d;\n\n  public Move(Double d) {\n    this.d = d;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel m) {\n    m.move(this.d);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\control\\commands\\Move.java","mask_span":[316,383],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0007] istance);\nList<Line> getLines();\nIt may be tempting to simply add these methods to the TurtleModel interface and implement them in the SimpleTurtle class. However doing so has several problems:\n\nWe no longer have a turtle without the capability to draw. Clients that currently use TurtleModel and SimpleTurtle now have extra operations that is not relevant. This violates the Interface Segregation principle.\nEditing code that is in use is recipe for disaster. If we accidentally broke what was previous working, it affects client code. This violates the Open for Extension, Closed for Modification principle.\nHow do we add these operations? We extend the existing interface and then implement it by reusing the existing implementation (with inheritance).\n\n\npublic interface TracingTurtleModel extend\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by ashesh on 10\/28\/2016.\n *\/\npublic class Retrieve implements TracingTurtleCommand {\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel m) {\n    m.retrieve();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\control\\commands\\Retrieve.java","mask_span":[261,326],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0001] lative to current position and direction (as the turtle) instead of absolute Cartesian coordinates. For example, driving directions provide navigation relative to the current position and direction (“Drive 0.3 miles”, “Take left onto...”).\n\n1.1 Basic Design\nBased on the basic operations identified above for turtle model, we begin by designing an interface for the model of our program:\n\n\/**\n * This interface specifies the operations on a 2D turtle\n * <p>\n * A 2D turtle is characterized by a position (x,y) and a\n * heading (where it is looking).\n * <p>\n * It can be asked to draw the path it has moved using one of\n * the commands below.\n *\/\npublic interface TurtleModel {\n    \/**\n     * Move the turtle by the specified distance along its\n     * heading. Do not change heading\n     *\n     * @par\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by ashesh on 10\/28\/2016.\n *\/\npublic class Save implements TracingTurtleCommand {\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel m) {\n    m.save();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\control\\commands\\Save.java","mask_span":[258,319],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class Square implements TracingTurtleCommand {\n  double d;\n\n  public Square(Double d) {\n    this.d = d;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel m) {\n    for (int i = 0; i < 4; i++) {\n      m.trace(this.d);\n      m.turn(90);\n    }\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\control\\commands\\Square.java","mask_span":[320,448],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0007] istance);\nList<Line> getLines();\nIt may be tempting to simply add these methods to the TurtleModel interface and implement them in the SimpleTurtle class. However doing so has several problems:\n\nWe no longer have a turtle without the capability to draw. Clients that currently use TurtleModel and SimpleTurtle now have extra operations that is not relevant. This violates the Interface Segregation principle.\nEditing code that is in use is recipe for disaster. If we accidentally broke what was previous working, it affects client code. This violates the Open for Extension, Closed for Modification principle.\nHow do we add these operations? We extend the existing interface and then implement it by reusing the existing implementation (with inheritance).\n\n\npublic interface TracingTurtleModel extend\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class Trace implements TracingTurtleCommand {\n  double d;\n\n  public Trace(Double d) {\n    this.d = d;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel m) {\n    m.trace(this.d);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\control\\commands\\Trace.java","mask_span":[318,386],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.control.commands;\n\nimport cs3500.turtle.control.TracingTurtleCommand;\nimport cs3500.turtle.tracingmodel.TracingTurtleModel;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class Turn implements TracingTurtleCommand {\n  double d;\n\n  public Turn(Double d) {\n    this.d = d;\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void execute(TracingTurtleModel m) {\n    m.turn(this.d);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\control\\commands\\Turn.java","mask_span":[316,383],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0003] \n\n\/**\n * This class represents a 2D position\n *\/\npublic final class Position2D {\n  private final double x;\n  private final double y;\n\n  \/**\n   * Initialize this object to the specified position\n   *\/\n  public Position2D(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  \/**\n   * Copy constructor\n   *\/\n  public Position2D(Position2D v) {\n    this(v.x, v.y);\n  }\n\n\n\n  public double getX() {\n    return x;\n  }\n\n  public double getY() {\n    return y;\n  }\n\n\n  @Override\n  public String toString() {\n    return String.format(\"(%f, %f)\", this.x, this.y);\n  }\n\n  @Override\n  public boolean equals(Object a) {\n    if (this == a) {\n      return true;\n    }\n    if (!(a instanceof Position2D)) {\n      return false;\n    }\n\n    Position2D that = (Position2D) a;\n\n    return ((Math.abs(this.x - that.x\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.model;\n\nimport java.util.Objects;\n\n\/**\n * This class represents a 2D position (Quadrant I)\n *\/\npublic final class Position2D {\n  private final double x;\n\n  public double getX() {\n    return x;\n  }\n\n  public double getY() {\n    return y;\n  }\n\n  private final double y;\n\n  \/**\n   * Initialize this object to the specified position\n   *\/\n  public Position2D(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  \/**\n   * Copy constructor\n   *\/\n  public Position2D(Position2D v) {\n    this(v.x, v.y);\n  }\n\n  @Override\n  public String toString() {\n    return String.format(\"(%f, %f)\", this.x, this.y);\n  }\n\n  @Override\n  public boolean equals(Object a) {\n    if (this == a) {\n      return true;\n    }\n    if (!(a instanceof Position2D)) {\n      return false;\n    }\n\n    Position2D that = (Position2D) a;\n\n    return ((Math.abs(this.x - that.x) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\model\\Position2D.java","mask_span":[935,1003],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.model;\n\nimport java.util.Objects;\nimport java.util.Stack;\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n  }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() {\n    return heading;\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic SimpleTurtle() {\n    this(new Position2D(0, 0), 0);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\model\\SimpleTurtle.java","mask_span":[626,688],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.tracingmodel;\n\nimport java.util.Objects;\n\nimport cs3500.turtle.model.Position2D;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic final class Line {\n  public final Position2D start;\n  public final Position2D end;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public String toString() {\n    return String.format(\"%s--%s\", this.start.toString(), this.end.toString());\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (!(o instanceof Line)) {\n      return false;\n    }\n\n    Line line = (Line) o;\n\n    return (this.start.equals(line.start) && this.end.equals(line.end))\n            || (this.end.equals(line.start) && this.start.equals(line.end));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.start, this.end);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic Line(Position2D start, Position2D end) {\n    this.start = start;\n    this.end = end;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\tracingmodel\\Line.java","mask_span":[240,335],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.tracingmodel;\n\nimport java.util.Objects;\n\nimport cs3500.turtle.model.Position2D;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic final class Line {\n  public final Position2D start;\n  public final Position2D end;\n\n  public Line(Position2D start, Position2D end) {\n    this.start = start;\n    this.end = end;\n  }\n\n  @Override\n  public String toString() {\n    return String.format(\"%s--%s\", this.start.toString(), this.end.toString());\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (!(o instanceof Line)) {\n      return false;\n    }\n\n    Line line = (Line) o;\n\n    return (this.start.equals(line.start) && this.end.equals(line.end))\n            || (this.end.equals(line.start) && this.start.equals(line.end));\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic int hashCode() {\n    return Objects.hash(this.start, this.end);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\tracingmodel\\Line.java","mask_span":[811,885],"topics":["mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.tracingmodel;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.model.SimpleTurtle;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public List<Line> getLines() {\n    return new ArrayList<>(lines);\n  }\n\n  \/\/list of lines traced since this object was created\n  List<Line> lines;\n\n}\n\n\n<\/CodeSuffix>","target":"<Target>\npublic SmarterTurtle() {\n    super();\n    lines = new ArrayList<>();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\tracingmodel\\SmarterTurtle.java","mask_span":[295,367],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0004] ) < 0.01) && (Math.abs(this.y - that.y) < 0.01));\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(this.x, this.y);\n  }\n}\nWe implement the TurtleModel interface as a SimpleTurtle class.\n\n\/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n *\/\npublic class SimpleTurtle implements TurtleModel {\n  \/\/ the position of the turtle\n  private Position2D position;\n  \/\/ the heading of the turtle in degrees\n  private double heading;\n  \/\/ stacks to save and retrieve turtle states\n  Stack<Position2D> stackPositions;\n  Stack<Double> stackHeadings;\n\n  \/**\n   * Initializes the turtle to the default state.\n   * Default state = position (0,0) and heading (0) meaning\n   * looking in the +X direction.\n   *\/\n  public SimpleTurtle() {\n    this(new Position2D(0,\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0002] am distance\n     *\/\n    void move(double distance);\n\n\n    \/**\n     * Turn the turtle's heading by the given angle.\n     * A positive angle means counter-clockwise\n     * turning. The turtle turns in place, i.e.\n     * it does not change position.\n     *\n     * @param angleDegrees\n     *\/\n    void turn(double angleDegrees);\n\n    \/**\n     * Save the current turtle state (position + heading)\n     *\/\n    void save();\n\n    \/**\n     * Retrieve the last saved turtle state (position + heading)\n     *\/\n    void retrieve();\n\n    \/**\n     * Get the current position of the turtle\n     *\n     * @return\n     *\/\n    Position2D getPosition();\n\n  \/**\n   * Get the current heading of the turtle\n   *\n   * @return\n   *\/\n    double getHeading();\n}\nThe Position2D class represents a single, immutable 2D position.\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.tracingmodel;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.model.SimpleTurtle;\n\n\/**\n * Created by blerner on 10\/10\/16.\n *\/\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/\/list of lines traced since this object was created\n  List<Line> lines;\n\n}\n\n\n<\/CodeSuffix>","target":"<Target>\npublic List<Line> getLines() {\n    return new ArrayList<>(lines);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\tracingmodel\\SmarterTurtle.java","mask_span":[551,620],"topics":[]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0046]  extends JPanel, and override its paintComponent method to draw whatever you want, just to confirm that it works.\n\nNext, enhance the IView interface so you can pass the relevant information from the model, through the controller, into the view and into your TurtlePanel class. Once you’ve connected the pieces, use this information in your paintComponent implementation to draw the turtle’s trace.\n\nThe links at the top of the lecture include a “solution” implementation; do not to look at that until you’ve tried to implement this yourself.\n\nThe IView interface contains one method for setting up an event listener. What is its signature? Does it seem like a high-level event to you, or a low-level one? If you think it’s too low-level, can you think of a better, higher-level signature to use? If y\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0002] t extends JPanel and overrides paintComponent that draws the game board and game status. Status includes indicating whose turn it is, and if the game is over, who won (or if it was a tie).\na class that extends MouseAdapter and overrides mouseClicked to capture a click on the game board and pass it to the controller.\nYou will also need to fill in the parts of the main method in Main.java as noted in the comments in that method.\n\n2 Testing\nTest your view by running it, inspecting the view, clicking on the game board and playing the game. No automated tests here.\n\n3 Notes to Keep in Mind\nYou will likely want to refer to the sample code on graphical programs, such as the Turtle Graphics example (see the \"solution code\" link).\nSubmit your zip containing only your src directory to In-class Exerc\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.view;\n\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\n\nimport java.util.List;\nimport java.util.function.Consumer;\n\nimport javax.swing.*;\n\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.tracingmodel.Line;\n\n\/**\n * This is an implementation of the IView interface\n * that uses Java Swing to draw the results of the\n * turtle. It shows any error messages using a\n * pop-up dialog box, and shows the turtle position\n * and heading\n *\/\npublic class TurtleGraphicsView extends JFrame implements IView {\n  private JButton commandButton, quitButton;\n  private JPanel buttonPanel;\n  private TurtlePanel turtlePanel;\n  private JScrollPane scrollPane;\n  private JTextField input;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void makeVisible() {\n    this.setVisible(true);\n  }\n\n  @Override\n  public void refresh() {\n    this.repaint();\n  }\n\n  @Override\n  public void setViewActions(ViewActions actions) {\n    commandButton.addActionListener(\n        (ActionEvent evt) -> { actions.executeCommand(input.getText()); }\n    );\n    quitButton.addActionListener( (evt) -> { actions.exitProgram(); } );\n  }\n\n  \/\/ TODO: Complete the Observer Pattern as the Subject\n    \n  \/\/ TODO: Add methods here to notify the TurtlePanel about what to draw.\n\n  @Override\n  public void showErrorMessage(String error) {\n    JOptionPane.showMessageDialog(this, error, \"Error\", JOptionPane.ERROR_MESSAGE);\n\n  }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TurtleGraphicsView() {\n    super();\n    this.setTitle(\"Turtles!\");\n    this.setSize(500, 500);\n    this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n    \/\/use a borderlayout with drawing panel in center and button panel in south\n    this.setLayout(new BorderLayout());\n    turtlePanel = new TurtlePanel();\n    turtlePanel.setPreferredSize(new Dimension(500, 500));\n    scrollPane = new JScrollPane(turtlePanel);\n    this.add(scrollPane, BorderLayout.CENTER);\n\n    \/\/button panel\n    buttonPanel = new JPanel();\n    buttonPanel.setLayout(new FlowLayout());\n    this.add(buttonPanel, BorderLayout.SOUTH);\n\n    \/\/input textfield\n    input = new JTextField(15);\n    buttonPanel.add(input);\n\n    \/\/buttons\n    commandButton = new JButton(\"Execute\");\n    buttonPanel.add(commandButton);\n\n    \/\/quit button\n    quitButton = new JButton(\"Quit\");\n    buttonPanel.add(quitButton);\n\n    this.pack();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\view\\TurtleGraphicsView.java","mask_span":[713,1616],"topics":["observer","gui","adapter","decorator","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0046]  extends JPanel, and override its paintComponent method to draw whatever you want, just to confirm that it works.\n\nNext, enhance the IView interface so you can pass the relevant information from the model, through the controller, into the view and into your TurtlePanel class. Once you’ve connected the pieces, use this information in your paintComponent implementation to draw the turtle’s trace.\n\nThe links at the top of the lecture include a “solution” implementation; do not to look at that until you’ve tried to implement this yourself.\n\nThe IView interface contains one method for setting up an event listener. What is its signature? Does it seem like a high-level event to you, or a low-level one? If you think it’s too low-level, can you think of a better, higher-level signature to use? If y\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0002] t extends JPanel and overrides paintComponent that draws the game board and game status. Status includes indicating whose turn it is, and if the game is over, who won (or if it was a tie).\na class that extends MouseAdapter and overrides mouseClicked to capture a click on the game board and pass it to the controller.\nYou will also need to fill in the parts of the main method in Main.java as noted in the comments in that method.\n\n2 Testing\nTest your view by running it, inspecting the view, clicking on the game board and playing the game. No automated tests here.\n\n3 Notes to Keep in Mind\nYou will likely want to refer to the sample code on graphical programs, such as the Turtle Graphics example (see the \"solution code\" link).\nSubmit your zip containing only your src directory to In-class Exerc\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.view;\n\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\n\nimport java.util.List;\nimport java.util.function.Consumer;\n\nimport javax.swing.*;\n\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.tracingmodel.Line;\n\n\/**\n * This is an implementation of the IView interface\n * that uses Java Swing to draw the results of the\n * turtle. It shows any error messages using a\n * pop-up dialog box, and shows the turtle position\n * and heading\n *\/\npublic class TurtleGraphicsView extends JFrame implements IView {\n  private JButton commandButton, quitButton;\n  private JPanel buttonPanel;\n  private TurtlePanel turtlePanel;\n  private JScrollPane scrollPane;\n  private JTextField input;\n\n  public TurtleGraphicsView() {\n    super();\n    this.setTitle(\"Turtles!\");\n    this.setSize(500, 500);\n    this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n    \/\/use a borderlayout with drawing panel in center and button panel in south\n    this.setLayout(new BorderLayout());\n    turtlePanel = new TurtlePanel();\n    turtlePanel.setPreferredSize(new Dimension(500, 500));\n    scrollPane = new JScrollPane(turtlePanel);\n    this.add(scrollPane, BorderLayout.CENTER);\n\n    \/\/button panel\n    buttonPanel = new JPanel();\n    buttonPanel.setLayout(new FlowLayout());\n    this.add(buttonPanel, BorderLayout.SOUTH);\n\n    \/\/input textfield\n    input = new JTextField(15);\n    buttonPanel.add(input);\n\n    \/\/buttons\n    commandButton = new JButton(\"Execute\");\n    buttonPanel.add(commandButton);\n\n    \/\/quit button\n    quitButton = new JButton(\"Quit\");\n    buttonPanel.add(quitButton);\n\n    this.pack();\n  }\n\n  @Override\n  public void makeVisible() {\n    this.setVisible(true);\n  }\n\n  @Override\n  public void refresh() {\n    this.repaint();\n  }\n\n  @Override\n  public void setViewActions(ViewActions actions) {\n    commandButton.addActionListener(\n        (ActionEvent evt) -> { actions.executeCommand(input.getText()); }\n    );\n    quitButton.addActionListener( (evt) -> { actions.exitProgram(); } );\n  }\n\n  \/\/ TODO: Complete the Observer Pattern as the Subject\n    \n  \/\/ TODO: Add methods here to notify the TurtlePanel about what to draw.\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void showErrorMessage(String error) {\n    JOptionPane.showMessageDialog(this, error, \"Error\", JOptionPane.ERROR_MESSAGE);\n\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\view\\TurtleGraphicsView.java","mask_span":[2165,2298],"topics":["observer","gui","adapter","decorator","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] s TurtleModel {\n  \/**\n   * Move the turtle by the specified distance along its\n   * heading. Do not change heading.\n   * Draw a line from its initial position to its\n   * final position.\n   *\n   * @param distance\n   *\/\n  void trace(double distance);\n\n  \/**\n   * Get the lines traced by this turtle, caused by the\n   * trace method above.\n   *\n   * @return a list of {@code Line} objects, in the order they were drawn.\n   *\/\n  List<Line> getLines();\n}\n\npublic class SmarterTurtle extends SimpleTurtle implements TracingTurtleModel {\n  public SmarterTurtle() {\n    super();\n    lines = new ArrayList<Line>();\n  }\n\n\n  @Override\n  public void trace(double distance) {\n    Position2D cur = this.getPosition();\n    move(distance);\n    lines.add(new Line(cur, this.getPosition()));\n  }\n\n  @Override\n  public\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0046]  extends JPanel, and override its paintComponent method to draw whatever you want, just to confirm that it works.\n\nNext, enhance the IView interface so you can pass the relevant information from the model, through the controller, into the view and into your TurtlePanel class. Once you’ve connected the pieces, use this information in your paintComponent implementation to draw the turtle’s trace.\n\nThe links at the top of the lecture include a “solution” implementation; do not to look at that until you’ve tried to implement this yourself.\n\nThe IView interface contains one method for setting up an event listener. What is its signature? Does it seem like a high-level event to you, or a low-level one? If you think it’s too low-level, can you think of a better, higher-level signature to use? If y\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0005]  0), 0);\n  }\n  \/**\n   * Initializes the turtle to the given position and heading.\n   *\/\n  public SimpleTurtle(Position2D startPos, double startHeading) {\n    position = Objects.requireNonNull(startPos);\n    heading = startHeading;\n    stackPositions = new Stack<>();\n    stackHeadings = new Stack<>();\n  }\n\n  @Override\n  public void move(double distance) {\n    \/\/trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n\n  @Override\n  public void save() {\n    stackPositions.push(position);\n    stackHeadings.push(heading);\n\n---\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0006]   }\n\n  @Override\n  public void retrieve() {\n    if ((stackPositions.isEmpty()) || (stackHeadings.isEmpty())) {\n      throw new IllegalArgumentException(\"no state to retrieve\");\n    }\n    position = stackPositions.pop();\n    heading = stackHeadings.pop();\n  }\n\n  @Override\n  public Position2D getPosition() {\n    return position;\n  }\n\n  @Override\n  public double getHeading() { return heading;}\n}\n1.2 Enhancement\nThe above turtle model is able to move and turn, but is not able to draw anything. Although drawing is within the scope of the view, the model must provide it with the data to draw. In this specific example, our turtle must trace its path, and provide a way for the client to retrieve its traces (in the form of lines).\n\nSpecifically we need the following operations:\n\nvoid trace(double d\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.turtle.view;\n\nimport cs3500.turtle.model.Position2D;\nimport cs3500.turtle.tracingmodel.Line;\n\nimport javax.swing.JPanel;\nimport java.awt.*;\nimport java.awt.geom.AffineTransform;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class TurtlePanel extends JPanel {\n  List<Line> curLines;\n  double headingDegrees;\n  Position2D pos;\n\n  TurtlePanel() {\n    this.curLines = new ArrayList<>();\n    this.pos = new Position2D(-1, -1);\n  }\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\nprotected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n\n    \/\/ TODO: Fill this in to draw the lines\n    \/\/ Note: generally a good idea to copy the existing graphics\n    \/\/ so that if you change its state (color, transform, etc)\n    \/\/ you won't modify the original `g` that was passed in.\n    Graphics2D g2d = (Graphics2D) g.create();\n\n    g2d.drawOval(30, 30, 30, 30);\n    g2d.fillRect(300, 350, 100, 50);\n\n\n    \/\/ Use methods on the Graphics2D class to drawOval or fillOval,\n    \/\/ drawLine, getColor, setColor, getTransform,\n    \/\/ translate, scale, rotate, etc...\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\turtles-drawing\\src\\cs3500\\turtle\\view\\TurtlePanel.java","mask_span":[468,1057],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport cs3500.tictactoe.controller.TicTacToeController;\nimport cs3500.tictactoe.controller.TicTacToeGUIController;\nimport cs3500.tictactoe.model.TicTacToe;\nimport cs3500.tictactoe.model.TicTacToeModel;\nimport cs3500.tictactoe.provider.view.TicTacToeFrame;\nimport cs3500.tictactoe.view.TTTFrame;\nimport cs3500.tictactoe.view.TTTView;\nimport cs3500.tictactoe.view.TicTacToeViewToTTTViewAdapter;\n\n\/**\n * Run a Tic Tac Toe game interactively.\n *\/\npublic class Main {\n  \/**\n   * Run a Tic Tac Toe game interactively.\n   *\/\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    \/\/ Old News: console-based game:\n    \/\/new TicTacToeConsoleController(new InputStreamReader(System.in),\n    \/\/    System.out).playGame(new TicTacToeModel());\n\n    \/\/ New Hotness: Graphical User Interface:\n    \/\/ 1. Create an instance of the model.\n    TicTacToe model = new TicTacToeModel();\n    \/\/ 2. Create an instance of the view.\n    TTTView view = new TicTacToeViewToTTTViewAdapter(model, new TicTacToeFrame());\n    \/\/ 3. Create an instance of the controller, passing the view to its constructor.\n    TicTacToeController controller =\n        new TicTacToeGUIController(view);\n    \/\/ 4. Call playGame() on the controller.\n    controller.playGame(model);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1030\\src\\cs3500\\tictactoe\\Main.java","mask_span":[547,1253],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.controller;\n\nimport java.io.IOException;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\nimport cs3500.tictactoe.model.TicTacToe;\n\npublic class TicTacToeConsoleController implements TicTacToeController {\n\n  private final Appendable out;\n  private final Scanner scan;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void playGame(TicTacToe m) {\n    try {\n      appendStateAndPrompt(m);\n      Integer mvRow = null;\n      Integer mvCol = null;\n      String tok = \"\";\n      while (!m.isGameOver()) {\n        tok = scan.next();\n        if (tok.equalsIgnoreCase(\"q\")) {\n          break;\n        }\n        try {\n          int v = Integer.parseInt(tok);\n          if (mvRow == null) {\n            mvRow = v;\n          } else {\n            mvCol = v;\n            m.move(mvRow - 1, mvCol - 1);\n            if(m.isGameOver()) {\n              out.append(m.toString()).append(\"\\n\");\n              out.append(\"Game is over! \");\n              if(m.getWinner() != null) {\n                out.append(m.getWinner().toString() + \" wins.\\n\");\n              } else {\n                out.append(\"Tie game.\\n\");\n              }\n              break;\n            }\n            appendStateAndPrompt(m);\n            mvRow = mvCol = null;\n          }\n        } catch (NumberFormatException nfe) {\n          out.append(\"Not a valid number: \" + tok).append(\"\\n\");\n        } catch (IllegalArgumentException iae) {\n          out.append(\"Not a valid move: \" + mvRow + \", \" + mvCol).append(\"\\n\");\n          mvRow = mvCol = null;\n        }\n      }\n      if (!m.isGameOver() && tok.equalsIgnoreCase(\"q\")) {\n        out.append(\"Game quit! Ending game state:\\n\" + m.toString() + \"\\n\");\n      } else if (!m.isGameOver()) {\n        throw new IllegalStateException(\"Ran out of inputs\");\n      }\n    } catch (IOException ioe) {\n      scan.close();\n      throw new IllegalStateException(\"append failed\", ioe);\n    } catch (NoSuchElementException e) {\n      throw new IllegalStateException(\"failed to read from readable\");\n    }\n    scan.close();\n  }\n\n  private void appendStateAndPrompt(TicTacToe m) throws IOException {\n    out.append(m.toString()).append(\"\\n\");\n    out.append(\"Enter a move for \" + m.getTurn().toString()).append(\":\\n\");\n  }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeConsoleController(Readable in, Appendable out) {\n    if (in == null || out == null) {\n      throw new IllegalArgumentException(\"Readable and Appendable can't be null\");\n    }\n    this.out = out;\n    scan = new Scanner(in);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1030\\src\\cs3500\\tictactoe\\controller\\TicTacToeConsoleController.java","mask_span":[315,557],"topics":["gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.controller;\n\nimport cs3500.tictactoe.model.TicTacToe;\nimport cs3500.tictactoe.view.TTTView;\nimport cs3500.tictactoe.view.ViewActions;\n\npublic class TicTacToeGUIController implements TicTacToeController, ViewActions {\n\n  private final TTTView view;\n  private TicTacToe model;\n  public TicTacToeGUIController(TTTView view) {\n    this.view = view;\n  }\n\n  @Override\n  public void playGame(TicTacToe m) {\n    this.model = m;\n    this.view.addClickListener(this);\n    this.view.makeVisible();\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void handleCellClick(int row, int col) {\n    try {\n      model.move(row, col);\n    } catch (IllegalArgumentException ex) {\n      \/\/tell the user somehow the arguments were wrong\n    } catch (IllegalStateException ex) {\n      \/\/tell the user somehow they made a mistake choosing a cell\n      \/\/or the game is over\n    }\n    view.refresh();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1030\\src\\cs3500\\tictactoe\\controller\\TicTacToeGUIController.java","mask_span":[531,880],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.model;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n\/**\n * Represents a single game of Tic Tac Toe. Three in a row down\/across\/diagonally to win; X goes\n * first.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n  private final Player[][] board;\n  private Player turn;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void move(int r, int c) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(r, c);\n    if (board[r][c] != null) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[r][c] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (Player[] row : board) {\n      if (Arrays.stream(row).anyMatch(Objects::isNull)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (Player p : Player.values()) {\n      \/\/ check horizontals\n      for (Player[] row : board) {\n        if(Arrays.stream(row).allMatch(m -> m == p)) {\n          return p;\n        }\n      }\n      \/\/ check verticals\n      for (int i = 0; i < board[0].length; i++) {\n        if (board[0][i] == p && board[1][i] == p && board[2][i] == p) {\n          return p;\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == p && board[1][1] == p && board[2][2] == p) {\n        return p;\n      }\n      if (board[0][2] == p && board[1][1] == p && board[2][0] == p) {\n        return p;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int r = 0; r < board.length; r++) {\n      ret[r] = Arrays.copyOf(board[r], board[r].length);\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int r, int c) {\n    validateRowCol(r, c);\n    return board[r][c];\n  }\n\n  private static void validateRowCol(int r, int c) {\n    if (r < 0 || r > 2 || c < 0 || c > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + r + \",\" + c);\n    }\n  }\n\n  @Override\n  public String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard()).map(\n      row -> \" \" + Arrays.stream(row).map(\n        p -> p == null ? \" \" : p.toString()).collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1030\\src\\cs3500\\tictactoe\\model\\TicTacToeModel.java","mask_span":[347,427],"topics":["strategy","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.model;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n\/**\n * Represents a single game of Tic Tac Toe. Three in a row down\/across\/diagonally to win; X goes\n * first.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n  private final Player[][] board;\n  private Player turn;\n\n  public TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n\n  @Override\n  public void move(int r, int c) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(r, c);\n    if (board[r][c] != null) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[r][c] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (Player[] row : board) {\n      if (Arrays.stream(row).anyMatch(Objects::isNull)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (Player p : Player.values()) {\n      \/\/ check horizontals\n      for (Player[] row : board) {\n        if(Arrays.stream(row).allMatch(m -> m == p)) {\n          return p;\n        }\n      }\n      \/\/ check verticals\n      for (int i = 0; i < board[0].length; i++) {\n        if (board[0][i] == p && board[1][i] == p && board[2][i] == p) {\n          return p;\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == p && board[1][1] == p && board[2][2] == p) {\n        return p;\n      }\n      if (board[0][2] == p && board[1][1] == p && board[2][0] == p) {\n        return p;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int r = 0; r < board.length; r++) {\n      ret[r] = Arrays.copyOf(board[r], board[r].length);\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int r, int c) {\n    validateRowCol(r, c);\n    return board[r][c];\n  }\n\n  private static void validateRowCol(int r, int c) {\n    if (r < 0 || r > 2 || c < 0 || c > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + r + \",\" + c);\n    }\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard()).map(\n      row -> \" \" + Arrays.stream(row).map(\n        p -> p == null ? \" \" : p.toString()).collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1030\\src\\cs3500\\tictactoe\\model\\TicTacToeModel.java","mask_span":[2294,3159],"topics":["strategy","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0005]  {\n  public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n    if (model.getPieceAt(0, 0) == null)      return new Coord(0, 0);\n    else if (model.getPieceAt(0, 2) == null) return new Coord(0, 2);\n    else if (model.getPieceAt(2, 0) == null) return new Coord(2, 0);\n    else if (model.getPieceAt(2, 2) == null) return new Coord(2, 2);\n    else\n       return new AnyOpenSquare().chooseMove(model, forWhom);\n  }\n}\nThis resolves the question-marks, at the cost of hardcoding which fallback mechanism to choose. But we can definitely be more flexible.\n\n1.2 Strategies can be composed\nThe any-open-square strategy and the any-open-corner strategy are both functions that take in a board state and return a coordinate to move. We can easily, and generally, combine the two of them into a higher-or\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.provider;\n\nimport cs3500.tictactoe.model.TicTacToe;\nimport cs3500.tictactoe.model.TicTacToeModel;\nimport cs3500.tictactoe.provider.view.TicTacToeFrame;\nimport cs3500.tictactoe.provider.view.TicTacToeView;\n\npublic class Main {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    TicTacToe model = new TicTacToeModel();\n    TicTacToeView view = new TicTacToeFrame();\n    view.makeVisible();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1030\\src\\cs3500\\tictactoe\\provider\\Main.java","mask_span":[254,413],"topics":["observer","strategy","gui","decorator","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0004] emented already... Let’s implement just the new part, first:\n\nclass AnyOpenCorner implements TicTacToeStrategy {\n  public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n    if (model.getPieceAt(0, 0) == null)      return new Coord(0, 0);\n    else if (model.getPieceAt(0, 2) == null) return new Coord(0, 2);\n    else if (model.getPieceAt(2, 0) == null) return new Coord(2, 0);\n    else if (model.getPieceAt(2, 2) == null) return new Coord(2, 2);\n    else                                     ????????\n  }\n}\nHow might we fill in the question-marks? This strategy looks for an open corner, but if it can’t find one, it needs to use another approach to pick a response. Fortunately, we have such an approach already: we could reuse AnyOpenSquare!\n\nclass AnyOpenCorner implements TicTacToeStrategy\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.provider.model;\n\npublic class Posn {\n\n  private final int row;\n  private final int col;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic int row() {\n    return row;\n  }\n\n  public int col() {\n    return col;\n  }\n}\n\n\n<\/CodeSuffix>","target":"<Target>\npublic Posn(int row, int col) {\n    this.row = row;\n    this.col = col;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1030\\src\\cs3500\\tictactoe\\provider\\model\\Posn.java","mask_span":[116,191],"topics":["strategy","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0007] y a function that gets called when something interesting occurs. In our case, the clicking of different buttons should trigger a callback. In the jargon of Swing, clicking on buttons triggers their action, and so we must supply a function object that implements the ActionListener interface. (Other controls have additional events besides “actions”.) For convenience, Swing allows us to label each button with a so-called action command, which is a String of our choosing: when the ActionListener’s callback is invoked, it will be given an ActionEvent object that knows the action command of the button that was clicked. In this way, we can use a single listener to listen to multiple buttons at once, and distinguish them by means of this command string. See the calls to setActionCommand and setAct\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0043] e key, String featureName) {\n    this.keyComponent.getInputMap().put(key, featureName);\n  }\n\n  public void addFeatures(Features features) {\n    this.keyComponent.addFeatures(features);\n  }\n}\n\n\/\/ NOTE: Neither does this class!  It only refers to Features.\nclass KeyComponent extends JPanel {\n  List<Features> featureListeners = new ArrayList<>();\n\n  \/\/ Includes this new feature listener in responding to keys\n  void addFeatures(Features f) { this.featureListeners.add(f); }\n\n  KeyComponent() {\n    \/\/ Install action command -> Feature callback associations\n    this.getActionMap().put(\"makeCaps\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.makeUppercase();\n      }\n    });\n    this.getActionMap().put(\"restoreLowe\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.provider.view;\n\nimport javax.swing.*;\n\npublic class CommandPanel extends JPanel {\n\n  private final JTextField field;\n  private final JButton button;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic void addFeatures(Features feat) {\n    this.button.addActionListener((evt) -> feat.processCommand(this.field.getText()));\n  }\n\n  public void clearText() {\n    this.field.setText(\"\");\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic CommandPanel() {\n    this.field = new JTextField(20);\n    this.add(field);\n    this.button = new JButton(\"Execute\");\n    this.add(button);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1030\\src\\cs3500\\tictactoe\\provider\\view\\CommandPanel.java","mask_span":[176,325],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0002] t extends JPanel and overrides paintComponent that draws the game board and game status. Status includes indicating whose turn it is, and if the game is over, who won (or if it was a tie).\na class that extends MouseAdapter and overrides mouseClicked to capture a click on the game board and pass it to the controller.\nYou will also need to fill in the parts of the main method in Main.java as noted in the comments in that method.\n\n2 Testing\nTest your view by running it, inspecting the view, clicking on the game board and playing the game. No automated tests here.\n\n3 Notes to Keep in Mind\nYou will likely want to refer to the sample code on graphical programs, such as the Turtle Graphics example (see the \"solution code\" link).\nSubmit your zip containing only your src directory to In-class Exerc\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.provider.view;\n\nimport java.awt.*;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Point2D;\n\nimport javax.swing.*;\n\nimport cs3500.tictactoe.model.Player;\n\npublic class DisplayPanel extends JPanel {\n\n  private Player[][] board;\n\n  public DisplayPanel() {\n\n  }\n\n  @Override\n  protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n    Graphics2D g2d = (Graphics2D)g.create();\n\n    g2d.transform(transformFromLogicalToPhysical());\n\n    \/\/Two options:\n    \/\/Either set a stroke width so the lines for shapes\n    \/\/look nice\n    \/\/OR find a scalable constant to multiply every coordinate number by\n    \/\/to fit in the intermediate coordinates.\n    \/\/g2d.setStroke(new BasicStroke(0.05f));\n\n    drawBoardState(g2d);\n    drawGridLines(g2d);\n  }\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\nprivate void drawGridLines(Graphics2D g2d) {\n    drawLine(g2d, new Point(1, 0), new Point(1, 3));\n    drawLine(g2d, new Point(2, 0), new Point(2, 3));\n    drawLine(g2d, new Point(0, 1), new Point(3, 1));\n    drawLine(g2d, new Point(0, 2), new Point(3, 2));\n  }\n\n\n\n  public Dimension getPreferredLogicalSize() {\n    return new Dimension(60, 60);\n  }\n\n  public Dimension getPreferredModelSize() {\n    return new Dimension(3, 3);\n  }\n\n  private AffineTransform transformFromLogicalToPhysical() {\n    AffineTransform xform = new AffineTransform();\n    Dimension preferred = this.getPreferredLogicalSize();\n    xform.scale(this.getWidth() \/ preferred.getWidth(),\n        this.getHeight() \/ preferred.getHeight());\n    return xform;\n  }\n\n  private AffineTransform transformModelToLogical() {\n    AffineTransform xform = new AffineTransform();\n    Dimension preferred = this.getPreferredLogicalSize();\n    Dimension preferredModel = this.getPreferredModelSize();\n    xform.scale(preferred.getWidth() \/ preferredModel.getWidth(),\n        preferred.getHeight() \/ preferredModel.getHeight());\n    return xform;\n  }\n\n  \/\/Draw the board state\n  private void drawBoardState(Graphics2D g2d) {\n    if(board != null) {\n      for (int row = 0; row < board.length; row++) {\n        for (int col = 0; col < board[0].length; col++) {\n          if (board[row][col] != null) {\n            drawPlayer(g2d, row, col, board[row][col]);\n          }\n        }\n      }\n    }\n  }\n\n  private void drawPlayer(Graphics2D g2d, int row, int col, Player player) {\n    Color oldColor = g2d.getColor();\n\n    switch(player) {\n      case X:\n        g2d.setColor(Color.CYAN);\n        drawLine(g2d, new Point(col, row), new Point(col+1, row+1));\n        drawLine(g2d, new Point(col+1, row), new Point(col, row+1));\n        break;\n      case O:\n        g2d.setColor(Color.MAGENTA);\n        drawOval(g2d, new Point(col, row), 0.9, 0.9);\n        break;\n      default:\n        \/\/draw nothing\n        break;\n    }\n\n    g2d.setColor(oldColor);\n\n  }\n\n  private void drawLine(Graphics2D g2d, Point2D src, Point2D dst) {\n    Point2D logicalSrc = transformModelToLogical().transform(src, null);\n    Point2D logicalDst = transformModelToLogical().transform(dst, null);\n    g2d.drawLine((int)logicalSrc.getX(),\n        (int)logicalSrc.getY(),\n        (int)logicalDst.getX(),\n        (int)logicalDst.getY());\n  }\n\n  private void drawOval(Graphics2D g2d, Point leftCorner, double width, double height) {\n    Point2D logicalLeftCorner = transformModelToLogical().transform(leftCorner, null);\n    Point2D logicalDimensions = transformModelToLogical().transform(new Point2D.Double(width, height), null);\n    g2d.drawOval((int)logicalLeftCorner.getX(), (int)logicalLeftCorner.getY(),\n        (int)logicalDimensions.getX(), (int)logicalDimensions.getY());\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void updateBoard(Player[][] board) {\n    this.board = board;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1030\\src\\cs3500\\tictactoe\\provider\\view\\DisplayPanel.java","mask_span":[795,866],"topics":["gui","mvc","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.provider.view;\n\nimport java.awt.*;\n\nimport javax.swing.*;\n\nimport cs3500.tictactoe.model.Player;\n\npublic class TicTacToeFrame extends JFrame implements TicTacToeView {\n\n  private final CommandPanel commandPanel;\n  private final DisplayPanel displayPanel;\n\n  public TicTacToeFrame() {\n    super();\n    setSize(800, 800);\n    setDefaultCloseOperation(EXIT_ON_CLOSE);\n    this.setLayout(new BorderLayout());\n\n    this.displayPanel = new DisplayPanel();\n    this.add(this.displayPanel, BorderLayout.CENTER);\n\n    this.commandPanel = new CommandPanel();\n    this.add(this.commandPanel, BorderLayout.PAGE_END);\n  }\n\n  @Override\n  public void addFeatures(Features feat) {\n    this.commandPanel.addFeatures(feat);\n  }\n\n  @Override\n  public void refresh() {\n    this.commandPanel.clearText();\n    this.repaint();\n  }\n\n  @Override\n  public void makeVisible() {\n    this.setVisible(true);\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void updateBoard(Player[][] board) {\n    this.displayPanel.updateBoard(board);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1030\\src\\cs3500\\tictactoe\\provider\\view\\TicTacToeFrame.java","mask_span":[922,1011],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.view;\n\nimport cs3500.tictactoe.model.TicTacToe;\nimport cs3500.tictactoe.provider.view.TicTacToeView;\n\npublic class TicTacToeViewToTTTViewAdapter implements TTTView {\n\n  private TicTacToeView adaptee;\n  private TicTacToe model;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void addClickListener(ViewActions listener) {\n    this.adaptee.addFeatures(new ViewActionsToFeaturesAdapter(listener));\n  }\n\n  @Override\n  public void refresh() {\n    this.adaptee.updateBoard(model.getBoard());\n    this.adaptee.refresh();\n  }\n\n  @Override\n  public void makeVisible() {\n    this.adaptee.makeVisible();\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeViewToTTTViewAdapter(TicTacToe model, TicTacToeView adaptee) {\n    if(adaptee == null || model == null) {\n      throw new IllegalArgumentException(\"Can't be null\");\n    }\n    this.adaptee = adaptee;\n    this.model = model;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1030\\src\\cs3500\\tictactoe\\view\\TicTacToeViewToTTTViewAdapter.java","mask_span":[255,497],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.view;\n\nimport cs3500.tictactoe.model.TicTacToe;\nimport cs3500.tictactoe.provider.view.TicTacToeView;\n\npublic class TicTacToeViewToTTTViewAdapter implements TTTView {\n\n  private TicTacToeView adaptee;\n  private TicTacToe model;\n\n  public TicTacToeViewToTTTViewAdapter(TicTacToe model, TicTacToeView adaptee) {\n    if(adaptee == null || model == null) {\n      throw new IllegalArgumentException(\"Can't be null\");\n    }\n    this.adaptee = adaptee;\n    this.model = model;\n  }\n\n  @Override\n  public void addClickListener(ViewActions listener) {\n    this.adaptee.addFeatures(new ViewActionsToFeaturesAdapter(listener));\n  }\n\n  @Override\n  public void refresh() {\n    this.adaptee.updateBoard(model.getBoard());\n    this.adaptee.refresh();\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void makeVisible() {\n    this.adaptee.makeVisible();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1030\\src\\cs3500\\tictactoe\\view\\TicTacToeViewToTTTViewAdapter.java","mask_span":[778,841],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0002] t extends JPanel and overrides paintComponent that draws the game board and game status. Status includes indicating whose turn it is, and if the game is over, who won (or if it was a tie).\na class that extends MouseAdapter and overrides mouseClicked to capture a click on the game board and pass it to the controller.\nYou will also need to fill in the parts of the main method in Main.java as noted in the comments in that method.\n\n2 Testing\nTest your view by running it, inspecting the view, clicking on the game board and playing the game. No automated tests here.\n\n3 Notes to Keep in Mind\nYou will likely want to refer to the sample code on graphical programs, such as the Turtle Graphics example (see the \"solution code\" link).\nSubmit your zip containing only your src directory to In-class Exerc\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.view;\n\nimport javax.swing.*;\n\nimport cs3500.tictactoe.model.ReadonlyTTTModel;\n\npublic class TTTFrame extends JFrame implements TTTView {\n\n  private TTTPanel panel;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void addClickListener(ViewActions observer) {\n    panel.addClickListener(observer);\n  }\n\n  @Override\n  public void refresh() {\n    this.repaint();\n  }\n\n  @Override\n  public void makeVisible() {\n    setVisible(true);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TTTFrame(ReadonlyTTTModel model) {\n    super();\n    setSize(800, 800);\n    setDefaultCloseOperation(EXIT_ON_CLOSE);\n    panel = new TTTPanel(model);\n    this.add(panel);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1030\\src\\cs3500\\tictactoe\\view\\TTTFrame.java","mask_span":[192,372],"topics":["observer","gui","adapter","decorator","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0002] t extends JPanel and overrides paintComponent that draws the game board and game status. Status includes indicating whose turn it is, and if the game is over, who won (or if it was a tie).\na class that extends MouseAdapter and overrides mouseClicked to capture a click on the game board and pass it to the controller.\nYou will also need to fill in the parts of the main method in Main.java as noted in the comments in that method.\n\n2 Testing\nTest your view by running it, inspecting the view, clicking on the game board and playing the game. No automated tests here.\n\n3 Notes to Keep in Mind\nYou will likely want to refer to the sample code on graphical programs, such as the Turtle Graphics example (see the \"solution code\" link).\nSubmit your zip containing only your src directory to In-class Exerc\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.view;\n\nimport java.awt.*;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.NoninvertibleTransformException;\nimport java.awt.geom.Point2D;\n\nimport javax.swing.*;\n\nimport cs3500.tictactoe.model.Player;\nimport cs3500.tictactoe.model.ReadonlyTTTModel;\n\npublic class TTTPanel extends JPanel {\n  private final ReadonlyTTTModel model;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n    Graphics2D g2d = (Graphics2D)g.create();\n\n    g2d.transform(transformFromLogicalToPhysical());\n\n    \/\/Two options:\n    \/\/Either set a stroke width so the lines for shapes\n    \/\/look nice\n    \/\/OR find a scalable constant to multiply every coordinate number by\n    \/\/to fit in the intermediate coordinates.\n    \/\/g2d.setStroke(new BasicStroke(0.05f));\n\n    drawBoardState(g2d);\n    drawGridLines(g2d);\n\n  }\n\n  private void drawGridLines(Graphics2D g2d) {\n    drawLine(g2d, new Point(1, 0), new Point(1, 3));\n    drawLine(g2d, new Point(2, 0), new Point(2, 3));\n    drawLine(g2d, new Point(0, 1), new Point(3, 1));\n    drawLine(g2d, new Point(0, 2), new Point(3, 2));\n  }\n\n\n\n  public Dimension getPreferredLogicalSize() {\n    return new Dimension(30, 30);\n  }\n\n  public Dimension getPreferredModelSize() {\n    return new Dimension(3, 3);\n  }\n\n  private AffineTransform transformFromLogicalToPhysical() {\n    AffineTransform xform = new AffineTransform();\n    Dimension preferred = this.getPreferredLogicalSize();\n    xform.scale(this.getWidth() \/ preferred.getWidth(),\n        this.getHeight() \/ preferred.getHeight());\n    return xform;\n  }\n\n  private AffineTransform transformModelToLogical() {\n    AffineTransform xform = new AffineTransform();\n    Dimension preferred = this.getPreferredLogicalSize();\n    Dimension preferredModel = this.getPreferredModelSize();\n    xform.scale(preferred.getWidth() \/ preferredModel.getWidth(),\n        preferred.getHeight() \/ preferredModel.getHeight());\n    return xform;\n  }\n\n  \/\/Draw the board state\n  private void drawBoardState(Graphics2D g2d) {\n    Player[][] board = model.getBoard();\n    for(int row = 0; row < board.length; row++) {\n      for(int col = 0; col < board[0].length; col++) {\n        if(board[row][col] != null) {\n          drawPlayer(g2d, row, col, board[row][col]);\n        }\n      }\n    }\n  }\n\n  private void drawPlayer(Graphics2D g2d, int row, int col, Player player) {\n    Color oldColor = g2d.getColor();\n\n    switch(player) {\n      case X:\n        g2d.setColor(Color.BLACK);\n        drawLine(g2d, new Point(col, row), new Point(col+1, row+1));\n        drawLine(g2d, new Point(col+1, row), new Point(col, row+1));\n        break;\n      case O:\n        g2d.setColor(Color.RED);\n        drawOval(g2d, new Point(col, row), 1, 1);\n        break;\n      default:\n        \/\/draw nothing\n        break;\n    }\n\n    g2d.setColor(oldColor);\n\n  }\n\n  private void drawLine(Graphics2D g2d, Point2D src, Point2D dst) {\n    Point2D logicalSrc = transformModelToLogical().transform(src, null);\n    Point2D logicalDst = transformModelToLogical().transform(dst, null);\n    g2d.drawLine((int)logicalSrc.getX(),\n        (int)logicalSrc.getY(),\n        (int)logicalDst.getX(),\n        (int)logicalDst.getY());\n  }\n\n  private void drawOval(Graphics2D g2d, Point leftCorner, int width, int height) {\n    Point2D logicalLeftCorner = transformModelToLogical().transform(leftCorner, null);\n    Point2D logicalDimensions = transformModelToLogical().transform(new Point(width, height), null);\n    g2d.drawOval((int)logicalLeftCorner.getX(), (int)logicalLeftCorner.getY(),\n        (int)logicalDimensions.getX(), (int)logicalDimensions.getY());\n  }\n\n\n\n  public void addClickListener(ViewActions observer) {\n    this.addMouseListener(new MouseListener() { \/\/anonymous class. Can do inner instead\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        try {\n          AffineTransform physicalToLogical = transformFromLogicalToPhysical();\n          physicalToLogical.invert();\n\n          AffineTransform logicalToModel = transformModelToLogical();\n          logicalToModel.invert();\n\n          Point2D evtPt = e.getPoint();\n          Point2D modelPt = physicalToLogical.transform(evtPt, null);\n          logicalToModel.transform(modelPt, modelPt);\n\n          observer.handleCellClick((int)modelPt.getY(),\n              (int)modelPt.getX());\n        } catch (NoninvertibleTransformException ex) {\n          throw new RuntimeException(ex);\n        }\n      }\n\n      @Override\n      public void mousePressed(MouseEvent e) {\n\n      }\n\n      @Override\n      public void mouseReleased(MouseEvent e) {\n\n      }\n\n      @Override\n      public void mouseEntered(MouseEvent e) {\n\n      }\n\n      @Override\n      public void mouseExited(MouseEvent e) {\n\n      }\n    });\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TTTPanel(ReadonlyTTTModel model) {\n    super();\n    this.model = model;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1030\\src\\cs3500\\tictactoe\\view\\TTTPanel.java","mask_span":[436,518],"topics":["observer","gui","adapter","decorator","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.view;\n\nimport cs3500.tictactoe.provider.view.Features;\n\npublic class ViewActionsToFeaturesAdapter implements Features {\n\n  \/\/input is 1-index based coordinates.\n  \/\/recall ViewActions uses 0-index based coordinates\n  private ViewActions adaptee;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void processCommand(String input) {\n    \/\/parse the input to get a row and col\n    String[] indices = input.split(\" \"); \/\/index 0 is row, index 1 is col\n    \/\/pass that into handleCellClick\n    this.adaptee.handleCellClick(\n        Integer.parseInt(indices[0])-1,\n        Integer.parseInt(indices[1])-1);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic ViewActionsToFeaturesAdapter(ViewActions adaptee) {\n    this.adaptee = adaptee;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1030\\src\\cs3500\\tictactoe\\view\\ViewActionsToFeaturesAdapter.java","mask_span":[274,364],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe;\n\nimport cs3500.tictactoe.controller.TicTacToeController;\nimport cs3500.tictactoe.controller.TicTacToeGUIController;\nimport cs3500.tictactoe.model.TicTacToe;\nimport cs3500.tictactoe.model.TicTacToeModel;\nimport cs3500.tictactoe.provider.view.TicTacToeFrame;\nimport cs3500.tictactoe.view.TTTFrame;\nimport cs3500.tictactoe.view.TTTView;\nimport cs3500.tictactoe.view.TicTacToeViewToTTTViewAdapter;\n\n\/**\n * Run a Tic Tac Toe game interactively.\n *\/\npublic class Main {\n  \/**\n   * Run a Tic Tac Toe game interactively.\n   *\/\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    \/\/ Old News: console-based game:\n    \/\/new TicTacToeConsoleController(new InputStreamReader(System.in),\n    \/\/    System.out).playGame(new TicTacToeModel());\n\n    \/\/ New Hotness: Graphical User Interface:\n    \/\/ 1. Create an instance of the model.\n    TicTacToe model = new TicTacToeModel();\n    \/\/ 2. Create an instance of the view.\n    TTTView view = new TicTacToeViewToTTTViewAdapter(new TicTacToeFrame(),\n        model);\n    \/\/ 3. Create an instance of the controller, passing the view to its constructor.\n    TicTacToeController controller =\n        new TicTacToeGUIController(view);\n    \/\/ 4. Call playGame() on the controller.\n    controller.playGame(model);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1335\\src\\cs3500\\tictactoe\\Main.java","mask_span":[547,1261],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.controller;\n\nimport java.io.IOException;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\nimport cs3500.tictactoe.model.TicTacToe;\n\npublic class TicTacToeConsoleController implements TicTacToeController {\n\n  private final Appendable out;\n  private final Scanner scan;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void playGame(TicTacToe m) {\n    try {\n      appendStateAndPrompt(m);\n      Integer mvRow = null;\n      Integer mvCol = null;\n      String tok = \"\";\n      while (!m.isGameOver()) {\n        tok = scan.next();\n        if (tok.equalsIgnoreCase(\"q\")) {\n          break;\n        }\n        try {\n          int v = Integer.parseInt(tok);\n          if (mvRow == null) {\n            mvRow = v;\n          } else {\n            mvCol = v;\n            m.move(mvRow - 1, mvCol - 1);\n            if(m.isGameOver()) {\n              out.append(m.toString()).append(\"\\n\");\n              out.append(\"Game is over! \");\n              if(m.getWinner() != null) {\n                out.append(m.getWinner().toString() + \" wins.\\n\");\n              } else {\n                out.append(\"Tie game.\\n\");\n              }\n              break;\n            }\n            appendStateAndPrompt(m);\n            mvRow = mvCol = null;\n          }\n        } catch (NumberFormatException nfe) {\n          out.append(\"Not a valid number: \" + tok).append(\"\\n\");\n        } catch (IllegalArgumentException iae) {\n          out.append(\"Not a valid move: \" + mvRow + \", \" + mvCol).append(\"\\n\");\n          mvRow = mvCol = null;\n        }\n      }\n      if (!m.isGameOver() && tok.equalsIgnoreCase(\"q\")) {\n        out.append(\"Game quit! Ending game state:\\n\" + m.toString() + \"\\n\");\n      } else if (!m.isGameOver()) {\n        throw new IllegalStateException(\"Ran out of inputs\");\n      }\n    } catch (IOException ioe) {\n      scan.close();\n      throw new IllegalStateException(\"append failed\", ioe);\n    } catch (NoSuchElementException e) {\n      throw new IllegalStateException(\"failed to read from readable\");\n    }\n    scan.close();\n  }\n\n  private void appendStateAndPrompt(TicTacToe m) throws IOException {\n    out.append(m.toString()).append(\"\\n\");\n    out.append(\"Enter a move for \" + m.getTurn().toString()).append(\":\\n\");\n  }\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeConsoleController(Readable in, Appendable out) {\n    if (in == null || out == null) {\n      throw new IllegalArgumentException(\"Readable and Appendable can't be null\");\n    }\n    this.out = out;\n    scan = new Scanner(in);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1335\\src\\cs3500\\tictactoe\\controller\\TicTacToeConsoleController.java","mask_span":[315,557],"topics":["gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.controller;\n\nimport cs3500.tictactoe.model.TicTacToe;\nimport cs3500.tictactoe.view.TTTView;\nimport cs3500.tictactoe.view.ViewActions;\n\npublic class TicTacToeGUIController implements TicTacToeController, ViewActions {\n\n  private final TTTView view;\n  private TicTacToe model;\n  public TicTacToeGUIController(TTTView view) {\n    this.view = view;\n  }\n\n  @Override\n  public void playGame(TicTacToe m) {\n    this.model = m;\n    this.view.addClickListener(this);\n    this.view.makeVisible();\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void handleCellClick(int row, int col) {\n    try {\n      model.move(row, col);\n    } catch (IllegalArgumentException ex) {\n      \/\/tell the user somehow the arguments were wrong\n    } catch (IllegalStateException ex) {\n      \/\/tell the user somehow they made a mistake choosing a cell\n      \/\/or the game is over\n    }\n    view.refresh();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1335\\src\\cs3500\\tictactoe\\controller\\TicTacToeGUIController.java","mask_span":[531,880],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.model;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n\/**\n * Represents a single game of Tic Tac Toe. Three in a row down\/across\/diagonally to win; X goes\n * first.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n  private final Player[][] board;\n  private Player turn;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void move(int r, int c) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(r, c);\n    if (board[r][c] != null) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[r][c] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (Player[] row : board) {\n      if (Arrays.stream(row).anyMatch(Objects::isNull)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (Player p : Player.values()) {\n      \/\/ check horizontals\n      for (Player[] row : board) {\n        if(Arrays.stream(row).allMatch(m -> m == p)) {\n          return p;\n        }\n      }\n      \/\/ check verticals\n      for (int i = 0; i < board[0].length; i++) {\n        if (board[0][i] == p && board[1][i] == p && board[2][i] == p) {\n          return p;\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == p && board[1][1] == p && board[2][2] == p) {\n        return p;\n      }\n      if (board[0][2] == p && board[1][1] == p && board[2][0] == p) {\n        return p;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int r = 0; r < board.length; r++) {\n      ret[r] = Arrays.copyOf(board[r], board[r].length);\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int r, int c) {\n    validateRowCol(r, c);\n    return board[r][c];\n  }\n\n  private static void validateRowCol(int r, int c) {\n    if (r < 0 || r > 2 || c < 0 || c > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + r + \",\" + c);\n    }\n  }\n\n  @Override\n  public String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard()).map(\n      row -> \" \" + Arrays.stream(row).map(\n        p -> p == null ? \" \" : p.toString()).collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1335\\src\\cs3500\\tictactoe\\model\\TicTacToeModel.java","mask_span":[347,427],"topics":["strategy","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0002] ategy above is pretty good.1 How might we implement these strategies?\n\n1.1 A strategy is just a function object\nSuppose in our program we had a TicTacToeModel containing the board state, and a Piece enumeration naming X and O. Our program also contains two Player objects (one for each Piece), which may call the model’s playMove(Piece player, int row, int col) method to make a move. How should the Players choose where to move? What information would be needed to make an informed choice? We’d need to know the state of the board, and also know which player we’re trying to choose a move for:\n\nclass Coord {\n  int row;\n  int col\n}\ninterface TicTacToeStrategy {\n  Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\nImplementing our first strategy is pretty easy. It doesn’t care who it’s choos\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 6 The Model.txt::chunk0008] simply have one move method, and require the model to move for the correct player in each case. This is an example of preventing a problematic situation through design:\n\n\/**\n * Places an X or O mark in the specified cell. Whether it places an X\n * or O depends on which player's turn it is.\n *\n * @param column the column of the cell\n * @param row    the row of the cell\n * @throws IllegalStateException if the game is over, or if there is\n * already a mark in the cell.\n * @throws IndexOutOfBoundsException if the cell is out of bounds.\n *\/\nvoid move(int column, int row);\nOf course, there are additional possibilities such as a single move method that takes some specification of which player is moving as the parameter. And we may not have specified the method fully, since we haven’t said how the\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.model;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n\/**\n * Represents a single game of Tic Tac Toe. Three in a row down\/across\/diagonally to win; X goes\n * first.\n *\/\npublic class TicTacToeModel implements TicTacToe {\n  private final Player[][] board;\n  private Player turn;\n\n  public TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n\n  @Override\n  public void move(int r, int c) {\n    if (isGameOver()) {\n      throw new IllegalStateException(\"Game is over\");\n    }\n    validateRowCol(r, c);\n    if (board[r][c] != null) {\n      throw new IllegalArgumentException(\"Position occupied\");\n    }\n    board[r][c] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    boolean boardFull = true;\n    for (Player[] row : board) {\n      if (Arrays.stream(row).anyMatch(Objects::isNull)) {\n        boardFull = false;\n        break;\n      }\n    }\n    return boardFull || getWinner() != null;\n  }\n\n  @Override\n  public Player getWinner() {\n    for (Player p : Player.values()) {\n      \/\/ check horizontals\n      for (Player[] row : board) {\n        if(Arrays.stream(row).allMatch(m -> m == p)) {\n          return p;\n        }\n      }\n      \/\/ check verticals\n      for (int i = 0; i < board[0].length; i++) {\n        if (board[0][i] == p && board[1][i] == p && board[2][i] == p) {\n          return p;\n        }\n      }\n      \/\/ check diagonals\n      if (board[0][0] == p && board[1][1] == p && board[2][2] == p) {\n        return p;\n      }\n      if (board[0][2] == p && board[1][1] == p && board[2][0] == p) {\n        return p;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public Player[][] getBoard() {\n    Player[][] ret = new Player[3][3];\n    for (int r = 0; r < board.length; r++) {\n      ret[r] = Arrays.copyOf(board[r], board[r].length);\n    }\n    return ret;\n  }\n\n  @Override\n  public Player getMarkAt(int r, int c) {\n    validateRowCol(r, c);\n    return board[r][c];\n  }\n\n  private static void validateRowCol(int r, int c) {\n    if (r < 0 || r > 2 || c < 0 || c > 2) {\n      throw new IllegalArgumentException(\"Invalid board position: \" + r + \",\" + c);\n    }\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic String toString() {\n    \/\/ Using Java stream API to save code:\n    return Arrays.stream(getBoard()).map(\n      row -> \" \" + Arrays.stream(row).map(\n        p -> p == null ? \" \" : p.toString()).collect(Collectors.joining(\" | \")))\n          .collect(Collectors.joining(\"\\n-----------\\n\"));\n    \/\/ This is the equivalent code as above, but using iteration, and still using the helpful\n    \/\/ built-in String.join method.\n    \/\/ List<String> rows = new ArrayList<>();\n    \/\/ for(Player[] row : getBoard()) {\n    \/\/   List<String> rowStrings = new ArrayList<>();\n    \/\/   for(Player p : row) {\n    \/\/     if(p == null) {\n    \/\/       rowStrings.add(\" \");\n    \/\/     } else {\n    \/\/       rowStrings.add(p.toString());\n    \/\/     }\n    \/\/   }\n    \/\/   rows.add(\" \" + String.join(\" | \", rowStrings));\n    \/\/ }\n    \/\/ return String.join(\"\\n-----------\\n\", rows);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1335\\src\\cs3500\\tictactoe\\model\\TicTacToeModel.java","mask_span":[2294,3159],"topics":["strategy","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 16 The Strategy and Decorat.txt::chunk0005]  {\n  public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n    if (model.getPieceAt(0, 0) == null)      return new Coord(0, 0);\n    else if (model.getPieceAt(0, 2) == null) return new Coord(0, 2);\n    else if (model.getPieceAt(2, 0) == null) return new Coord(2, 0);\n    else if (model.getPieceAt(2, 2) == null) return new Coord(2, 2);\n    else\n       return new AnyOpenSquare().chooseMove(model, forWhom);\n  }\n}\nThis resolves the question-marks, at the cost of hardcoding which fallback mechanism to choose. But we can definitely be more flexible.\n\n1.2 Strategies can be composed\nThe any-open-square strategy and the any-open-corner strategy are both functions that take in a board state and return a coordinate to move. We can easily, and generally, combine the two of them into a higher-or\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.provider;\n\nimport cs3500.tictactoe.model.TicTacToe;\nimport cs3500.tictactoe.model.TicTacToeModel;\nimport cs3500.tictactoe.provider.view.TicTacToeFrame;\nimport cs3500.tictactoe.provider.view.TicTacToeView;\n\npublic class Main {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic static void main(String[] args) {\n    TicTacToe model = new TicTacToeModel();\n    TicTacToeView view = new TicTacToeFrame();\n    view.makeVisible();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1335\\src\\cs3500\\tictactoe\\provider\\Main.java","mask_span":[254,413],"topics":["observer","strategy","gui","decorator","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0008] ionListener and the implementation of actionPerformed in JFrameView.java for an example:\n\nclass JFrameView extends JFrame implements ActionListener {\n  public JFrameView(String caption, IModel model) {\n    ...\n    echoButton = new JButton(\"Echo\");           \/\/ Create a button,\n    echoButton.setActionCommand(\"Echo Button\"); \/\/ set its command,\n    echoButton.addActionListener(this);         \/\/ set the callback,\n    this.add(echoButton);                       \/\/ and add it to the UI\n\n    exitButton = new JButton(\"Exit\");           \/\/ ditto, for another button\n    exitButton.setActionCommand(\"Exit Button\");\n    exitButton.addActionListener(this);\n    this.add(exitButton);\n    ...\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    switch (e.getActionCommand()) {\n    case \"Ech\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0007] y a function that gets called when something interesting occurs. In our case, the clicking of different buttons should trigger a callback. In the jargon of Swing, clicking on buttons triggers their action, and so we must supply a function object that implements the ActionListener interface. (Other controls have additional events besides “actions”.) For convenience, Swing allows us to label each button with a so-called action command, which is a String of our choosing: when the ActionListener’s callback is invoked, it will be given an ActionEvent object that knows the action command of the button that was clicked. In this way, we can use a single listener to listen to multiple buttons at once, and distinguish them by means of this command string. See the calls to setActionCommand and setAct\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0043] e key, String featureName) {\n    this.keyComponent.getInputMap().put(key, featureName);\n  }\n\n  public void addFeatures(Features features) {\n    this.keyComponent.addFeatures(features);\n  }\n}\n\n\/\/ NOTE: Neither does this class!  It only refers to Features.\nclass KeyComponent extends JPanel {\n  List<Features> featureListeners = new ArrayList<>();\n\n  \/\/ Includes this new feature listener in responding to keys\n  void addFeatures(Features f) { this.featureListeners.add(f); }\n\n  KeyComponent() {\n    \/\/ Install action command -> Feature callback associations\n    this.getActionMap().put(\"makeCaps\", new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        for (Features f : featureListeners)\n          f.makeUppercase();\n      }\n    });\n    this.getActionMap().put(\"restoreLowe\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.provider.view;\n\nimport javax.swing.*;\n\npublic class CommandPanel extends JPanel {\n\n  private final JTextField field;\n  private final JButton button;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\npublic void addFeatures(Features feat) {\n    this.button.addActionListener((evt) -> feat.processCommand(this.field.getText()));\n  }\n\n  public void clearText() {\n    this.field.setText(\"\");\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic CommandPanel() {\n    this.field = new JTextField(20);\n    this.add(field);\n    this.button = new JButton(\"Execute\");\n    this.add(button);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1335\\src\\cs3500\\tictactoe\\provider\\view\\CommandPanel.java","mask_span":[176,325],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0002] t extends JPanel and overrides paintComponent that draws the game board and game status. Status includes indicating whose turn it is, and if the game is over, who won (or if it was a tie).\na class that extends MouseAdapter and overrides mouseClicked to capture a click on the game board and pass it to the controller.\nYou will also need to fill in the parts of the main method in Main.java as noted in the comments in that method.\n\n2 Testing\nTest your view by running it, inspecting the view, clicking on the game board and playing the game. No automated tests here.\n\n3 Notes to Keep in Mind\nYou will likely want to refer to the sample code on graphical programs, such as the Turtle Graphics example (see the \"solution code\" link).\nSubmit your zip containing only your src directory to In-class Exerc\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.provider.view;\n\nimport java.awt.*;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Point2D;\n\nimport javax.swing.*;\n\nimport cs3500.tictactoe.model.Player;\n\npublic class DisplayPanel extends JPanel {\n\n  private Player[][] board;\n\n  public DisplayPanel() {\n\n  }\n\n  @Override\n  protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n    Graphics2D g2d = (Graphics2D)g.create();\n\n    g2d.transform(transformFromLogicalToPhysical());\n\n    \/\/Two options:\n    \/\/Either set a stroke width so the lines for shapes\n    \/\/look nice\n    \/\/OR find a scalable constant to multiply every coordinate number by\n    \/\/to fit in the intermediate coordinates.\n    \/\/g2d.setStroke(new BasicStroke(0.05f));\n\n    drawBoardState(g2d);\n    drawGridLines(g2d);\n  }\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\nprivate void drawGridLines(Graphics2D g2d) {\n    drawLine(g2d, new Point(1, 0), new Point(1, 3));\n    drawLine(g2d, new Point(2, 0), new Point(2, 3));\n    drawLine(g2d, new Point(0, 1), new Point(3, 1));\n    drawLine(g2d, new Point(0, 2), new Point(3, 2));\n  }\n\n\n\n  public Dimension getPreferredLogicalSize() {\n    return new Dimension(60, 60);\n  }\n\n  public Dimension getPreferredModelSize() {\n    return new Dimension(3, 3);\n  }\n\n  private AffineTransform transformFromLogicalToPhysical() {\n    AffineTransform xform = new AffineTransform();\n    Dimension preferred = this.getPreferredLogicalSize();\n    xform.scale(this.getWidth() \/ preferred.getWidth(),\n        this.getHeight() \/ preferred.getHeight());\n    return xform;\n  }\n\n  private AffineTransform transformModelToLogical() {\n    AffineTransform xform = new AffineTransform();\n    Dimension preferred = this.getPreferredLogicalSize();\n    Dimension preferredModel = this.getPreferredModelSize();\n    xform.scale(preferred.getWidth() \/ preferredModel.getWidth(),\n        preferred.getHeight() \/ preferredModel.getHeight());\n    return xform;\n  }\n\n  \/\/Draw the board state\n  private void drawBoardState(Graphics2D g2d) {\n    if(board != null) {\n      for (int row = 0; row < board.length; row++) {\n        for (int col = 0; col < board[0].length; col++) {\n          if (board[row][col] != null) {\n            drawPlayer(g2d, row, col, board[row][col]);\n          }\n        }\n      }\n    }\n  }\n\n  private void drawPlayer(Graphics2D g2d, int row, int col, Player player) {\n    Color oldColor = g2d.getColor();\n\n    switch(player) {\n      case X:\n        g2d.setColor(Color.CYAN);\n        drawLine(g2d, new Point(col, row), new Point(col+1, row+1));\n        drawLine(g2d, new Point(col+1, row), new Point(col, row+1));\n        break;\n      case O:\n        g2d.setColor(Color.MAGENTA);\n        drawOval(g2d, new Point(col, row), 0.9, 0.9);\n        break;\n      default:\n        \/\/draw nothing\n        break;\n    }\n\n    g2d.setColor(oldColor);\n\n  }\n\n  private void drawLine(Graphics2D g2d, Point2D src, Point2D dst) {\n    Point2D logicalSrc = transformModelToLogical().transform(src, null);\n    Point2D logicalDst = transformModelToLogical().transform(dst, null);\n    g2d.drawLine((int)logicalSrc.getX(),\n        (int)logicalSrc.getY(),\n        (int)logicalDst.getX(),\n        (int)logicalDst.getY());\n  }\n\n  private void drawOval(Graphics2D g2d, Point leftCorner, double width, double height) {\n    Point2D logicalLeftCorner = transformModelToLogical().transform(leftCorner, null);\n    Point2D logicalDimensions = transformModelToLogical().transform(new Point2D.Double(width, height), null);\n    g2d.drawOval((int)logicalLeftCorner.getX(), (int)logicalLeftCorner.getY(),\n        (int)logicalDimensions.getX(), (int)logicalDimensions.getY());\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void updateBoard(Player[][] board) {\n    this.board = board;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1335\\src\\cs3500\\tictactoe\\provider\\view\\DisplayPanel.java","mask_span":[795,866],"topics":["gui","mvc","decorator","adapter"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0045] se();\n    view.setEchoOutput(text);\n  }\n\n  @Override\n  public void restoreLowercase() {\n    String text = model.getString();\n    view.setEchoOutput(text);\n  }\n\n  \/\/ This attaches this controller as our features listener\n  public void setView(IView v) {\n    this.view = v;\n    view.addFeatures(this);\n\n    \/\/ Choose the keys we want\n    view.setHotKey(KeyStroke.getKeyStroke(\"pressed c\"), \"makeCaps\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"released c\"), \"restoreLowercase\");\n    view.setHotKey(KeyStroke.getKeyStroke(\"typed r\"), \"toggleColor\");\n  }\n\n  ...\n}\n12 Exercises\nAt the top of this lecture are starter files for a GUI version of the Turtles example we worked through in Lecture 10. The TurtleGraphicsView does not currently do anything. Enhance this code with a new TurtlePanel class that\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.provider.view;\n\nimport java.awt.*;\n\nimport javax.swing.*;\n\nimport cs3500.tictactoe.model.Player;\n\npublic class TicTacToeFrame extends JFrame implements TicTacToeView {\n\n  private final CommandPanel commandPanel;\n  private final DisplayPanel displayPanel;\n\n  public TicTacToeFrame() {\n    super();\n    setSize(800, 800);\n    setDefaultCloseOperation(EXIT_ON_CLOSE);\n    this.setLayout(new BorderLayout());\n\n    this.displayPanel = new DisplayPanel();\n    this.add(this.displayPanel, BorderLayout.CENTER);\n\n    this.commandPanel = new CommandPanel();\n    this.add(this.commandPanel, BorderLayout.PAGE_END);\n  }\n\n  @Override\n  public void addFeatures(Features feat) {\n    this.commandPanel.addFeatures(feat);\n  }\n\n  @Override\n  public void refresh() {\n    this.commandPanel.clearText();\n    this.repaint();\n  }\n\n  @Override\n  public void makeVisible() {\n    this.setVisible(true);\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void updateBoard(Player[][] board) {\n    this.displayPanel.updateBoard(board);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1335\\src\\cs3500\\tictactoe\\provider\\view\\TicTacToeFrame.java","mask_span":[922,1011],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.view;\n\nimport cs3500.tictactoe.model.TicTacToe;\nimport cs3500.tictactoe.provider.view.TicTacToeView;\n\npublic class TicTacToeViewToTTTViewAdapter implements TTTView {\n\n  private TicTacToeView adaptee;\n  private TicTacToe model;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n\/\/ processCommands is 1-index based row, then col\n  \/\/ handleCellClick is 0-index based row and col\n  @Override\n  public void addClickListener(ViewActions listener) {\n    \/\/TODO: Find a way to make sure the class adapter has the model itself\n    \/\/ since it IS the controller now\n    \/\/this.adaptee.addFeatures(new ViewActionsToFeaturesAdapter(this));\n\n    this.adaptee.addFeatures(new ViewActionsToFeaturesObjectAdapter(listener));\n  }\n\n  @Override\n  public void refresh() {\n    this.adaptee.updateBoard(model.getBoard());\n    this.adaptee.refresh();\n  }\n\n  @Override\n  public void makeVisible() {\n    this.adaptee.makeVisible();\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TicTacToeViewToTTTViewAdapter(TicTacToeView adaptee, TicTacToe model) {\n    if(adaptee == null) {\n      throw new IllegalArgumentException(\"Cannot be null\");\n    }\n    this.adaptee = adaptee;\n    this.model = model;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1335\\src\\cs3500\\tictactoe\\view\\TicTacToeViewToTTTViewAdapter.java","mask_span":[255,481],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n---\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.view;\n\nimport cs3500.tictactoe.model.TicTacToe;\nimport cs3500.tictactoe.provider.view.TicTacToeView;\n\npublic class TicTacToeViewToTTTViewAdapter implements TTTView {\n\n  private TicTacToeView adaptee;\n  private TicTacToe model;\n\n  public TicTacToeViewToTTTViewAdapter(TicTacToeView adaptee, TicTacToe model) {\n    if(adaptee == null) {\n      throw new IllegalArgumentException(\"Cannot be null\");\n    }\n    this.adaptee = adaptee;\n    this.model = model;\n  }\n\n  \/\/ processCommands is 1-index based row, then col\n  \/\/ handleCellClick is 0-index based row and col\n  @Override\n  public void addClickListener(ViewActions listener) {\n    \/\/TODO: Find a way to make sure the class adapter has the model itself\n    \/\/ since it IS the controller now\n    \/\/this.adaptee.addFeatures(new ViewActionsToFeaturesAdapter(this));\n\n    this.adaptee.addFeatures(new ViewActionsToFeaturesObjectAdapter(listener));\n  }\n\n  @Override\n  public void refresh() {\n    this.adaptee.updateBoard(model.getBoard());\n    this.adaptee.refresh();\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void makeVisible() {\n    this.adaptee.makeVisible();\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1335\\src\\cs3500\\tictactoe\\view\\TicTacToeViewToTTTViewAdapter.java","mask_span":[1056,1119],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0011]  the view to take in a listener object and forward any events it receives to that listener.\n\npublic class JFrameView extends JFrame implements IView {\n  public JFrameView(String caption) { \/\/ NOTE: No model!\n    ...\n    echoButton = new JButton(\"Echo\"); \/\/ NOTE: No action listener\n    echoButton.setActionCommand(\"Echo Button\");\n    this.add(echoButton);\n\n    exitButton = new JButton(\"Exit\");\n    exitButton.setActionCommand(\"Exit Button\");\n    this.add(exitButton);\n    ...\n  }\n\n  public void setListener(ActionListener listener) {\n    echoButton.addActionListener(listener); \/\/ Rather than adding *this* as a listener,\n    exitButton.addActionListener(listener); \/\/ add the provided one instead.\n  }\n\n  ...\n}\n\npublic class Controller implements ActionListener {\n  public Controller(IModel m, IVie\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n---\n[data\\raw\\notes\\Lecture 13 GUI Basics.txt::chunk0005] nterface.\n\nOur main() method constructs a Model, and constructs a view that is given a reference to the model. The view interface (IView) has only three methods: to obtain the text the user has typed in to the text box, to clear that text box, and to echo a string to the label in the UI. The implementation of the view, JFrameView, is markedly more complicated in appearance than expected, but it breaks down into several simpler parts.\n\n4.1 Frames and controls\nOur program uses the Swing framework to show its UI. In Swing, an individual window is known as a frame, which can contain controls known as components. To create our own window, we design a class that subclasses from JFrame, do some work to establish the components in it, and then call setVisible to display the window. Within the cons\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0002] t extends JPanel and overrides paintComponent that draws the game board and game status. Status includes indicating whose turn it is, and if the game is over, who won (or if it was a tie).\na class that extends MouseAdapter and overrides mouseClicked to capture a click on the game board and pass it to the controller.\nYou will also need to fill in the parts of the main method in Main.java as noted in the comments in that method.\n\n2 Testing\nTest your view by running it, inspecting the view, clicking on the game board and playing the game. No automated tests here.\n\n3 Notes to Keep in Mind\nYou will likely want to refer to the sample code on graphical programs, such as the Turtle Graphics example (see the \"solution code\" link).\nSubmit your zip containing only your src directory to In-class Exerc\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.view;\n\nimport javax.swing.*;\n\nimport cs3500.tictactoe.model.ReadonlyTTTModel;\n\npublic class TTTFrame extends JFrame implements TTTView {\n\n  private TTTPanel panel;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void addClickListener(ViewActions observer) {\n    panel.addClickListener(observer);\n  }\n\n  @Override\n  public void refresh() {\n    this.repaint();\n  }\n\n  @Override\n  public void makeVisible() {\n    setVisible(true);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TTTFrame(ReadonlyTTTModel model) {\n    super();\n    setSize(800, 800);\n    setDefaultCloseOperation(EXIT_ON_CLOSE);\n    panel = new TTTPanel(model);\n    this.add(panel);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1335\\src\\cs3500\\tictactoe\\view\\TTTFrame.java","mask_span":[192,372],"topics":["observer","gui","adapter","decorator","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0002] t extends JPanel and overrides paintComponent that draws the game board and game status. Status includes indicating whose turn it is, and if the game is over, who won (or if it was a tie).\na class that extends MouseAdapter and overrides mouseClicked to capture a click on the game board and pass it to the controller.\nYou will also need to fill in the parts of the main method in Main.java as noted in the comments in that method.\n\n2 Testing\nTest your view by running it, inspecting the view, clicking on the game board and playing the game. No automated tests here.\n\n3 Notes to Keep in Mind\nYou will likely want to refer to the sample code on graphical programs, such as the Turtle Graphics example (see the \"solution code\" link).\nSubmit your zip containing only your src directory to In-class Exerc\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.view;\n\nimport java.awt.*;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.NoninvertibleTransformException;\nimport java.awt.geom.Point2D;\n\nimport javax.swing.*;\n\nimport cs3500.tictactoe.model.Player;\nimport cs3500.tictactoe.model.ReadonlyTTTModel;\n\npublic class TTTPanel extends JPanel {\n  private final ReadonlyTTTModel model;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n    Graphics2D g2d = (Graphics2D)g.create();\n\n    g2d.transform(transformFromLogicalToPhysical());\n\n    \/\/Two options:\n    \/\/Either set a stroke width so the lines for shapes\n    \/\/look nice\n    \/\/OR find a scalable constant to multiply every coordinate number by\n    \/\/to fit in the intermediate coordinates.\n    \/\/g2d.setStroke(new BasicStroke(0.05f));\n\n    drawBoardState(g2d);\n    drawGridLines(g2d);\n\n  }\n\n  private void drawGridLines(Graphics2D g2d) {\n    drawLine(g2d, new Point(1, 0), new Point(1, 3));\n    drawLine(g2d, new Point(2, 0), new Point(2, 3));\n    drawLine(g2d, new Point(0, 1), new Point(3, 1));\n    drawLine(g2d, new Point(0, 2), new Point(3, 2));\n  }\n\n\n\n  public Dimension getPreferredLogicalSize() {\n    return new Dimension(30, 30);\n  }\n\n  public Dimension getPreferredModelSize() {\n    return new Dimension(3, 3);\n  }\n\n  private AffineTransform transformFromLogicalToPhysical() {\n    AffineTransform xform = new AffineTransform();\n    Dimension preferred = this.getPreferredLogicalSize();\n    xform.scale(this.getWidth() \/ preferred.getWidth(),\n        this.getHeight() \/ preferred.getHeight());\n    return xform;\n  }\n\n  private AffineTransform transformModelToLogical() {\n    AffineTransform xform = new AffineTransform();\n    Dimension preferred = this.getPreferredLogicalSize();\n    Dimension preferredModel = this.getPreferredModelSize();\n    xform.scale(preferred.getWidth() \/ preferredModel.getWidth(),\n        preferred.getHeight() \/ preferredModel.getHeight());\n    return xform;\n  }\n\n  \/\/Draw the board state\n  private void drawBoardState(Graphics2D g2d) {\n    Player[][] board = model.getBoard();\n    for(int row = 0; row < board.length; row++) {\n      for(int col = 0; col < board[0].length; col++) {\n        if(board[row][col] != null) {\n          drawPlayer(g2d, row, col, board[row][col]);\n        }\n      }\n    }\n  }\n\n  private void drawPlayer(Graphics2D g2d, int row, int col, Player player) {\n    Color oldColor = g2d.getColor();\n\n    switch(player) {\n      case X:\n        g2d.setColor(Color.BLACK);\n        drawLine(g2d, new Point(col, row), new Point(col+1, row+1));\n        drawLine(g2d, new Point(col+1, row), new Point(col, row+1));\n        break;\n      case O:\n        g2d.setColor(Color.RED);\n        drawOval(g2d, new Point(col, row), 1, 1);\n        break;\n      default:\n        \/\/draw nothing\n        break;\n    }\n\n    g2d.setColor(oldColor);\n\n  }\n\n  private void drawLine(Graphics2D g2d, Point2D src, Point2D dst) {\n    Point2D logicalSrc = transformModelToLogical().transform(src, null);\n    Point2D logicalDst = transformModelToLogical().transform(dst, null);\n    g2d.drawLine((int)logicalSrc.getX(),\n        (int)logicalSrc.getY(),\n        (int)logicalDst.getX(),\n        (int)logicalDst.getY());\n  }\n\n  private void drawOval(Graphics2D g2d, Point leftCorner, int width, int height) {\n    Point2D logicalLeftCorner = transformModelToLogical().transform(leftCorner, null);\n    Point2D logicalDimensions = transformModelToLogical().transform(new Point(width, height), null);\n    g2d.drawOval((int)logicalLeftCorner.getX(), (int)logicalLeftCorner.getY(),\n        (int)logicalDimensions.getX(), (int)logicalDimensions.getY());\n  }\n\n\n\n  public void addClickListener(ViewActions observer) {\n    this.addMouseListener(new MouseListener() { \/\/anonymous class. Can do inner instead\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        try {\n          AffineTransform physicalToLogical = transformFromLogicalToPhysical();\n          physicalToLogical.invert();\n\n          AffineTransform logicalToModel = transformModelToLogical();\n          logicalToModel.invert();\n\n          Point2D evtPt = e.getPoint();\n          Point2D modelPt = physicalToLogical.transform(evtPt, null);\n          logicalToModel.transform(modelPt, modelPt);\n\n          observer.handleCellClick((int)modelPt.getY(),\n              (int)modelPt.getX());\n        } catch (NoninvertibleTransformException ex) {\n          throw new RuntimeException(ex);\n        }\n      }\n\n      @Override\n      public void mousePressed(MouseEvent e) {\n\n      }\n\n      @Override\n      public void mouseReleased(MouseEvent e) {\n\n      }\n\n      @Override\n      public void mouseEntered(MouseEvent e) {\n\n      }\n\n      @Override\n      public void mouseExited(MouseEvent e) {\n\n      }\n    });\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic TTTPanel(ReadonlyTTTModel model) {\n    super();\n    this.model = model;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1335\\src\\cs3500\\tictactoe\\view\\TTTPanel.java","mask_span":[436,518],"topics":["observer","gui","adapter","decorator","mvc"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0001] ass: a public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). You will fill in the fields and the method definitions as appropriate. You may also define other classes at your option as needed.\n\nThe controller will output game state and prompts to the Appendable, and read inputs from the Readable corresponding to user moves. The append() method on Appendable throws a checked exception, IOException. Your playGame() method should not throw this exception. If it occurs, your playGame() should catch it and throw an IllegalStateException.\n\nA single move consists of two numbers, specifying the row and column of the intended move position. Board positions for these m\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.view;\n\nimport java.util.Scanner;\n\nimport cs3500.tictactoe.controller.TicTacToeGUIController;\nimport cs3500.tictactoe.provider.view.Features;\n\npublic class ViewActionsToFeaturesAdapter extends TicTacToeGUIController\n    implements Features {\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void processCommand(String input) {\n    Scanner scan = new Scanner(input);\n    int row = scan.nextInt();\n    int col = scan.nextInt();\n    super.handleCellClick(row-1, col-1);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic ViewActionsToFeaturesAdapter(TTTView view) {\n    super(view);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1335\\src\\cs3500\\tictactoe\\view\\ViewActionsToFeaturesAdapter.java","mask_span":[269,341],"topics":["gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 7 In-class Exercise A Model.txt::chunk0000] Lecture 7: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\nDue: Ideally by the end of class, but not later than 8:59pm the day your section does the exercise.\n\n1 A Model for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Model component of the Model-View-Controller design pattern.\n\nIn the starter code, you are given an interface representing a game of Tic Tac Toe, along with an enum representing the players (X and O). Your task is to implement the TicTacToe interface.\n\nYou may work freely with other students on this exercise!\n\nYou will need one class: a public class named TicTacToeModel, with a single public constructor that takes no arguments. The class definition, with a toString() implementation to help with debugging, are provided t\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0001] the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one interface and four classes:\n\na public interface ViewActions that defines the actions the view needs an observer to respond to.\na public class that implements both TicTacToeController and ViewActions, with a single public constructor that takes one argument of type TTTView. This class will have two fields, a model (TicTacToe) and a view (TTTView).\na public class that implements TTTView and extends JFrame. Its constructor should take in a ReadonlyTTTModel (note that the model interface has been refactored into two related interfaces). Note that TTTView and this class will both need a method to let a ViewActions observer subscribe to them.\na class tha\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0000] Lecture 9: In-class Exercise: A Model for Tic Tac Toe\nJava source (.zip)\n1 A Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the Controller component of the Model-View-Controller design pattern, by means of a textual, console-based controller.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with a single method, playGame(). Your task is to implement the TicTacToeController interface. Put your new controller code in the same package alongside your Tic Tac Toe model as it will depend on the model. You are also given a class Main with a main method that will allow you to test your game interactively.\n\nYou will need to create one additional cl\n---\n[data\\raw\\notes\\Lecture 15 In-class Exercise A Grap.txt::chunk0000] Lecture 15: In-class Exercise: A Graphical View and Controller for Tic Tac Toe\nJava source (.zip)\n1 A View and Controller for Tic Tac Toe\nThe purpose of this exercise is to give you practice with implementing the View and Controller components of the Model-View-Controller design pattern, by means of a graphical user interface using Java’s Swing library.\n\nYou may work freely with other students on this exercise!\n\nIn the starter code, you are given an interface representing a controller for Tic Tac Toe, with one method, playGame(). You are also given an interface for a view, TTTView. Your task is to implement the two interfaces to create an interactive, graphical Tic Tac Toe game. Put your new controller and view code in the same package alongside your Tic Tac Toe model as it will depend on \n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.tictactoe.view;\n\nimport java.util.Scanner;\n\nimport cs3500.tictactoe.provider.view.Features;\n\npublic class ViewActionsToFeaturesObjectAdapter implements Features  {\n\n  private ViewActions adaptee;\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public void processCommand(String input) {\n    Scanner scan = new Scanner(input);\n    int row = scan.nextInt();\n    int col = scan.nextInt();\n    this.adaptee.handleCellClick(row -1, col -1);\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic ViewActionsToFeaturesObjectAdapter(ViewActions adaptee) {\n    this.adaptee = adaptee;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\adapters-exercise-1335\\src\\cs3500\\tictactoe\\view\\ViewActionsToFeaturesObjectAdapter.java","mask_span":[214,310],"topics":["observer","gui","mvc","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0010] onicalize in the constructor. (Furthermore, a real class is likely to have additional methods that require the canonicalized components.) Thus, we add code to the constructor to canonicalize the representation:\n\nif (seconds > 59) {\n  minutes += seconds \/ 60;\n  seconds %= 60;\n}\n\nif (minutes > 59) {\n  hours += minutes \/ 60;\n  minutes %= 60;\n}\nThis ensures that the seconds and minutes never exceed 59 (because if they did, we would add to the minutes or hours, respectively, instead).\n2.3 Domain-specific methods\nThe observation methods are simple:\n\n@Override\npublic long inSeconds() {\n  return 3600 * hours + 60 * minutes + seconds;\n}\n\n@Override\npublic String asHms() {\n  return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n}\nIn a Java format string, the code %d means that the next param\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0004] *\n   * @return the number of seconds (non-negative)\n   *\/\n  long inSeconds();\n\n  \/**\n   * Formats this duration in the form {@code H:MM:SS} where the minutes and\n   * seconds are both zero-padded to two digits, but the hours are not.\n   *\n   * @return this duration formatted in hours, minutes, and seconds\n   *\/\n  String asHms();\n\n  \/**\n   * Returns the sum of two durations.\n   *\n   * @param other the duration to add to {@code this}\n   * @return the sum of the durations\n   *\/\n  Duration plus(Duration other);\n}\nThings to notice:\n\nWe extend interface Comparable in order to define its comparison method compareTo on durations. In particular, extending interface Comparable<Duration> means that all Durations need to be comparable to Durations.\nThe interface and the methods each have a Javadoc com\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0008]  so:\n\n\/**\n * Constructs a duration in terms of its length in hours, minutes, and\n * seconds.\n *\n * @param hours the number of hours\n * @param minutes the number of minutes\n * @param seconds the number of seconds\n * @throws IllegalArgumentException if any argument is negative\n *\/\npublic DurationImpl(int hours, int minutes, int seconds) {\n  if (hours < 0 || minutes < 0 || seconds < 0) {\n    throw new IllegalArgumentException(\"must be non-negative\");\n  }\n\n  \/\/ Insert omitted code from below \/\/\n\n  this.hours = hours;\n  this.minutes = minutes;\n  this.seconds = seconds;\n}\nThis constructor checks that each parameter is non-negative (as it makes sense in this context), to ensure that durations are not negative (this is called an invariant). However, this is not enough. Consider the following durat\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n\npublic class SimpleDurationsTest {\n\n  private Duration day;\n  private Duration ninetySeconds;\n  private Duration threeMinutes;\n\n  \/\/NOTE: This code does not compile yet because we haven't written this class.\n  \/\/      In your code, the class should at least have an empty constructor and\n  \/\/      implement the interface (i.e. class HMSDuration implements Duration)\n  @Before\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void testInSeconds() {\n    assertEquals(24 * 60 * 60, day.inSeconds());\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void setup() {\n    day = new HMSDuration(24, 0 ,0);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1030-0109\\test\\cs3500\\durations\\SimpleDurationsTest.java","mask_span":[538,600],"topics":["testing","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0010] onicalize in the constructor. (Furthermore, a real class is likely to have additional methods that require the canonicalized components.) Thus, we add code to the constructor to canonicalize the representation:\n\nif (seconds > 59) {\n  minutes += seconds \/ 60;\n  seconds %= 60;\n}\n\nif (minutes > 59) {\n  hours += minutes \/ 60;\n  minutes %= 60;\n}\nThis ensures that the seconds and minutes never exceed 59 (because if they did, we would add to the minutes or hours, respectively, instead).\n2.3 Domain-specific methods\nThe observation methods are simple:\n\n@Override\npublic long inSeconds() {\n  return 3600 * hours + 60 * minutes + seconds;\n}\n\n@Override\npublic String asHms() {\n  return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n}\nIn a Java format string, the code %d means that the next param\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0013] hat) {\n  return new DurationImpl(this.inSeconds() + that.inSeconds());\n}\n2.4 Standard methods\nBecause Duration extends Comparable<Duration>, we need to implement the compareTo(Duration) method. We could do this by comparing the components, but it’s simpler to compare the total seconds:\n\n@Override\npublic int compareTo(Duration that) {\n  return Long.compare(this.inSeconds(), that.inSeconds());\n}\nNote that the Long class has a static method for comparing primitive, lowercase-ell long values, because primitive values cannot themselves have methods.\nAll classes should override Object.toString() with something reasonable. In this case, asHms is a fine implementation of toString:\n\n@Override\npublic String toString() {\n  return asHms();\n}\nFinally, we need to decide whether to override Object.equals\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0012] (long inSeconds) {\n  if (inSeconds < 0) {\n    throw new IllegalArgumentException(\"must be non-negative\");\n  }\n\n  this.seconds = (int) (inSeconds % 60);\n  this.minutes = (int) (inSeconds \/ 60 % 60);\n  this.hours = (int) (inSeconds \/ 3600);  \/\/ overflow...\n}\nIn each assignment above, (int) is a numeric cast that converts from type long, in this case, to type int. Because the range of long is larger, not all longs can be represented correctly as ints, and instead will overflow, producing the wrong answer. The first two casts are guaranteed not to overflow, since x % 60 is between 0 and 59, plenty small to fit in an int, for any x. However, if inSeconds is large enough6 then the resulting object won’t be right.\n\nWith the new constructor, plus is easy:\n\n@Override\npublic Duration plus(Duration t\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0004] *\n   * @return the number of seconds (non-negative)\n   *\/\n  long inSeconds();\n\n  \/**\n   * Formats this duration in the form {@code H:MM:SS} where the minutes and\n   * seconds are both zero-padded to two digits, but the hours are not.\n   *\n   * @return this duration formatted in hours, minutes, and seconds\n   *\/\n  String asHms();\n\n  \/**\n   * Returns the sum of two durations.\n   *\n   * @param other the duration to add to {@code this}\n   * @return the sum of the durations\n   *\/\n  Duration plus(Duration other);\n}\nThings to notice:\n\nWe extend interface Comparable in order to define its comparison method compareTo on durations. In particular, extending interface Comparable<Duration> means that all Durations need to be comparable to Durations.\nThe interface and the methods each have a Javadoc com\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\n\/\/NOTE: Implemented some of the other methods to focus on the important details next lecture\n\/\/      Mainly equals and plus.\n\npublic class HMSDuration implements Duration {\n\n  private int hours;\n  private int minutes;\n  private int seconds;\n\n  \/**\n   * Creates a non-negative duration with the given hours, minutes, seconds\n   * @param hours number of hours in the duration\n   * @param minutes number of minutes in the duration\n   * @param seconds number of seconds in the duration\n   * @throws IllegalArgumentException if hours, minutes, or seconds < 0\n   *\/\n  public HMSDuration(int hours, int minutes, int seconds) throws IllegalArgumentException {\n    if (hours < 0 || minutes < 0 || seconds < 0) {\n      throw new IllegalArgumentException(\"Bad arguments\");\n    }\n\n    this.hours = hours;\n    this.minutes = minutes;\n    this.seconds = seconds;\n    if(seconds >= 60) {\n      this.minutes += seconds \/ 60;\n      this.seconds = seconds % 60; \/\/Get the remainder of a division\n    }\n\n    if(minutes >= 60) {\n      this.hours += this.minutes \/ 60;\n      this.minutes = this.minutes % 60;\n    }\n\n  }\n\n  @Override\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Override\n  public String asHms() {\n    return String.format(\"%02d:%02d:%02d\", hours, minutes, seconds);\n  }\n\n  @Override\n  public int compareTo(Duration other) {\n    return Long.compare(this.inSeconds(), other.inSeconds());\n  }\n\n  @Override\n  public Duration plus(Duration other) {\n    return null;\n  }\n\n\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic int inSeconds() {\n    return this.hours * 3600 + this.minutes * 60 + this.seconds;\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1030-0113\\src\\cs3500\\durations\\HMSDuration.java","mask_span":[1141,1234],"topics":["decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0010] onicalize in the constructor. (Furthermore, a real class is likely to have additional methods that require the canonicalized components.) Thus, we add code to the constructor to canonicalize the representation:\n\nif (seconds > 59) {\n  minutes += seconds \/ 60;\n  seconds %= 60;\n}\n\nif (minutes > 59) {\n  hours += minutes \/ 60;\n  minutes %= 60;\n}\nThis ensures that the seconds and minutes never exceed 59 (because if they did, we would add to the minutes or hours, respectively, instead).\n2.3 Domain-specific methods\nThe observation methods are simple:\n\n@Override\npublic long inSeconds() {\n  return 3600 * hours + 60 * minutes + seconds;\n}\n\n@Override\npublic String asHms() {\n  return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n}\nIn a Java format string, the code %d means that the next param\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0013] hat) {\n  return new DurationImpl(this.inSeconds() + that.inSeconds());\n}\n2.4 Standard methods\nBecause Duration extends Comparable<Duration>, we need to implement the compareTo(Duration) method. We could do this by comparing the components, but it’s simpler to compare the total seconds:\n\n@Override\npublic int compareTo(Duration that) {\n  return Long.compare(this.inSeconds(), that.inSeconds());\n}\nNote that the Long class has a static method for comparing primitive, lowercase-ell long values, because primitive values cannot themselves have methods.\nAll classes should override Object.toString() with something reasonable. In this case, asHms is a fine implementation of toString:\n\n@Override\npublic String toString() {\n  return asHms();\n}\nFinally, we need to decide whether to override Object.equals\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0004] *\n   * @return the number of seconds (non-negative)\n   *\/\n  long inSeconds();\n\n  \/**\n   * Formats this duration in the form {@code H:MM:SS} where the minutes and\n   * seconds are both zero-padded to two digits, but the hours are not.\n   *\n   * @return this duration formatted in hours, minutes, and seconds\n   *\/\n  String asHms();\n\n  \/**\n   * Returns the sum of two durations.\n   *\n   * @param other the duration to add to {@code this}\n   * @return the sum of the durations\n   *\/\n  Duration plus(Duration other);\n}\nThings to notice:\n\nWe extend interface Comparable in order to define its comparison method compareTo on durations. In particular, extending interface Comparable<Duration> means that all Durations need to be comparable to Durations.\nThe interface and the methods each have a Javadoc com\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\nimport static org.junit.Assert.fail;\n\npublic class SimpleDurationsTest {\n\n  private Duration day;\n  private Duration ninetySeconds;\n  private Duration threeMinutes;\n\n  \/\/NOTE: This code does not compile yet because we haven't written this class.\n  \/\/      In your code, the class should at least have an empty constructor and\n  \/\/      implement the interface (i.e. class HMSDuration implements Duration)\n  @Before\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n@Test\n  public void testValidConstruction() {\n    assertEquals(\"24:00:00\", day.asHms());\n    assertEquals(\"00:01:30\", ninetySeconds.asHms());\n    assertEquals(\"100:00:00\", new HMSDuration(100, 0, 0).asHms());\n  }\n\n  @Test\n  public void testInvalidConstruction() {\n    assertThrows(IllegalArgumentException.class,\n        () -> { new HMSDuration(-1, 0,0 ); }); \/\/line 35 is a LAMBDA\n  }\n\n  @Test\n  public void testInSeconds() {\n    assertEquals(24 * 60 * 60, day.inSeconds());\n  }\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void setup() {\n    day = new HMSDuration(24, 0 ,0);\n    ninetySeconds = new HMSDuration(0, 0, 90);\n    threeMinutes = new HMSDuration(0, 3, 00);\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1030-0113\\test\\cs3500\\durations\\SimpleDurationsTest.java","mask_span":[583,738],"topics":["testing","decorator"]}}
{"system":"<System>\nYou are a CS3500 TA. Follow MVC & design-pattern conventions. Use only the provided context if relevant. Cite slide ids when appropriate in comments like \/\/ cites: [chunk_id].\n<\/System>","context":"<Context>\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0010] onicalize in the constructor. (Furthermore, a real class is likely to have additional methods that require the canonicalized components.) Thus, we add code to the constructor to canonicalize the representation:\n\nif (seconds > 59) {\n  minutes += seconds \/ 60;\n  seconds %= 60;\n}\n\nif (minutes > 59) {\n  hours += minutes \/ 60;\n  minutes %= 60;\n}\nThis ensures that the seconds and minutes never exceed 59 (because if they did, we would add to the minutes or hours, respectively, instead).\n2.3 Domain-specific methods\nThe observation methods are simple:\n\n@Override\npublic long inSeconds() {\n  return 3600 * hours + 60 * minutes + seconds;\n}\n\n@Override\npublic String asHms() {\n  return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n}\nIn a Java format string, the code %d means that the next param\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0013] hat) {\n  return new DurationImpl(this.inSeconds() + that.inSeconds());\n}\n2.4 Standard methods\nBecause Duration extends Comparable<Duration>, we need to implement the compareTo(Duration) method. We could do this by comparing the components, but it’s simpler to compare the total seconds:\n\n@Override\npublic int compareTo(Duration that) {\n  return Long.compare(this.inSeconds(), that.inSeconds());\n}\nNote that the Long class has a static method for comparing primitive, lowercase-ell long values, because primitive values cannot themselves have methods.\nAll classes should override Object.toString() with something reasonable. In this case, asHms is a fine implementation of toString:\n\n@Override\npublic String toString() {\n  return asHms();\n}\nFinally, we need to decide whether to override Object.equals\n---\n[data\\raw\\notes\\Lecture 3 Getting (back) into Java.txt::chunk0004] *\n   * @return the number of seconds (non-negative)\n   *\/\n  long inSeconds();\n\n  \/**\n   * Formats this duration in the form {@code H:MM:SS} where the minutes and\n   * seconds are both zero-padded to two digits, but the hours are not.\n   *\n   * @return this duration formatted in hours, minutes, and seconds\n   *\/\n  String asHms();\n\n  \/**\n   * Returns the sum of two durations.\n   *\n   * @param other the duration to add to {@code this}\n   * @return the sum of the durations\n   *\/\n  Duration plus(Duration other);\n}\nThings to notice:\n\nWe extend interface Comparable in order to define its comparison method compareTo on durations. In particular, extending interface Comparable<Duration> means that all Durations need to be comparable to Durations.\nThe interface and the methods each have a Javadoc com\n---\n[data\\raw\\notes\\Lecture 5 Java Safari.txt::chunk0074] ry—but it is better integrated into the language and its tooling than the tester library was.\n\nWe translate the sample tests above into JUnit, then explain each feature:\n\nimport org.junit.*; \/\/ used to define @Test and @Before, etc.\nimport static org.junit.Assert.*; \/\/ used for assertEquals and assertTrue, etc.\n\nclass MyTestClass {\n  \/\/ various fields of data\n  int someData;\n  Foo aClassThatThrows;\n  @Before\n  void setupTestFixture() {\n    \/\/ reinitialize all your data\n    this.someData = 5;\n    this.aClassThatThrows = new Foo(5);\n  }\n\n  @Test\n  void simpleTest() {\n    assertEquals(\"Is it five\"? 5, this.someData);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  void constructorExceptionTest() {\n    new Foo(10);\n  }\n  @Test(expected = RuntimeException.class)\n  void methodExceptionT\n<\/Context>","code_prefix":"<CodePrefix>\npackage cs3500.durations;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\nimport static org.junit.Assert.fail;\n\npublic class SimpleDurationsTest {\n\n  private Duration day;\n  private Duration ninetySeconds;\n  private Duration threeMinutes;\n\n  \/\/NOTE: This code does not compile yet because we haven't written this class.\n  \/\/      In your code, the class should at least have an empty constructor and\n  \/\/      implement the interface (i.e. class HMSDuration implements Duration)\n  @Before\n  public void setup() {\n    day = new HMSDuration(24, 0 ,0);\n    ninetySeconds = new HMSDuration(0, 0, 90);\n    threeMinutes = new HMSDuration(0, 3, 00);\n  }\n\n  @Test\n  public void testValidConstruction() {\n    assertEquals(\"24:00:00\", day.asHms());\n    assertEquals(\"00:01:30\", ninetySeconds.asHms());\n    assertEquals(\"100:00:00\", new HMSDuration(100, 0, 0).asHms());\n  }\n\n  @Test\n  public void testInvalidConstruction() {\n    assertThrows(IllegalArgumentException.class,\n        () -> { new HMSDuration(-1, 0,0 ); }); \/\/line 35 is a LAMBDA\n  }\n\n  @Test\n<\/CodePrefix>","code_suffix":"<CodeSuffix>\n}\n\n<\/CodeSuffix>","target":"<Target>\npublic void testInSeconds() {\n    assertEquals(24 * 60 * 60, day.inSeconds());\n  }\n<\/Target>","meta":{"source":"data\\raw\\code\\duration-1030-0113\\test\\cs3500\\durations\\SimpleDurationsTest.java","mask_span":[1139,1221],"topics":["testing","decorator"]}}
