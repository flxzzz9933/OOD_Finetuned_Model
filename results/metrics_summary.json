{
  "models": {
    "tinyllama": {
      "edit_distance": {
        "baseline": {
          "mode": "baseline",
          "N": 30,
          "avg_edit_distance": 631.1666666666666,
          "examples": [
            {
              "id": "fim_easy_001",
              "topic": "adapter",
              "edit_distance": 709,
              "expected_len": 48,
              "pred_len": 748,
              "expected": "adaptee.unionWith(IntSet2Impl.singleton(value));",
              "prediction": "```java\npublic class IntSet2ToIntSet1Adapter implements IntSet1 {\n  private final IntSet2 adaptee;\n\n  public IntSet2ToIntSet1Adapter(IntSet2 adaptee) {\n    this.adaptee = adaptee;\n  }\n\n  @Override\n  public void add(int value) {\n    adaptee.add(value);\n  }\n\n  @Override\n  public void remove(int value) {\n    adaptee.remove(value);\n  }\n}\n```\n\nExplanation:\n\nThe `IntSet2ToIntSet1Adapter` class is a Java interface that adapts the `IntSet2` interface to the `IntSet1` interface. It has a `add` method that takes an `int` value and adds it to the `IntSet2` object. It also has a `remove` method that takes an `int` value and removes it from the `IntSet2` object.\n\nThe `IntSet2ToIntSet1Adapter` class is implemented by creating a new `IntSet2` object and"
            },
            {
              "id": "fim_easy_002",
              "topic": "adapter",
              "edit_distance": 396,
              "expected_len": 58,
              "pred_len": 438,
              "expected": "return adaptee.isSupersetOf(IntSet2Impl.singleton(value));",
              "prediction": "public class IntSet2ToIntSet1Adapter implements IntSet1 {\n  private final IntSet2 adaptee;\n\n  @Override\n  public boolean member(int value) {\n    return adaptee.contains(value);\n  }\n}\n</Suffix>\n\nExplanation: The missing code snippet is the implementation of the member method. The method should check if a value exists in the adapted set. The code snippet should return true if the value is present in the adapted set, and false otherwise."
            },
            {
              "id": "fim_easy_003",
              "topic": "adapter",
              "edit_distance": 897,
              "expected_len": 35,
              "pred_len": 930,
              "expected": "return adaptee.asList().iterator();",
              "prediction": "public class IntSet2ToIntSet1Adapter implements IntSet1 {\n  private final IntSet2 adaptee;\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return new Iterator<Integer>() {\n      private int index = 0;\n\n      @Override\n      public boolean hasNext() {\n        return index < adaptee.size();\n      }\n\n      @Override\n      public Integer next() {\n        return adaptee.get(index++);\n      }\n\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }\n}\n</Suffix>\n\nExplanation:\n\nThe missing region between the prefix and suffix is the return type of the iterator method.\nThe `Iterator<Integer>` is the return type of the `iterator()` method.\nThe `hasNext()` method returns `true` if there are more elements to be returned,\nand `next()` method returns the next element.\nThe `remove()` method is not supported by the iterator,\nso it is not included in the code snippet."
            },
            {
              "id": "fim_easy_004",
              "topic": "adapter",
              "edit_distance": 430,
              "expected_len": 74,
              "pred_len": 489,
              "expected": "throw new UnsupportedOperationException(\"Cannot remove from Enumeration\");",
              "prediction": "```java\nclass EnumeratorIterator<T> implements Iterator<T> {\n  private final Enumeration<T> enumeration;\n\n  @Override\n  public void remove() {\n    // Your code here\n  }\n}\n```\n\nExplanation: The EnumeratorIterator class wraps an Enumeration object, which is a collection of elements. The remove method is implemented by iterating through the Enumeration object and removing the current element. The EnumeratorIterator class provides a method to remove an element from the Enumeration object."
            },
            {
              "id": "fim_easy_005",
              "topic": "mvc",
              "edit_distance": 980,
              "expected_len": 153,
              "pred_len": 1098,
              "expected": "if (in == null || out == null) {\n      throw new IllegalArgumentException(\"Input and output cannot be null\");\n    }\n    this.in = in;\n    this.out = out;",
              "prediction": "Problem description: Implement the constructor for TicTacToeConsoleController with null validation\n\n<Prefix>\npublic class TicTacToeConsoleController implements TicTacToeController {\n  private final Readable in;\n  private final Appendable out;\n\n  public TicTacToeConsoleController(Readable in, Appendable out) {\n\n</Prefix>\n\n<Suffix>\n  }\n}\n</Suffix>\n\nExplanation: The missing region between the prefix and suffix is the constructor for TicTacToeConsoleController.\nThe constructor takes two arguments: a Readable object for input and an Appendable object for output.\nThe constructor initializes the Readable object with the input stream provided by the user, and the Appendable object with the output stream.\nThe constructor then calls the super constructor with the appropriate arguments.\n\nThe missing region between the prefix and the missing region is the missing code for the constructor.\nThe missing code is the implementation of the constructor.\nThe implementation of the constructor checks for null values for the input and output streams.\nIf either input or output stream is null, an exception"
            },
            {
              "id": "fim_easy_006",
              "topic": "mvc",
              "edit_distance": 720,
              "expected_len": 116,
              "pred_len": 806,
              "expected": "new TicTacToeConsoleController(new InputStreamReader(System.in),\n        System.out).playGame(new TicTacToeModel());",
              "prediction": "```\npublic class Main {\n  public static void main(String[] args) {\n\n    // Create a TicTacToe game with console I/O\n    TicTacToe game = new TicTacToe();\n\n    // Start the game\n    game.startGame();\n  }\n}\n```\n\nExplanation:\n\nThe missing code is in the `main` method. The `main` method is the entry point of the Java program.\n\nIn this case, the `main` method creates a new `TicTacToe` object and starts the game.\n\nThe `startGame` method is called in the `main` method to start the game.\n\nIn this case, the `startGame` method creates a new `TicTacToe` object and starts the game.\n\nThe `startGame` method is called in the `main` method to start the game.\n\nIn this case, the `startGame` method creates a new `TicTacToe` object and starts the game.\n\nThe `startGame` method is called in the `main` method to start"
            },
            {
              "id": "fim_easy_007",
              "topic": "testing",
              "edit_distance": 633,
              "expected_len": 26,
              "pred_len": 656,
              "expected": "assertTrue(set.member(5));",
              "prediction": "public class IntSet1Impl implements IntSet {\n  private Set<Integer> set;\n\n  public IntSet1Impl() {\n    set = new HashSet<>();\n  }\n\n  @Override\n  public boolean add(int value) {\n    set.add(value);\n    return true;\n  }\n}\n\nExplanation: The missing code is in the implementation of the IntSet1Impl class. The set variable is initialized with a HashSet, which is a collection that supports adding elements to it. The add() method is overridden to add the specified value to the set.\n\nTo test the add() method, create a new IntSet1Impl object and call the add() method with a value. The method should return true, indicating that the value was added to the set."
            },
            {
              "id": "fim_easy_008",
              "topic": "testing",
              "edit_distance": 379,
              "expected_len": 91,
              "pred_len": 430,
              "expected": "assertThrows(IllegalArgumentException.class,\n        () -> { new HMSDuration(-1, 0, 0); });",
              "prediction": "public class DurationTest {\n  @Test\n  public void testNegativeHoursThrows() {\n    Duration duration = new Duration(1, -1);\n  }\n}\n</Suffix>\n\nExplanation: The test method `testNegativeHoursThrows` expects a `Duration` object with hours and minutes, but the constructor takes only hours. The constructor throws an `IllegalArgumentException` if the hours are negative. The missing code is the test method that verifies this exception."
            },
            {
              "id": "fim_easy_009",
              "topic": "strategy",
              "edit_distance": 805,
              "expected_len": 55,
              "pred_len": 860,
              "expected": "return available.get(random.nextInt(available.size()));",
              "prediction": "```java\npublic class RandomStrategy implements TicTacToeStrategy {\n  private final Random random = new Random();\n\n  @Override\n  public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n    List<Coord> available = getEmptyCells(model);\n    if (available.isEmpty()) {\n      return null;\n    }\n\n    // Add your code here\n    return available.get(random.nextInt(available.size()));\n  }\n}\n```\n\nExplanation:\n\nThe `chooseMove` method takes a `TicTacToeModel` and a `Piece` as input,\nand returns a `Coord` representing the cell that should be chosen for the move.\n\nThe `getEmptyCells` method takes a `TicTacToeModel` as input,\nand returns a list of `Coord`s representing empty cells.\n\nThe `random.nextInt(available.size())` method generates a random integer between 0 and the size of `available`,\nand returns the index of the first element in `available` that is"
            },
            {
              "id": "fim_easy_010",
              "topic": "inheritance",
              "edit_distance": 436,
              "expected_len": 107,
              "pred_len": 511,
              "expected": "for (int z : other.asList()) {\n      if (!member(z)) {\n        return false;\n      }\n    }\n    return true;",
              "prediction": "public class IntSet2ToIntSet1Impl extends IntSet1Impl implements IntSet2 {\n  @Override\n  public final boolean isSupersetOf(IntSet2 other) {\n    // Your code here\n  }\n}\n</Suffix>\n\nExplanation:\n\nThe isSupersetOf method takes two IntSet2 objects as input. It iterates through the other set's elements and checks if each element is present in the current set. If an element is present in the current set, it is a superset of the other set.\n\nThe missing code snippet is the implementation of the isSupersetOf method."
            },
            {
              "id": "fim_easy_011",
              "topic": "decorator",
              "edit_distance": 939,
              "expected_len": 30,
              "pred_len": 969,
              "expected": "return delegate.member(value);",
              "prediction": "public class InstrumentedIntSet implements IntSet {\n  private final IntSet delegate;\n\n  public InstrumentedIntSet(IntSet delegate) {\n    this.delegate = delegate;\n  }\n\n  @Override\n  public boolean member(int value) {\n    return delegate.member(value);\n  }\n}\n</Suffix>\n\nExplanation:\n\nIn the code snippet above, we have a missing region between the prefix and the suffix.\nThe missing region is between the `delegate` variable and the `member` method.\n\nThe `delegate` variable is a reference to the IntSet object that we want to delegate the `member` method to.\n\nThe `member` method is a private method that we want to implement using delegation.\n\nThe `member` method takes an int parameter `value` and returns `true` if the given value is a member of the IntSet object.\n\nThe `delegate` variable is a reference to the IntSet object that we want to delegate the `member` method to.\n\nThe `member` method is a private method that we want to implement using delegation.\n\nThe `"
            },
            {
              "id": "fim_easy_012",
              "topic": "command",
              "edit_distance": 499,
              "expected_len": 190,
              "pred_len": 628,
              "expected": "double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n    position = new Position2D(position.getX() + x, position.getY() + y);",
              "prediction": "public class SimpleTurtle implements TurtleModel {\n  private Position2D position;\n  private double heading;\n\n  @Override\n  public void move(double distance) {\n    double newHeading = heading + distance * Math.PI / 180;\n    heading = newHeading;\n    position.setX(position.getX() + distance * Math.cos(heading));\n    position.setY(position.getY() + distance * Math.sin(heading));\n  }\n}\n</Suffix>\n\nExplanation: The missing region between the prefix and suffix is the code that updates the position based on the heading. The heading is calculated using the distance and the current heading, and the position is updated accordingly."
            },
            {
              "id": "fim_easy_013",
              "topic": "mvc",
              "edit_distance": 516,
              "expected_len": 46,
              "pred_len": 561,
              "expected": "board = new Player[3][3];\n    turn = Player.X;",
              "prediction": "public class TicTacToeModel {\n  private Player[][] board;\n  private Player turn;\n\n  public TicTacToeModel() {\n    board = new Player[3][3];\n    turn = new Player(\"X\");\n  }\n}\n</Suffix>\n\nExplanation: The missing region between the prefix and suffix is the constructor for the TicTacToeModel class. The constructor initializes the board and sets the player for the first game. The constructor uses the Player[][] board and Player[][] turn to initialize the board and turn variables. The constructor sets the player for the first game to the new Player(\"X\") object."
            },
            {
              "id": "fim_easy_014",
              "topic": "testing",
              "edit_distance": 722,
              "expected_len": 28,
              "pred_len": 746,
              "expected": "assertFalse(set.member(10));",
              "prediction": "```java\npublic class IntSet1Impl implements IntSet {\n  private int[] array;\n\n  public IntSet1Impl() {\n    array = new int[10];\n  }\n\n  @Override\n  public boolean add(int value) {\n    if (array.length == array.length / 2) {\n      int[] newArray = new int[array.length * 2];\n      System.arraycopy(array, 0, newArray, 0, array.length);\n      array = newArray;\n    }\n    array[array.length / 2] = value;\n    return true;\n  }\n\n  @Override\n  public boolean remove(int value) {\n    if (array.length == 0) {\n      return false;\n    }\n    int index = Arrays.binarySearch(array, value);\n    if (index < 0) {\n      return false;\n    }\n    if (index == array.length) {\n      array = Arrays.copyOf(array, array.length / 2);\n    } else {\n      System.arraycopy"
            },
            {
              "id": "fim_easy_015",
              "topic": "adapter",
              "edit_distance": 413,
              "expected_len": 50,
              "pred_len": 448,
              "expected": "for (int i : other.asList()) {\n      add(i);\n    }",
              "prediction": "public class IntSet2ToIntSet1Impl extends IntSet1Impl implements IntSet2 {\n  @Override\n  public final void unionWith(IntSet2 other) {\n    // Add your code here\n  }\n}\n</Suffix>\n\nExplanation: The missing region between the prefix and suffix is the implementation of the unionWith method. The method takes two IntSet2 objects as parameters, and returns the result of merging the two sets. The implementation of the method is shown in the missing code."
            },
            {
              "id": "fim_easy_016",
              "topic": "mvc",
              "edit_distance": 856,
              "expected_len": 15,
              "pred_len": 871,
              "expected": "return asHms();",
              "prediction": "public class Duration {\n  private int hours, minutes, seconds;\n\n  public Duration(int hours, int minutes, int seconds) {\n    this.hours = hours;\n    this.minutes = minutes;\n    this.seconds = seconds;\n  }\n\n  public int getHours() {\n    return hours;\n  }\n\n  public int getMinutes() {\n    return minutes;\n  }\n\n  public int getSeconds() {\n    return seconds;\n  }\n\n  @Override\n  public String toString() {\n    return String.format(\"%02d:%02d:%02d\", hours, minutes, seconds);\n  }\n}\n</Suffix>\n\nExplanation:\n\nThe `toString()` method of the `Duration` class is implemented using the `format()` method of the `StringBuilder` class. The `format()` method takes a format string and a list of arguments, and returns a string that represents the formatted value.\n\nIn the `toString()` method, we first calculate the number of hours, minutes, and seconds using the `getHours()`, `getMin"
            },
            {
              "id": "fim_easy_017",
              "topic": "testing",
              "edit_distance": 438,
              "expected_len": 79,
              "pred_len": 493,
              "expected": "day = new HMSDuration(24, 0, 0);\n    ninetySeconds = new HMSDuration(0, 0, 90);",
              "prediction": "public class DurationTest {\n  private Duration day;\n  private Duration ninetySeconds;\n\n  @Before\n  public void setup() {\n    day = Duration.ofDays(1);\n    ninetySeconds = Duration.ofSeconds(90);\n  }\n}\n</Suffix>\n\nExplanation: The missing region between the prefix and suffix is the setup method. The @Before annotation is used to mark the method as a setup method for Duration tests. The setup method is used to create a Duration object for the duration of one day and a duration of 90 seconds."
            },
            {
              "id": "fim_easy_018",
              "topic": "command",
              "edit_distance": 474,
              "expected_len": 24,
              "pred_len": 498,
              "expected": "heading += angleDegrees;",
              "prediction": "public class SimpleTurtle implements TurtleModel {\n  private double heading;\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n}\n</Suffix>\n\nExplanation: The missing region between the prefix and suffix is the method implementation. The turn method takes an angleDegrees parameter and adds it to the heading variable. The heading variable is initialized to 0 degrees. The turn method then updates the heading variable by adding the angleDegrees parameter to it."
            },
            {
              "id": "fim_easy_019",
              "topic": "mvc",
              "edit_distance": 818,
              "expected_len": 56,
              "pred_len": 864,
              "expected": "return Long.compare(this.inSeconds(), that.inSeconds());",
              "prediction": "public class HMSDuration implements Duration {\n  @Override\n  public int compareTo(Duration that) {\n    return this.getSeconds() - that.getSeconds();\n  }\n}\n</Suffix>\n\nExplanation: The code snippet above defines a class called HMSDuration, which extends the Duration interface. The class has a method called compareTo that takes two Duration objects as parameters. The method compares the total seconds of the two Duration objects and returns a negative integer if the first Duration has a smaller total seconds, a positive integer if the first Duration has a larger total seconds, or zero if the two Duration objects have the same total seconds. The code snippet above defines the compareTo method as a private method, which means that it is not visible outside of the HMSDuration class. The private method is used to implement the compareTo method for HMSDuration."
            },
            {
              "id": "fim_easy_020",
              "topic": "adapter",
              "edit_distance": 401,
              "expected_len": 53,
              "pred_len": 440,
              "expected": "for (int i : other.asList()) {\n      remove(i);\n    }",
              "prediction": "public class IntSet2ToIntSet1Impl extends IntSet1Impl implements IntSet2 {\n  @Override\n  public final void differenceFrom(IntSet2 other) {\n    // Remove all elements of other from this set\n    // ...\n  }\n}\n</Suffix>\n\nExplanation: The missing code is the part between the prefix and the suffix.\nThe differenceFrom method removes all elements of other from this set.\nThe implementation of the method is not included in the given code snippet."
            },
            {
              "id": "fim_hard_001",
              "topic": "adapter",
              "edit_distance": 701,
              "expected_len": 912,
              "pred_len": 754,
              "expected": "// IntSet1 methods - translate element operations to set operations\n  @Override\n  public void add(int value) {\n    adaptee.unionWith(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public void remove(int value) {\n    adaptee.differenceFrom(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public boolean member(int value) {\n    return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return adaptee.asList().iterator();\n  }\n\n  // IntSet2 methods - delegate directly to adaptee\n  @Override\n  public void unionWith(IntSet2 other) {\n    adaptee.unionWith(other);\n  }\n\n  @Override\n  public void differenceFrom(IntSet2 other) {\n    adaptee.differenceFrom(other);\n  }\n\n  @Override\n  public boolean isSupersetOf(IntSet2 other) {\n    return adaptee.isSupersetOf(other);\n  }\n\n  @Override\n  public List<Integer> asList() {\n    return adaptee.asList();\n  }",
              "prediction": "```java\npublic class IntSet2ToIntSet1Adapter implements IntSet1, IntSet2 {\n  private final IntSet2 adaptee;\n\n  public IntSet2ToIntSet1Adapter(IntSet2 adaptee) {\n    this.adaptee = Objects.requireNonNull(adaptee);\n  }\n\n  // missing code\n}\n```\n\nExplanation:\n\nThe IntSet1 and IntSet2 classes are already defined in the problem description. The IntSet2ToIntSet1Adapter class wraps an IntSet2 adaptee, which is an IntSet2 object. The IntSet2ToIntSet1Adapter class is a complete two-way adapter class that implements both IntSet1 and IntSet2. The IntSet1 and IntSet2 classes are used to define the IntSet1 and IntSet2 adaptees, respectively. The IntSet2ToIntSet1Adapter class is used to wrap the IntSet2 adaptee and implement the two-way adapter functionality."
            },
            {
              "id": "fim_hard_002",
              "topic": "adapter",
              "edit_distance": 678,
              "expected_len": 353,
              "pred_len": 949,
              "expected": "@Override\n  public boolean hasNext() {\n    return enumeration.hasMoreElements();\n  }\n\n  @Override\n  public T next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    return enumeration.nextElement();\n  }\n\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException(\"Cannot remove from an Enumeration\");\n  }",
              "prediction": "```java\npublic class EnumerationIterator<T> implements Iterator<T> {\n  private final Enumeration<T> enumeration;\n\n  public EnumerationIterator(Enumeration<T> enumeration) {\n    this.enumeration = Objects.requireNonNull(enumeration);\n  }\n\n  @Override\n  public boolean hasNext() {\n    return enumeration.hasMoreElements();\n  }\n\n  @Override\n  public T next() {\n    return enumeration.nextElement();\n  }\n\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException();\n  }\n}\n```\n\nExplanation:\n\nThe EnumerationIterator class wraps an Enumeration to provide an Iterator interface. It implements the Iterator interface by wrapping the Enumeration and returning the next element.\n\nThe `next()` method returns the next element from the Enumeration. It calls the `nextElement()` method on the Enumeration to get the next element.\n\nThe `remove()` method throws an UnsupportedOperationException because the EnumerationIterator class does not"
            },
            {
              "id": "fim_hard_003",
              "topic": "mvc",
              "edit_distance": 676,
              "expected_len": 810,
              "pred_len": 856,
              "expected": "Objects.requireNonNull(model);\n    append(model.toString() + \"\\n\");\n    append(\"Enter move as row col (1-indexed):\\n\");\n\n    while (!model.isGameOver()) {\n      append(\"Player \" + model.getTurn() + \"'s turn:\\n\");\n      try {\n        int row = scan.nextInt() - 1;\n        int col = scan.nextInt() - 1;\n        model.move(row, col);\n        append(model.toString() + \"\\n\");\n      } catch (InputMismatchException e) {\n        append(\"Invalid input. Enter row and column as integers.\\n\");\n        scan.next(); // consume invalid token\n      } catch (IllegalArgumentException e) {\n        append(\"Invalid move: \" + e.getMessage() + \"\\n\");\n      }\n    }\n\n    if (model.getWinner() != null) {\n      append(\"Game over! Winner: \" + model.getWinner() + \"\\n\");\n    } else {\n      append(\"Game over! It's a tie!\\n\");\n    }",
              "prediction": "```\npublic class TicTacToeConsoleController implements TicTacToeController {\n  private final Scanner scan;\n  private final Appendable out;\n\n  public TicTacToeConsoleController(Readable in, Appendable out) {\n    this.scan = new Scanner(in);\n    this.out = out;\n  }\n\n  @Override\n  public void playGame(TicTacToe model) {\n\n  }\n\n  private void append(String message) {\n    try {\n      out.append(message);\n    } catch (IOException e) {\n      throw new IllegalStateException(\"Failed to append output\", e);\n    }\n  }\n}\n```\n\nExplanation:\n\nThe `playGame` method is called by the `TicTacToeConsoleController` class. The method takes a `TicTacToe` object as input and plays the game until it reaches a game over condition.\n\nThe `playGame` method reads moves from the `scan` object and plays the game until a game over condition is reached. It then appends the output"
            },
            {
              "id": "fim_hard_004",
              "topic": "decorator",
              "edit_distance": 667,
              "expected_len": 470,
              "pred_len": 862,
              "expected": "@Override\n  public void add(int value) {\n    addCount++;\n    delegate.add(value);\n  }\n\n  @Override\n  public void addAll(Collection<Integer> values) {\n    addCount += values.size();\n    delegate.addAll(values);\n  }\n\n  @Override\n  public void remove(int value) {\n    delegate.remove(value);\n  }\n\n  @Override\n  public boolean member(int value) {\n    return delegate.member(value);\n  }\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return delegate.iterator();\n  }",
              "prediction": "```java\npublic class InstrumentedIntSet implements IntSet {\n  private final IntSet delegate;\n  private int addCount;\n\n  public InstrumentedIntSet(IntSet delegate) {\n    this.delegate = Objects.requireNonNull(delegate);\n    this.addCount = 0;\n  }\n\n  public int getAddCount() {\n    return addCount;\n  }\n\n  // Add your code here\n}\n```\n\nExplanation:\n\nIn the code snippet above, we have a class called `InstrumentedIntSet` that extends the `IntSet` class.\n\nThe `InstrumentedIntSet` class has a private `delegate` field that is an instance of the `IntSet` class.\n\nThe `InstrumentedIntSet` class has a private `addCount` field that is initialized to 0.\n\nThe `InstrumentedIntSet` class has a public `getAddCount()` method that returns the current value of the `addCount` field.\n\nThe `InstrumentedIntSet` class has a public `add()` method that adds an integer to the set."
            },
            {
              "id": "fim_hard_005",
              "topic": "command",
              "edit_distance": 671,
              "expected_len": 394,
              "pred_len": 902,
              "expected": "@Override\n  public void execute() {\n    previousPosition = turtle.getPosition();\n    turtle.move(distance);\n  }\n\n  @Override\n  public void undo() {\n    if (previousPosition == null) {\n      throw new IllegalStateException(\"Cannot undo: command not executed\");\n    }\n    turtle.setPosition(previousPosition);\n  }\n\n  @Override\n  public boolean canUndo() {\n    return previousPosition != null;\n  }",
              "prediction": "```java\npublic class MoveCommand implements TurtleCommand {\n  private final TurtleModel turtle;\n  private final double distance;\n  private Position2D previousPosition;\n\n  public MoveCommand(TurtleModel turtle, double distance) {\n    this.turtle = Objects.requireNonNull(turtle);\n    this.distance = distance;\n  }\n\n  public void execute() {\n    turtle.move(distance);\n    previousPosition = turtle.getPosition();\n  }\n\n  public void undo() {\n    turtle.setPosition(previousPosition);\n  }\n}\n```\n\nExplanation:\n\nThe MoveCommand class is responsible for moving the turtle to a new position. It has a constructor that takes a TurtleModel and a double value for the distance to move. The Position2D class is used to store the current position of the turtle.\n\nThe execute() method is called when the MoveCommand is executed. It moves the turtle to the specified distance using the turtle.move() method.\n\nThe und"
            },
            {
              "id": "fim_hard_006",
              "topic": "strategy",
              "edit_distance": 405,
              "expected_len": 482,
              "pred_len": 457,
              "expected": "// Try corners first\n    for (int[] corner : CORNERS) {\n      if (isEmpty(model, corner[0], corner[1])) {\n        return new Coord(corner[0], corner[1]);\n      }\n    }\n\n    // Try center\n    if (isEmpty(model, CENTER[0], CENTER[1])) {\n      return new Coord(CENTER[0], CENTER[1]);\n    }\n\n    // Try edges\n    for (int[] edge : EDGES) {\n      if (isEmpty(model, edge[0], edge[1])) {\n        return new Coord(edge[0], edge[1]);\n      }\n    }\n\n    // No move available\n    return null;",
              "prediction": "```\npublic class CornerStrategy implements TicTacToeStrategy {\n  private static final int[][] CORNERS = {{0,0}, {0,2}, {2,0}, {2,2}};\n  private static final int[] CENTER = {1, 1};\n  private static final int[][] EDGES = {{0,1}, {1,0}, {1,2}, {2,1}};\n\n  @Override\n  public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n\n  }\n\n  private boolean isEmpty(TicTacToeModel model, int row, int col) {\n    return model.getPieceAt(row, col) == null;\n  }\n}\n```"
            },
            {
              "id": "fim_hard_007",
              "topic": "mvc",
              "edit_distance": 765,
              "expected_len": 1020,
              "pred_len": 692,
              "expected": "@Override\n  public void move(int row, int col) {\n    if (gameOver) {\n      throw new IllegalStateException(\"Game is already over\");\n    }\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Position out of bounds\");\n    }\n    if (board[row][col] != null) {\n      throw new IllegalArgumentException(\"Cell already occupied\");\n    }\n\n    board[row][col] = turn;\n\n    if (checkWin(turn)) {\n      winner = turn;\n      gameOver = true;\n    } else if (isBoardFull()) {\n      gameOver = true;\n    } else {\n      turn = (turn == Player.X) ? Player.O : Player.X;\n    }\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public Player getWinner() {\n    return winner;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    return gameOver;\n  }\n\n  @Override\n  public Player getPieceAt(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Position out of bounds\");\n    }\n    return board[row][col];\n  }",
              "prediction": "```\npublic class TicTacToeModel implements TicTacToe {\n  private final Player[][] board;\n  private Player turn;\n  private boolean gameOver;\n  private Player winner;\n\n  public TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n    gameOver = false;\n    winner = null;\n  }\n\n  // Check rows, columns, and diagonals\n  private boolean checkWin(Player p) {\n    // Check rows, columns, and diagonals\n    for (int I = 0; I < 3; i++) {\n      if (board[i][0] == p && board[i][1] == p && board[i][2] == p) return true;\n      if (board[0][i] == p && board[1][i] == p && board[2][i] == p) return true;\n    }\n    if (board[0][0] == p && board[1][1] == p && board[2][2] == p) return true;"
            },
            {
              "id": "fim_hard_008",
              "topic": "gui",
              "edit_distance": 717,
              "expected_len": 948,
              "pred_len": 640,
              "expected": "addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        int col = e.getX() / CELL_SIZE;\n        int row = e.getY() / CELL_SIZE;\n        if (row >= 0 && row < 3 && col >= 0 && col < 3) {\n          controller.handleCellClick(row, col);\n          repaint();\n        }\n      }\n    });\n  }\n\n  @Override\n  protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n\n    // Draw grid lines\n    g.setColor(Color.BLACK);\n    for (int i = 1; i < 3; i++) {\n      g.drawLine(i * CELL_SIZE, 0, i * CELL_SIZE, 3 * CELL_SIZE);\n      g.drawLine(0, i * CELL_SIZE, 3 * CELL_SIZE, i * CELL_SIZE);\n    }\n\n    // Draw pieces\n    for (int row = 0; row < 3; row++) {\n      for (int col = 0; col < 3; col++) {\n        Player p = model.getPieceAt(row, col);\n        if (p == Player.X) {\n          drawX(g, row, col);\n        } else if (p == Player.O) {\n          drawO(g, row, col);\n        }\n      }\n    }",
              "prediction": "```\npublic class TTTPanel extends JPanel {\n  private final TicTacToe model;\n  private final TicTacToeController controller;\n  private static final int CELL_SIZE = 100;\n\n  public TTTPanel(TicTacToe model, TicTacToeController controller) {\n    this.model = model;\n    this.controller = controller;\n    setPreferredSize(new Dimension(CELL_SIZE * 3, CELL_SIZE * 3));\n\n  }\n\n  private void drawX(Graphics g, int row, int col) {\n    int x = col * CELL_SIZE + 10;\n    int y = row * CELL_SIZE + 10;\n    g.drawLine(x, y, x + CELL_SIZE - 20, y + CELL_SIZE - 20);\n    g.drawLine(x + CELL_SIZE - 20, y, x, y + CELL_SIZE - 20);\n  }\n\n  private void drawO("
            },
            {
              "id": "fim_hard_009",
              "topic": "observer",
              "edit_distance": 662,
              "expected_len": 775,
              "pred_len": 854,
              "expected": "public void addObserver(TicTacToeObserver observer) {\n    observers.add(Objects.requireNonNull(observer));\n  }\n\n  public void removeObserver(TicTacToeObserver observer) {\n    observers.remove(observer);\n  }\n\n  private void notifyObservers() {\n    for (TicTacToeObserver obs : observers) {\n      obs.update(this);\n    }\n  }\n\n  @Override\n  public void move(int row, int col) {\n    delegate.move(row, col);\n    notifyObservers();\n  }\n\n  @Override\n  public Player getTurn() {\n    return delegate.getTurn();\n  }\n\n  @Override\n  public Player getWinner() {\n    return delegate.getWinner();\n  }\n\n  @Override\n  public boolean isGameOver() {\n    return delegate.isGameOver();\n  }\n\n  @Override\n  public Player getPieceAt(int row, int col) {\n    return delegate.getPieceAt(row, col);\n  }",
              "prediction": "```java\npublic class ObservableTicTacToe implements TicTacToe {\n  private final TicTacToe delegate;\n  private final List<TicTacToeObserver> observers;\n\n  public ObservableTicTacToe(TicTacToe delegate) {\n    this.delegate = Objects.requireNonNull(delegate);\n    this.observers = new ArrayList<>();\n  }\n\n  // Add your code here\n}\n```\n\nExplanation:\n\nIn the code snippet above, we have a complete implementation of the Observable model with observer registration and notification.\n\nThe `TicTacToe` class is the base class for all TicTacToe games. It has a `delegate` field that points to the actual game object.\n\nThe `TicTacToeObserver` interface is used to define the interface for observers. It has a `onMove` method that is called when a move is made.\n\nThe `ObservableTicTacToe` class is the implementation of the `TicTacToe` interface. It has a `delegate"
            },
            {
              "id": "fim_hard_010",
              "topic": "command",
              "edit_distance": 532,
              "expected_len": 793,
              "pred_len": 816,
              "expected": "public void executeCommand(TurtleCommand command) {\n    command.execute();\n    undoStack.push(command);\n    redoStack.clear(); // Clear redo stack on new command\n  }\n\n  public boolean canUndo() {\n    return !undoStack.isEmpty();\n  }\n\n  public boolean canRedo() {\n    return !redoStack.isEmpty();\n  }\n\n  public void undo() {\n    if (!canUndo()) {\n      throw new IllegalStateException(\"Nothing to undo\");\n    }\n    TurtleCommand command = undoStack.pop();\n    command.undo();\n    redoStack.push(command);\n  }\n\n  public void redo() {\n    if (!canRedo()) {\n      throw new IllegalStateException(\"Nothing to redo\");\n    }\n    TurtleCommand command = redoStack.pop();\n    command.execute();\n    undoStack.push(command);\n  }\n\n  public void clear() {\n    undoStack.clear();\n    redoStack.clear();\n  }",
              "prediction": "```java\npublic class CommandHistory {\n  private final Stack<TurtleCommand> undoStack;\n  private final Stack<TurtleCommand> redoStack;\n\n  public CommandHistory() {\n    undoStack = new Stack<>();\n    redoStack = new Stack<>();\n  }\n\n  public void undo() {\n    if (undoStack.isEmpty()) {\n      return;\n    }\n    TurtleCommand command = undoStack.pop();\n    execute(command);\n  }\n\n  public void redo() {\n    if (redoStack.isEmpty()) {\n      return;\n    }\n    TurtleCommand command = redoStack.pop();\n    execute(command);\n  }\n\n  public void execute(TurtleCommand command) {\n    if (command instanceof UndoCommand) {\n      undoStack.push(command);\n    } else if (command instanceof RedoCommand) {\n      redoStack.push(command);\n    } else {\n      throw new IllegalArgumentException(\"Invalid command type\");\n    }\n  }\n}\n```"
            }
          ]
        },
        "rag": {
          "mode": "rag",
          "N": 30,
          "avg_edit_distance": 719.6666666666666,
          "examples": [
            {
              "id": "fim_easy_001",
              "topic": "adapter",
              "edit_distance": 715,
              "expected_len": 48,
              "pred_len": 762,
              "expected": "adaptee.unionWith(IntSet2Impl.singleton(value));",
              "prediction": "Problem statement: Implement the add method in an IntSet2ToIntSet1Adapter that adapts IntSet2 operations to IntSet1 interface\n\nRelevant course context:\n- Lecture 17 The Adapter Pattern - unionWith method\n\n<Prefix>\npublic class IntSet2ToIntSet1Adapter implements IntSet1 {\n  private final IntSet2 adaptee;\n\n  public IntSet2ToIntSet1Adapter(IntSet2 adaptee) {\n    this.adaptee = adaptee;\n  }\n\n  @Override\n  public void add(int value) {\n\n</Prefix>\n\n<Suffix>\n  }\n\n  @Override\n  public void remove(int value) {\n    adaptee.differenceFrom(IntSet2Impl.singleton(value));\n  }\n}\n</Suffix>\n\nMissing Java code:\n\nProblem statement: Implement the add method in an IntSet2ToIntSet1Adapter that adapts IntSet2 operations to IntSet1 interface\n\nRelevant course context:\n- Lecture"
            },
            {
              "id": "fim_easy_002",
              "topic": "adapter",
              "edit_distance": 834,
              "expected_len": 58,
              "pred_len": 885,
              "expected": "return adaptee.isSupersetOf(IntSet2Impl.singleton(value));",
              "prediction": "public class IntSet2ToIntSet1Adapter implements IntSet1 {\n  private final IntSet2 adaptee;\n\n  @Override\n  public boolean member(int value) {\n    return adaptee.member(value);\n  }\n}\n</Suffix>\n\nExplanation:\nThe missing code snippet is the implementation of the `member()` method in the `IntSet2ToIntSet1Adapter` class.\nThe `IntSet2` class is the original set that is being adapted, and the `IntSet1` class is the new set that is being created.\nThe `member()` method checks if the given value is present in the `IntSet2` class.\nIf the value is present, the method returns `true`, otherwise it returns `false`.\n\nTo implement the `member()` method, we need to create a new `IntSet1` object and call the `member()` method on it.\nWe then return the result of the `member()` method.\n\nIn the `IntSet2ToIntSet1Adapter` class, we create a new `IntSet2` object and call the `member()` method on it"
            },
            {
              "id": "fim_easy_003",
              "topic": "adapter",
              "edit_distance": 962,
              "expected_len": 35,
              "pred_len": 995,
              "expected": "return adaptee.asList().iterator();",
              "prediction": "Problem description: Implement the iterator method that returns an iterator over the adapted set's elements\n\nRelevant course context:\n- Lecture 17 The Adapter Pattern - iterator implementation\n\n<Prefix>\npublic class IntSet2ToIntSet1Adapter implements IntSet1 {\n  private final IntSet2 adaptee;\n\n  @Override\n  public Iterator<Integer> iterator() {\n\n</Prefix>\n\n<Suffix>\n  }\n}\n</Suffix>\n\nExplanation:\n\nThe missing region between the prefix and suffix is the implementation of the iterator method.\nThe `iterator()` method is the method that returns an iterator over the adapted set's elements.\nThe `iterator()` method should return an iterator over the elements of the adapted set.\n\nThe `iterator()` method should be implemented using the `Iterator` interface.\nThe `Iterator` interface defines the `hasNext()` method, which returns `true` if there are more elements to be returned, and the `next()` method, which returns the next element.\n\nThe `IntSet2ToIntSet1Adapter` class implements the `IntSet1"
            },
            {
              "id": "fim_easy_004",
              "topic": "adapter",
              "edit_distance": 924,
              "expected_len": 74,
              "pred_len": 989,
              "expected": "throw new UnsupportedOperationException(\"Cannot remove from Enumeration\");",
              "prediction": "```\nclass EnumeratorIterator<T> implements Iterator<T> {\n  private final Enumeration<T> enumeration;\n\n  @Override\n  public void remove() {\n    // Your code here\n  }\n}\n```\n\nExplanation:\nThe EnumeratorIterator class is a subclass of Iterator that wraps an Enumeration. The remove method is implemented by wrapping the Enumeration and calling the remove method on the wrapped Enumeration.\n\nThe EnumeratorIterator class is used to iterate over an Enumeration. The Enumeration class is a base class for iterators that provides methods for iterating over a collection of elements.\n\nThe EnumeratorIterator class has a private field, `enumeration`, which is an Enumeration object. The `remove()` method is called on the Enumeration object to remove the current element from the Enumeration.\n\nThe `remove()` method is implemented by wrapping the Enumeration object and calling the remove method on the wrapped Enumeration. The wrapped Enumeration object is then returned from the `remove()` method."
            },
            {
              "id": "fim_easy_005",
              "topic": "mvc",
              "edit_distance": 739,
              "expected_len": 153,
              "pred_len": 868,
              "expected": "if (in == null || out == null) {\n      throw new IllegalArgumentException(\"Input and output cannot be null\");\n    }\n    this.in = in;\n    this.out = out;",
              "prediction": "Problem description: Implement the constructor for TicTacToeConsoleController with null validation\n\nRelevant course context:\n- Lecture 9 - TicTacToeConsoleController\n\n<Prefix>\npublic class TicTacToeConsoleController implements TicTacToeController {\n  private final Readable in;\n  private final Appendable out;\n\n  public TicTacToeConsoleController(Readable in, Appendable out) {\n    if (in == null) {\n      throw new NullPointerException(\"Input stream is null\");\n    }\n    if (out == null) {\n      throw new NullPointerException(\"Output stream is null\");\n    }\n    this.in = in;\n    this.out = out;\n  }\n}\n</Suffix>\n\nMissing Java code:\n\nProblem description: Implement the constructor for TicTacToeConsoleController with null validation\n\nRelevant course context:\n- Lecture 9 - TicTacToeConsoleController\n\n<Prefix>\npublic class TicTacToeConsoleController implements TicTac"
            },
            {
              "id": "fim_easy_006",
              "topic": "mvc",
              "edit_distance": 514,
              "expected_len": 116,
              "pred_len": 583,
              "expected": "new TicTacToeConsoleController(new InputStreamReader(System.in),\n        System.out).playGame(new TicTacToeModel());",
              "prediction": "```java\npublic class Main {\n  public static void main(String[] args) {\n    // Your code here\n  }\n}\n```\n\nExplanation:\n\nThe missing code is in the `main` method. The `main` method is the entry point of the Java program. It is responsible for starting the program and handling user input.\n\nTo fix this issue, you need to add the missing code to the `main` method.\n\n```java\npublic class Main {\n  public static void main(String[] args) {\n    // Your code here\n  }\n}\n```\n\nNote: The `main` method is not a part of the lecture material. It is a common Java method used in many Java programs."
            },
            {
              "id": "fim_easy_007",
              "topic": "testing",
              "edit_distance": 661,
              "expected_len": 26,
              "pred_len": 681,
              "expected": "assertTrue(set.member(5));",
              "prediction": "public class IntSet1Impl implements IntSet {\n  private Set<Integer> set;\n\n  public IntSet1Impl() {\n    set = new HashSet<>();\n  }\n\n  @Override\n  public boolean add(int value) {\n    set.add(value);\n    return true;\n  }\n}\n</Suffix>\n\nExplanation:\n\nIn the code snippet above, we have a class called IntSet1Impl that extends the HashSet class.\nThe constructor of the class sets the HashSet to an empty set.\n\nIn the test setup, we create a new IntSet1Impl object and add an element to it.\n\nIn the test, we verify that the IntSet1Impl object has added the element to its set.\n\nNote: The test is not complete and does not verify that the IntSet1Impl object is actually a member of the set."
            },
            {
              "id": "fim_easy_008",
              "topic": "testing",
              "edit_distance": 973,
              "expected_len": 91,
              "pred_len": 1044,
              "expected": "assertThrows(IllegalArgumentException.class,\n        () -> { new HMSDuration(-1, 0, 0); });",
              "prediction": "```java\npublic class DurationTest {\n  @Test\n  public void testNegativeHoursThrows() {\n    // Your code here\n  }\n}\n```\n\nExplanation:\nThe test method `testNegativeHoursThrows` is expected to throw an IllegalArgumentException when called with a negative value for `hours`.\nThe test method should verify that the constructor throws an exception with a message that includes the value of `hours`.\n\nTo verify that the constructor throws an exception, we can use the `throws` keyword in the test method.\n\nIn this example, we have added a `throws` keyword to the test method to indicate that the constructor should throw an exception with a message that includes the value of `hours`.\n\nNote that the `throws` keyword is used to indicate that the test method should throw an exception with a message that includes the value of `hours`.\n\nIn this example, the message of the exception thrown by the constructor is included in the test method's message.\n\nIn this example, the test method's message includes the value of `hours`, which is the value that the"
            },
            {
              "id": "fim_easy_009",
              "topic": "strategy",
              "edit_distance": 792,
              "expected_len": 55,
              "pred_len": 845,
              "expected": "return available.get(random.nextInt(available.size()));",
              "prediction": "```\npublic class RandomStrategy implements TicTacToeStrategy {\n  private final Random random = new Random();\n\n  @Override\n  public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n    List<Coord> available = getEmptyCells(model);\n    if (available.isEmpty()) {\n      return null;\n    }\n\n    int randomIndex = random.nextInt(available.size());\n    Coord coord = available.get(randomIndex);\n    model.setPiece(coord, forWhom);\n    return coord;\n  }\n}\n```\n\nExplanation:\nThe `chooseMove` method takes a `TicTacToeModel` and a `Piece` as input,\nand returns a `Coord` representing the chosen cell.\n\nThe `getEmptyCells` method returns a list of all empty cells in the board.\n\nThe `randomIndex` method returns a random index within the list of available cells.\n\nThe `Coord` class represents a cell on the board, and the `setPiece` method sets the"
            },
            {
              "id": "fim_easy_010",
              "topic": "inheritance",
              "edit_distance": 772,
              "expected_len": 107,
              "pred_len": 853,
              "expected": "for (int z : other.asList()) {\n      if (!member(z)) {\n        return false;\n      }\n    }\n    return true;",
              "prediction": "public class IntSet2ToIntSet1Impl extends IntSet1Impl implements IntSet2 {\n  @Override\n  public final boolean isSupersetOf(IntSet2 other) {\n    // Your code here\n  }\n}\n</Suffix>\n\nExplanation:\nThe missing code is in the `isSupersetOf` method. The method takes an `IntSet2` object as an argument, which is a subclass of `IntSet1`. The `isSupersetOf` method should return `true` if the `IntSet2` object is a superset of the `IntSet1` object.\n\nTo implement this method, we need to iterate through the `other` set's elements and check if they are also elements of the `IntSet1` object. If they are, then the `IntSet2` object is a superset of the `IntSet1` object.\n\nWe can do this by iterating through the `other` set's elements and comparing them to the `IntSet1` object's elements. If the two elements are equal, then they are both elements of the `IntSet1`"
            },
            {
              "id": "fim_easy_011",
              "topic": "decorator",
              "edit_distance": 910,
              "expected_len": 30,
              "pred_len": 940,
              "expected": "return delegate.member(value);",
              "prediction": "public class InstrumentedIntSet implements IntSet {\n  private final IntSet delegate;\n\n  public InstrumentedIntSet(IntSet delegate) {\n    this.delegate = delegate;\n  }\n\n  @Override\n  public boolean member(int value) {\n    return delegate.member(value);\n  }\n}\n</Suffix>\n\nExplanation:\n\nIn the code snippet above, we have a missing region between the prefix and the suffix.\nThe missing region is between the `delegate` variable and the `member` method.\n\nThe `delegate` variable is a reference to the IntSet class, which is a member of the `InstrumentedIntSet` class.\nThe `member` method is a member of the `IntSet` class, which is a member of the `InstrumentedIntSet` class.\n\nThe `member` method is implemented using delegation, which means that it delegates the actual work of checking if a given value is a member of the set to the `delegate` member of the `InstrumentedIntSet` class.\n\nThe `member` method returns `true` if the given value is"
            },
            {
              "id": "fim_easy_012",
              "topic": "command",
              "edit_distance": 674,
              "expected_len": 190,
              "pred_len": 815,
              "expected": "double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n    position = new Position2D(position.getX() + x, position.getY() + y);",
              "prediction": "public class SimpleTurtle implements TurtleModel {\n  private Position2D position;\n  private double heading;\n\n  @Override\n  public void move(double distance) {\n    double angle = heading * Math.PI / 180;\n    double x = position.getX() + distance * Math.cos(angle);\n    double y = position.getY() + distance * Math.sin(angle);\n    position.setX(x);\n    position.setY(y);\n  }\n}\n</Suffix>\n\nExplanation:\nThe move method updates the position based on the heading. The heading is calculated using the heading variable, which is a double value representing the angle in radians. The heading is multiplied by Math.PI/180 to convert it from degrees to radians. The position is then updated using the x and y coordinates of the current position. The x and y coordinates are added to the position object to update the position."
            },
            {
              "id": "fim_easy_013",
              "topic": "mvc",
              "edit_distance": 759,
              "expected_len": 46,
              "pred_len": 798,
              "expected": "board = new Player[3][3];\n    turn = Player.X;",
              "prediction": "Problem description: Implement the move method for TicTacToeModel that takes a move as input and\nreturns the result of the move. The move method should check if the move is valid and if the player\nhas already made the move. If the move is valid, the move should be added to the board. If the move\nis not valid, the move should be rejected.\n\nRelevant course context:\n- Lecture 7 - TicTacToe model\n\n<Prefix>\npublic class TicTacToeModel implements TicTacToe {\n  private Player[][] board;\n  private Player turn;\n\n  public TicTacToeModel() {\n\n</Prefix>\n\n<Suffix>\n  public void move(int row, int col, Player player) {\n    if (board[row][col] != null) {\n      if (board[row][col].equals(player)) {\n        board[row][col] = null;\n        return;\n      }\n    }\n    board[row][col] = player;\n  }\n}\n</Suffix>"
            },
            {
              "id": "fim_easy_014",
              "topic": "testing",
              "edit_distance": 373,
              "expected_len": 28,
              "pred_len": 394,
              "expected": "assertFalse(set.member(10));",
              "prediction": "```\n@Test\npublic void testRemoveRemoves() {\n  IntSet set = new IntSet1Impl();\n  set.add(10);\n  set.remove(10);\n\n  // expected output: IntSet1Impl with size 1\n}\n```\n\nExplanation: The missing code is the `remove(10)` call. The test verifies that the `remove` method removes the specified element from the set. The `IntSet1Impl` class is a stub implementation that does not have a `remove` method."
            },
            {
              "id": "fim_easy_015",
              "topic": "adapter",
              "edit_distance": 834,
              "expected_len": 50,
              "pred_len": 871,
              "expected": "for (int i : other.asList()) {\n      add(i);\n    }",
              "prediction": "public class IntSet2ToIntSet1Impl extends IntSet1Impl implements IntSet2 {\n  @Override\n  public final void unionWith(IntSet2 other) {\n    // Add your code here\n  }\n}\n</Suffix>\n\nExplanation:\nThe missing code is in the `unionWith` method. The `IntSet2` class has a `unionWith` method that takes another `IntSet2` object as a parameter. The `IntSet1Impl` class is a base class for both `IntSet1` and `IntSet2`. The `IntSet1Impl` class has a `unionWith` method that takes another `IntSet1` object as a parameter. The `IntSet2` class has a `unionWith` method that takes another `IntSet2` object as a parameter. The `IntSet1Impl` class has a `unionWith` method that takes another `IntSet1` object as a parameter. The `IntSet2` class has a `unionWith` method that takes another `IntSet2` object as a parameter. The `IntSet1Impl` class has a `unionWith` method that takes another"
            },
            {
              "id": "fim_easy_016",
              "topic": "mvc",
              "edit_distance": 808,
              "expected_len": 15,
              "pred_len": 823,
              "expected": "return asHms();",
              "prediction": "public class Duration {\n  private int hours, minutes, seconds;\n\n  public Duration(int hours, int minutes, int seconds) {\n    this.hours = hours;\n    this.minutes = minutes;\n    this.seconds = seconds;\n  }\n\n  public int getHours() {\n    return hours;\n  }\n\n  public int getMinutes() {\n    return minutes;\n  }\n\n  public int getSeconds() {\n    return seconds;\n  }\n\n  @Override\n  public String toString() {\n    return String.format(\"%02d:%02d:%02d\", hours, minutes, seconds);\n  }\n}\n</Suffix>\n\nExplanation:\n\nThe Duration class has a private field `hours`, `minutes`, and `seconds` to store the duration in hours, minutes, and seconds.\n\nThe `toString()` method is implemented to return the HH:MM:SS format.\n\nThe `toString()` method takes an integer parameter `hours`, `minutes`, and `seconds` to store the duration in the format H"
            },
            {
              "id": "fim_easy_017",
              "topic": "testing",
              "edit_distance": 504,
              "expected_len": 79,
              "pred_len": 558,
              "expected": "day = new HMSDuration(24, 0, 0);\n    ninetySeconds = new HMSDuration(0, 0, 90);",
              "prediction": "public class DurationTest {\n  private Duration day;\n  private Duration ninetySeconds;\n\n  @Before\n  public void setup() {\n    day = Duration.ofDays(1);\n    ninetySeconds = Duration.ofSeconds(90);\n  }\n}\n</Suffix>\n\nExplanation:\nThe missing region between the prefix and suffix is the setup method. The @Before annotation is used to mark the method as a setup method for Duration tests. The setup method is called before each test method in the DurationTest class. The setup method initializes the Duration objects with the default values of 1 day and 0 seconds."
            },
            {
              "id": "fim_easy_018",
              "topic": "command",
              "edit_distance": 470,
              "expected_len": 24,
              "pred_len": 494,
              "expected": "heading += angleDegrees;",
              "prediction": "public class SimpleTurtle implements TurtleModel {\n  private double heading;\n\n  @Override\n  public void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n}\n</Suffix>\n\nExplanation: The missing region between the prefix and suffix is the method implementation. The method signature is `turn(double angleDegrees)`, which is the signature of the `turn` method. The missing region is the method implementation, which includes the `heading` variable declaration and the `turn` method body."
            },
            {
              "id": "fim_easy_019",
              "topic": "mvc",
              "edit_distance": 1011,
              "expected_len": 56,
              "pred_len": 1060,
              "expected": "return Long.compare(this.inSeconds(), that.inSeconds());",
              "prediction": "public class HMSDuration implements Duration {\n  @Override\n  public int compareTo(Duration that) {\n    int result = 0;\n    if (that instanceof Duration) {\n      Duration thatDuration = (Duration) that;\n      result = (int) (this.getSeconds() - thatDuration.getSeconds());\n    }\n    return result;\n  }\n}\n</Suffix>\n\nExplanation:\n\nThe code snippet above defines a class called HMSDuration that implements the Duration interface. The class has a method called compareTo that takes two Duration objects as parameters. The method compares the total seconds of the two Duration objects and returns a negative integer if the first Duration is shorter than the second, a positive integer if the first Duration is longer than the second, or zero if the two Duration objects have the same total seconds.\n\nThe code snippet also defines a method called getSeconds that returns the seconds component of the Duration object.\n\nThe code snippet is missing a region between the prefix and the suffix. The missing region should contain the implementation of the compareTo method."
            },
            {
              "id": "fim_easy_020",
              "topic": "adapter",
              "edit_distance": 673,
              "expected_len": 53,
              "pred_len": 715,
              "expected": "for (int i : other.asList()) {\n      remove(i);\n    }",
              "prediction": "public class IntSet2ToIntSet1Impl extends IntSet1Impl implements IntSet2 {\n  @Override\n  public final void differenceFrom(IntSet2 other) {\n    // Add your code here\n  }\n}\n</Suffix>\n\nExplanation:\nIn the code snippet above, we have a missing region between the prefix and the suffix.\nThe missing region is between the `public class IntSet2ToIntSet1Impl extends IntSet1Impl implements IntSet2 {` and the `}`.\n\nTo fix this, we need to add the missing code between the `public class` and the `}`.\n\nIn this case, we need to add the following code:\n\n```java\n  }\n}\n```\n\nTo complete the missing code, we need to add the following code:\n\n```java\n  }\n}\n```\n\nThis completes the missing code and makes the code snippet complete."
            },
            {
              "id": "fim_hard_001",
              "topic": "adapter",
              "edit_distance": 712,
              "expected_len": 912,
              "pred_len": 819,
              "expected": "// IntSet1 methods - translate element operations to set operations\n  @Override\n  public void add(int value) {\n    adaptee.unionWith(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public void remove(int value) {\n    adaptee.differenceFrom(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public boolean member(int value) {\n    return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return adaptee.asList().iterator();\n  }\n\n  // IntSet2 methods - delegate directly to adaptee\n  @Override\n  public void unionWith(IntSet2 other) {\n    adaptee.unionWith(other);\n  }\n\n  @Override\n  public void differenceFrom(IntSet2 other) {\n    adaptee.differenceFrom(other);\n  }\n\n  @Override\n  public boolean isSupersetOf(IntSet2 other) {\n    return adaptee.isSupersetOf(other);\n  }\n\n  @Override\n  public List<Integer> asList() {\n    return adaptee.asList();\n  }",
              "prediction": "```java\npublic class IntSet2ToIntSet1Adapter implements IntSet1, IntSet2 {\n  private final IntSet2 adaptee;\n\n  public IntSet2ToIntSet1Adapter(IntSet2 adaptee) {\n    this.adaptee = Objects.requireNonNull(adaptee);\n  }\n\n  // missing region between a prefix and suffix\n}\n```\n\nExplanation:\nThe missing region between a prefix and suffix is the region between the `private final` keyword and the `public` keyword.\n\nIn this case, the `private final` keyword is used to declare the `IntSet2ToIntSet1Adapter` class, while the `public` keyword is used to declare the `IntSet2ToIntSet1Adapter` class itself.\n\nThe `IntSet2ToIntSet1Adapter` class is a complete two-way adapter class that wraps the `IntSet2` adaptee.\n\nThe `IntSet2ToIntSet1Adapter` class has a private final field `adaptee` that is a reference to the `IntSet2` adap"
            },
            {
              "id": "fim_hard_002",
              "topic": "adapter",
              "edit_distance": 678,
              "expected_len": 353,
              "pred_len": 949,
              "expected": "@Override\n  public boolean hasNext() {\n    return enumeration.hasMoreElements();\n  }\n\n  @Override\n  public T next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    return enumeration.nextElement();\n  }\n\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException(\"Cannot remove from an Enumeration\");\n  }",
              "prediction": "```java\npublic class EnumerationIterator<T> implements Iterator<T> {\n  private final Enumeration<T> enumeration;\n\n  public EnumerationIterator(Enumeration<T> enumeration) {\n    this.enumeration = Objects.requireNonNull(enumeration);\n  }\n\n  @Override\n  public boolean hasNext() {\n    return enumeration.hasMoreElements();\n  }\n\n  @Override\n  public T next() {\n    return enumeration.nextElement();\n  }\n\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException();\n  }\n}\n```\n\nExplanation:\n\nThe EnumerationIterator class wraps an Enumeration to provide an Iterator interface. It implements the Iterator interface by wrapping the Enumeration and returning the next element.\n\nThe `next()` method returns the next element from the Enumeration. It calls the `nextElement()` method on the Enumeration to get the next element.\n\nThe `remove()` method throws an UnsupportedOperationException because the EnumerationIterator class does not"
            },
            {
              "id": "fim_hard_003",
              "topic": "mvc",
              "edit_distance": 672,
              "expected_len": 810,
              "pred_len": 857,
              "expected": "Objects.requireNonNull(model);\n    append(model.toString() + \"\\n\");\n    append(\"Enter move as row col (1-indexed):\\n\");\n\n    while (!model.isGameOver()) {\n      append(\"Player \" + model.getTurn() + \"'s turn:\\n\");\n      try {\n        int row = scan.nextInt() - 1;\n        int col = scan.nextInt() - 1;\n        model.move(row, col);\n        append(model.toString() + \"\\n\");\n      } catch (InputMismatchException e) {\n        append(\"Invalid input. Enter row and column as integers.\\n\");\n        scan.next(); // consume invalid token\n      } catch (IllegalArgumentException e) {\n        append(\"Invalid move: \" + e.getMessage() + \"\\n\");\n      }\n    }\n\n    if (model.getWinner() != null) {\n      append(\"Game over! Winner: \" + model.getWinner() + \"\\n\");\n    } else {\n      append(\"Game over! It's a tie!\\n\");\n    }",
              "prediction": "```\npublic class TicTacToeConsoleController implements TicTacToeController {\n  private final Scanner scan;\n  private final Appendable out;\n\n  public TicTacToeConsoleController(Readable in, Appendable out) {\n    this.scan = new Scanner(in);\n    this.out = out;\n  }\n\n  @Override\n  public void playGame(TicTacToe model) {\n\n  }\n\n  private void append(String message) {\n    try {\n      out.append(message);\n    } catch (IOException e) {\n      throw new IllegalStateException(\"Failed to append output\", e);\n    }\n  }\n}\n```\n\nExplanation:\n- The `playGame` method is called by the `TicTacToeConsoleController` class.\n- The `playGame` method reads moves from the `scan` object and plays the game until game over.\n- The `append` method is called to append the output to the `out` object.\n- The `append` method is called with a message that includes the current player'"
            },
            {
              "id": "fim_hard_004",
              "topic": "decorator",
              "edit_distance": 688,
              "expected_len": 470,
              "pred_len": 885,
              "expected": "@Override\n  public void add(int value) {\n    addCount++;\n    delegate.add(value);\n  }\n\n  @Override\n  public void addAll(Collection<Integer> values) {\n    addCount += values.size();\n    delegate.addAll(values);\n  }\n\n  @Override\n  public void remove(int value) {\n    delegate.remove(value);\n  }\n\n  @Override\n  public boolean member(int value) {\n    return delegate.member(value);\n  }\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return delegate.iterator();\n  }",
              "prediction": "```java\npublic class InstrumentedIntSet implements IntSet {\n  private final IntSet delegate;\n  private int addCount;\n\n  public InstrumentedIntSet(IntSet delegate) {\n    this.delegate = Objects.requireNonNull(delegate);\n    this.addCount = 0;\n  }\n\n  public int getAddCount() {\n    return addCount;\n  }\n\n  // Add your code here\n}\n```\n\nExplanation:\n\nIn this code snippet, we have a class called `InstrumentedIntSet` that extends the `IntSet` class.\nThe `InstrumentedIntSet` class has a private field called `delegate` that is an instance of the `IntSet` class.\n\nThe `InstrumentedIntSet` class has a method called `getAddCount()` that returns the current value of the `addCount` field.\n\nThe `InstrumentedIntSet` class has a constructor that takes an instance of the `IntSet` class as a parameter.\n\nThe `InstrumentedIntSet` class has a private field called `addCount` that is initialized to"
            },
            {
              "id": "fim_hard_005",
              "topic": "command",
              "edit_distance": 656,
              "expected_len": 394,
              "pred_len": 912,
              "expected": "@Override\n  public void execute() {\n    previousPosition = turtle.getPosition();\n    turtle.move(distance);\n  }\n\n  @Override\n  public void undo() {\n    if (previousPosition == null) {\n      throw new IllegalStateException(\"Cannot undo: command not executed\");\n    }\n    turtle.setPosition(previousPosition);\n  }\n\n  @Override\n  public boolean canUndo() {\n    return previousPosition != null;\n  }",
              "prediction": "```java\npublic class MoveCommand implements TurtleCommand {\n  private final TurtleModel turtle;\n  private final double distance;\n  private Position2D previousPosition;\n\n  public MoveCommand(TurtleModel turtle, double distance) {\n    this.turtle = Objects.requireNonNull(turtle);\n    this.distance = distance;\n  }\n\n  @Override\n  public void execute() {\n    turtle.move(distance);\n    previousPosition = turtle.getPosition();\n  }\n\n  @Override\n  public void undo() {\n    turtle.setPosition(previousPosition);\n  }\n}\n```\n\nExplanation:\n\nThe MoveCommand class defines a command that moves the turtle by a given distance. The class has a private field `turtle` that references the turtle model. The `execute()` method moves the turtle by the given distance and sets the previous position to the current position. The `undo()` method undoes the last move and sets the previous position to the current position.\n\nThe `Move"
            },
            {
              "id": "fim_hard_006",
              "topic": "strategy",
              "edit_distance": 583,
              "expected_len": 482,
              "pred_len": 757,
              "expected": "// Try corners first\n    for (int[] corner : CORNERS) {\n      if (isEmpty(model, corner[0], corner[1])) {\n        return new Coord(corner[0], corner[1]);\n      }\n    }\n\n    // Try center\n    if (isEmpty(model, CENTER[0], CENTER[1])) {\n      return new Coord(CENTER[0], CENTER[1]);\n    }\n\n    // Try edges\n    for (int[] edge : EDGES) {\n      if (isEmpty(model, edge[0], edge[1])) {\n        return new Coord(edge[0], edge[1]);\n      }\n    }\n\n    // No move available\n    return null;",
              "prediction": "```\npublic class CornerStrategy implements TicTacToeStrategy {\n  private static final int[][] CORNERS = {{0,0}, {0,2}, {2,0}, {2,2}};\n  private static final int[] CENTER = {1, 1};\n  private static final int[][] EDGES = {{0,1}, {1,0}, {1,2}, {2,1}};\n\n  @Override\n  public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n    // TODO: Implement your strategy here\n    return null;\n  }\n\n  private boolean isEmpty(TicTacToeModel model, int row, int col) {\n    return model.getPieceAt(row, col) == null;\n  }\n}\n```\n\nExplanation:\n\nThe CornerStrategy class defines a private static final array of int[][] CORNERS, which is used to prioritize corner moves. The array is defined as an array of arrays, where each array represents a corner. The first element of"
            },
            {
              "id": "fim_hard_007",
              "topic": "mvc",
              "edit_distance": 765,
              "expected_len": 1020,
              "pred_len": 692,
              "expected": "@Override\n  public void move(int row, int col) {\n    if (gameOver) {\n      throw new IllegalStateException(\"Game is already over\");\n    }\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Position out of bounds\");\n    }\n    if (board[row][col] != null) {\n      throw new IllegalArgumentException(\"Cell already occupied\");\n    }\n\n    board[row][col] = turn;\n\n    if (checkWin(turn)) {\n      winner = turn;\n      gameOver = true;\n    } else if (isBoardFull()) {\n      gameOver = true;\n    } else {\n      turn = (turn == Player.X) ? Player.O : Player.X;\n    }\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public Player getWinner() {\n    return winner;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    return gameOver;\n  }\n\n  @Override\n  public Player getPieceAt(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Position out of bounds\");\n    }\n    return board[row][col];\n  }",
              "prediction": "```\npublic class TicTacToeModel implements TicTacToe {\n  private final Player[][] board;\n  private Player turn;\n  private boolean gameOver;\n  private Player winner;\n\n  public TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n    gameOver = false;\n    winner = null;\n  }\n\n  // Check rows, columns, and diagonals\n  private boolean checkWin(Player p) {\n    // Check rows, columns, and diagonals\n    for (int I = 0; I < 3; i++) {\n      if (board[i][0] == p && board[i][1] == p && board[i][2] == p) return true;\n      if (board[0][i] == p && board[1][i] == p && board[2][i] == p) return true;\n    }\n    if (board[0][0] == p && board[1][1] == p && board[2][2] == p) return true;"
            },
            {
              "id": "fim_hard_008",
              "topic": "gui",
              "edit_distance": 811,
              "expected_len": 948,
              "pred_len": 968,
              "expected": "addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        int col = e.getX() / CELL_SIZE;\n        int row = e.getY() / CELL_SIZE;\n        if (row >= 0 && row < 3 && col >= 0 && col < 3) {\n          controller.handleCellClick(row, col);\n          repaint();\n        }\n      }\n    });\n  }\n\n  @Override\n  protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n\n    // Draw grid lines\n    g.setColor(Color.BLACK);\n    for (int i = 1; i < 3; i++) {\n      g.drawLine(i * CELL_SIZE, 0, i * CELL_SIZE, 3 * CELL_SIZE);\n      g.drawLine(0, i * CELL_SIZE, 3 * CELL_SIZE, i * CELL_SIZE);\n    }\n\n    // Draw pieces\n    for (int row = 0; row < 3; row++) {\n      for (int col = 0; col < 3; col++) {\n        Player p = model.getPieceAt(row, col);\n        if (p == Player.X) {\n          drawX(g, row, col);\n        } else if (p == Player.O) {\n          drawO(g, row, col);\n        }\n      }\n    }",
              "prediction": "- The missing region between the prefix and the suffix is the drawX() method.\n\nExplanation:\nThe drawX() method is responsible for drawing the X symbol on the board. It takes in a reference to the graphics context and the row and column of the cell to draw. It then draws a line from the center of the cell to the left and right edges, and a line from the center of the cell to the top and bottom edges.\n\nThe drawO() method is responsible for drawing the O symbol on the board. It takes in a reference to the graphics context and the row and column of the cell to draw. It then draws an oval with the specified size and center position.\n\nThe TTTPanel class is responsible for drawing the TicTacToe board and handling mouse clicks. It has a reference to the TicTacToe model and a reference to the TicTacToeController controller. It draws the board using the drawX() and drawO() methods. It also handles mouse clicks by calling the controller's handleMouseClick() method."
            },
            {
              "id": "fim_hard_009",
              "topic": "observer",
              "edit_distance": 591,
              "expected_len": 775,
              "pred_len": 773,
              "expected": "public void addObserver(TicTacToeObserver observer) {\n    observers.add(Objects.requireNonNull(observer));\n  }\n\n  public void removeObserver(TicTacToeObserver observer) {\n    observers.remove(observer);\n  }\n\n  private void notifyObservers() {\n    for (TicTacToeObserver obs : observers) {\n      obs.update(this);\n    }\n  }\n\n  @Override\n  public void move(int row, int col) {\n    delegate.move(row, col);\n    notifyObservers();\n  }\n\n  @Override\n  public Player getTurn() {\n    return delegate.getTurn();\n  }\n\n  @Override\n  public Player getWinner() {\n    return delegate.getWinner();\n  }\n\n  @Override\n  public boolean isGameOver() {\n    return delegate.isGameOver();\n  }\n\n  @Override\n  public Player getPieceAt(int row, int col) {\n    return delegate.getPieceAt(row, col);\n  }",
              "prediction": "```java\npublic class ObservableTicTacToe implements TicTacToe {\n  private final TicTacToe delegate;\n  private final List<TicTacToeObserver> observers;\n\n  public ObservableTicTacToe(TicTacToe delegate) {\n    this.delegate = Objects.requireNonNull(delegate);\n    this.observers = new ArrayList<>();\n  }\n\n  // Add an observer to the list\n  public void addObserver(TicTacToeObserver observer) {\n    observers.add(observer);\n  }\n\n  // Remove an observer from the list\n  public void removeObserver(TicTacToeObserver observer) {\n    observers.remove(observer);\n  }\n\n  // Notify all observers of a change\n  public void notifyObservers() {\n    for (TicTacToeObserver observer : observers) {\n      observer.update();\n    }\n  }\n}\n```\n\nExplanation:\n\nThe `ObservableTicTacToe` class has"
            },
            {
              "id": "fim_hard_010",
              "topic": "command",
              "edit_distance": 532,
              "expected_len": 793,
              "pred_len": 816,
              "expected": "public void executeCommand(TurtleCommand command) {\n    command.execute();\n    undoStack.push(command);\n    redoStack.clear(); // Clear redo stack on new command\n  }\n\n  public boolean canUndo() {\n    return !undoStack.isEmpty();\n  }\n\n  public boolean canRedo() {\n    return !redoStack.isEmpty();\n  }\n\n  public void undo() {\n    if (!canUndo()) {\n      throw new IllegalStateException(\"Nothing to undo\");\n    }\n    TurtleCommand command = undoStack.pop();\n    command.undo();\n    redoStack.push(command);\n  }\n\n  public void redo() {\n    if (!canRedo()) {\n      throw new IllegalStateException(\"Nothing to redo\");\n    }\n    TurtleCommand command = redoStack.pop();\n    command.execute();\n    undoStack.push(command);\n  }\n\n  public void clear() {\n    undoStack.clear();\n    redoStack.clear();\n  }",
              "prediction": "```java\npublic class CommandHistory {\n  private final Stack<TurtleCommand> undoStack;\n  private final Stack<TurtleCommand> redoStack;\n\n  public CommandHistory() {\n    undoStack = new Stack<>();\n    redoStack = new Stack<>();\n  }\n\n  public void undo() {\n    if (undoStack.isEmpty()) {\n      return;\n    }\n    TurtleCommand command = undoStack.pop();\n    execute(command);\n  }\n\n  public void redo() {\n    if (redoStack.isEmpty()) {\n      return;\n    }\n    TurtleCommand command = redoStack.pop();\n    execute(command);\n  }\n\n  public void execute(TurtleCommand command) {\n    if (command instanceof UndoCommand) {\n      undoStack.push(command);\n    } else if (command instanceof RedoCommand) {\n      redoStack.push(command);\n    } else {\n      throw new IllegalArgumentException(\"Invalid command type\");\n    }\n  }\n}\n```"
            }
          ]
        },
        "rag_lora": {
          "mode": "rag_lora",
          "N": 30,
          "avg_edit_distance": 801.3,
          "examples": [
            {
              "id": "fim_easy_001",
              "topic": "adapter",
              "edit_distance": 764,
              "expected_len": 48,
              "pred_len": 806,
              "expected": "adaptee.unionWith(IntSet2Impl.singleton(value));",
              "prediction": "1. A class that implements IntSet1 and IntSet2 interfaces.\n2. A class that implements IntSet1ToIntSet1Adapter and overrides the add and remove methods.\n3. One implementation of IntSet2 in the form of IntSet2Impl.\n4. One implementation of IntSet1 in the form of IntSetImpl.\n5. One implementation of IntSet1ToIntSet1Adapter in the form of IntSet1ImplToIntSet1AdapterImpl.\n6. One implementation of IntSet2ToIntSet1Adapter in the form of IntSet2ImplToIntSet1AdapterImpl.\n\n1.1 A IntSet2ToIntSet1AdapterImpl implementation:\n\npublic class IntSet2ToIntSet1AdapterImpl implements IntSet1ToIntSet1Adapter {\n  private final IntSet2 adaptee;\n  private final IntSet1 result;\n\n  public IntSet2ToIntSet1AdapterImpl(IntSet2 adaptee) {\n    this.adaptee = adaptee;\n    this.result = IntSetImpl.singleton(0);\n  }\n\n  @Override"
            },
            {
              "id": "fim_easy_002",
              "topic": "adapter",
              "edit_distance": 644,
              "expected_len": 58,
              "pred_len": 695,
              "expected": "return adaptee.isSupersetOf(IntSet2Impl.singleton(value));",
              "prediction": "public IntSet2ToIntSet1Adapter() {\n  //initialize the set to empty\n  this.adaptee = new IntSet2();\n}\n\npublic IntSet2ToIntSet1Adapter(IntSet2 adaptee) {\n  this.adaptee = adaptee;\n}\n\npublic IntSet2ToIntSet1Adapter(IntSet1 source) {\n  this.adaptee = new IntSet2();\n  for (int i : source) {\n    adaptee.add(i);\n  }\n}\n\npublic boolean member(int value) {\n  return adaptee.member(value);\n}\n}\n\n3.1 A IntSet1 interface\n\n/**\n * An implementation of an IntSet1.\n */\npublic class IntSet1 implements IntSet {\n  private final Set<Integer> set = new HashSet<>();\n\n  @Override\n  public void add(int value) {\n    set.add(value);\n  }\n\n  @Override\n  public boolean member(int value) {\n    return set.contains(value"
            },
            {
              "id": "fim_easy_003",
              "topic": "adapter",
              "edit_distance": 976,
              "expected_len": 35,
              "pred_len": 1009,
              "expected": "return adaptee.asList().iterator();",
              "prediction": "1. An adapter that transforms an IntSet2 into an IntSet1.\n\n2. One implementation of the IntSet1 interface, IntSet2ToIntSet1Adapter.\n\n3. One method, the default implementation of iterator(), that returns an iterator over the adapted set's elements.\n\n4. The missing code in this case is an implementation of the iterator() method.\n\n5. The intention is that the adapter should be as close as possible to an IntSet1, so that it can be used as such.\n\n6. The intention is that the default implementation of the iterator() method should be as simple as possible, so that it can be tested.\n\n7. The intention is that the adapter should be as general as possible, so that it can be used with any IntSet2.\n\n8. The intention is that the adapter should be as efficient as possible, so that it can be used with any IntSet1.\n\n9. The intention is that the adapter should be as close as possible to an IntSet1, so that it can be used as such.\n\n10. The intention is that the adapter should be as general as possible, so that it"
            },
            {
              "id": "fim_easy_004",
              "topic": "adapter",
              "edit_distance": 862,
              "expected_len": 74,
              "pred_len": 926,
              "expected": "throw new UnsupportedOperationException(\"Cannot remove from Enumeration\");",
              "prediction": "1. A single method, remove()\n2. One enum member, Enumeration (which is not an enum)\n3. One field, the enumeration object (which is not an enum)\n4. One class, TestEnumIterator\n5. One package, Test\n6. One class, TestEnumIterator, with a single public method, testBasicOperations\n7. One enum, TestEnum, with one constant, TEST\n8. One interface, TestEnumIteratorAdapter, with one method, testBasicOperations\n9. One implementation, TestEnumIteratorAdapter, with one field, an enum named TestEnum\n10. One class, TestEnumIteratorAdapter, with a single public method, testBasicOperations\n11. One package, Test\n12. One class, TestEnum2, with a single public method, testBasicOperations\n13. One interface, TestEnum2Adapter, with one method, testBasicOperations\n14. One class, TestEnum2Adapter, with one field, an enum named TestEnum2\n15. One class, TestEnum3, with a single public method, testBasicOperations\n16. One interface, TestEnum"
            },
            {
              "id": "fim_easy_005",
              "topic": "mvc",
              "edit_distance": 819,
              "expected_len": 153,
              "pred_len": 930,
              "expected": "if (in == null || out == null) {\n      throw new IllegalArgumentException(\"Input and output cannot be null\");\n    }\n    this.in = in;\n    this.out = out;",
              "prediction": "1. A public constructor that takes in and out as arguments,\n   ensuring that they are not null.\n2. A method to read a game state from the input stream,\n   and construct a TicTacToe object from it.\n3. A method to write the game state to the appendable out,\n   using TTTModel to represent the state.\n4. A method to prompt the user for input, and read it in as a string.\n5. A method to execute a game move for the model,\n   and write any relevant feedback to the appendable.\n6. A method to close the input and appendable streams.\n\nYou are a CS3500 TA helping with GUI components.\n\n1. A class Main that contains a single public static main method,\n   with two parameters, which are a Readable (in) and an Appendable (out).\n   Your task is to create an instance of Main,\n   and to call its main method with these parameters.\n\n2. A TicTacToeModel that implements TTTModel.\n   Your task is to implement TicTacToeConsoleController,\n   and"
            },
            {
              "id": "fim_easy_006",
              "topic": "mvc",
              "edit_distance": 636,
              "expected_len": 116,
              "pred_len": 720,
              "expected": "new TicTacToeConsoleController(new InputStreamReader(System.in),\n        System.out).playGame(new TicTacToeModel());",
              "prediction": "1.1 A class to represent a Tic Tac Toe game, with a model (but no view)\n\n/**\n * This class manages a 3x3 game of Tic Tac Toe, and\n * has a model (TicTacToe) and a view (TicTacToePanel)\n */\npublic class TicTacToeConsoleController implements TicTacToeController {\n  // the model\n  private TicTacToe model;\n  // the view\n  private TicTacToePanel view;\n\n  /**\n   * The constructor for the controller.\n   *\n   * @param view the view to show prompts and results to\n   */\n  public TicTacToeConsoleController(TicTacToePanel view) {\n    this.view = view;\n  }\n\n  @Override\n  public void playGame(TicTacToe game) {\n    //TODO: Implement game play here\n    view.displayBoard(game);\n    view.askUserInput();\n  }\n\n  @Override\n  public"
            },
            {
              "id": "fim_easy_007",
              "topic": "testing",
              "edit_distance": 944,
              "expected_len": 26,
              "pred_len": 963,
              "expected": "assertTrue(set.member(5));",
              "prediction": "1.1 A class named IntSet1Impl that implements IntSet1, with a single public constructor that takes no arguments.\n\n1.2 A class named IntSet1 that extends IntSet1Impl.\n\n2.1 A class named IntSet2 that extends IntSet1 and overrides the plusMethod method to return + for each element.\n\n2.2 A class named IntSet3 that extends IntSet2 and overrides the plusMethod method to return + for each element.\n\n3.1 A class named IntSet4 that extends IntSet3 and overrides the plusMethod method to return + for each element.\n\n4.1 A class named IntSet5 that extends IntSet4 and overrides the plusMethod method to return + for each element.\n\n5.1 A class named IntSet6 that extends IntSet5 and overrides the plusMethod method to return + for each element.\n\n6.1 A class named IntSet7 that extends IntSet6 and overrides the plusMethod method to return + for each element.\n\n7.1 A class named IntSet8 that extends IntSet7 and overrides the plusMethod method to return + for each element."
            },
            {
              "id": "fim_easy_008",
              "topic": "testing",
              "edit_distance": 891,
              "expected_len": 91,
              "pred_len": 964,
              "expected": "assertThrows(IllegalArgumentException.class,\n        () -> { new HMSDuration(-1, 0, 0); });",
              "prediction": "public class TestDuration {\n  @Test(expected = IllegalArgumentException.class)\n  public void testBadHours() {\n    new Duration(0, 0, 0);\n  }\n}\n\n3.1 A public class named Duration with a single public constructor that takes two arguments of type int. The constructor should initialize the fields to the default values of 0 seconds, 0 minutes, and 0 hours. A read-only field of type Duration that represents the time in the form of a Duration object. A read-only field of type long that represents the hours component of the duration. A method, named getFormattedDurationString, that takes no arguments and returns a String representing the duration in the form of H:MM:SS.\n\nA sample test case for the above functionality is provided as a template:\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.Objects;\n\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\n\n/**"
            },
            {
              "id": "fim_easy_009",
              "topic": "strategy",
              "edit_distance": 782,
              "expected_len": 55,
              "pred_len": 829,
              "expected": "return available.get(random.nextInt(available.size()));",
              "prediction": "public class RandomStrategy implements TicTacToeStrategy {\n  private final int maxRows;\n  private final int maxCols;\n\n  public RandomStrategy(int maxRows, int maxCols) {\n    this.maxRows = maxRows;\n    this.maxCols = maxCols;\n  }\n\n  @Override\n  public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n    List<Coord> available = getEmptyCells(model);\n    if (available.isEmpty()) {\n      return null;\n    }\n\n    int row = random.nextInt(maxRows);\n    int col = random.nextInt(maxCols);\n\n    return new Coord(row, col);\n  }\n}\n\n3.1 A public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable (in that order). The Readable pipeable to a PrintStream, and the Appendable pipeable to a Writer (in this case, a Print"
            },
            {
              "id": "fim_easy_010",
              "topic": "inheritance",
              "edit_distance": 690,
              "expected_len": 107,
              "pred_len": 774,
              "expected": "for (int z : other.asList()) {\n      if (!member(z)) {\n        return false;\n      }\n    }\n    return true;",
              "prediction": "1.1 A IntSet1Impl is a IntSet2Impl-adapter.\n\npublic class IntSet1Impl implements IntSet2 {\n  // The IntSet2 that this IntSet1Impl is a part of.\n  private final IntSet2 mInner;\n\n  public IntSet1Impl(IntSet2 mInner) {\n    this.mInner = mInner;\n  }\n\n  // The remaining methods are the same for all IntSet implementations.\n  // The only difference is that the IntSet2 is a IntSet1Impl.\n  // This means that the IntSet1Impl constructor will take an IntSet1Impl as a\n  // parameter, and pass it the IntSet2 it was instantiated with.\n  public static IntSet1Impl fromIntSet2(IntSet2 mInner) {\n    return new IntSet1Impl(mInner);\n  }\n\n  @Override\n  public final boolean isSupersetOf(IntSet2 other) {\n    return mInner.isSupersetOf(other);\n  }\n}\n\n1.2 A IntSet2 is a IntSet1 that is ad"
            },
            {
              "id": "fim_easy_011",
              "topic": "decorator",
              "edit_distance": 930,
              "expected_len": 30,
              "pred_len": 958,
              "expected": "return delegate.member(value);",
              "prediction": "We provide an existing IntSet implementation as our base.\n\n1.1 A IntSet is a generic set of integers, with the ability to instrument\nthe operations to log the operation to a logger.\n\n1.2 A IntSetAdapter is a adapter class that wraps an IntSet and implements\nall its methods as expected.\n\n1.3 Our goal is to implement InstrumentedIntSet, which extends IntSet and\noverride all methods to log the operation to the logger.\n\n1.4 The log method is particularly tricky, because it takes in two arguments:\nthe integer value to log, and the object that would be logged.\n\nTask: Complete the missing code in this Java file.\n\nCode BEFORE the gap:\n```java\npackage cs3500.lec09;\n\nimport java.util.Objects;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\n/**\n * An implementation of {@link IntSet} using the Collections Framework's\n * {@link IntSet} interface.\n */\npublic class InstrumentedIntSet implements IntSet {\n  private final IntSet delegate"
            },
            {
              "id": "fim_easy_012",
              "topic": "command",
              "edit_distance": 672,
              "expected_len": 190,
              "pred_len": 779,
              "expected": "double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n    position = new Position2D(position.getX() + x, position.getY() + y);",
              "prediction": "public SimpleTurtle() {\n    super();\n    this.position = new Position2D(0, 0);\n    this.heading = 0;\n  }\n\n}\n\n3.1 A public class named SimpleTurtleTurtleGraphics that extends TurtleTurtleGraphics and overrides all methods to provide turtle graphics for 2D turtles.\n\n/**\n * This class manages a 2D turtle and implements all\n * its associated operations\n */\npublic class SimpleTurtleTurtleGraphics extends TurtleTurtleGraphics implements\n\nTask: Complete the missing code in this Java file.\n\nCode BEFORE the gap:\n```java\npackage cs3500.turtle.turtlegraphics;\n\nimport java.awt.*;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.NoninvertibleTransformException;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.image.BufferedImage;\nimport java"
            },
            {
              "id": "fim_easy_013",
              "topic": "mvc",
              "edit_distance": 718,
              "expected_len": 46,
              "pred_len": 762,
              "expected": "board = new Player[3][3];\n    turn = Player.X;",
              "prediction": "public class Cell {\n  int row;\n  int col;\n}\n\npublic class TicTacToeModel implements TicTacToe {\n  private Player[][] board;\n  private Player turn;\n\n  public TicTacToeModel() {\n    board = new Player[3][3];\n    turn = null;\n  }\n\n  // Initializes the board to the default state. Default state = empty board\n  // with 3x3 fields.\n  public void initializeBoard() {\n    for (int row = 0; row < board.length; row++) {\n      for (int col = 0; col < board[row].length; col++) {\n        board[row][col] = null;\n      }\n    }\n  }\n\n  // Get the current state of the game\n  public Player[][] getBoard() {\n    return board;\n  }\n\n  // Get the player for the turn\n  public Player getTurn() {\n    return turn;\n  }\n\n  // Set the turn\n  public void setTurn(Player turn) {\n    this"
            },
            {
              "id": "fim_easy_014",
              "topic": "testing",
              "edit_distance": 770,
              "expected_len": 28,
              "pred_len": 795,
              "expected": "assertFalse(set.member(10));",
              "prediction": "public void remove(int value) {\n    if (value < 0) {\n      throw new IllegalArgumentException(\"Value must be non-negative\");\n    }\n    int index = set.indexOf(value);\n    if (index < 0) {\n      throw new IllegalArgumentException(\"Value not found\");\n    }\n    set.remove(index);\n  }\n}\n\nNow, implement the IntSet1Impl class:\n\npublic class IntSet1Impl implements IntSet {\n  private final List<Integer> list = new ArrayList<>();\n\n  @Override\n  public void add(int value) {\n    list.add(value);\n  }\n\n  @Override\n  public void remove(int value) {\n    list.remove(value);\n  }\n\n  @Override\n  public int size() {\n    return list.size();\n  }\n\n  @Override\n  public boolean isSupersetOf(IntSet other) {\n    if (other.size() > size()) {\n      return false;\n    }\n    for (int i : other.list) {\n      if (list"
            },
            {
              "id": "fim_easy_015",
              "topic": "adapter",
              "edit_distance": 810,
              "expected_len": 50,
              "pred_len": 849,
              "expected": "for (int i : other.asList()) {\n      add(i);\n    }",
              "prediction": "We provide the missing code:\n\npublic IntSet2ToIntSet1Impl() {\n  super();\n  elements = new int[0];\n}\n\n\n1 is the initial capacity of the set.\n\n2 is the initial size of the set.\n\n3 is the size of the set when it was created.\n\n4 is the capacity of the elements array.\n\n5 is the size of the elements array.\n\n6 is the mod count.\n\n7 is the index of the last element added to the set.\n\n8 is the index of the last element removed from the set.\n\n9 is the capacity of the elements array.\n\n10 is the mod count.\n\n11 is the index of the last element added to the set.\n\n12 is the index of the last element removed from the set.\n\n13 is the capacity of the elements array.\n\n14 is the mod count.\n\n15 is the index of the last element added to the set.\n\n16 is the index of the last element removed from the set.\n\n17 is the capacity of the elements array.\n\n18 is the mod"
            },
            {
              "id": "fim_easy_016",
              "topic": "mvc",
              "edit_distance": 1031,
              "expected_len": 15,
              "pred_len": 1046,
              "expected": "return asHms();",
              "prediction": "1. A public constructor that takes in two integers, representing the hours and minutes, respectively.\n\n2. A single public method, named <code>toString</code>, that takes in no arguments and returns a string representing the duration in the HH:MM:SS format.\n\n3. It is also possible to implement the Duration interface directly, and not use this class at all. In that case, your implementation of the interface would look something like this:\n\npublic class SimpleDuration implements Duration {\n  private int seconds;\n\n  public SimpleDuration(int seconds) {\n    this.seconds = seconds;\n  }\n\n  @Override\n  public String toString() {\n    return \"\" + seconds;\n  }\n}\n\n4. You are free to choose any name for the method, as long as it is unique.\n\n5. You may also choose to implement the Duration interface directly, and not use this class at all. In that case, your implementation of the interface would look something like this:\n\npublic class SimpleDuration2 implements Duration {\n  private int minutes;\n\n  public SimpleDuration2(int minutes) {\n    this."
            },
            {
              "id": "fim_easy_017",
              "topic": "testing",
              "edit_distance": 747,
              "expected_len": 79,
              "pred_len": 807,
              "expected": "day = new HMSDuration(24, 0, 0);\n    ninetySeconds = new HMSDuration(0, 0, 90);",
              "prediction": "public class TestDuration {\n  @Test\n  public void testOneDay() {\n    // Arrange\n    day = Duration.oneDay();\n\n    // Act\n    // Assert\n  }\n\n  @Test\n  public void testOneMinute() {\n    // Arrange\n    ninetySeconds = Duration.oneMinute();\n\n    // Act\n    // Assert\n  }\n\n  @Test\n  public void testTwoHours() {\n    // Arrange\n    ninetySeconds = Duration.twoHours();\n\n    // Act\n    // Assert\n  }\n\n  @Test\n  public void testFiveMinutes() {\n    // Arrange\n    ninetySeconds = Duration.fiveMinutes();\n\n    // Act\n    // Assert\n  }\n}\n\n1.1 The test cases\nThe test cases for the duration class are provided as a sample.\n\nThe test cases are designed to exercise the various methods of the\nclass.\n\n1.2 The class itself\nThe class is a simple implementation of the Duration interface.\n\n1.3 The interface\nThe interface is"
            },
            {
              "id": "fim_easy_018",
              "topic": "command",
              "edit_distance": 972,
              "expected_len": 24,
              "pred_len": 992,
              "expected": "heading += angleDegrees;",
              "prediction": "1. A constructor that takes one parameter of type double, representing the\n   heading in degrees.\n2. One method, turn(double), to be implemented by a client of this\n   class. This method should not do anything itself. It should only\n   call a method, turn(double), in the implementation of a\n   TurtleModel subclass.\n3. A field, double _heading, to store the heading, such that the turtle\n   can be initialized with the heading and retrieved from it later.\n4. One implementation of TurtleModel, named SimpleTurtle. This class\n   implements all the methods, but not the constructor. It extends\n   TurtleModel, which means it has the same fields and methods.\n\nYou are free to add other methods to this class as you see fit.\n\n3.1 A good place to start is with a toString() implementation, which\n   should give us some information about the turtle's state:\n\n   @Override\n   public String toString() {\n     return \"Heading: \" + heading + \", position: \" +\n            Integer.toHexString(Math.round"
            },
            {
              "id": "fim_easy_019",
              "topic": "mvc",
              "edit_distance": 875,
              "expected_len": 56,
              "pred_len": 927,
              "expected": "return Long.compare(this.inSeconds(), that.inSeconds());",
              "prediction": "1. A class named HMSDuration that implements the Duration interface.\n2. A single method, named <init>, that takes two arguments, a long and an\n   Integer representing the hours, minutes, and seconds, respectively. The\n   hours and minutes should be non-negative, and the seconds should be\n   between 0 and 59. If any of these conditions is violated, the method\n   should throw an IllegalArgumentException.\n3. One of the fields should be a Readable representation of the duration,\n   in the form of a string. For example:\n\nString d = \"12:34\";\ntry {\n  HMSDuration t = HMSDuration.fromString(d);\n  System.out.println(\"Duration in hours: \" + t.getHours());\n  System.out.println(\"Duration in minutes: \" + t.getMinutes());\n  System.out.println(\"Duration in seconds: \" + t.getSeconds());\n} catch (IllegalArgumentException e) {\n  System.out.println(\"Bad format string: \" + e.getMessage());\n}\n\n4. If the method is implemented correctly,"
            },
            {
              "id": "fim_easy_020",
              "topic": "adapter",
              "edit_distance": 829,
              "expected_len": 53,
              "pred_len": 876,
              "expected": "for (int i : other.asList()) {\n      remove(i);\n    }",
              "prediction": "1. A class with a single field of type IntSet2 that we want to implement.\n2. A constructor that takes no arguments.\n3. One method, addAll(int value). This method should not change the contents of the set.\n4. One final method, isSupersetOf(IntSet2 other). This method should return true if the set is a superset of the\n   set we are implementing.\n\nNote: You may add other methods to the interface as needed.\n\n3.1 A toString() implementation to help with debugging:\n\n/**\n * Returns a string representation of this set.\n */\n@Override\npublic String toString() {\n  return \"IntSet2ToIntSet1Impl{\" +\n         \"membership=\" + membership +\n         '}';\n}\n\n3.2 A constructor that takes no arguments:\n\n/**\n * Creates a new empty IntSet2ToIntSet1Impl object.\n */\npublic IntSet2ToIntSet1Impl() {\n}\n\n3.3 A constructor that takes one argument:\n\n/**\n * Creates an IntSet2ToIntSet1Impl object"
            },
            {
              "id": "fim_hard_001",
              "topic": "adapter",
              "edit_distance": 761,
              "expected_len": 912,
              "pred_len": 925,
              "expected": "// IntSet1 methods - translate element operations to set operations\n  @Override\n  public void add(int value) {\n    adaptee.unionWith(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public void remove(int value) {\n    adaptee.differenceFrom(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public boolean member(int value) {\n    return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return adaptee.asList().iterator();\n  }\n\n  // IntSet2 methods - delegate directly to adaptee\n  @Override\n  public void unionWith(IntSet2 other) {\n    adaptee.unionWith(other);\n  }\n\n  @Override\n  public void differenceFrom(IntSet2 other) {\n    adaptee.differenceFrom(other);\n  }\n\n  @Override\n  public boolean isSupersetOf(IntSet2 other) {\n    return adaptee.isSupersetOf(other);\n  }\n\n  @Override\n  public List<Integer> asList() {\n    return adaptee.asList();\n  }",
              "prediction": "1. A single method, toString() that returns the string representation of the IntSet1 it wraps.\n\n3. A single constructor that takes an argument of type IntSet2, in the form\n\nnew IntSet2ToIntSet1Adapter(IntSet2Impl1).\n\n4. One additional public constructor that takes no arguments, and that throws an\n---\n[Based on the text material above, the code BEFORE the gap is the IntSet1 interface and its implementation, along with a toString() implementation for testing purposes. The code AFTER the gap is blank because it is empty.]\n\n1. A single public constructor that takes an argument of type IntSet2, in the form\n\nnew IntSet2ToIntSet1Adapter(IntSet2Impl1).\n\n2. One additional public constructor that takes no arguments, and that throws an\n\nTask: Complete the missing code in this Java file.\n\nCode BEFORE the gap:\n```java\npackage cs3500.lec09;\n\nimport java.util.Objects;\n\n/**\n * An adapter from {@link IntSet2} to {@link IntSet1}."
            },
            {
              "id": "fim_hard_002",
              "topic": "adapter",
              "edit_distance": 845,
              "expected_len": 353,
              "pred_len": 1065,
              "expected": "@Override\n  public boolean hasNext() {\n    return enumeration.hasMoreElements();\n  }\n\n  @Override\n  public T next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    return enumeration.nextElement();\n  }\n\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException(\"Cannot remove from an Enumeration\");\n  }",
              "prediction": "1. A public constructor that takes one argument, a non-null reference to an Enumeration<T>.\n2. A method to return the enumeration itself, as an object of some other class. In this case, an object of type Iterable<T>, which is a superclass of Enumeration<T>.\n3. A method to implement the Iterator interface. In this case, the implementation of the method is empty, since the enumeration is enumerable, and has no elements.\n4. A method to tell the compiler what to do when an EnumerationIterator is returned as the result of some operation. In this case, the method should throw an IllegalArgumentException, since an EnumerationIterator can never be returned as the result of an operation.\n\n5. A class that extends Enum and overrides the toString() method to provide a more helpful description of its contents.\n\n6. A class that extends Enum and overrides the iterator() method to return this EnumerationIterator object.\n\n7. A class that extends Enum and overrides the iterator() method to return this EnumerationIterator object.\n\n8. A class that extends Enum and over"
            },
            {
              "id": "fim_hard_003",
              "topic": "mvc",
              "edit_distance": 699,
              "expected_len": 810,
              "pred_len": 796,
              "expected": "Objects.requireNonNull(model);\n    append(model.toString() + \"\\n\");\n    append(\"Enter move as row col (1-indexed):\\n\");\n\n    while (!model.isGameOver()) {\n      append(\"Player \" + model.getTurn() + \"'s turn:\\n\");\n      try {\n        int row = scan.nextInt() - 1;\n        int col = scan.nextInt() - 1;\n        model.move(row, col);\n        append(model.toString() + \"\\n\");\n      } catch (InputMismatchException e) {\n        append(\"Invalid input. Enter row and column as integers.\\n\");\n        scan.next(); // consume invalid token\n      } catch (IllegalArgumentException e) {\n        append(\"Invalid move: \" + e.getMessage() + \"\\n\");\n      }\n    }\n\n    if (model.getWinner() != null) {\n      append(\"Game over! Winner: \" + model.getWinner() + \"\\n\");\n    } else {\n      append(\"Game over! It's a tie!\\n\");\n    }",
              "prediction": "1.1 A public class named TicTacToeConsoleController that implements TicTacToeController.\n\n2.1 A class Main that is a public class named TicTacToeConsoleGUIController.\n\n3.1 A class Main that is a public class named TicTacToeGUIController.\n\n4.1 A class Main that is a public class named TicTacToeController.\n\n5.1 A class Main that is a public class named TicTacToeGUIController.\n\n6.1 A class Main that is a public class named TicTacToeConsoleController.\n\n7.1 A class Main that is a public class named TicTacToeController.\n\n8.1 A class Main that is a public class named TicTacToeConsoleController.\n\n9.1 A class Main that is a public class named TicTacToeController.\n\n10.1 A class Main that is a public class named TicTacToeConsoleController.\n\n11.1 A class Main that is a public class named TicTacToe"
            },
            {
              "id": "fim_hard_004",
              "topic": "decorator",
              "edit_distance": 849,
              "expected_len": 470,
              "pred_len": 1061,
              "expected": "@Override\n  public void add(int value) {\n    addCount++;\n    delegate.add(value);\n  }\n\n  @Override\n  public void addAll(Collection<Integer> values) {\n    addCount += values.size();\n    delegate.addAll(values);\n  }\n\n  @Override\n  public void remove(int value) {\n    delegate.remove(value);\n  }\n\n  @Override\n  public boolean member(int value) {\n    return delegate.member(value);\n  }\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return delegate.iterator();\n  }",
              "prediction": "1. A class named MyIntSet that extends IntSet, with a single public constructor that takes no arguments.\n2. A method named instrument that takes no arguments and implements the instrumentedIntSet interface.\n3. A class named TestIntSet that extends IntSetTest and implements IntSetTest1. The test methods for IntSetTest1\n  are OK, but not for IntSetTest. The test method for IntSetTest1 should fail, because the instrumented\n  IntSet should not count add operations.\n\n4. A class named InstrumentedIntSetTest that extends IntSetTest and implements IntSetTest2. The test methods for\n  IntSetTest2 should succeed, because the instrumented IntSet should count add operations.\n\n5. A class named InstrumentedIntSetTest3 that extends IntSetTest and implements IntSetTest3. The test methods for\n  IntSetTest3 should succeed, because the instrumented IntSet should count add operations.\n\n6. A class named InstrumentedIntSetTest4 that extends IntSetTest and implements IntSetTest4. The test methods for\n  IntSetTest4 should fail, because the instrumented IntSet should not"
            },
            {
              "id": "fim_hard_005",
              "topic": "command",
              "edit_distance": 707,
              "expected_len": 394,
              "pred_len": 911,
              "expected": "@Override\n  public void execute() {\n    previousPosition = turtle.getPosition();\n    turtle.move(distance);\n  }\n\n  @Override\n  public void undo() {\n    if (previousPosition == null) {\n      throw new IllegalStateException(\"Cannot undo: command not executed\");\n    }\n    turtle.setPosition(previousPosition);\n  }\n\n  @Override\n  public boolean canUndo() {\n    return previousPosition != null;\n  }",
              "prediction": "1. A single method to implement that will allow us to execute the command\n   by calling the appropriate method on the model.\n2. A constructor that takes two arguments, since we need the model to\n   fill in the other fields.\n3. One field, which is the distance to move the turtle by. This is\n   necessary because we need to be able to move the turtle by this\n   distance before we can execute the command.\n4. One method, to allow us to execute the command.\n\nNote: The TurtleModel interface is the same for both Turtles and\nTurtleGraphics.\n\nProvide ONLY the missing code:\n\npublic MoveCommand(TurtleModel turtle, double distance) {\n    this.turtle = Objects.requireNonNull(turtle);\n    this.distance = distance;\n  }\n\n\n\nA: \n1.1 What is the difference between an expert Java Turtle Turtle Controller and an expert Java Turtle Turtle Model, and how are they related?\n\nThe TurtleTurtleController is an expert Java Turt"
            },
            {
              "id": "fim_hard_006",
              "topic": "strategy",
              "edit_distance": 765,
              "expected_len": 482,
              "pred_len": 973,
              "expected": "// Try corners first\n    for (int[] corner : CORNERS) {\n      if (isEmpty(model, corner[0], corner[1])) {\n        return new Coord(corner[0], corner[1]);\n      }\n    }\n\n    // Try center\n    if (isEmpty(model, CENTER[0], CENTER[1])) {\n      return new Coord(CENTER[0], CENTER[1]);\n    }\n\n    // Try edges\n    for (int[] edge : EDGES) {\n      if (isEmpty(model, edge[0], edge[1])) {\n        return new Coord(edge[0], edge[1]);\n      }\n    }\n\n    // No move available\n    return null;",
              "prediction": "1. A constructor that takes in a model and a function to determine whether a cell is empty (non-null)\n2. A method to determine which corner or edge the player wants to move to\n3. A method to determine whether the move is legal (i.e. The player wants to move to that cell)\n4. A method to determine whether the move is valid (i.e. The move is not in the way of another player's move)\n5. A method to determine whether the game is over (i.e. All players have moved)\n\nYou are free to implement these as you see fit!\n\n6. A constructor that takes in a model and a function to determine whether a cell is empty (non-null)\n7. A method to determine which corner or edge the player wants to move to\n8. A method to determine whether the move is legal (i.e. The player wants to move to that cell)\n9. A method to determine whether the move is valid (i.e. The move is not in the way of another player's move)\n10. A method to determine whether the game is over (i.e. All players have moved"
            },
            {
              "id": "fim_hard_007",
              "topic": "mvc",
              "edit_distance": 782,
              "expected_len": 1020,
              "pred_len": 843,
              "expected": "@Override\n  public void move(int row, int col) {\n    if (gameOver) {\n      throw new IllegalStateException(\"Game is already over\");\n    }\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Position out of bounds\");\n    }\n    if (board[row][col] != null) {\n      throw new IllegalArgumentException(\"Cell already occupied\");\n    }\n\n    board[row][col] = turn;\n\n    if (checkWin(turn)) {\n      winner = turn;\n      gameOver = true;\n    } else if (isBoardFull()) {\n      gameOver = true;\n    } else {\n      turn = (turn == Player.X) ? Player.O : Player.X;\n    }\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public Player getWinner() {\n    return winner;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    return gameOver;\n  }\n\n  @Override\n  public Player getPieceAt(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Position out of bounds\");\n    }\n    return board[row][col];\n  }",
              "prediction": "1. A constructor that takes no arguments\n2. A method to check if the game is over\n3. A method to check if the board is full\n4. A method to get the player for a cell\n5. A method to get the cell value\n6. A method to move a cell\n7. A method to turn the game\n8. A method to turn the board\n9. A method to turn the player\n10. A method to turn the game over\n11. A method to turn the board over\n12. A method to turn the player over\n13. A method to get the turn\n14. A method to get the winner\n15. A method to get the game state\n16. A method to get the board state\n17. A method to get the board\n18. A method to get the player\n19. A method to get the player for a position\n20. A method to get the row\n21. A method to get the column\n22. A method to get the cell value\n23. A method to get the player for a cell\n24. A method to get the player for a position"
            },
            {
              "id": "fim_hard_008",
              "topic": "gui",
              "edit_distance": 797,
              "expected_len": 948,
              "pred_len": 958,
              "expected": "addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        int col = e.getX() / CELL_SIZE;\n        int row = e.getY() / CELL_SIZE;\n        if (row >= 0 && row < 3 && col >= 0 && col < 3) {\n          controller.handleCellClick(row, col);\n          repaint();\n        }\n      }\n    });\n  }\n\n  @Override\n  protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n\n    // Draw grid lines\n    g.setColor(Color.BLACK);\n    for (int i = 1; i < 3; i++) {\n      g.drawLine(i * CELL_SIZE, 0, i * CELL_SIZE, 3 * CELL_SIZE);\n      g.drawLine(0, i * CELL_SIZE, 3 * CELL_SIZE, i * CELL_SIZE);\n    }\n\n    // Draw pieces\n    for (int row = 0; row < 3; row++) {\n      for (int col = 0; col < 3; col++) {\n        Player p = model.getPieceAt(row, col);\n        if (p == Player.X) {\n          drawX(g, row, col);\n        } else if (p == Player.O) {\n          drawO(g, row, col);\n        }\n      }\n    }",
              "prediction": "1. A class for a Tic Tac Toe game, with a model containing the board state,\n   and a controller to allow user interaction and to play the game.\n2. A class for a Tic Tac Toe panel, with a 3x3 grid of cells, and a view\n   that allows users to place marks on the board, and to see the board state\n   and game state.\n3. A class for an Tic Tac Toe model containing the board state, and methods\n   for getting and setting the board state.\n4. A class for an Tic Tac Toe controller containing the view, and methods\n   for playing the game, and controlling the view to allow user interaction.\n5. A class for a Tic Tac Toe view containing the board, and methods for\n   getting and setting the view state, and for drawing the board and game state.\n6. A class for a Tic Tac Toe model containing the board state, and methods\n   for getting and setting the board state.\n7. A class for an Tic Tac Toe controller containing the view, and methods\n   for playing the game, and"
            },
            {
              "id": "fim_hard_009",
              "topic": "observer",
              "edit_distance": 754,
              "expected_len": 775,
              "pred_len": 1028,
              "expected": "public void addObserver(TicTacToeObserver observer) {\n    observers.add(Objects.requireNonNull(observer));\n  }\n\n  public void removeObserver(TicTacToeObserver observer) {\n    observers.remove(observer);\n  }\n\n  private void notifyObservers() {\n    for (TicTacToeObserver obs : observers) {\n      obs.update(this);\n    }\n  }\n\n  @Override\n  public void move(int row, int col) {\n    delegate.move(row, col);\n    notifyObservers();\n  }\n\n  @Override\n  public Player getTurn() {\n    return delegate.getTurn();\n  }\n\n  @Override\n  public Player getWinner() {\n    return delegate.getWinner();\n  }\n\n  @Override\n  public boolean isGameOver() {\n    return delegate.isGameOver();\n  }\n\n  @Override\n  public Player getPieceAt(int row, int col) {\n    return delegate.getPieceAt(row, col);\n  }",
              "prediction": "1.1 A public class named TicTacToeObserver that extends TicTacToeObserverInterface.\n1.2 A public constructor with no parameters.\n\n2.1 A public method named registerObserver that takes a Throwable argument. If that argument is not null, it means that the observer has already been added to the list of observers, in which case the method should throw an IllegalArgumentException. If the argument is null, it means that the observer has not yet been added to the list of observers, in which case the method should be implemented as follows:\n\npublic void observe(TicTacToe m) {\n  if (this.m == null) {\n    throw new IllegalArgumentException(\"This observer has not been added to the list of observers\");\n  }\n  this.m.addObserver(this);\n}\n\n2.2 A public method named notifyObservers. This method should not throw an exception. It means that the method will not throw an exception, but it does not mean that the method is safe to call. If the method throws an exception, it means that the observer has already been added to the list of"
            },
            {
              "id": "fim_hard_010",
              "topic": "command",
              "edit_distance": 718,
              "expected_len": 793,
              "pred_len": 966,
              "expected": "public void executeCommand(TurtleCommand command) {\n    command.execute();\n    undoStack.push(command);\n    redoStack.clear(); // Clear redo stack on new command\n  }\n\n  public boolean canUndo() {\n    return !undoStack.isEmpty();\n  }\n\n  public boolean canRedo() {\n    return !redoStack.isEmpty();\n  }\n\n  public void undo() {\n    if (!canUndo()) {\n      throw new IllegalStateException(\"Nothing to undo\");\n    }\n    TurtleCommand command = undoStack.pop();\n    command.undo();\n    redoStack.push(command);\n  }\n\n  public void redo() {\n    if (!canRedo()) {\n      throw new IllegalStateException(\"Nothing to redo\");\n    }\n    TurtleCommand command = redoStack.pop();\n    command.execute();\n    undoStack.push(command);\n  }\n\n  public void clear() {\n    undoStack.clear();\n    redoStack.clear();\n  }",
              "prediction": "1.1 A public constructor that takes no arguments\n\n2.1 A public constructor that takes one argument, a Readable representing the input stream\n\n3.1 A public method to add a command to the command stack\n\n4.1 A public method to retrieve the top command in the command stack\n\n5.1 A public method to clear the command stack\n\n6.1 A public method to execute the command in the command stack\n\n7.1 A public method to undo the command in the command stack\n\n8.1 A public method to redo the command in the command stack\n\n9.1 A public method to clear the command stack\n\n10.1 A public method to execute the command in the command stack\n\n11.1 A public method to undo the command in the command stack\n\n12.1 A public method to redo the command in the command stack\n\n13.1 A public method to clear the command stack\n\n14.1 A public method to execute the command in the command stack\n\n15.1 A public method to undo the command in the command stack\n\n16.1 A public method to redo the command"
            }
          ]
        }
      },
      "quiz": {
        "model_key": "tinyllama",
        "question_types": {
          "true_false": {
            "n": 30,
            "n_correct": 17,
            "accuracy": 56.666666666666664,
            "questions": [
              {
                "id": "tf_001",
                "topic": "Adapter",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_002",
                "topic": "Adapter",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_003",
                "topic": "Adapter",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_004",
                "topic": "MVC",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_005",
                "topic": "MVC",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_006",
                "topic": "MVC",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_007",
                "topic": "Observer",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_008",
                "topic": "Decorator",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_009",
                "topic": "Decorator",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_010",
                "topic": "Strategy",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_011",
                "topic": "Strategy",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_012",
                "topic": "Command",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_013",
                "topic": "Command",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_014",
                "topic": "Inheritance",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_015",
                "topic": "Inheritance",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_016",
                "topic": "Composition",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_017",
                "topic": "Testing",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_018",
                "topic": "Testing",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_019",
                "topic": "Testing",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_020",
                "topic": "MVC",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_021",
                "topic": "Factory",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_022",
                "topic": "Adapter",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_023",
                "topic": "Decorator",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_024",
                "topic": "GUI",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_025",
                "topic": "GUI",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_026",
                "topic": "MVC",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_027",
                "topic": "Inheritance",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_028",
                "topic": "Strategy",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_029",
                "topic": "Testing",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_030",
                "topic": "Composition",
                "correct": true,
                "score": 1.0
              }
            ]
          },
          "short_answer": {
            "n": 30,
            "n_correct": 0,
            "accuracy": 0.0,
            "questions": [
              {
                "id": "sa_001",
                "topic": "Adapter",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_002",
                "topic": "Adapter",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_003",
                "topic": "Adapter",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_004",
                "topic": "MVC",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_005",
                "topic": "MVC",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_006",
                "topic": "MVC",
                "correct": false,
                "score": 0.25
              },
              {
                "id": "sa_007",
                "topic": "Observer",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_008",
                "topic": "Decorator",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_009",
                "topic": "Decorator",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_010",
                "topic": "Strategy",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_011",
                "topic": "Strategy",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_012",
                "topic": "Command",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_013",
                "topic": "Command",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_014",
                "topic": "Inheritance",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_015",
                "topic": "Inheritance",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_016",
                "topic": "Composition",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_017",
                "topic": "Testing",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_018",
                "topic": "Testing",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_019",
                "topic": "Testing",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_020",
                "topic": "Testing",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_021",
                "topic": "Factory",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_022",
                "topic": "GUI",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_023",
                "topic": "GUI",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_024",
                "topic": "MVC",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_025",
                "topic": "Adapter",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_026",
                "topic": "Inheritance",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_027",
                "topic": "Decorator",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_028",
                "topic": "MVC",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_029",
                "topic": "Strategy",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_030",
                "topic": "Command",
                "correct": false,
                "score": 0.0
              }
            ]
          },
          "fim_easy": {
            "n": 20,
            "n_correct": 0,
            "accuracy": 0.0,
            "questions": [
              {
                "id": "fim_easy_001",
                "topic": "Adapter",
                "correct": false,
                "score": 0.05707196029776673
              },
              {
                "id": "fim_easy_002",
                "topic": "Adapter",
                "correct": false,
                "score": 0.07769784172661875
              },
              {
                "id": "fim_easy_003",
                "topic": "Adapter",
                "correct": false,
                "score": 0.03666997026759167
              },
              {
                "id": "fim_easy_004",
                "topic": "Adapter",
                "correct": false,
                "score": 0.07235421166306699
              },
              {
                "id": "fim_easy_005",
                "topic": "MVC",
                "correct": false,
                "score": 0.12365591397849462
              },
              {
                "id": "fim_easy_006",
                "topic": "MVC",
                "correct": false,
                "score": 0.12222222222222223
              },
              {
                "id": "fim_easy_007",
                "topic": "Testing",
                "correct": false,
                "score": 0.023883696780893082
              },
              {
                "id": "fim_easy_008",
                "topic": "Testing",
                "correct": false,
                "score": 0.07676348547717837
              },
              {
                "id": "fim_easy_009",
                "topic": "Strategy",
                "correct": false,
                "score": 0.06151990349819059
              },
              {
                "id": "fim_easy_010",
                "topic": "Inheritance",
                "correct": false,
                "score": 0.1136950904392765
              },
              {
                "id": "fim_easy_011",
                "topic": "Decorator",
                "correct": false,
                "score": 0.03340292275574108
              },
              {
                "id": "fim_easy_012",
                "topic": "Command",
                "correct": false,
                "score": 0.1386392811296534
              },
              {
                "id": "fim_easy_013",
                "topic": "MVC",
                "correct": false,
                "score": 0.06299212598425197
              },
              {
                "id": "fim_easy_014",
                "topic": "Testing",
                "correct": false,
                "score": 0.03396226415094339
              },
              {
                "id": "fim_easy_015",
                "topic": "Adapter",
                "correct": false,
                "score": 0.050647820965842194
              },
              {
                "id": "fim_easy_016",
                "topic": "MVC",
                "correct": false,
                "score": 0.018164435946462665
              },
              {
                "id": "fim_easy_017",
                "topic": "Testing",
                "correct": false,
                "score": 0.07930607187112759
              },
              {
                "id": "fim_easy_018",
                "topic": "Command",
                "correct": false,
                "score": 0.024193548387096753
              },
              {
                "id": "fim_easy_019",
                "topic": "MVC",
                "correct": false,
                "score": 0.06040992448759441
              },
              {
                "id": "fim_easy_020",
                "topic": "Adapter",
                "correct": false,
                "score": 0.05821917808219179
              }
            ]
          },
          "fim_hard": {
            "n": 10,
            "n_correct": 0,
            "accuracy": 0.0,
            "questions": [
              {
                "id": "fim_hard_001",
                "topic": "Adapter",
                "correct": false,
                "score": 0.17729729729729726
              },
              {
                "id": "fim_hard_002",
                "topic": "Adapter",
                "correct": false,
                "score": 0.20845070422535217
              },
              {
                "id": "fim_hard_003",
                "topic": "MVC",
                "correct": false,
                "score": 0.13882063882063878
              },
              {
                "id": "fim_hard_004",
                "topic": "Decorator",
                "correct": false,
                "score": 0.20169651272384548
              },
              {
                "id": "fim_hard_005",
                "topic": "Command",
                "correct": false,
                "score": 0.2250274423710209
              },
              {
                "id": "fim_hard_006",
                "topic": "Strategy",
                "correct": false,
                "score": 0.21377183967112023
              },
              {
                "id": "fim_hard_007",
                "topic": "MVC",
                "correct": false,
                "score": 0.23287671232876717
              },
              {
                "id": "fim_hard_008",
                "topic": "GUI",
                "correct": false,
                "score": 0.16597077244258873
              },
              {
                "id": "fim_hard_009",
                "topic": "Observer",
                "correct": false,
                "score": 0.2684824902723736
              },
              {
                "id": "fim_hard_010",
                "topic": "Command",
                "correct": false,
                "score": 0.2587991718426501
              }
            ]
          },
          "essay": {
            "n": 10,
            "n_correct": 0,
            "accuracy": 0.0,
            "questions": [
              {
                "id": "essay_001",
                "topic": "Inheritance",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "essay_002",
                "topic": "Adapter",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "essay_003",
                "topic": "MVC",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "essay_004",
                "topic": "Decorator",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "essay_005",
                "topic": "Strategy",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "essay_006",
                "topic": "Command",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "essay_007",
                "topic": "Testing",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "essay_008",
                "topic": "Observer",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "essay_009",
                "topic": "Inheritance",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "essay_010",
                "topic": "Integration",
                "correct": false,
                "score": 0.0
              }
            ]
          }
        },
        "topics": {
          "Adapter": {
            "n": 17,
            "n_correct": 2,
            "accuracy": 11.764705882352942
          },
          "MVC": {
            "n": 18,
            "n_correct": 2,
            "accuracy": 11.11111111111111
          },
          "Observer": {
            "n": 4,
            "n_correct": 1,
            "accuracy": 25.0
          },
          "Decorator": {
            "n": 9,
            "n_correct": 2,
            "accuracy": 22.22222222222222
          },
          "Strategy": {
            "n": 9,
            "n_correct": 1,
            "accuracy": 11.11111111111111
          },
          "Command": {
            "n": 10,
            "n_correct": 1,
            "accuracy": 10.0
          },
          "Inheritance": {
            "n": 9,
            "n_correct": 3,
            "accuracy": 33.333333333333336
          },
          "Composition": {
            "n": 3,
            "n_correct": 2,
            "accuracy": 66.66666666666667
          },
          "Testing": {
            "n": 13,
            "n_correct": 2,
            "accuracy": 15.384615384615385
          },
          "Factory": {
            "n": 2,
            "n_correct": 0,
            "accuracy": 0.0
          },
          "GUI": {
            "n": 5,
            "n_correct": 1,
            "accuracy": 20.0
          },
          "Integration": {
            "n": 1,
            "n_correct": 0,
            "accuracy": 0.0
          }
        }
      }
    },
    "gemma2": {
      "edit_distance": {
        "baseline": {
          "mode": "baseline",
          "N": 30,
          "avg_edit_distance": 222.96666666666667,
          "examples": [
            {
              "id": "fim_easy_001",
              "topic": "adapter",
              "edit_distance": 68,
              "expected_len": 48,
              "pred_len": 87,
              "expected": "adaptee.unionWith(IntSet2Impl.singleton(value));",
              "prediction": "```java\n  }\n\n  @Override\n  public void add(int value) {\n    adaptee.add(value);\n  }\n```"
            },
            {
              "id": "fim_easy_002",
              "topic": "adapter",
              "edit_distance": 48,
              "expected_len": 58,
              "pred_len": 45,
              "expected": "return adaptee.isSupersetOf(IntSet2Impl.singleton(value));",
              "prediction": "```java\n  return adaptee.member(value);\n}\n```"
            },
            {
              "id": "fim_easy_003",
              "topic": "adapter",
              "edit_distance": 25,
              "expected_len": 35,
              "pred_len": 42,
              "expected": "return adaptee.asList().iterator();",
              "prediction": "```java\n  return adaptee.iterator();\n}\n```"
            },
            {
              "id": "fim_easy_004",
              "topic": "adapter",
              "edit_distance": 92,
              "expected_len": 74,
              "pred_len": 130,
              "expected": "throw new UnsupportedOperationException(\"Cannot remove from Enumeration\");",
              "prediction": "```java\n  private final Enumeration<T> enumeration;\n\n  @Override\n  public void remove() {\n    enumeration.removeElement();\n  }\n```"
            },
            {
              "id": "fim_easy_005",
              "topic": "mvc",
              "edit_distance": 181,
              "expected_len": 153,
              "pred_len": 324,
              "expected": "if (in == null || out == null) {\n      throw new IllegalArgumentException(\"Input and output cannot be null\");\n    }\n    this.in = in;\n    this.out = out;",
              "prediction": "```java\n  public TicTacToeConsoleController(Readable in, Appendable out) {\n    if (in == null) {\n      throw new IllegalArgumentException(\"Input stream cannot be null\");\n    }\n    if (out == null) {\n      throw new IllegalArgumentException(\"Output stream cannot be null\");\n    }\n    this.in = in;\n    this.out = out;\n  }\n```"
            },
            {
              "id": "fim_easy_006",
              "topic": "mvc",
              "edit_distance": 107,
              "expected_len": 116,
              "pred_len": 118,
              "expected": "new TicTacToeConsoleController(new InputStreamReader(System.in),\n        System.out).playGame(new TicTacToeModel());",
              "prediction": "```java\n  public static void main(String[] args) {\n    TicTacToe game = new TicTacToe();\n    game.start();\n  }\n```\n```"
            },
            {
              "id": "fim_easy_007",
              "topic": "testing",
              "edit_distance": 40,
              "expected_len": 26,
              "pred_len": 49,
              "expected": "assertTrue(set.member(5));",
              "prediction": "```java\n  assert set.contains(5);\n}\n</Suffix>\n```"
            },
            {
              "id": "fim_easy_008",
              "topic": "testing",
              "edit_distance": 34,
              "expected_len": 91,
              "pred_len": 85,
              "expected": "assertThrows(IllegalArgumentException.class,\n        () -> { new HMSDuration(-1, 0, 0); });",
              "prediction": "```java\n  assertThrows(IllegalArgumentException.class, () -> new Duration(-1));\n}\n```"
            },
            {
              "id": "fim_easy_009",
              "topic": "strategy",
              "edit_distance": 24,
              "expected_len": 55,
              "pred_len": 56,
              "expected": "return available.get(random.nextInt(available.size()));",
              "prediction": "```java\n  return random.nextInt(available.size());\n}\n```"
            },
            {
              "id": "fim_easy_010",
              "topic": "inheritance",
              "edit_distance": 57,
              "expected_len": 107,
              "pred_len": 118,
              "expected": "for (int z : other.asList()) {\n      if (!member(z)) {\n        return false;\n      }\n    }\n    return true;",
              "prediction": "```java\n  for (int element : other) {\n    if (!contains(element)) {\n      return false;\n    }\n  }\n  return true;\n}\n```"
            },
            {
              "id": "fim_easy_011",
              "topic": "decorator",
              "edit_distance": 16,
              "expected_len": 30,
              "pred_len": 46,
              "expected": "return delegate.member(value);",
              "prediction": "```java\n  return delegate.member(value);\n}\n```"
            },
            {
              "id": "fim_easy_012",
              "topic": "command",
              "edit_distance": 501,
              "expected_len": 190,
              "pred_len": 646,
              "expected": "double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n    position = new Position2D(position.getX() + x, position.getY() + y);",
              "prediction": "```java\n  private void move(double distance) {\n    // Calculate the new position\n    double newX = position.getX() + Math.cos(heading * Math.PI / 180) * distance;\n    double newY = position.getY() + Math.sin(heading * Math.PI / 180) * distance;\n    // Update the position\n    position = new Position2D(newX, newY);\n  }\n```\n\n```java\n  private void move(double distance) {\n    // Calculate the new position\n    double newX = position.getX() + Math.cos(heading * Math.PI / 180) * distance;\n    double newY = position.getY() + Math.sin(heading * Math.PI / 180) * distance;\n    // Update the position\n    position = new Position2D(newX, newY);\n  }\n```"
            },
            {
              "id": "fim_easy_013",
              "topic": "mvc",
              "edit_distance": 48,
              "expected_len": 46,
              "pred_len": 94,
              "expected": "board = new Player[3][3];\n    turn = Player.X;",
              "prediction": "```java\n  public TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n```"
            },
            {
              "id": "fim_easy_014",
              "topic": "testing",
              "edit_distance": 30,
              "expected_len": 28,
              "pred_len": 39,
              "expected": "assertFalse(set.member(10));",
              "prediction": "```java\n  assert set.size() == 0;\n}\n```"
            },
            {
              "id": "fim_easy_015",
              "topic": "adapter",
              "edit_distance": 104,
              "expected_len": 50,
              "pred_len": 143,
              "expected": "for (int i : other.asList()) {\n      add(i);\n    }",
              "prediction": "```java\n  }\n  // Add the elements of the other set to this set\n  for (int i = 0; i < other.size(); i++) {\n    this.add(other.get(i));\n  }\n}\n```"
            },
            {
              "id": "fim_easy_016",
              "topic": "mvc",
              "edit_distance": 143,
              "expected_len": 15,
              "pred_len": 157,
              "expected": "return asHms();",
              "prediction": "```java\n  return String.format(\"%02d:%02d:%02d\", hours, minutes, seconds);\n```\n```java\n  return String.format(\"%02d:%02d:%02d\", hours, minutes, seconds);\n```"
            },
            {
              "id": "fim_easy_017",
              "topic": "testing",
              "edit_distance": 73,
              "expected_len": 79,
              "pred_len": 114,
              "expected": "day = new HMSDuration(24, 0, 0);\n    ninetySeconds = new HMSDuration(0, 0, 90);",
              "prediction": "```java\n  private void setup() {\n    day = Duration.ofDays(1);\n    ninetySeconds = Duration.ofSeconds(90);\n  }\n```"
            },
            {
              "id": "fim_easy_018",
              "topic": "command",
              "edit_distance": 80,
              "expected_len": 24,
              "pred_len": 102,
              "expected": "heading += angleDegrees;",
              "prediction": "```java\n  private void turn(double angleDegrees) {\n    heading = angleDegrees * Math.PI / 180;\n  }\n```"
            },
            {
              "id": "fim_easy_019",
              "topic": "mvc",
              "edit_distance": 187,
              "expected_len": 56,
              "pred_len": 229,
              "expected": "return Long.compare(this.inSeconds(), that.inSeconds());",
              "prediction": "```java\n  return this.totalSeconds - that.totalSeconds;\n}\n```\n\n```java\npublic class HMSDuration implements Duration {\n  @Override\n  public int compareTo(Duration that) {\n    return this.totalSeconds - that.totalSeconds;\n  }\n}\n```"
            },
            {
              "id": "fim_easy_020",
              "topic": "adapter",
              "edit_distance": 142,
              "expected_len": 53,
              "pred_len": 192,
              "expected": "for (int i : other.asList()) {\n      remove(i);\n    }",
              "prediction": "```java\n  }\n  // ...\n}\n```\n\n\n**Answer:**\n```java\n  }\n  // ...\n  for (int i = 0; i < other.size(); i++) {\n    if (this.contains(other.get(i))) {\n      this.remove(other.get(i));\n    }\n  }\n}\n```"
            },
            {
              "id": "fim_hard_001",
              "topic": "adapter",
              "edit_distance": 596,
              "expected_len": 912,
              "pred_len": 410,
              "expected": "// IntSet1 methods - translate element operations to set operations\n  @Override\n  public void add(int value) {\n    adaptee.unionWith(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public void remove(int value) {\n    adaptee.differenceFrom(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public boolean member(int value) {\n    return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return adaptee.asList().iterator();\n  }\n\n  // IntSet2 methods - delegate directly to adaptee\n  @Override\n  public void unionWith(IntSet2 other) {\n    adaptee.unionWith(other);\n  }\n\n  @Override\n  public void differenceFrom(IntSet2 other) {\n    adaptee.differenceFrom(other);\n  }\n\n  @Override\n  public boolean isSupersetOf(IntSet2 other) {\n    return adaptee.isSupersetOf(other);\n  }\n\n  @Override\n  public List<Integer> asList() {\n    return adaptee.asList();\n  }",
              "prediction": "```java\n  @Override\n  public boolean contains(int element) {\n    return adaptee.contains(element);\n  }\n\n  @Override\n  public void add(int element) {\n    adaptee.add(element);\n  }\n\n  @Override\n  public void remove(int element) {\n    adaptee.remove(element);\n  }\n\n  @Override\n  public int size() {\n    return adaptee.size();\n  }\n\n  @Override\n  public boolean isEmpty() {\n    return adaptee.isEmpty();\n  }\n```\n```"
            },
            {
              "id": "fim_hard_002",
              "topic": "adapter",
              "edit_distance": 213,
              "expected_len": 353,
              "pred_len": 151,
              "expected": "@Override\n  public boolean hasNext() {\n    return enumeration.hasMoreElements();\n  }\n\n  @Override\n  public T next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    return enumeration.nextElement();\n  }\n\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException(\"Cannot remove from an Enumeration\");\n  }",
              "prediction": "```java\n  public boolean hasNext() {\n    return enumeration.hasMoreElements();\n  }\n\n  public T next() {\n    return enumeration.nextElement();\n  }\n}\n```"
            },
            {
              "id": "fim_hard_003",
              "topic": "mvc",
              "edit_distance": 653,
              "expected_len": 810,
              "pred_len": 240,
              "expected": "Objects.requireNonNull(model);\n    append(model.toString() + \"\\n\");\n    append(\"Enter move as row col (1-indexed):\\n\");\n\n    while (!model.isGameOver()) {\n      append(\"Player \" + model.getTurn() + \"'s turn:\\n\");\n      try {\n        int row = scan.nextInt() - 1;\n        int col = scan.nextInt() - 1;\n        model.move(row, col);\n        append(model.toString() + \"\\n\");\n      } catch (InputMismatchException e) {\n        append(\"Invalid input. Enter row and column as integers.\\n\");\n        scan.next(); // consume invalid token\n      } catch (IllegalArgumentException e) {\n        append(\"Invalid move: \" + e.getMessage() + \"\\n\");\n      }\n    }\n\n    if (model.getWinner() != null) {\n      append(\"Game over! Winner: \" + model.getWinner() + \"\\n\");\n    } else {\n      append(\"Game over! It's a tie!\\n\");\n    }",
              "prediction": "```java\n  @Override\n  public void playGame(TicTacToe model) {\n    while (true) {\n      String move = scan.nextLine();\n      if (move.equals(\"quit\")) {\n        break;\n      }\n      model.makeMove(move);\n      printBoard(model);\n    }\n  }\n```"
            },
            {
              "id": "fim_hard_004",
              "topic": "decorator",
              "edit_distance": 393,
              "expected_len": 470,
              "pred_len": 87,
              "expected": "@Override\n  public void add(int value) {\n    addCount++;\n    delegate.add(value);\n  }\n\n  @Override\n  public void addAll(Collection<Integer> values) {\n    addCount += values.size();\n    delegate.addAll(values);\n  }\n\n  @Override\n  public void remove(int value) {\n    delegate.remove(value);\n  }\n\n  @Override\n  public boolean member(int value) {\n    return delegate.member(value);\n  }\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return delegate.iterator();\n  }",
              "prediction": "```java\n  public void add(int value) {\n    delegate.add(value);\n    addCount++;\n  }\n```"
            },
            {
              "id": "fim_hard_005",
              "topic": "command",
              "edit_distance": 230,
              "expected_len": 394,
              "pred_len": 178,
              "expected": "@Override\n  public void execute() {\n    previousPosition = turtle.getPosition();\n    turtle.move(distance);\n  }\n\n  @Override\n  public void undo() {\n    if (previousPosition == null) {\n      throw new IllegalStateException(\"Cannot undo: command not executed\");\n    }\n    turtle.setPosition(previousPosition);\n  }\n\n  @Override\n  public boolean canUndo() {\n    return previousPosition != null;\n  }",
              "prediction": "```java\n  public void execute() {\n    previousPosition = turtle.getPosition();\n    turtle.move(distance);\n  }\n\n  public void undo() {\n    turtle.moveTo(previousPosition);\n  }\n```"
            },
            {
              "id": "fim_hard_006",
              "topic": "strategy",
              "edit_distance": 197,
              "expected_len": 482,
              "pred_len": 537,
              "expected": "// Try corners first\n    for (int[] corner : CORNERS) {\n      if (isEmpty(model, corner[0], corner[1])) {\n        return new Coord(corner[0], corner[1]);\n      }\n    }\n\n    // Try center\n    if (isEmpty(model, CENTER[0], CENTER[1])) {\n      return new Coord(CENTER[0], CENTER[1]);\n    }\n\n    // Try edges\n    for (int[] edge : EDGES) {\n      if (isEmpty(model, edge[0], edge[1])) {\n        return new Coord(edge[0], edge[1]);\n      }\n    }\n\n    // No move available\n    return null;",
              "prediction": "```java\n  @Override\n  public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n    for (int[] corner : CORNERS) {\n      if (isEmpty(model, corner[0], corner[1])) {\n        return new Coord(corner[0], corner[1]);\n      }\n    }\n    for (int[] edge : EDGES) {\n      if (isEmpty(model, edge[0], edge[1])) {\n        return new Coord(edge[0], edge[1]);\n      }\n    }\n    for (int[] center : CENTER) {\n      if (isEmpty(model, center[0], center[1])) {\n        return new Coord(center[0], center[1]);\n      }\n    }\n    return null;\n  }\n```"
            },
            {
              "id": "fim_hard_007",
              "topic": "mvc",
              "edit_distance": 685,
              "expected_len": 1020,
              "pred_len": 506,
              "expected": "@Override\n  public void move(int row, int col) {\n    if (gameOver) {\n      throw new IllegalStateException(\"Game is already over\");\n    }\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Position out of bounds\");\n    }\n    if (board[row][col] != null) {\n      throw new IllegalArgumentException(\"Cell already occupied\");\n    }\n\n    board[row][col] = turn;\n\n    if (checkWin(turn)) {\n      winner = turn;\n      gameOver = true;\n    } else if (isBoardFull()) {\n      gameOver = true;\n    } else {\n      turn = (turn == Player.X) ? Player.O : Player.X;\n    }\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public Player getWinner() {\n    return winner;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    return gameOver;\n  }\n\n  @Override\n  public Player getPieceAt(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Position out of bounds\");\n    }\n    return board[row][col];\n  }",
              "prediction": "```java\n  public void makeMove(int row, int col) {\n    if (gameOver || !isValidMove(row, col)) {\n      return;\n    }\n    board[row][col] = turn;\n    turn = (turn == Player.X) ? Player.O : Player.X;\n    if (checkWin(turn)) {\n      gameOver = true;\n      winner = turn;\n    }\n  }\n```\n\n```java\n  private boolean isValidMove(int row, int col) {\n    if (row < 0 || row >= 3 || col < 0 || col >= 3) {\n      return false;\n    }\n    if (board[row][col] != null) {\n      return false;\n    }\n    return true;\n  }\n```"
            },
            {
              "id": "fim_hard_008",
              "topic": "gui",
              "edit_distance": 663,
              "expected_len": 948,
              "pred_len": 388,
              "expected": "addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        int col = e.getX() / CELL_SIZE;\n        int row = e.getY() / CELL_SIZE;\n        if (row >= 0 && row < 3 && col >= 0 && col < 3) {\n          controller.handleCellClick(row, col);\n          repaint();\n        }\n      }\n    });\n  }\n\n  @Override\n  protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n\n    // Draw grid lines\n    g.setColor(Color.BLACK);\n    for (int i = 1; i < 3; i++) {\n      g.drawLine(i * CELL_SIZE, 0, i * CELL_SIZE, 3 * CELL_SIZE);\n      g.drawLine(0, i * CELL_SIZE, 3 * CELL_SIZE, i * CELL_SIZE);\n    }\n\n    // Draw pieces\n    for (int row = 0; row < 3; row++) {\n      for (int col = 0; col < 3; col++) {\n        Player p = model.getPieceAt(row, col);\n        if (p == Player.X) {\n          drawX(g, row, col);\n        } else if (p == Player.O) {\n          drawO(g, row, col);\n        }\n      }\n    }",
              "prediction": "```java\n  public void paintComponent(Graphics g) {\n    super.paintComponent(g);\n    for (int i = 0; i < 3; i++) {\n      for (int j = 0; j < 3; j++) {\n        int row = i;\n        int col = j;\n        if (model.getCellValue(row, col) == 1) {\n          drawX(g, row, col);\n        } else if (model.getCellValue(row, col) == 2) {\n          drawO(g, row, col);\n        }\n      }\n    }\n  }\n```"
            },
            {
              "id": "fim_hard_009",
              "topic": "observer",
              "edit_distance": 572,
              "expected_len": 775,
              "pred_len": 230,
              "expected": "public void addObserver(TicTacToeObserver observer) {\n    observers.add(Objects.requireNonNull(observer));\n  }\n\n  public void removeObserver(TicTacToeObserver observer) {\n    observers.remove(observer);\n  }\n\n  private void notifyObservers() {\n    for (TicTacToeObserver obs : observers) {\n      obs.update(this);\n    }\n  }\n\n  @Override\n  public void move(int row, int col) {\n    delegate.move(row, col);\n    notifyObservers();\n  }\n\n  @Override\n  public Player getTurn() {\n    return delegate.getTurn();\n  }\n\n  @Override\n  public Player getWinner() {\n    return delegate.getWinner();\n  }\n\n  @Override\n  public boolean isGameOver() {\n    return delegate.isGameOver();\n  }\n\n  @Override\n  public Player getPieceAt(int row, int col) {\n    return delegate.getPieceAt(row, col);\n  }",
              "prediction": "```java\n  public void registerObserver(TicTacToeObserver observer) {\n    observers.add(observer);\n  }\n\n  public void notifyObservers() {\n    for (TicTacToeObserver observer : observers) {\n      observer.update(this);\n    }\n  }\n```"
            },
            {
              "id": "fim_hard_010",
              "topic": "command",
              "edit_distance": 487,
              "expected_len": 793,
              "pred_len": 716,
              "expected": "public void executeCommand(TurtleCommand command) {\n    command.execute();\n    undoStack.push(command);\n    redoStack.clear(); // Clear redo stack on new command\n  }\n\n  public boolean canUndo() {\n    return !undoStack.isEmpty();\n  }\n\n  public boolean canRedo() {\n    return !redoStack.isEmpty();\n  }\n\n  public void undo() {\n    if (!canUndo()) {\n      throw new IllegalStateException(\"Nothing to undo\");\n    }\n    TurtleCommand command = undoStack.pop();\n    command.undo();\n    redoStack.push(command);\n  }\n\n  public void redo() {\n    if (!canRedo()) {\n      throw new IllegalStateException(\"Nothing to redo\");\n    }\n    TurtleCommand command = redoStack.pop();\n    command.execute();\n    undoStack.push(command);\n  }\n\n  public void clear() {\n    undoStack.clear();\n    redoStack.clear();\n  }",
              "prediction": "```java\npublic class CommandHistory {\n  private final Stack<TurtleCommand> undoStack;\n  private final Stack<TurtleCommand> redoStack;\n\n  public CommandHistory() {\n    undoStack = new Stack<>();\n    redoStack = new Stack<>();\n  }\n\n\n  public void addCommand(TurtleCommand command) {\n    redoStack.clear();\n    undoStack.push(command);\n  }\n\n  public TurtleCommand undo() {\n    if (undoStack.isEmpty()) {\n      return null;\n    }\n    TurtleCommand command = undoStack.pop();\n    redoStack.push(command);\n    return command;\n  }\n\n  public TurtleCommand redo() {\n    if (redoStack.isEmpty()) {\n      return null;\n    }\n    TurtleCommand command = redoStack.pop();\n    undoStack.push(command);\n    return command;\n  }\n}\n```"
            }
          ]
        },
        "rag": {
          "mode": "rag",
          "N": 30,
          "avg_edit_distance": 196.4,
          "examples": [
            {
              "id": "fim_easy_001",
              "topic": "adapter",
              "edit_distance": 68,
              "expected_len": 48,
              "pred_len": 87,
              "expected": "adaptee.unionWith(IntSet2Impl.singleton(value));",
              "prediction": "```java\n  }\n\n  @Override\n  public void add(int value) {\n    adaptee.add(value);\n  }\n```"
            },
            {
              "id": "fim_easy_002",
              "topic": "adapter",
              "edit_distance": 48,
              "expected_len": 58,
              "pred_len": 45,
              "expected": "return adaptee.isSupersetOf(IntSet2Impl.singleton(value));",
              "prediction": "```java\n  return adaptee.member(value);\n}\n```"
            },
            {
              "id": "fim_easy_003",
              "topic": "adapter",
              "edit_distance": 25,
              "expected_len": 35,
              "pred_len": 42,
              "expected": "return adaptee.asList().iterator();",
              "prediction": "```java\n  return adaptee.iterator();\n}\n```"
            },
            {
              "id": "fim_easy_004",
              "topic": "adapter",
              "edit_distance": 74,
              "expected_len": 74,
              "pred_len": 7,
              "expected": "throw new UnsupportedOperationException(\"Cannot remove from Enumeration\");",
              "prediction": "}\n}\n```"
            },
            {
              "id": "fim_easy_005",
              "topic": "mvc",
              "edit_distance": 181,
              "expected_len": 153,
              "pred_len": 324,
              "expected": "if (in == null || out == null) {\n      throw new IllegalArgumentException(\"Input and output cannot be null\");\n    }\n    this.in = in;\n    this.out = out;",
              "prediction": "```java\n  public TicTacToeConsoleController(Readable in, Appendable out) {\n    if (in == null) {\n      throw new IllegalArgumentException(\"Input stream cannot be null\");\n    }\n    if (out == null) {\n      throw new IllegalArgumentException(\"Output stream cannot be null\");\n    }\n    this.in = in;\n    this.out = out;\n  }\n```"
            },
            {
              "id": "fim_easy_006",
              "topic": "mvc",
              "edit_distance": 104,
              "expected_len": 116,
              "pred_len": 118,
              "expected": "new TicTacToeConsoleController(new InputStreamReader(System.in),\n        System.out).playGame(new TicTacToeModel());",
              "prediction": "```java\n  }\n  public static void main(String[] args) {\n    TicTacToe game = new TicTacToe();\n    game.start();\n  }\n```"
            },
            {
              "id": "fim_easy_007",
              "topic": "testing",
              "edit_distance": 26,
              "expected_len": 26,
              "pred_len": 35,
              "expected": "assertTrue(set.member(5));",
              "prediction": "assert set.contains(5);\n}\n</Suffix>"
            },
            {
              "id": "fim_easy_008",
              "topic": "testing",
              "edit_distance": 34,
              "expected_len": 91,
              "pred_len": 85,
              "expected": "assertThrows(IllegalArgumentException.class,\n        () -> { new HMSDuration(-1, 0, 0); });",
              "prediction": "```java\n  assertThrows(IllegalArgumentException.class, () -> new Duration(-1));\n}\n```"
            },
            {
              "id": "fim_easy_009",
              "topic": "strategy",
              "edit_distance": 24,
              "expected_len": 55,
              "pred_len": 56,
              "expected": "return available.get(random.nextInt(available.size()));",
              "prediction": "```java\n  return random.nextInt(available.size());\n}\n```"
            },
            {
              "id": "fim_easy_010",
              "topic": "inheritance",
              "edit_distance": 51,
              "expected_len": 107,
              "pred_len": 112,
              "expected": "for (int z : other.asList()) {\n      if (!member(z)) {\n        return false;\n      }\n    }\n    return true;",
              "prediction": "for (int element : other) {\n    if (!contains(element)) {\n      return false;\n    }\n  }\n  return true;\n</Suffix>"
            },
            {
              "id": "fim_easy_011",
              "topic": "decorator",
              "edit_distance": 16,
              "expected_len": 30,
              "pred_len": 46,
              "expected": "return delegate.member(value);",
              "prediction": "```java\n  return delegate.member(value);\n}\n```"
            },
            {
              "id": "fim_easy_012",
              "topic": "command",
              "edit_distance": 106,
              "expected_len": 190,
              "pred_len": 145,
              "expected": "double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n    position = new Position2D(position.getX() + x, position.getY() + y);",
              "prediction": "```java\n  position.x += Math.cos(Math.toRadians(heading)) * distance;\n  position.y += Math.sin(Math.toRadians(heading)) * distance;\n</Suffix>\n```"
            },
            {
              "id": "fim_easy_013",
              "topic": "mvc",
              "edit_distance": 48,
              "expected_len": 46,
              "pred_len": 94,
              "expected": "board = new Player[3][3];\n    turn = Player.X;",
              "prediction": "```java\n  public TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n```"
            },
            {
              "id": "fim_easy_014",
              "topic": "testing",
              "edit_distance": 40,
              "expected_len": 28,
              "pred_len": 49,
              "expected": "assertFalse(set.member(10));",
              "prediction": "```java\n  assert set.size() == 0;\n}\n</Suffix>\n```"
            },
            {
              "id": "fim_easy_015",
              "topic": "adapter",
              "edit_distance": 58,
              "expected_len": 50,
              "pred_len": 67,
              "expected": "for (int i : other.asList()) {\n      add(i);\n    }",
              "prediction": "```java\n  }\n  // ...\n}\n```\n\n\n**Answer:**\n```java\n  }\n  // ...\n}\n```"
            },
            {
              "id": "fim_easy_016",
              "topic": "mvc",
              "edit_distance": 66,
              "expected_len": 15,
              "pred_len": 79,
              "expected": "return asHms();",
              "prediction": "return String.format(\"%02d:%02d:%02d\", hours, minutes, seconds);\n</Suffix>\n\n```"
            },
            {
              "id": "fim_easy_017",
              "topic": "testing",
              "edit_distance": 49,
              "expected_len": 79,
              "pred_len": 83,
              "expected": "day = new HMSDuration(24, 0, 0);\n    ninetySeconds = new HMSDuration(0, 0, 90);",
              "prediction": "```java\n  day = Duration.ofDays(1);\n  ninetySeconds = Duration.ofSeconds(90);\n}\n```"
            },
            {
              "id": "fim_easy_018",
              "topic": "command",
              "edit_distance": 82,
              "expected_len": 24,
              "pred_len": 104,
              "expected": "heading += angleDegrees;",
              "prediction": "```java\n  private void turn(double angleDegrees) {\n    heading = angleDegrees * Math.PI / 180.0;\n  }\n```"
            },
            {
              "id": "fim_easy_019",
              "topic": "mvc",
              "edit_distance": 39,
              "expected_len": 56,
              "pred_len": 61,
              "expected": "return Long.compare(this.inSeconds(), that.inSeconds());",
              "prediction": "```java\n  return this.totalSeconds - that.totalSeconds;\n}\n```"
            },
            {
              "id": "fim_easy_020",
              "topic": "adapter",
              "edit_distance": 92,
              "expected_len": 53,
              "pred_len": 142,
              "expected": "for (int i : other.asList()) {\n      remove(i);\n    }",
              "prediction": "```java\n  }\n  for (int i = 0; i < other.size(); i++) {\n    if (this.contains(other.get(i))) {\n      this.remove(other.get(i));\n    }\n  }\n}\n```"
            },
            {
              "id": "fim_hard_001",
              "topic": "adapter",
              "edit_distance": 611,
              "expected_len": 912,
              "pred_len": 433,
              "expected": "// IntSet1 methods - translate element operations to set operations\n  @Override\n  public void add(int value) {\n    adaptee.unionWith(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public void remove(int value) {\n    adaptee.differenceFrom(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public boolean member(int value) {\n    return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return adaptee.asList().iterator();\n  }\n\n  // IntSet2 methods - delegate directly to adaptee\n  @Override\n  public void unionWith(IntSet2 other) {\n    adaptee.unionWith(other);\n  }\n\n  @Override\n  public void differenceFrom(IntSet2 other) {\n    adaptee.differenceFrom(other);\n  }\n\n  @Override\n  public boolean isSupersetOf(IntSet2 other) {\n    return adaptee.isSupersetOf(other);\n  }\n\n  @Override\n  public List<Integer> asList() {\n    return adaptee.asList();\n  }",
              "prediction": "```java\n  public Set<Integer> getSet() {\n    return adaptee.getSet();\n  }\n\n  public boolean add(int element) {\n    return adaptee.add(element);\n  }\n\n  public boolean remove(int element) {\n    return adaptee.remove(element);\n  }\n\n  public boolean contains(int element) {\n    return adaptee.contains(element);\n  }\n\n  public int size() {\n    return adaptee.size();\n  }\n\n  public boolean isEmpty() {\n    return adaptee.isEmpty();\n  }\n```"
            },
            {
              "id": "fim_hard_002",
              "topic": "adapter",
              "edit_distance": 203,
              "expected_len": 353,
              "pred_len": 173,
              "expected": "@Override\n  public boolean hasNext() {\n    return enumeration.hasMoreElements();\n  }\n\n  @Override\n  public T next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    return enumeration.nextElement();\n  }\n\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException(\"Cannot remove from an Enumeration\");\n  }",
              "prediction": "```java\n  @Override\n  public boolean hasNext() {\n    return enumeration.hasMoreElements();\n  }\n\n  @Override\n  public T next() {\n    return enumeration.nextElement();\n  }\n```"
            },
            {
              "id": "fim_hard_003",
              "topic": "mvc",
              "edit_distance": 653,
              "expected_len": 810,
              "pred_len": 240,
              "expected": "Objects.requireNonNull(model);\n    append(model.toString() + \"\\n\");\n    append(\"Enter move as row col (1-indexed):\\n\");\n\n    while (!model.isGameOver()) {\n      append(\"Player \" + model.getTurn() + \"'s turn:\\n\");\n      try {\n        int row = scan.nextInt() - 1;\n        int col = scan.nextInt() - 1;\n        model.move(row, col);\n        append(model.toString() + \"\\n\");\n      } catch (InputMismatchException e) {\n        append(\"Invalid input. Enter row and column as integers.\\n\");\n        scan.next(); // consume invalid token\n      } catch (IllegalArgumentException e) {\n        append(\"Invalid move: \" + e.getMessage() + \"\\n\");\n      }\n    }\n\n    if (model.getWinner() != null) {\n      append(\"Game over! Winner: \" + model.getWinner() + \"\\n\");\n    } else {\n      append(\"Game over! It's a tie!\\n\");\n    }",
              "prediction": "```java\n  @Override\n  public void playGame(TicTacToe model) {\n    while (true) {\n      String move = scan.nextLine();\n      if (move.equals(\"quit\")) {\n        break;\n      }\n      model.makeMove(move);\n      printBoard(model);\n    }\n  }\n```"
            },
            {
              "id": "fim_hard_004",
              "topic": "decorator",
              "edit_distance": 393,
              "expected_len": 470,
              "pred_len": 87,
              "expected": "@Override\n  public void add(int value) {\n    addCount++;\n    delegate.add(value);\n  }\n\n  @Override\n  public void addAll(Collection<Integer> values) {\n    addCount += values.size();\n    delegate.addAll(values);\n  }\n\n  @Override\n  public void remove(int value) {\n    delegate.remove(value);\n  }\n\n  @Override\n  public boolean member(int value) {\n    return delegate.member(value);\n  }\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return delegate.iterator();\n  }",
              "prediction": "```java\n  public void add(int value) {\n    delegate.add(value);\n    addCount++;\n  }\n```"
            },
            {
              "id": "fim_hard_005",
              "topic": "command",
              "edit_distance": 202,
              "expected_len": 394,
              "pred_len": 211,
              "expected": "@Override\n  public void execute() {\n    previousPosition = turtle.getPosition();\n    turtle.move(distance);\n  }\n\n  @Override\n  public void undo() {\n    if (previousPosition == null) {\n      throw new IllegalStateException(\"Cannot undo: command not executed\");\n    }\n    turtle.setPosition(previousPosition);\n  }\n\n  @Override\n  public boolean canUndo() {\n    return previousPosition != null;\n  }",
              "prediction": "```java\n  public void execute() {\n    previousPosition = turtle.getPosition();\n    turtle.move(distance);\n  }\n\n  public void undo() {\n    turtle.move(-distance);\n    turtle.setPosition(previousPosition);\n  }\n```"
            },
            {
              "id": "fim_hard_006",
              "topic": "strategy",
              "edit_distance": 197,
              "expected_len": 482,
              "pred_len": 537,
              "expected": "// Try corners first\n    for (int[] corner : CORNERS) {\n      if (isEmpty(model, corner[0], corner[1])) {\n        return new Coord(corner[0], corner[1]);\n      }\n    }\n\n    // Try center\n    if (isEmpty(model, CENTER[0], CENTER[1])) {\n      return new Coord(CENTER[0], CENTER[1]);\n    }\n\n    // Try edges\n    for (int[] edge : EDGES) {\n      if (isEmpty(model, edge[0], edge[1])) {\n        return new Coord(edge[0], edge[1]);\n      }\n    }\n\n    // No move available\n    return null;",
              "prediction": "```java\n  @Override\n  public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n    for (int[] corner : CORNERS) {\n      if (isEmpty(model, corner[0], corner[1])) {\n        return new Coord(corner[0], corner[1]);\n      }\n    }\n    for (int[] edge : EDGES) {\n      if (isEmpty(model, edge[0], edge[1])) {\n        return new Coord(edge[0], edge[1]);\n      }\n    }\n    for (int[] center : CENTER) {\n      if (isEmpty(model, center[0], center[1])) {\n        return new Coord(center[0], center[1]);\n      }\n    }\n    return null;\n  }\n```"
            },
            {
              "id": "fim_hard_007",
              "topic": "mvc",
              "edit_distance": 685,
              "expected_len": 1020,
              "pred_len": 506,
              "expected": "@Override\n  public void move(int row, int col) {\n    if (gameOver) {\n      throw new IllegalStateException(\"Game is already over\");\n    }\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Position out of bounds\");\n    }\n    if (board[row][col] != null) {\n      throw new IllegalArgumentException(\"Cell already occupied\");\n    }\n\n    board[row][col] = turn;\n\n    if (checkWin(turn)) {\n      winner = turn;\n      gameOver = true;\n    } else if (isBoardFull()) {\n      gameOver = true;\n    } else {\n      turn = (turn == Player.X) ? Player.O : Player.X;\n    }\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public Player getWinner() {\n    return winner;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    return gameOver;\n  }\n\n  @Override\n  public Player getPieceAt(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Position out of bounds\");\n    }\n    return board[row][col];\n  }",
              "prediction": "```java\n  public void makeMove(int row, int col) {\n    if (gameOver || !isValidMove(row, col)) {\n      return;\n    }\n    board[row][col] = turn;\n    turn = (turn == Player.X) ? Player.O : Player.X;\n    if (checkWin(turn)) {\n      gameOver = true;\n      winner = turn;\n    }\n  }\n```\n\n```java\n  private boolean isValidMove(int row, int col) {\n    if (row < 0 || row >= 3 || col < 0 || col >= 3) {\n      return false;\n    }\n    if (board[row][col] != null) {\n      return false;\n    }\n    return true;\n  }\n```"
            },
            {
              "id": "fim_hard_008",
              "topic": "gui",
              "edit_distance": 664,
              "expected_len": 948,
              "pred_len": 392,
              "expected": "addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        int col = e.getX() / CELL_SIZE;\n        int row = e.getY() / CELL_SIZE;\n        if (row >= 0 && row < 3 && col >= 0 && col < 3) {\n          controller.handleCellClick(row, col);\n          repaint();\n        }\n      }\n    });\n  }\n\n  @Override\n  protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n\n    // Draw grid lines\n    g.setColor(Color.BLACK);\n    for (int i = 1; i < 3; i++) {\n      g.drawLine(i * CELL_SIZE, 0, i * CELL_SIZE, 3 * CELL_SIZE);\n      g.drawLine(0, i * CELL_SIZE, 3 * CELL_SIZE, i * CELL_SIZE);\n    }\n\n    // Draw pieces\n    for (int row = 0; row < 3; row++) {\n      for (int col = 0; col < 3; col++) {\n        Player p = model.getPieceAt(row, col);\n        if (p == Player.X) {\n          drawX(g, row, col);\n        } else if (p == Player.O) {\n          drawO(g, row, col);\n        }\n      }\n    }",
              "prediction": "```java\n  public void paintComponent(Graphics g) {\n    super.paintComponent(g);\n    for (int i = 0; i < 3; i++) {\n      for (int j = 0; j < 3; j++) {\n        int row = i;\n        int col = j;\n        if (model.getCellValue(row, col) == 'X') {\n          drawX(g, row, col);\n        } else if (model.getCellValue(row, col) == 'O') {\n          drawO(g, row, col);\n        }\n      }\n    }\n  }\n```"
            },
            {
              "id": "fim_hard_009",
              "topic": "observer",
              "edit_distance": 567,
              "expected_len": 775,
              "pred_len": 234,
              "expected": "public void addObserver(TicTacToeObserver observer) {\n    observers.add(Objects.requireNonNull(observer));\n  }\n\n  public void removeObserver(TicTacToeObserver observer) {\n    observers.remove(observer);\n  }\n\n  private void notifyObservers() {\n    for (TicTacToeObserver obs : observers) {\n      obs.update(this);\n    }\n  }\n\n  @Override\n  public void move(int row, int col) {\n    delegate.move(row, col);\n    notifyObservers();\n  }\n\n  @Override\n  public Player getTurn() {\n    return delegate.getTurn();\n  }\n\n  @Override\n  public Player getWinner() {\n    return delegate.getWinner();\n  }\n\n  @Override\n  public boolean isGameOver() {\n    return delegate.isGameOver();\n  }\n\n  @Override\n  public Player getPieceAt(int row, int col) {\n    return delegate.getPieceAt(row, col);\n  }",
              "prediction": "```java\n  public void registerObserver(TicTacToeObserver observer) {\n    observers.add(observer);\n  }\n\n  public void notifyObservers() {\n    for (TicTacToeObserver observer : observers) {\n      observer.update(delegate);\n    }\n  }\n```"
            },
            {
              "id": "fim_hard_010",
              "topic": "command",
              "edit_distance": 486,
              "expected_len": 793,
              "pred_len": 715,
              "expected": "public void executeCommand(TurtleCommand command) {\n    command.execute();\n    undoStack.push(command);\n    redoStack.clear(); // Clear redo stack on new command\n  }\n\n  public boolean canUndo() {\n    return !undoStack.isEmpty();\n  }\n\n  public boolean canRedo() {\n    return !redoStack.isEmpty();\n  }\n\n  public void undo() {\n    if (!canUndo()) {\n      throw new IllegalStateException(\"Nothing to undo\");\n    }\n    TurtleCommand command = undoStack.pop();\n    command.undo();\n    redoStack.push(command);\n  }\n\n  public void redo() {\n    if (!canRedo()) {\n      throw new IllegalStateException(\"Nothing to redo\");\n    }\n    TurtleCommand command = redoStack.pop();\n    command.execute();\n    undoStack.push(command);\n  }\n\n  public void clear() {\n    undoStack.clear();\n    redoStack.clear();\n  }",
              "prediction": "```java\npublic class CommandHistory {\n  private final Stack<TurtleCommand> undoStack;\n  private final Stack<TurtleCommand> redoStack;\n\n  public CommandHistory() {\n    undoStack = new Stack<>();\n    redoStack = new Stack<>();\n  }\n\n  public void addCommand(TurtleCommand command) {\n    undoStack.push(command);\n    redoStack.clear();\n  }\n\n  public TurtleCommand undo() {\n    if (undoStack.isEmpty()) {\n      return null;\n    }\n    TurtleCommand command = undoStack.pop();\n    redoStack.push(command);\n    return command;\n  }\n\n  public TurtleCommand redo() {\n    if (redoStack.isEmpty()) {\n      return null;\n    }\n    TurtleCommand command = redoStack.pop();\n    undoStack.push(command);\n    return command;\n  }\n}\n```"
            }
          ]
        },
        "rag_lora": {
          "mode": "rag_lora",
          "N": 30,
          "avg_edit_distance": 797.6666666666666,
          "examples": [
            {
              "id": "fim_easy_001",
              "topic": "adapter",
              "edit_distance": 1026,
              "expected_len": 48,
              "pred_len": 1070,
              "expected": "adaptee.unionWith(IntSet2Impl.singleton(value));",
              "prediction": "<Target>\npublic void add(int value) {\n    adaptee.add(value);\n  }\n</Target>\n\nThis seems like it should be enough to change one method. However, because this is an adapter, we also need to ensure that the new operations work correctly with the existing client. In particular, we need to ensure that the unionWith method works correctly.\n\nWe can implement unionWith by extending IntSet2 and then implementing the interface as a subclass. Since all operations on IntSet2 also work on IntSet1, we can simply pass the IntSet1 object to the superclass constructor.\n\nclass IntSet2Plus implements IntSet2 {\n  // ... (other fields and methods)\n\n  @Override\n  public void unionWith(IntSet<Integer> other) {\n    // Use the existing implementation of unionWith\n    // from IntSet2\n    other.unionWith(this);\n  }\n</Target>\n\nThis implementation of unionWith is problematic because it will throw an IllegalStateException if the other argument is null. However, it may be possible that the client will pass in a null argument. If so, then we need to handle the null case. We could throw"
            },
            {
              "id": "fim_easy_002",
              "topic": "adapter",
              "edit_distance": 948,
              "expected_len": 58,
              "pred_len": 1000,
              "expected": "return adaptee.isSupersetOf(IntSet2Impl.singleton(value));",
              "prediction": "<CodePrefix>\npublic class IntSet2ToIntSet1Adapter implements IntSet1 {\n  private final IntSet2 adaptee;\n\n  @Override\n  public boolean member(int value) {\n    return adaptee.member(value);\n  }\n</CodePrefix>\n\n<CodeSuffix>\n</Suffix>\n1. How might we implement the IntSet1 interface?\n2. Can we use the existing IntSet2 implementation to satisfy the interface? If so, how?\n3. If not, what other data structure besides IntSet2 might we use? What are the advantages and disadvantages of each?\n4. Consider the following additional operations:\n   a) isEmpty()\n   b) add(int value)\n   c) remove(int value)\n   d) size()\n   How might we implement these operations?\n\nJava source (.zip)\nA zip file containing the starter code for the exercise, along with an answer key (.txt) if applicable.\n1 A public class named TicTacToeConsoleController that implements TicTacToeController, with a single public constructor that takes two arguments, a Readable and an Appendable.\n2 A public class named TicTacToeConsoleView that"
            },
            {
              "id": "fim_easy_003",
              "topic": "adapter",
              "edit_distance": 1079,
              "expected_len": 35,
              "pred_len": 1112,
              "expected": "return adaptee.asList().iterator();",
              "prediction": "<CodePrefix>\npublic class IntSet2ToIntSet1Adapter implements IntSet1 {\n  private final IntSet2 adaptee;\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return new Iterator<Integer>() {\n      int current = 0;\n      @Override\n      public boolean hasNext() {\n        return current < adaptee.size();\n      }\n      @Override\n      public Integer next() {\n        if (!hasNext()) {\n          throw new IllegalArgumentException(\"no such element\");\n        }\n        return adaptee.get(current++);\n      }\n    };\n  }\n</CodeSuffix>\nThis code implements the iterator interface correctly. What additional interface, if any, needs to be implemented by the adapter? And what implementation, if any, are there?\n\nSolution:\nThe additional interface is Iterator.\nThe implementation is a simple interface named `IteratorOverIntSet1Actions` with a single method, `performAction()`, that takes a function argument of type IntSet1Action and returns void.\n\nIf the adapter is given the ability to perform additional operations on the wrapped object, then it needs to expose these operations through this interface. And since"
            },
            {
              "id": "fim_easy_004",
              "topic": "adapter",
              "edit_distance": 1049,
              "expected_len": 74,
              "pred_len": 1116,
              "expected": "throw new UnsupportedOperationException(\"Cannot remove from Enumeration\");",
              "prediction": "<CodePrefix>\npublic void remove() {\n    if (hasElement()) {\n      enumeration.remove();\n    }\n  }\n</CodeSuffix>\n\nThis code checks that the iterator has an element before attempting to remove it. If it does not, then attempting to remove it will result in a IllegalStateException.\n\nIf you were asked to implement this method for a different class, what considerations might you have? Would the considerations change if the class had additional methods?\n<Target>\npublic void remove() {\n    if (isEmpty()) {\n      throw new IllegalArgumentException(\"Cannot remove from an empty list\");\n    }\n    // If the list is non-empty, then we need to remove the last element\n    // because removing the last element is the only operation that\n    // changes the size of the list.\n    list.remove(list.size() - 1);\n  }\n</Target>\n\nIn each case, the comments should be sufficient to explain the reasoning.\n</Target>\n\n2 Testing\nThe purpose of this exercise is to give you practice with implementing the iterator interface and with writing tests for your interface and implementation. We have provided you with some basic JUnit tests."
            },
            {
              "id": "fim_easy_005",
              "topic": "mvc",
              "edit_distance": 700,
              "expected_len": 153,
              "pred_len": 824,
              "expected": "if (in == null || out == null) {\n      throw new IllegalArgumentException(\"Input and output cannot be null\");\n    }\n    this.in = in;\n    this.out = out;",
              "prediction": "<Target>\npublic TicTacToeConsoleController(Readable in, Appendable out) {\n    Objects.requireNonNull(in);\n    Objects.requireNonNull(out);\n    this.in = in;\n    this.out = out;\n  }\n</Target>\n<Fill>\npublic TicTacToeConsoleController(Readable in, Appendable out) {\n    Objects.requireNonNull(in);\n    Objects.requireNonNull(out);\n    this.in = in;\n    this.out = out;\n  }\n</Fill>\n<Target>\npublic TicTacToeConsoleController(Readable in, Appendable out) {\n    Objects.requireNonNull(in);\n    Objects.requireNonNull(out);\n    this.in = in;\n    this.out = out;\n  }\n</Target>\n\n<Fill>\npublic TicTacToeConsoleController(Readable in, Appendable out) {\n    Objects.requireNonNull(in);\n    Objects.requireNonNull(out);\n    this.in = in;\n    this.out = out;\n  }\n</Fill>\n---\n[data\\raw\\notes\\Lecture 9 In-class Exercise A Model.txt::chunk0"
            },
            {
              "id": "fim_easy_006",
              "topic": "mvc",
              "edit_distance": 661,
              "expected_len": 116,
              "pred_len": 758,
              "expected": "new TicTacToeConsoleController(new InputStreamReader(System.in),\n        System.out).playGame(new TicTacToeModel());",
              "prediction": "<Target>\npublic static void main(String[] args) {\n    new TicTacToe(new Scanner(System.in).next()).run();\n  }\n</Target>\n\n<FillIn>\npublic static void main(String[] args) {\n    new TicTacToe(new Scanner(System.in).next()).run();\n  }\n</FillIn>\n</Target>\n\n<FillIn>\npublic static void main(String[] args) {\n    new TicTacToe(new Scanner(System.in).next()).run();\n  }\n</FillIn>\n\n<FillIn>\npublic static void main(String[] args) {\n    new TicTacToe(new Scanner(System.in).next()).run();\n  }\n</FillIn>\n\n<FillIn>\npublic static void main(String[] args) {\n    new TicTacToe(new Scanner(System.in).next()).run();\n  }\n</FillIn>\n\n<FillIn>\npublic static void main(String[] args) {\n    new TicTacToe(new Scanner(System.in).next()).run();\n  }\n</FillIn>\n\n<FillIn>\npublic static"
            },
            {
              "id": "fim_easy_007",
              "topic": "testing",
              "edit_distance": 867,
              "expected_len": 26,
              "pred_len": 890,
              "expected": "assertTrue(set.member(5));",
              "prediction": "public void testAddMakesMember() {\n    assertEquals(true, set.contains(5));\n  }\n</Suffix>\n\nThis is a sample test. You may include additional test cases as appropriate.\n---\n[data\\raw\\notes\\Lecture 5 In-class Exercise A Grap.txt::chunk0008] ass: a public class named TicTacToeModel {\npublic TicTacToeModel() {\n    board = new int[3][3];\n    turn = \"X\";\n  }\n</Target>\n\n<Context>\n[data\\raw\\notes\\Lecture 5 In-class Exercise A Grap.txt::chunk0004] plements a simple implementation of the Tic Tac Toe game as a text-based game.\n\nIn a text-based game of Tic Tac Toe, the board is printed to the console, and players take turns entering their mark (X or O) in an empty cell. The game ends when one player has three in a row, column, or diagonal, or when the board is full.\n\nThe game will start with one player, the first player is X.\n\nThe game will run until one player gets three in a row, column,"
            },
            {
              "id": "fim_easy_008",
              "topic": "testing",
              "edit_distance": 803,
              "expected_len": 91,
              "pred_len": 882,
              "expected": "assertThrows(IllegalArgumentException.class,\n        () -> { new HMSDuration(-1, 0, 0); });",
              "prediction": "<Target>\npublic class DurationTest {\n  @Test\n  public void testNegativeHoursThrows() {\n    try {\n      new Duration(5, 0, -1);\n      fail(\"Expected an IllegalArgumentException\");\n    } catch (IllegalArgumentException iae) {\n      // Expected\n    }\n  }\n</Target>\n<FillIn>\npublic class DurationTest {\n  @Test\n  public void testNegativeHoursThrows() {\n    try {\n      new Duration(5, 0, -1);\n      fail(\"Expected an IllegalArgumentException\");\n    } catch (IllegalArgumentException iae) {\n      // Expected\n    }\n  }\n</FillIn>\n<Target>\npublic class DurationTest {\n  @Test\n  public void testNegativeHoursThrows() {\n    try {\n      new Duration(5, 0, -1);\n      fail(\"Expected an IllegalArgumentException\");\n    } catch (IllegalArgumentException iae) {\n      // Expected\n    }\n  }\n</Target>\n<FillIn>\npublic class DurationTest {\n  @Test\n  public void testNegativeHoursThrows() {\n    try {"
            },
            {
              "id": "fim_easy_009",
              "topic": "strategy",
              "edit_distance": 1000,
              "expected_len": 55,
              "pred_len": 1041,
              "expected": "return available.get(random.nextInt(available.size()));",
              "prediction": "<CodePrefix>\nList<Coord> getEmptyCells(TicTacToeModel model) {\n    for (Row row : model.getRows()) {\n      for (Cell cell : row) {\n        if (cell.isEmpty()) {\n          return Arrays.asList(cell);\n        }\n      }\n    }\n    return Collections.emptyList();\n  }\n</CodeSuffix>\n\nThis code snippet appears to have a logic error. How might we fix it?\n\nIn the current implementation, the `getEmptyCells` method returns the first empty cell it finds. If there are multiple empty cells, it will return only one of them. This could be problematic if the program tries to play the game using this strategy, because it may not get the correct result.\n\nConsider the following game state:\n\nthe board is initialized such that player X goes first\nin the board, the 3rd row has two empty cells\nplayer X plays in the first empty cell of the 3rd row\nplayer O then plays in the second empty cell of the 3rd row\n\nwhich player goes where? What strategy would be needed to ensure that the correct player goes in each case?\n\nA strategy is just some function that"
            },
            {
              "id": "fim_easy_010",
              "topic": "inheritance",
              "edit_distance": 857,
              "expected_len": 107,
              "pred_len": 946,
              "expected": "for (int z : other.asList()) {\n      if (!member(z)) {\n        return false;\n      }\n    }\n    return true;",
              "prediction": "public class IntSet2ToIntSet1Impl extends IntSet1Impl implements IntSet2 {\n  @Override\n  public final boolean isSupersetOf(IntSet2 other) {\n    for (int num : other) {\n      if (!contains(num)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n</Suffix>\n\nThis implementation is not correct. The following test cases are invalid:\n[data\\raw\\notes\\Lecture 17 The Command Design Patte.txt::chunk0008] ass:\n\nIf a set contains the number 5, then it is a superset of any set that also contains 5. We need to include this relationship in our test cases.\n\nOur second test case is overly specific. An implementation of IntSet2 that only contains the element 5 is not very interesting. We should test more general cases.\n\nLet\u2019s implement the remaining tests cases:\n\n/**\n * Tests an instance of IntSet2 to ensure it is a superset of the expected set.\n *\n * @param set the set to test\n * @param expected the expected superset\n */\npublic void testIs"
            },
            {
              "id": "fim_easy_011",
              "topic": "decorator",
              "edit_distance": 807,
              "expected_len": 30,
              "pred_len": 837,
              "expected": "return delegate.member(value);",
              "prediction": "<CodePrefix>\npublic boolean member(int value) {\n    return delegate.member(value);\n  }\n</CodePrefix>\n\n<CodeSuffix>\n</Suffix>\nFill in the missing code between the markers. Use the provided context to infer the missing parts of the method definition. You may also refer to the interface and the other methods in the class as needed.\n</Context>\n\n<FillIn>\npublic boolean member(int value) {\n    return delegate.member(value);\n  }\n</FillIn>\n\n<FillIn>\npublic int size() {\n    return delegate.size();\n  }\n</FillIn>\n\n<FillIn>\npublic void add(int value) {\n    delegate.add(value);\n  }\n</FillIn>\n\n<FillIn>\npublic void remove(int value) {\n    delegate.remove(value);\n  }\n</FillIn>\n\n<FillIn>\npublic int getLowerBound() {\n    return delegate.getLowerBound();\n  }\n</FillIn>\n\n<FillIn>\npublic int getUpperBound() {\n    return delegate.getUpperBound();\n}"
            },
            {
              "id": "fim_easy_012",
              "topic": "command",
              "edit_distance": 721,
              "expected_len": 190,
              "pred_len": 911,
              "expected": "double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n    position = new Position2D(position.getX() + x, position.getY() + y);",
              "prediction": "<Target>\npublic class SimpleTurtle implements TurtleModel {\n  private Position2D position;\n  private double heading;\n\n  @Override\n  public void move(double distance) {\n    //trigonometry to move by distance along angle\n    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n    position = new Position2D(position.getX() + x, position.getY() + y);\n  }\n</Target>\n\n<Target>\npublic void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n</Target>\n\n<Target>\npublic void save() {\n    position = this.getPosition();\n  }\n</Target>\n\n<Target>\npublic void retrieve() {\n    if ((position == null) || (stackPositions.isEmpty())) {\n      throw new IllegalArgumentException(\"no position to retrieve\");\n    }\n    position = stackPositions.pop();\n  }\n</Target>\nWe fill in the missing<Target>\n<Target>\npublic void execute(TracingTurtleModel m) {\n    m"
            },
            {
              "id": "fim_easy_013",
              "topic": "mvc",
              "edit_distance": 1114,
              "expected_len": 46,
              "pred_len": 1160,
              "expected": "board = new Player[3][3];\n    turn = Player.X;",
              "prediction": "<Target>\npublic TicTacToeModel() {\n    board = new Player[3][3];\n    turn = Player.X;\n  }\n</Target>\n\nThis code snippet defines a default constructor for the TicTacToeModel interface. The interface and the associated Player enum are defined in the same lecture as the model.\n\nThe constructor should initialize the model with the board state and the current turn to X. The board should be initialized with three three-element arrays, each representing a row, filled with Player.EMPTY. The current turn should be set to Player.X.\n\nYou may use any method you like to initialize the board, as long as the result is a 2D array of Player objects where EMPTY initially represents an open square.\n</Target>\n\nFill in the missing code in the <Target> tag. You may also define other classes at your option as needed.\n\nYou will need to use the enum interface and the associated static method in the Player class to represent game state.\nYou may also refer to the other classes in the same package for additional help if needed.\n</Target>\n\nYou will likely find it helpful to work through this exercise by first implementing the Player and TicTacToeModel interfaces, and then"
            },
            {
              "id": "fim_easy_014",
              "topic": "testing",
              "edit_distance": 644,
              "expected_len": 28,
              "pred_len": 671,
              "expected": "assertFalse(set.member(10));",
              "prediction": "<Target>\n@Test\npublic void testRemoveRemoves() {\n  IntSet set = new IntSet1Impl();\n  set.add(10);\n  set.remove(10);\n  assertEquals(0, set.size());\n}\n</Target>\n<FillIn>\npublic void testRemoveRemoves() {\n  IntSet set = new IntSet1Impl();\n  set.add(10);\n  set.remove(10);\n  assertEquals(0, set.size());\n}\n</FillIn>\n<Target>\n@Test\npublic void testRemoveRemoves() {\n  IntSet set = new IntSet1Impl();\n  set.add(10);\n  set.remove(10);\n  assertEquals(0, set.size());\n}\n</Target>\n<FillIn>\npublic void testRemoveRemoves() {\n  IntSet set = new IntSet1Impl();\n  set.add(10);\n  set.remove(10);\n  assertEquals(0, set.size());\n}\n</FillIn>\n\n<Target>\n@Test\npublic void testRemoveRemoves()"
            },
            {
              "id": "fim_easy_015",
              "topic": "adapter",
              "edit_distance": 693,
              "expected_len": 50,
              "pred_len": 741,
              "expected": "for (int i : other.asList()) {\n      add(i);\n    }",
              "prediction": "<CodePrefix>\npublic void unionWith(IntSet2 other) {\n    for (int num : other) {\n      this.add(num);\n    }\n</CodeSuffix>\n\n<Target>\npublic class IntSet2ToIntSet1Impl extends IntSet1Impl implements IntSet2 {\n  @Override\n  public final void unionWith(IntSet2 other) {\n    for (int num : other) {\n      this.add(num);\n    }\n  }\n</Target>\n\n<FillIn>\npublic void unionWith(IntSet2 other) {\n    for (int num : other) {\n      this.add(num);\n    }\n  }\n</FillIn>\n\n<Target>\npublic class IntSet2ToIntSet1Impl extends IntSet1Impl implements IntSet2 {\n  @Override\n  public final void unionWith(IntSet2 other) {\n    for (int num : other) {\n      this.add(num);\n    }\n  }\n</Target>\n\n<FillIn>\npublic void unionWith(IntSet2 other) {\n    for (int num : other) {"
            },
            {
              "id": "fim_easy_016",
              "topic": "mvc",
              "edit_distance": 882,
              "expected_len": 15,
              "pred_len": 897,
              "expected": "return asHms();",
              "prediction": "<Target>\npublic class HMSDuration implements Duration {\n  private final int hours, minutes, seconds;\n\n  @Override\n  public String toString() {\n    return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n  }\n</Target>\n<Target>\npublic class HMSDuration implements Duration {\n  private final int hours, minutes, seconds;\n\n  @Override\n  public String toString() {\n    return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n  }\n</Target>\n\n<Target>\npublic class HMSDuration implements Duration {\n  private final int hours, minutes, seconds;\n\n  @Override\n  public String toString() {\n    return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n  }\n</Target>\n\n<Target>\npublic class HMSDuration implements Duration {\n  private final int hours, minutes, seconds;\n\n  @Override\n  public String toString() {\n    return String.format(\"%d:%02d:%02d\", hours, minutes, seconds);\n  }\n</Target>"
            },
            {
              "id": "fim_easy_017",
              "topic": "testing",
              "edit_distance": 724,
              "expected_len": 79,
              "pred_len": 794,
              "expected": "day = new HMSDuration(24, 0, 0);\n    ninetySeconds = new HMSDuration(0, 0, 90);",
              "prediction": "<Target>\npublic void setup() {\n    day = new Duration(24, 0, 0);\n    ninetySeconds = new Duration(90, 0);\n  }\n</Target>\n<Fill>\npublic void setup() {\n    day = new Duration(24, 0, 0);\n    ninetySeconds = new Duration(90, 0);\n  }\n</Fill>\n\n<Target>\npublic void testAdd() {\n    assertEquals(Duration.builder().plus(ninetySeconds).build(),\n        Duration.builder().plus(ninetySeconds).build());\n  }\n</Target>\n<Fill>\npublic void testAdd() {\n    assertEquals(Duration.builder().plus(ninetySeconds).build(),\n        Duration.builder().plus(ninetySeconds).build());\n  }\n</Fill>\n---\n[data\\raw\\notes\\Lecture 3\\Lecture 3 In-class Exercise A Grap.txt::chunk0008] ass: a public constructor that takes two Durations as arguments and returns the sum of the two durations.\npublic class Duration {\n  //package-"
            },
            {
              "id": "fim_easy_018",
              "topic": "command",
              "edit_distance": 757,
              "expected_len": 24,
              "pred_len": 781,
              "expected": "heading += angleDegrees;",
              "prediction": "<Target>\npublic void turn(double angleDegrees) {\n    <Target>\npublic void turn(double angleDegrees) {\n    heading += angleDegrees;\n  }\n</Target>\n\n<Target>\npublic void turn(double angleDegrees) {\n    if (angleDegrees < 0) {\n      heading += 360 + angleDegrees;\n    }\n    if (Math.abs(angleDegrees) > 360) {\n      heading = angleDegrees % 360;\n    }\n    this.heading += angleDegrees;\n  }\n</Target>\nYou may refer to the lecture for additional context.<Target>\npublic void turn(double angleDegrees) {\n    if (angleDegrees < 0) {\n      angleDegrees += 360;\n    }\n    this.heading += angleDegrees;\n  }\n</Target>\n\n<Target>\npublic void turn(double angleDegrees) {\n    if (angleDegrees < 0) {\n      angleDegrees += 360;\n    }\n    this.heading += angleDegrees;\n  }\n</Target>\n\n1. How might we"
            },
            {
              "id": "fim_easy_019",
              "topic": "mvc",
              "edit_distance": 1081,
              "expected_len": 56,
              "pred_len": 1130,
              "expected": "return Long.compare(this.inSeconds(), that.inSeconds());",
              "prediction": "public class HMSDuration implements Duration {\n  @Override\n  public int compareTo(Duration that) {\n    long thisSeconds = totalSeconds();\n    long thatSeconds = that.totalSeconds();\n    if (thisSeconds < thatSeconds) {\n      return -1;\n    } else if (thisSeconds > thatSeconds) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n}\n</Suffix>\n\nThis implementation of compareTo is sufficient for our purposes, as all expected Durations will be within 59 minutes of the current implementation. However, if we were to use this class in a more general context, we would need to be more careful. For example, if we allowed Durations to be negative, then we would need to compare the magnitudes of the durations instead of comparing the total seconds.\n\nAdditionally, having a static method on the Duration class is problematic because it is unclear whether it is intended to compare durations of the same type or some other duration. We can fix this by moving the comparison code into the compareTo method of the Duration interface itself.\n\nFinally, we need to decide whether to override Object.toString() or not. If we override it,"
            },
            {
              "id": "fim_easy_020",
              "topic": "adapter",
              "edit_distance": 768,
              "expected_len": 53,
              "pred_len": 818,
              "expected": "for (int i : other.asList()) {\n      remove(i);\n    }",
              "prediction": "<CodePrefix>\npublic class IntSet2ToIntSet1Impl extends IntSet1Impl implements IntSet2 {\n  @Override\n  public final void differenceFrom(IntSet2 other) {\n    for (int num : other) {\n      remove(num);\n    }\n  }\n</CodeSuffix>\n\n<FillIn>\npublic class IntSet2ToIntSet1Impl extends IntSet1Impl implements IntSet2 {\n@Override\npublic final void differenceFrom(IntSet2 other) {\n    for (int num : other) {\n      remove(num);\n    }\n  }\n</FillIn>\n<Target>\npublic class IntSet2ToIntSet1Impl extends IntSet1Impl implements IntSet2 {\n@Override\npublic final void differenceFrom(IntSet2 other) {\n    for (int num : other) {\n      remove(num);\n    }\n  }\n</Target>\n\n<FillIn>\npublic class IntSet2ToIntSet1Impl extends IntSet1Impl implements IntSet2 {\n@Override\npublic final void differenceFrom(IntSet2 other) {\n    for (int num : other) {"
            },
            {
              "id": "fim_hard_001",
              "topic": "adapter",
              "edit_distance": 634,
              "expected_len": 912,
              "pred_len": 768,
              "expected": "// IntSet1 methods - translate element operations to set operations\n  @Override\n  public void add(int value) {\n    adaptee.unionWith(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public void remove(int value) {\n    adaptee.differenceFrom(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public boolean member(int value) {\n    return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return adaptee.asList().iterator();\n  }\n\n  // IntSet2 methods - delegate directly to adaptee\n  @Override\n  public void unionWith(IntSet2 other) {\n    adaptee.unionWith(other);\n  }\n\n  @Override\n  public void differenceFrom(IntSet2 other) {\n    adaptee.differenceFrom(other);\n  }\n\n  @Override\n  public boolean isSupersetOf(IntSet2 other) {\n    return adaptee.isSupersetOf(other);\n  }\n\n  @Override\n  public List<Integer> asList() {\n    return adaptee.asList();\n  }",
              "prediction": "<Target>\npublic int size() {\n    return adaptee.size();\n  }\n</Target>\n<Target>\npublic boolean isEmpty() {\n    return adaptee.isEmpty();\n  }\n</Target>\n<Target>\npublic void add(int element) {\n    adaptee.add(element);\n  }\n</Target>\n<Target>\npublic void remove(int element) {\n    adaptee.remove(element);\n  }\n</Target>\n<Target>\npublic Set<Integer> stream() {\n    return new HashSet<>(adaptee.stream());\n  }\n</Target>\npublic int hashCode() {\n    return adaptee.hashCode();\n  }\n</Target>\npublic boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (!(o instanceof IntSet2ToIntSet1Adapter)) {\n      return false;\n    }\n    IntSet2ToIntSet1Adapter that = (IntSet2ToIntSet1Adapter) o;\n    return adaptee.equals(that.adaptee);\n  }\n</Target>\n</Target>"
            },
            {
              "id": "fim_hard_002",
              "topic": "adapter",
              "edit_distance": 919,
              "expected_len": 353,
              "pred_len": 1157,
              "expected": "@Override\n  public boolean hasNext() {\n    return enumeration.hasMoreElements();\n  }\n\n  @Override\n  public T next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    return enumeration.nextElement();\n  }\n\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException(\"Cannot remove from an Enumeration\");\n  }",
              "prediction": "public Iterator<T> iterator() {\n    return new EnumerationIterator<T>(this);\n}\n</Suffix>\n\nThis adapter class will return an iterator that implements the same interface as the enumeration it was adapted from, in this case, Iterator<T>. Because the enumeration interface has only one method, <Target>\npublic Iterator<Target> iterator() {\n    return new LambdaIterator<Target>(this::next);\n}\n</Target>\n\nThis adapter class will return an iterator that implements the same interface as the enumeration it was adapted from, in this case, Iterator<Target>. Because the enumeration interface has only one method, <Target>\npublic Enumeration<Target> wrap() {\n    return new Enumeration<Target>() {\n      int currentIndex = 0;\n      @Override\n      public boolean hasMoreElements() {\n        return currentIndex < size();\n      }\n\n      @Override\n      public Target next() {\n        if (!hasMoreElements()) {\n          throw new IllegalArgumentException(\"no such element\");\n        }\n        return values[currentIndex++];\n      }\n    };\n  }\n</Target>\n\nThis adapter class will return an enumeration that implements all the same operations as the original enumeration"
            },
            {
              "id": "fim_hard_003",
              "topic": "mvc",
              "edit_distance": 652,
              "expected_len": 810,
              "pred_len": 831,
              "expected": "Objects.requireNonNull(model);\n    append(model.toString() + \"\\n\");\n    append(\"Enter move as row col (1-indexed):\\n\");\n\n    while (!model.isGameOver()) {\n      append(\"Player \" + model.getTurn() + \"'s turn:\\n\");\n      try {\n        int row = scan.nextInt() - 1;\n        int col = scan.nextInt() - 1;\n        model.move(row, col);\n        append(model.toString() + \"\\n\");\n      } catch (InputMismatchException e) {\n        append(\"Invalid input. Enter row and column as integers.\\n\");\n        scan.next(); // consume invalid token\n      } catch (IllegalArgumentException e) {\n        append(\"Invalid move: \" + e.getMessage() + \"\\n\");\n      }\n    }\n\n    if (model.getWinner() != null) {\n      append(\"Game over! Winner: \" + model.getWinner() + \"\\n\");\n    } else {\n      append(\"Game over! It's a tie!\\n\");\n    }",
              "prediction": "<Target>\npublic void playGame(TicTacToe model) {\n    while (!model.isGameOver()) {\n      printBoard(model);\n      printPrompt();\n      readMove(model);\n    }\n    printBoard(model);\n    printPrompt();\n    printGameOver(model);\n  }\n</Target>\n\n<FillIn>\n<Target>\npublic void playGame(TicTacToe model) {\n    while (!model.isGameOver()) {\n      printBoard(model);\n      printPrompt();\n      readMove(model);\n    }\n    printBoard(model);\n    printPrompt();\n    printGameOver(model);\n  }\n</Target>\n\n<FillIn>\npublic void readMove(TicTacToe model) {\n    String[] tokens = scan.next().split(\" \");\n    int row, col;\n    try {\n      row = Integer.parseInt(tokens[0]);\n      col = Integer.parseInt(tokens[1]);\n    } catch (NumberFormatException ex) {\n      printInvalidMove();\n      readMove(model);\n      return;\n    }\n    model.move(row, col);"
            },
            {
              "id": "fim_hard_004",
              "topic": "decorator",
              "edit_distance": 719,
              "expected_len": 470,
              "pred_len": 959,
              "expected": "@Override\n  public void add(int value) {\n    addCount++;\n    delegate.add(value);\n  }\n\n  @Override\n  public void addAll(Collection<Integer> values) {\n    addCount += values.size();\n    delegate.addAll(values);\n  }\n\n  @Override\n  public void remove(int value) {\n    delegate.remove(value);\n  }\n\n  @Override\n  public boolean member(int value) {\n    return delegate.member(value);\n  }\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return delegate.iterator();\n  }",
              "prediction": "<CodePrefix>\n@Override\npublic void add(int num) {\n    delegate.add(num);\n    addCount++;\n}\n</CodePrefix>\n\n<CodeSuffix>\n</CodeSuffix>\nThis implementation is not valid because adding the same element multiple times should not change the result. In other words, the operation should be associative. We need to be able to say that (A + B) + C = A + (B + C). To ensure this, we need to keep track of the sum of all the elements we have added.\n\nAlso, we need a way to retrieve the sum.\n\nWe can use a single interface and then implement it by composing two existing interfaces: IntSet and Integers. This is known as interface composition.\n\ninterface Addable extends IntSet {\n  int getSum();\n}\n\nclass Integers implements Addable {\n  private final List<Integer> numbers;\n  public Integers() {\n    numbers = new ArrayList<>();\n  }\n  public void add(int num) {\n    numbers.add(num);\n  }\n  public int getSum() {\n    return numbers.stream().mapToInt(Integer::intValue).sum"
            },
            {
              "id": "fim_hard_005",
              "topic": "command",
              "edit_distance": 708,
              "expected_len": 394,
              "pred_len": 944,
              "expected": "@Override\n  public void execute() {\n    previousPosition = turtle.getPosition();\n    turtle.move(distance);\n  }\n\n  @Override\n  public void undo() {\n    if (previousPosition == null) {\n      throw new IllegalStateException(\"Cannot undo: command not executed\");\n    }\n    turtle.setPosition(previousPosition);\n  }\n\n  @Override\n  public boolean canUndo() {\n    return previousPosition != null;\n  }",
              "prediction": "<Context>\n<Target>\npublic void execute(Position2D start) {\n    this.previousPosition = start;\n  }\n</Target>\n\n<FillIn>\npublic void execute(Position2D start) {\n    this.previousPosition = start;\n  }\n</FillIn>\n\n<Target>\npublic Position2D getPosition() {\n    return this.previousPosition;\n  }\n</Target>\n\n<FillIn>\npublic Position2D getPosition() {\n    return this.previousPosition;\n  }\n</FillIn>\n\n<Target>\n@Override\npublic String toString() {\n    return String.format(\"Move %f\", this.distance);\n}\n</Target>\n\n<FillIn>\n@Override\npublic String toString() {\n    return String.format(\"Move %f\", this.distance);\n}\n</Target>\n\nThis code defines a simple interface and a class that implements it, both named TurtleCommand. The interface has only one method, execute, which takes a Position2D argument and throws a checked exception, IOException. The class definition contains a single public constructor that takes two arguments, a Readable and an Appendable"
            },
            {
              "id": "fim_hard_006",
              "topic": "strategy",
              "edit_distance": 447,
              "expected_len": 482,
              "pred_len": 825,
              "expected": "// Try corners first\n    for (int[] corner : CORNERS) {\n      if (isEmpty(model, corner[0], corner[1])) {\n        return new Coord(corner[0], corner[1]);\n      }\n    }\n\n    // Try center\n    if (isEmpty(model, CENTER[0], CENTER[1])) {\n      return new Coord(CENTER[0], CENTER[1]);\n    }\n\n    // Try edges\n    for (int[] edge : EDGES) {\n      if (isEmpty(model, edge[0], edge[1])) {\n        return new Coord(edge[0], edge[1]);\n      }\n    }\n\n    // No move available\n    return null;",
              "prediction": "<CodePrefix>\npublic Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n    for (int[] corner : CORNERS) {\n      if (isEmpty(model, corner[0], corner[1]) && forWhom == model.getPieceAt(corner[0], corner[1])) {\n        return new Coord(corner[0], corner[1]);\n      }\n    }\n    for (int[] edge : EDGES) {\n      if (isEmpty(model, edge[0], edge[1]) && forWhom == model.getPieceAt(edge[0], edge[1])) {\n        return new Coord(edge[0], edge[1]);\n      }\n    }\n    for (int[] center : CENTER) {\n      if (isEmpty(model, center[0], center[1]) && forWhom == model.getPieceAt(center[0], center[1])) {\n        return new Coord(center[0], center[1]);\n      }\n    }\n    return null;\n  }\n</CodeSuffix>\n\nThis code implements the CornerStrategy interface as a simple strategy. How might you change this interface and the implementation"
            },
            {
              "id": "fim_hard_007",
              "topic": "mvc",
              "edit_distance": 718,
              "expected_len": 1020,
              "pred_len": 1018,
              "expected": "@Override\n  public void move(int row, int col) {\n    if (gameOver) {\n      throw new IllegalStateException(\"Game is already over\");\n    }\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Position out of bounds\");\n    }\n    if (board[row][col] != null) {\n      throw new IllegalArgumentException(\"Cell already occupied\");\n    }\n\n    board[row][col] = turn;\n\n    if (checkWin(turn)) {\n      winner = turn;\n      gameOver = true;\n    } else if (isBoardFull()) {\n      gameOver = true;\n    } else {\n      turn = (turn == Player.X) ? Player.O : Player.X;\n    }\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public Player getWinner() {\n    return winner;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    return gameOver;\n  }\n\n  @Override\n  public Player getPieceAt(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Position out of bounds\");\n    }\n    return board[row][col];\n  }",
              "prediction": "<Target>\npublic void move(int row, int col) {\n    if (gameOver || turn == null) {\n      throw new IllegalStateException(\"Game is over or it's not X's turn\");\n    }\n    if (!isSafeMove(row, col)) {\n      throw new IllegalArgumentException(\"Invalid move\");\n    }\n    board[row][col] = turn;\n    turn = turn == Player.X ? Player.O : Player.X;\n  }\n</Target>\n\nThis code implements a single move method for the TicTacToe model. The method takes two arguments, r and c, representing the row and column of the intended move position. It first checks if the game is over or if it\u2019s the wrong turn using the isGameOver and isTurn methods respectively. If so, it throws an IllegalStateException. Otherwise, it calls isSafeMove to check if the move position is valid. If it is, then it places an X or O mark in the correct position and switches turns.\n\nThe isSafeMove method implements the appropriate strategy for this particular game. In a TicTacToe game, a valid move is defined as one that does not result in an X or O already"
            },
            {
              "id": "fim_hard_008",
              "topic": "gui",
              "edit_distance": 694,
              "expected_len": 948,
              "pred_len": 766,
              "expected": "addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        int col = e.getX() / CELL_SIZE;\n        int row = e.getY() / CELL_SIZE;\n        if (row >= 0 && row < 3 && col >= 0 && col < 3) {\n          controller.handleCellClick(row, col);\n          repaint();\n        }\n      }\n    });\n  }\n\n  @Override\n  protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n\n    // Draw grid lines\n    g.setColor(Color.BLACK);\n    for (int i = 1; i < 3; i++) {\n      g.drawLine(i * CELL_SIZE, 0, i * CELL_SIZE, 3 * CELL_SIZE);\n      g.drawLine(0, i * CELL_SIZE, 3 * CELL_SIZE, i * CELL_SIZE);\n    }\n\n    // Draw pieces\n    for (int row = 0; row < 3; row++) {\n      for (int col = 0; col < 3; col++) {\n        Player p = model.getPieceAt(row, col);\n        if (p == Player.X) {\n          drawX(g, row, col);\n        } else if (p == Player.O) {\n          drawO(g, row, col);\n        }\n      }\n    }",
              "prediction": "<Target>\npublic void paintComponent(Graphics g) {\n    super.paintComponent(g);\n    int row, col;\n    for (row = 0; row < 3; row++) {\n      for (col = 0; col < 3; col++) {\n        if (model.isCellEmpty(row, col)) {\n          drawEmptyCell(g, row, col);\n        } else if (model.isCellMark(row, col)) {\n          drawMark(g, row, col);\n        }\n      }\n    }\n  }\n</Target>\nIn each cell position (row, col), draw the corresponding mark (X or O) using the appropriate method (drawX or drawO). The game state is managed by the model.\n\nYou may define helper methods at your option as needed.\n</Target>\n\n<Fill>\npublic void paintComponent(Graphics g) {\n    super.paintComponent(g);\n    int row, col;\n    for (row = 0; row < 3; row++) {\n      for (col = 0; col < 3; col++) {"
            },
            {
              "id": "fim_hard_009",
              "topic": "observer",
              "edit_distance": 681,
              "expected_len": 775,
              "pred_len": 1075,
              "expected": "public void addObserver(TicTacToeObserver observer) {\n    observers.add(Objects.requireNonNull(observer));\n  }\n\n  public void removeObserver(TicTacToeObserver observer) {\n    observers.remove(observer);\n  }\n\n  private void notifyObservers() {\n    for (TicTacToeObserver obs : observers) {\n      obs.update(this);\n    }\n  }\n\n  @Override\n  public void move(int row, int col) {\n    delegate.move(row, col);\n    notifyObservers();\n  }\n\n  @Override\n  public Player getTurn() {\n    return delegate.getTurn();\n  }\n\n  @Override\n  public Player getWinner() {\n    return delegate.getWinner();\n  }\n\n  @Override\n  public boolean isGameOver() {\n    return delegate.isGameOver();\n  }\n\n  @Override\n  public Player getPieceAt(int row, int col) {\n    return delegate.getPieceAt(row, col);\n  }",
              "prediction": "<Target>\npublic void register(TicTacToeObserver observer) {\n    observers.add(observer);\n  }\npublic void unregister(TicTacToeObserver observer) {\n    observers.remove(observer);\n  }\npublic void notifyObservers(TicTacToeEvent event) {\n    for (TicTacToeObserver observer : observers) {\n      observer.update(event);\n    }\n  }\n</Target>\nLet a single observer register with the controller. How would the controller notify that observer of the game state changes? What class could serve as the observer, and what methods would it need to implement?\n\nIf a user inputs some text into the controller, how would the controller validate that text? What strategy could be used for validation, and how would the controller implement it?\n\nA controller typically has access to a model. How might the model information be passed to the controller, and what methods might the controller need to call on the model to retrieve the information it needs?\n</Target>\n\n<Context>\n[data\\raw\\notes\\Lecture 10 The Command Design Patte.txt::chunk0008] Lecture 10: The Command Design Patte\n---\n[data\\raw"
            },
            {
              "id": "fim_hard_010",
              "topic": "command",
              "edit_distance": 577,
              "expected_len": 793,
              "pred_len": 756,
              "expected": "public void executeCommand(TurtleCommand command) {\n    command.execute();\n    undoStack.push(command);\n    redoStack.clear(); // Clear redo stack on new command\n  }\n\n  public boolean canUndo() {\n    return !undoStack.isEmpty();\n  }\n\n  public boolean canRedo() {\n    return !redoStack.isEmpty();\n  }\n\n  public void undo() {\n    if (!canUndo()) {\n      throw new IllegalStateException(\"Nothing to undo\");\n    }\n    TurtleCommand command = undoStack.pop();\n    command.undo();\n    redoStack.push(command);\n  }\n\n  public void redo() {\n    if (!canRedo()) {\n      throw new IllegalStateException(\"Nothing to redo\");\n    }\n    TurtleCommand command = redoStack.pop();\n    command.execute();\n    undoStack.push(command);\n  }\n\n  public void clear() {\n    undoStack.clear();\n    redoStack.clear();\n  }",
              "prediction": "<CodePrefix>\npublic void add(TurtleCommand cmd) {\n    <Target>\n    <Target>\n    <Target>\n    <Target>\n    <Target>\n    <Target>\n    <Target>\n    <Target>\n    <Target>\n    <Target>\n    <Target>\n    <Target>\n    <Target>\n    <Target>\n    <Target>\n    <Target>\n    public void add(TurtleCommand cmd) {\n        this.undoStack.push(cmd);\n        this.redoStack.push(null);\n    }\n</Target>\n</Target>\n\n<Target>\npublic void undo() {\n    if ((this.undoStack.isEmpty()) || (this.redoStack.isEmpty())) {\n      return;\n    }\n    TurtleCommand lastCmd = this.undoStack.pop();\n    this.redoStack.push(lastCmd);\n  }\n</Target>\n\n<Target>\npublic void redo() {\n    if ((this.redoStack.isEmpty())) {\n      return;\n    }\n    TurtleCommand topCmd = this.redoStack.pop();\n    top"
            }
          ]
        }
      },
      "quiz": {
        "model_key": "gemma2",
        "question_types": {
          "true_false": {
            "n": 30,
            "n_correct": 18,
            "accuracy": 60.0,
            "questions": [
              {
                "id": "tf_001",
                "topic": "Adapter",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_002",
                "topic": "Adapter",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_003",
                "topic": "Adapter",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_004",
                "topic": "MVC",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_005",
                "topic": "MVC",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_006",
                "topic": "MVC",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_007",
                "topic": "Observer",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_008",
                "topic": "Decorator",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_009",
                "topic": "Decorator",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_010",
                "topic": "Strategy",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_011",
                "topic": "Strategy",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_012",
                "topic": "Command",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_013",
                "topic": "Command",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_014",
                "topic": "Inheritance",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_015",
                "topic": "Inheritance",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_016",
                "topic": "Composition",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_017",
                "topic": "Testing",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_018",
                "topic": "Testing",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_019",
                "topic": "Testing",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_020",
                "topic": "MVC",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_021",
                "topic": "Factory",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_022",
                "topic": "Adapter",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_023",
                "topic": "Decorator",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_024",
                "topic": "GUI",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_025",
                "topic": "GUI",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_026",
                "topic": "MVC",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_027",
                "topic": "Inheritance",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_028",
                "topic": "Strategy",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "tf_029",
                "topic": "Testing",
                "correct": true,
                "score": 1.0
              },
              {
                "id": "tf_030",
                "topic": "Composition",
                "correct": true,
                "score": 1.0
              }
            ]
          },
          "short_answer": {
            "n": 30,
            "n_correct": 1,
            "accuracy": 3.3333333333333335,
            "questions": [
              {
                "id": "sa_001",
                "topic": "Adapter",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_002",
                "topic": "Adapter",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_003",
                "topic": "Adapter",
                "correct": false,
                "score": 0.25
              },
              {
                "id": "sa_004",
                "topic": "MVC",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_005",
                "topic": "MVC",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_006",
                "topic": "MVC",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_007",
                "topic": "Observer",
                "correct": false,
                "score": 0.25
              },
              {
                "id": "sa_008",
                "topic": "Decorator",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_009",
                "topic": "Decorator",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_010",
                "topic": "Strategy",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_011",
                "topic": "Strategy",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_012",
                "topic": "Command",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_013",
                "topic": "Command",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_014",
                "topic": "Inheritance",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_015",
                "topic": "Inheritance",
                "correct": false,
                "score": 0.25
              },
              {
                "id": "sa_016",
                "topic": "Composition",
                "correct": false,
                "score": 0.25
              },
              {
                "id": "sa_017",
                "topic": "Testing",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_018",
                "topic": "Testing",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_019",
                "topic": "Testing",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_020",
                "topic": "Testing",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_021",
                "topic": "Factory",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_022",
                "topic": "GUI",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_023",
                "topic": "GUI",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_024",
                "topic": "MVC",
                "correct": false,
                "score": 0.25
              },
              {
                "id": "sa_025",
                "topic": "Adapter",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_026",
                "topic": "Inheritance",
                "correct": true,
                "score": 0.5
              },
              {
                "id": "sa_027",
                "topic": "Decorator",
                "correct": false,
                "score": 0.25
              },
              {
                "id": "sa_028",
                "topic": "MVC",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "sa_029",
                "topic": "Strategy",
                "correct": false,
                "score": 0.25
              },
              {
                "id": "sa_030",
                "topic": "Command",
                "correct": false,
                "score": 0.25
              }
            ]
          },
          "fim_easy": {
            "n": 20,
            "n_correct": 0,
            "accuracy": 0.0,
            "questions": [
              {
                "id": "fim_easy_001",
                "topic": "Adapter",
                "correct": false,
                "score": 0.04485981308411213
              },
              {
                "id": "fim_easy_002",
                "topic": "Adapter",
                "correct": false,
                "score": 0.05600000000000005
              },
              {
                "id": "fim_easy_003",
                "topic": "Adapter",
                "correct": false,
                "score": 0.033273381294964044
              },
              {
                "id": "fim_easy_004",
                "topic": "Adapter",
                "correct": false,
                "score": 0.06362007168458783
              },
              {
                "id": "fim_easy_005",
                "topic": "MVC",
                "correct": false,
                "score": 0.15291262135922334
              },
              {
                "id": "fim_easy_006",
                "topic": "MVC",
                "correct": false,
                "score": 0.13324538258575203
              },
              {
                "id": "fim_easy_007",
                "topic": "Testing",
                "correct": false,
                "score": 0.030337078651685445
              },
              {
                "id": "fim_easy_008",
                "topic": "Testing",
                "correct": false,
                "score": 0.09297052154195007
              },
              {
                "id": "fim_easy_009",
                "topic": "Strategy",
                "correct": false,
                "score": 0.043227665706051854
              },
              {
                "id": "fim_easy_010",
                "topic": "Inheritance",
                "correct": false,
                "score": 0.09619450317124734
              },
              {
                "id": "fim_easy_011",
                "topic": "Decorator",
                "correct": false,
                "score": 0.04062126642771802
              },
              {
                "id": "fim_easy_012",
                "topic": "Command",
                "correct": false,
                "score": 0.21295279912184417
              },
              {
                "id": "fim_easy_013",
                "topic": "MVC",
                "correct": false,
                "score": 0.0431034482758621
              },
              {
                "id": "fim_easy_014",
                "topic": "Testing",
                "correct": false,
                "score": 0.0432190760059612
              },
              {
                "id": "fim_easy_015",
                "topic": "Adapter",
                "correct": false,
                "score": 0.07017543859649122
              },
              {
                "id": "fim_easy_016",
                "topic": "MVC",
                "correct": false,
                "score": 0.021181716833890696
              },
              {
                "id": "fim_easy_017",
                "topic": "Testing",
                "correct": false,
                "score": 0.09319899244332497
              },
              {
                "id": "fim_easy_018",
                "topic": "Command",
                "correct": false,
                "score": 0.035851472471190804
              },
              {
                "id": "fim_easy_019",
                "topic": "MVC",
                "correct": false,
                "score": 0.046017699115044275
              },
              {
                "id": "fim_easy_020",
                "topic": "Adapter",
                "correct": false,
                "score": 0.0660146699266504
              }
            ]
          },
          "fim_hard": {
            "n": 10,
            "n_correct": 0,
            "accuracy": 0.0,
            "questions": [
              {
                "id": "fim_hard_001",
                "topic": "Adapter",
                "correct": false,
                "score": 0.30525164113785563
              },
              {
                "id": "fim_hard_002",
                "topic": "Adapter",
                "correct": false,
                "score": 0.20570440795159894
              },
              {
                "id": "fim_hard_003",
                "topic": "MVC",
                "correct": false,
                "score": 0.21299638989169678
              },
              {
                "id": "fim_hard_004",
                "topic": "Decorator",
                "correct": false,
                "score": 0.2502606882168926
              },
              {
                "id": "fim_hard_005",
                "topic": "Command",
                "correct": false,
                "score": 0.25105932203389836
              },
              {
                "id": "fim_hard_006",
                "topic": "Strategy",
                "correct": false,
                "score": 0.45818181818181813
              },
              {
                "id": "fim_hard_007",
                "topic": "MVC",
                "correct": false,
                "score": 0.2954990215264188
              },
              {
                "id": "fim_hard_008",
                "topic": "GUI",
                "correct": false,
                "score": 0.2678571428571429
              },
              {
                "id": "fim_hard_009",
                "topic": "Observer",
                "correct": false,
                "score": 0.3665116279069768
              },
              {
                "id": "fim_hard_010",
                "topic": "Command",
                "correct": false,
                "score": 0.27295597484276735
              }
            ]
          },
          "essay": {
            "n": 10,
            "n_correct": 0,
            "accuracy": 0.0,
            "questions": [
              {
                "id": "essay_001",
                "topic": "Inheritance",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "essay_002",
                "topic": "Adapter",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "essay_003",
                "topic": "MVC",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "essay_004",
                "topic": "Decorator",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "essay_005",
                "topic": "Strategy",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "essay_006",
                "topic": "Command",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "essay_007",
                "topic": "Testing",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "essay_008",
                "topic": "Observer",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "essay_009",
                "topic": "Inheritance",
                "correct": false,
                "score": 0.0
              },
              {
                "id": "essay_010",
                "topic": "Integration",
                "correct": false,
                "score": 0.0
              }
            ]
          }
        },
        "topics": {
          "Adapter": {
            "n": 17,
            "n_correct": 2,
            "accuracy": 11.764705882352942
          },
          "MVC": {
            "n": 18,
            "n_correct": 3,
            "accuracy": 16.666666666666668
          },
          "Observer": {
            "n": 4,
            "n_correct": 1,
            "accuracy": 25.0
          },
          "Decorator": {
            "n": 9,
            "n_correct": 2,
            "accuracy": 22.22222222222222
          },
          "Strategy": {
            "n": 9,
            "n_correct": 1,
            "accuracy": 11.11111111111111
          },
          "Command": {
            "n": 10,
            "n_correct": 1,
            "accuracy": 10.0
          },
          "Inheritance": {
            "n": 9,
            "n_correct": 4,
            "accuracy": 44.44444444444444
          },
          "Composition": {
            "n": 3,
            "n_correct": 2,
            "accuracy": 66.66666666666667
          },
          "Testing": {
            "n": 13,
            "n_correct": 2,
            "accuracy": 15.384615384615385
          },
          "Factory": {
            "n": 2,
            "n_correct": 0,
            "accuracy": 0.0
          },
          "GUI": {
            "n": 5,
            "n_correct": 1,
            "accuracy": 20.0
          },
          "Integration": {
            "n": 1,
            "n_correct": 0,
            "accuracy": 0.0
          }
        }
      }
    }
  },
  "teammate_tinyllama_existing": {
    "question_types": {
      "labels": [
        "True/False",
        "Short Answer",
        "FIM Easy",
        "FIM Hard",
        "Essay"
      ],
      "scores": [
        56.7,
        14.0,
        5.0,
        13.0,
        22.3
      ],
      "counts": [
        30,
        30,
        20,
        10,
        10
      ],
      "overall_avg": 25.7
    },
    "topics": {
      "labels": [
        "Composition",
        "Inheritance",
        "Observer",
        "Decorator",
        "GUI",
        "Testing",
        "Adapter",
        "Strategy",
        "MVC",
        "Command",
        "Factory"
      ],
      "scores": [
        66.7,
        42.9,
        33.3,
        25.0,
        20.0,
        16.7,
        12.5,
        12.5,
        11.8,
        11.1,
        0.0
      ],
      "counts": [
        3,
        7,
        3,
        8,
        5,
        12,
        16,
        8,
        17,
        9,
        2
      ]
    }
  }
}