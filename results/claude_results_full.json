[
  {
    "id": "fim_easy_001",
    "type": "fim_easy",
    "topic": "adapter",
    "correct": false,
    "score": 0.03513513513513511,
    "edit_distance": 1065,
    "prediction": "# Java Teaching Assistant\n\nHello! I'm here to help you with Java programming. I notice you haven't included a specific question yet. I can assist you with a wide range of Java topics, including:\n\n## Topics I Can Help With:\n\n- **Basics**: variables, data types, operators, control flow\n- **Object-Oriented Programming**: classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Collections Framework**: ArrayList, HashMap, LinkedList, Sets, etc.\n- **Exception Handling**: try-catch blocks, custom exceptions\n- **File I/O**: reading and writing files\n- **Multithreading**: threads, synchronization, concurrency\n- **Java 8+ Features**: lambdas, streams, Optional, method references\n- **Best Practices**: coding conventions, design patterns\n- **Debugging**: helping identify and fix errors\n\n## How to Ask Your Question:\n\nPlease share:\n1. Your specific Java question or problem\n2. Any code you're working with (if applicable)\n3. Error messages you're encountering (if any)\n4. What you've already tried\n\nFeel free to ask your question, and I'll provide a clear, detailed explanation with examples!",
    "expected": "    adaptee.unionWith(IntSet2Impl.singleton(value));"
  },
  {
    "id": "fim_easy_002",
    "type": "fim_easy",
    "topic": "adapter",
    "correct": false,
    "score": 0.035828025477707026,
    "edit_distance": 1203,
    "prediction": "# Java Teaching Assistant\n\nHello! I'm here to help you with Java programming. As your teaching assistant, I can help you with:\n\n## Topics I Can Help With:\n\n- **Fundamentals**: Variables, data types, operators, control structures\n- **Object-Oriented Programming**: Classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Data Structures**: Arrays, ArrayLists, LinkedLists, HashMaps, Sets, Stacks, Queues\n- **Exception Handling**: Try-catch blocks, custom exceptions\n- **File I/O**: Reading and writing files\n- **Multithreading**: Threads, synchronization\n- **Java Collections Framework**: List, Set, Map interfaces and implementations\n- **Lambda Expressions & Streams**: Functional programming in Java\n- **Best Practices**: Code organization, naming conventions, design patterns\n\n## How I Can Assist:\n\n\u2705 Explain Java concepts and syntax  \n\u2705 Debug code and fix errors  \n\u2705 Review and optimize your code  \n\u2705 Provide examples and practice problems  \n\u2705 Answer specific questions about Java  \n\n**Please go ahead and ask your question!** \n\nFeel free to:\n- Share code snippets that need review\n- Ask about specific Java concepts\n- Request examples or explanations\n- Get help debugging errors\n\nWhat would you like to learn about or work on today?",
    "expected": "    return adaptee.isSupersetOf(IntSet2Impl.singleton(value));"
  },
  {
    "id": "fim_easy_003",
    "type": "fim_easy",
    "topic": "adapter",
    "correct": false,
    "score": 0.028745644599303177,
    "edit_distance": 1111,
    "prediction": "# Java Teaching Assistant\n\nHello! I'm here to help you with Java programming concepts, questions, and problems. I can assist with:\n\n## Topics I Can Help With:\n- **Basics**: Variables, data types, operators, control flow\n- **Object-Oriented Programming**: Classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Data Structures**: Arrays, ArrayLists, LinkedLists, HashMaps, Sets, etc.\n- **Exception Handling**: try-catch blocks, custom exceptions\n- **File I/O**: Reading and writing files\n- **Algorithms**: Sorting, searching, recursion\n- **Advanced Topics**: Generics, streams, lambda expressions, multithreading\n- **Best Practices**: Code style, debugging, optimization\n\n## How to Ask Questions:\n1. Share your specific question or problem\n2. Include any relevant code (I can help debug!)\n3. Describe what you've tried or what's confusing you\n4. Let me know your current level (beginner, intermediate, advanced)\n\n**I notice you haven't included a specific question yet.** Please go ahead and ask your Java-related question, and I'll provide a clear, detailed explanation with examples!\n\nWhat would you like to learn about today?",
    "expected": "    return adaptee.asList().iterator();"
  },
  {
    "id": "fim_easy_004",
    "type": "fim_easy",
    "topic": "adapter",
    "correct": false,
    "score": 0.05656934306569339,
    "edit_distance": 1029,
    "prediction": "# Java Teaching Assistant\n\nHello! I'm here to help you with Java programming. I notice you haven't included a specific question yet. I can assist you with topics such as:\n\n## Common Java Topics:\n- **Basics**: Variables, data types, operators, control structures\n- **Object-Oriented Programming**: Classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Collections**: ArrayList, HashMap, HashSet, LinkedList, etc.\n- **Exception Handling**: try-catch blocks, custom exceptions\n- **File I/O**: Reading and writing files\n- **Multithreading**: Threads, synchronization, concurrency\n- **Java 8+ Features**: Lambda expressions, streams, functional interfaces\n- **Design Patterns**: Singleton, Factory, Observer, etc.\n- **Debugging**: Common errors and how to fix them\n\n## How I Can Help:\n- Explain concepts with clear examples\n- Debug code issues\n- Review and improve your code\n- Provide best practices\n- Create sample programs\n- Answer theoretical questions\n\n**Please share your Java question, code snippet, or topic you'd like help with, and I'll provide a detailed explanation!**",
    "expected": "    throw new UnsupportedOperationException(\"Cannot remove from Enumeration\");"
  },
  {
    "id": "fim_easy_005",
    "type": "fim_easy",
    "topic": "mvc",
    "correct": false,
    "score": 0.09991386735572783,
    "edit_distance": 1041,
    "prediction": "# Java Teaching Assistant\n\nHello! I'm here to help you with Java programming concepts, questions, and problems. Since you haven't asked a specific question yet, let me share how I can assist you:\n\n## How I Can Help:\n\n1. **Explain Java Concepts**\n   - Object-Oriented Programming (Classes, Objects, Inheritance, Polymorphism, Encapsulation, Abstraction)\n   - Data structures and Collections\n   - Exception handling\n   - Multithreading and Concurrency\n   - File I/O and Streams\n   - Generics, Lambda expressions, and Functional Programming\n\n2. **Debug Code**\n   - Help identify and fix errors\n   - Explain compilation errors\n   - Trace runtime exceptions\n\n3. **Review & Optimize Code**\n   - Best practices and coding standards\n   - Performance optimization\n   - Design patterns\n\n4. **Provide Examples**\n   - Code snippets for specific tasks\n   - Step-by-step explanations\n\n5. **Answer Theory Questions**\n   - Core Java concepts\n   - JVM architecture\n   - Memory management\n\n## Please feel free to ask:\n- Specific Java questions\n- Code debugging help\n- Concept explanations\n- Practice problems\n- Project guidance\n\n**What would you like to learn or work on today?**",
    "expected": "    if (in == null || out == null) {\n      throw new IllegalArgumentException(\"Input and output cannot be null\");\n    }\n    this.in = in;\n    this.out = out;"
  },
  {
    "id": "fim_easy_006",
    "type": "fim_easy",
    "topic": "mvc",
    "correct": false,
    "score": 0.0859872611464968,
    "edit_distance": 857,
    "prediction": "# Java Teaching Assistant\n\nI'm here to help you with Java programming! I can assist with:\n\n## Topics I Cover:\n- **Basics**: Variables, data types, operators, control flow\n- **Object-Oriented Programming**: Classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Data Structures**: Arrays, ArrayLists, LinkedLists, HashMaps, etc.\n- **Advanced Concepts**: Generics, exceptions, file I/O, multithreading\n- **Best Practices**: Code style, debugging techniques, design patterns\n\n## How I Can Help:\n\u2705 Explain Java concepts clearly\n\u2705 Debug and fix code errors\n\u2705 Review and improve your code\n\u2705 Provide examples and practice problems\n\u2705 Answer specific questions\n\n---\n\n**Please share your Java question, and I'll be happy to help!** \n\nYou can:\n- Ask about a specific concept\n- Share code that needs debugging\n- Request examples or explanations\n- Ask for help with homework or projects\n\nWhat would you like to learn or work on today?",
    "expected": "    new TicTacToeConsoleController(new InputStreamReader(System.in),\n        System.out).playGame(new TicTacToeModel());"
  },
  {
    "id": "fim_easy_007",
    "type": "fim_easy",
    "topic": "testing",
    "correct": false,
    "score": 0.020289855072463725,
    "edit_distance": 1011,
    "prediction": "# Java Teaching Assistant\n\nHello! I'm here to help you with Java programming. I notice you haven't included a specific question yet. I can assist you with topics such as:\n\n## Common Java Topics:\n- **Basics**: syntax, data types, variables, operators\n- **Object-Oriented Programming**: classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Control Flow**: if-else, switch, loops (for, while, do-while)\n- **Data Structures**: arrays, ArrayList, HashMap, LinkedList, etc.\n- **Exception Handling**: try-catch, throws, custom exceptions\n- **File I/O**: reading/writing files\n- **Multithreading**: threads, synchronization\n- **Java 8+ Features**: lambdas, streams, optional\n- **Debugging**: common errors and how to fix them\n\n## How I Can Help:\n\u2713 Explain Java concepts with examples\n\u2713 Debug your code\n\u2713 Provide best practices\n\u2713 Review your solutions\n\u2713 Suggest improvements\n\n**Please feel free to ask your Java question, and I'll provide a detailed explanation with examples!**\n\nWhat would you like to learn about today?",
    "expected": "    assertTrue(set.member(5));"
  },
  {
    "id": "fim_easy_008",
    "type": "fim_easy",
    "topic": "testing",
    "correct": false,
    "score": 0.06112702960840499,
    "edit_distance": 980,
    "prediction": "# Java Teaching Assistant\n\nI'm here to help you with Java programming! I can assist with:\n\n## Topics I Cover:\n- **Basics**: Variables, data types, operators, control flow\n- **Object-Oriented Programming**: Classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Data Structures**: Arrays, ArrayList, LinkedList, HashMap, HashSet, etc.\n- **Exception Handling**: Try-catch blocks, custom exceptions\n- **File I/O**: Reading and writing files\n- **Advanced Topics**: Generics, streams, lambda expressions, multithreading\n- **Debugging**: Common errors and how to fix them\n\n## How I Can Help:\n\u2713 Explain Java concepts clearly  \n\u2713 Review and debug your code  \n\u2713 Provide code examples  \n\u2713 Answer specific questions  \n\u2713 Suggest best practices  \n\n**Please feel free to ask me any Java-related question!** \n\n*For example:*\n- \"How do I create a class in Java?\"\n- \"What's the difference between ArrayList and LinkedList?\"\n- \"Can you help me debug this code?\"\n- \"Explain inheritance with an example\"\n\nWhat would you like to learn about today?",
    "expected": "    assertThrows(IllegalArgumentException.class,\n        () -> { new HMSDuration(-1, 0, 0); });"
  },
  {
    "id": "fim_easy_009",
    "type": "fim_easy",
    "topic": "strategy",
    "correct": false,
    "score": 0.043269230769230727,
    "edit_distance": 991,
    "prediction": "# Java Teaching Assistant\n\nHello! I'm here to help you with Java programming questions. I notice you haven't included a specific question yet.\n\n## What I Can Help With:\n\n- **Core Java Concepts**: Variables, data types, operators, control structures\n- **Object-Oriented Programming**: Classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Collections Framework**: Lists, Sets, Maps, and their implementations\n- **Exception Handling**: Try-catch blocks, custom exceptions\n- **Multithreading**: Thread creation, synchronization, concurrency\n- **File I/O**: Reading and writing files\n- **Java 8+ Features**: Lambdas, Streams, Optional, etc.\n- **Debugging**: Help finding and fixing errors\n- **Best Practices**: Code optimization and clean code principles\n\n## How to Ask:\n\nPlease provide:\n1. Your specific question or problem\n2. Any relevant code you're working with\n3. Error messages (if applicable)\n4. What you've tried so far\n\nFeel free to ask your Java question, and I'll provide a clear, detailed answer with examples!",
    "expected": "    return available.get(random.nextInt(available.size()));"
  },
  {
    "id": "fim_easy_010",
    "type": "fim_easy",
    "topic": "inheritance",
    "correct": false,
    "score": 0.07464028776978415,
    "edit_distance": 1024,
    "prediction": "# Java Teaching Assistant\n\nHello! I'm here to help you with Java programming. I notice you haven't included a specific question yet. I can assist you with a wide range of Java topics, including:\n\n## Topics I Can Help With:\n\n- **Basics**: Variables, data types, operators, control structures\n- **Object-Oriented Programming**: Classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Data Structures**: Arrays, ArrayLists, LinkedLists, HashMaps, Sets, etc.\n- **Exception Handling**: try-catch blocks, custom exceptions\n- **File I/O**: Reading and writing files\n- **Collections Framework**: Lists, Sets, Maps, and their implementations\n- **Multithreading**: Thread creation, synchronization\n- **Java 8+ Features**: Lambda expressions, streams, functional interfaces\n- **Best Practices**: Code organization, naming conventions, design patterns\n\n## How to Ask:\n\nPlease feel free to ask:\n- Concept explanations\n- Code debugging help\n- Best practices and recommendations\n- Examples and sample code\n- Interview preparation questions\n\n**Please share your Java question, and I'll be happy to help!** \ud83d\udcda\u2615",
    "expected": "    for (int z : other.asList()) {\n      if (!member(z)) {\n        return false;\n      }\n    }\n    return true;"
  },
  {
    "id": "fim_easy_011",
    "type": "fim_easy",
    "topic": "decorator",
    "correct": false,
    "score": 0.024478694469628248,
    "edit_distance": 1072,
    "prediction": "# Java Teaching Assistant - Ready to Help! \ud83d\udc68\u200d\ud83c\udfeb\n\nHello! I'm here to help you with Java programming. However, I notice you haven't asked a specific question yet.\n\n## I can help you with:\n\n### **Fundamentals**\n- Variables, data types, and operators\n- Control structures (if/else, loops, switch)\n- Methods and parameters\n- Arrays and collections\n\n### **Object-Oriented Programming**\n- Classes and objects\n- Inheritance and polymorphism\n- Encapsulation and abstraction\n- Interfaces and abstract classes\n\n### **Advanced Topics**\n- Exception handling\n- Generics\n- Lambda expressions and streams\n- Multithreading\n- File I/O\n\n### **Common Tasks**\n- Debugging code\n- Explaining errors\n- Code review and best practices\n- Algorithm implementation\n\n## How to ask your question:\n\nPlease provide:\n1. **Your question or problem**\n2. **Any relevant code** (if applicable)\n3. **Error messages** (if you're getting errors)\n4. **What you've tried** so far\n\n**Example:** \"Can you explain how inheritance works in Java?\" or \"I'm getting a NullPointerException in this code...\"\n\n**What would you like to learn about today?** \ud83d\ude80",
    "expected": "    return delegate.member(value);"
  },
  {
    "id": "fim_easy_012",
    "type": "fim_easy",
    "topic": "command",
    "correct": false,
    "score": 0.14379084967320266,
    "edit_distance": 651,
    "prediction": "# Java Teaching Assistant\n\nI'm ready to help you with Java programming! I can assist with:\n\n- **Core Java concepts** (syntax, data types, control structures)\n- **Object-Oriented Programming** (classes, inheritance, polymorphism, encapsulation)\n- **Collections Framework** (Lists, Sets, Maps)\n- **Exception Handling**\n- **File I/O and Streams**\n- **Multithreading and Concurrency**\n- **Java 8+ features** (lambdas, streams, Optional)\n- **Best practices and code review**\n- **Debugging help**\n- **Algorithm implementation**\n\n## How can I help you today?\n\nPlease feel free to:\n- Ask a specific Java question\n- Share code for review or debugging\n- Request an explanation of a concept\n- Ask for examples or practice problems\n\n**What would you like to learn or work on?**",
    "expected": "    double x = distance * Math.cos(Math.toRadians(heading));\n    double y = distance * Math.sin(Math.toRadians(heading));\n    position = new Position2D(position.getX() + x, position.getY() + y);"
  },
  {
    "id": "fim_easy_013",
    "type": "fim_easy",
    "topic": "mvc",
    "correct": false,
    "score": 0.03241650294695486,
    "edit_distance": 981,
    "prediction": "# Java Teaching Assistant\n\nHello! I'm here to help you with Java programming questions. I can assist you with:\n\n## Topics I Cover:\n- **Basic Syntax**: Variables, data types, operators, control structures\n- **Object-Oriented Programming**: Classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Data Structures**: Arrays, ArrayList, LinkedList, HashMap, HashSet, etc.\n- **Exception Handling**: Try-catch blocks, custom exceptions\n- **File I/O**: Reading and writing files\n- **Collections Framework**: Lists, Sets, Maps, and their implementations\n- **Multithreading**: Threads, synchronization, concurrency\n- **Java 8+ Features**: Lambda expressions, streams, functional interfaces\n- **Best Practices**: Coding standards, design patterns, debugging tips\n\n## How to Ask Questions:\nPlease provide:\n1. Your specific Java question or problem\n2. Any relevant code you're working with\n3. Error messages (if applicable)\n4. What you've already tried\n\n**I'm ready to help! What Java question do you have?** \ud83d\ude0a",
    "expected": "    board = new Player[3][3];\n    turn = Player.X;"
  },
  {
    "id": "fim_easy_014",
    "type": "fim_easy",
    "topic": "testing",
    "correct": false,
    "score": 0.022265246853823806,
    "edit_distance": 1008,
    "prediction": "# Java Teaching Assistant\n\nI'm here to help you with Java programming! However, I notice you haven't included a specific question yet. \n\nI can assist you with topics such as:\n\n## **Core Java Concepts**\n- Variables, data types, and operators\n- Control structures (if/else, loops, switch)\n- Object-Oriented Programming (classes, objects, inheritance, polymorphism, encapsulation, abstraction)\n- Arrays and Collections (ArrayList, HashMap, etc.)\n- Exception handling\n- File I/O\n- Strings and StringBuilder\n\n## **Advanced Topics**\n- Generics\n- Multithreading and concurrency\n- Lambda expressions and Streams\n- JDBC and database connectivity\n- Design patterns\n\n## **Debugging & Best Practices**\n- Code review and optimization\n- Common errors and how to fix them\n- Java coding conventions\n\n**Please share your specific question, and I'll provide a clear, detailed explanation with examples!**\n\nFor the best help, include:\n- Your question or problem\n- Any code you're working with\n- Error messages (if applicable)\n- What you've tried so far",
    "expected": "  assertFalse(set.member(10));"
  },
  {
    "id": "fim_easy_015",
    "type": "fim_easy",
    "topic": "adapter",
    "correct": false,
    "score": 0.04019607843137252,
    "edit_distance": 975,
    "prediction": "# Java Teaching Assistant\n\nHello! I'm here to help you with Java programming. I can assist with:\n\n## Topics I Can Help With:\n\n### **Fundamentals**\n- Variables, data types, and operators\n- Control flow (if/else, loops, switch)\n- Methods and parameters\n- Arrays and collections\n\n### **Object-Oriented Programming**\n- Classes and objects\n- Inheritance and polymorphism\n- Encapsulation and abstraction\n- Interfaces and abstract classes\n\n### **Advanced Topics**\n- Exception handling\n- Generics\n- Lambda expressions and streams\n- Multithreading\n- File I/O\n\n### **Best Practices**\n- Code organization\n- Naming conventions\n- Design patterns\n- Debugging strategies\n\n## How to Ask Questions:\n\nPlease feel free to ask me:\n- Conceptual questions (e.g., \"What is polymorphism?\")\n- Code debugging help\n- Explanations of error messages\n- Best practices and recommendations\n- Code review and optimization\n\n**What would you like help with today?** Please share your question, and I'll provide a clear, detailed explanation with examples!",
    "expected": "    for (int i : other.asList()) {\n      add(i);\n    }"
  },
  {
    "id": "fim_easy_016",
    "type": "fim_easy",
    "topic": "mvc",
    "correct": false,
    "score": 0.013333333333333308,
    "edit_distance": 957,
    "prediction": "# Java Teaching Assistant\n\nHello! I'm here to help you learn Java programming. I can assist with:\n\n## Topics I Can Help With:\n\n### Fundamentals\n- Variables and data types\n- Operators and expressions\n- Control flow (if/else, switch, loops)\n- Methods and parameters\n\n### Object-Oriented Programming\n- Classes and objects\n- Inheritance and polymorphism\n- Encapsulation and abstraction\n- Interfaces and abstract classes\n\n### Advanced Topics\n- Collections Framework (Lists, Sets, Maps)\n- Exception handling\n- File I/O\n- Generics\n- Multithreading\n- Lambda expressions and Streams\n\n### Best Practices\n- Code organization\n- Naming conventions\n- Design patterns\n- Debugging strategies\n\n## How I Can Help:\n- \ud83d\udcdd Explain concepts with examples\n- \ud83d\udc1b Debug code issues\n- \ud83d\udca1 Provide coding tips and best practices\n- \u2705 Review and improve your code\n- \ud83d\udcda Suggest learning resources\n\n**Please share your Java question or code, and I'll be happy to help!**\n\nWhat would you like to learn about today?",
    "expected": "    return asHms();"
  },
  {
    "id": "fim_easy_017",
    "type": "fim_easy",
    "topic": "testing",
    "correct": false,
    "score": 0.04318936877076407,
    "edit_distance": 1145,
    "prediction": "# Java Teaching Assistant\n\nHello! I'm here to help you with Java programming. I notice you haven't included a specific question yet. I can assist you with a wide range of Java topics, including:\n\n## Topics I Can Help With:\n\n- **Basics**: Variables, data types, operators, control structures\n- **Object-Oriented Programming**: Classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Data Structures**: Arrays, ArrayList, LinkedList, HashMap, HashSet, etc.\n- **Exception Handling**: try-catch blocks, custom exceptions\n- **File I/O**: Reading and writing files\n- **Multithreading**: Creating and managing threads\n- **Java Collections Framework**: Lists, Sets, Maps, Queues\n- **Lambda Expressions & Streams**: Functional programming in Java\n- **Design Patterns**: Common Java design patterns\n- **Debugging**: Help finding and fixing errors\n\n## How to Ask Your Question:\n\nPlease feel free to:\n- Share your specific Java question\n- Post code that you need help understanding\n- Describe an error you're encountering\n- Ask for explanations of Java concepts\n- Request code examples or best practices\n\n**Go ahead and post your question, and I'll provide a detailed explanation with examples!**",
    "expected": "    day = new HMSDuration(24, 0, 0);\n    ninetySeconds = new HMSDuration(0, 0, 90);"
  },
  {
    "id": "fim_easy_018",
    "type": "fim_easy",
    "topic": "command",
    "correct": false,
    "score": 0.017933390264730953,
    "edit_distance": 1146,
    "prediction": "# Java Teaching Assistant\n\nI'm here to help you with Java programming! However, I notice you haven't included a specific question yet.\n\n## I can help you with:\n\n- **Java Fundamentals**: variables, data types, operators, control structures\n- **Object-Oriented Programming**: classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Collections Framework**: Lists, Sets, Maps, and their implementations\n- **Exception Handling**: try-catch blocks, custom exceptions\n- **Multithreading**: threads, synchronization, concurrency\n- **File I/O**: reading and writing files\n- **Java 8+ Features**: lambda expressions, streams, optional\n- **Best Practices**: coding standards, design patterns\n- **Debugging**: understanding error messages and fixing code\n\n## How to ask:\n\nPlease provide:\n1. Your specific question or problem\n2. Any relevant code you're working with\n3. Error messages (if applicable)\n4. What you've already tried\n\n**Example format:**\n```\n\"I'm trying to create a method that reverses a string, \nbut I'm getting an IndexOutOfBoundsException...\"\n```\n\nFeel free to ask your Java question, and I'll provide a clear, detailed explanation with examples!",
    "expected": "    heading += angleDegrees;"
  },
  {
    "id": "fim_easy_019",
    "type": "fim_easy",
    "topic": "mvc",
    "correct": false,
    "score": 0.04108309990662928,
    "edit_distance": 1023,
    "prediction": "# Java Teaching Assistant\n\nHello! I'm here to help you with Java programming. I notice you haven't included a specific question yet. I can assist you with topics such as:\n\n## Common Java Topics:\n- **Basic Syntax** - variables, data types, operators\n- **Object-Oriented Programming** - classes, objects, inheritance, polymorphism, encapsulation\n- **Control Structures** - if/else, loops, switch statements\n- **Data Structures** - arrays, ArrayList, HashMap, LinkedList, etc.\n- **Exception Handling** - try-catch blocks, throwing exceptions\n- **File I/O** - reading and writing files\n- **Multithreading** - threads, synchronization\n- **Java Collections Framework**\n- **Lambda Expressions & Streams**\n- **Debugging** - common errors and how to fix them\n\n## How I Can Help:\n\u2713 Explain Java concepts with examples\n\u2713 Debug code and identify errors\n\u2713 Provide best practices and coding standards\n\u2713 Walk through algorithms step-by-step\n\u2713 Answer specific homework or project questions\n\n**Please share your Java question, and I'll provide a detailed explanation with code examples!**",
    "expected": "    return Long.compare(this.inSeconds(), that.inSeconds());"
  },
  {
    "id": "fim_easy_020",
    "type": "fim_easy",
    "topic": "adapter",
    "correct": false,
    "score": 0.045553145336225564,
    "edit_distance": 876,
    "prediction": "# Java Teaching Assistant\n\nI'm here to help you with Java programming! I can assist with:\n\n## Topics I Cover:\n- **Basics**: syntax, data types, variables, operators\n- **Object-Oriented Programming**: classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Data Structures**: arrays, ArrayLists, LinkedLists, HashMaps, etc.\n- **Control Flow**: loops, conditionals, switch statements\n- **Exception Handling**: try-catch blocks, custom exceptions\n- **File I/O**: reading and writing files\n- **Advanced Topics**: generics, lambdas, streams, multithreading\n- **Debugging**: common errors and how to fix them\n\n## How I Can Help:\n\u2705 Explain concepts with examples  \n\u2705 Debug your code  \n\u2705 Review and improve your solutions  \n\u2705 Provide practice problems  \n\u2705 Answer specific questions  \n\n---\n\n**Please share your Java question or code, and I'll be happy to help!** \n\nWhat would you like to learn or work on today?",
    "expected": "    for (int i : other.asList()) {\n      remove(i);\n    }"
  },
  {
    "id": "fim_hard_001",
    "type": "fim_hard",
    "topic": "adapter",
    "correct": false,
    "score": 0.18478260869565222,
    "edit_distance": 828,
    "prediction": "# Java Teaching Assistant\n\nI'm here to help you with Java programming! I can assist with:\n\n## Topics I Cover:\n- **Basic Concepts**: Variables, data types, operators, control structures\n- **Object-Oriented Programming**: Classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Advanced Topics**: Collections, generics, exception handling, multithreading, streams, lambda expressions\n- **Best Practices**: Code style, design patterns, debugging techniques\n- **Common Problems**: Error explanations, code review, optimization suggestions\n\n## How I Can Help:\n\u2713 Explain Java concepts clearly\n\u2713 Debug and fix code issues\n\u2713 Provide code examples\n\u2713 Answer specific questions\n\u2713 Review your code\n\u2713 Suggest improvements\n\n---\n\n**Please share your Java question or code, and I'll be happy to help!** \n\nWhether you're working on:\n- A specific error or bug \ud83d\udc1b\n- Understanding a concept \ud83d\udcda\n- Writing new code \ud83d\udcbb\n- Optimizing existing code \u26a1\n- Preparing for exams or interviews \ud83d\udcdd\n\nJust let me know what you need!",
    "expected": "  // IntSet1 methods - translate element operations to set operations\n  @Override\n  public void add(int value) {\n    adaptee.unionWith(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public void remove(int value) {\n    adaptee.differenceFrom(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public boolean member(int value) {\n    return adaptee.isSupersetOf(IntSet2Impl.singleton(value));\n  }\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return adaptee.asList().iterator();\n  }\n\n  // IntSet2 methods - delegate directly to adaptee\n  @Override\n  public void unionWith(IntSet2 other) {\n    adaptee.unionWith(other);\n  }\n\n  @Override\n  public void differenceFrom(IntSet2 other) {\n    adaptee.differenceFrom(other);\n  }\n\n  @Override\n  public boolean isSupersetOf(IntSet2 other) {\n    return adaptee.isSupersetOf(other);\n  }\n\n  @Override\n  public List<Integer> asList() {\n    return adaptee.asList();\n  }"
  },
  {
    "id": "fim_hard_002",
    "type": "fim_hard",
    "topic": "adapter",
    "correct": false,
    "score": 0.16120906801007562,
    "edit_distance": 998,
    "prediction": "# Java Teaching Assistant\n\nHello! I'm here to help you with Java programming. I notice you haven't included a specific question yet, but I'm ready to assist you with any Java-related topics, including:\n\n## Topics I Can Help With:\n\n- **Fundamentals**: Variables, data types, operators, control flow\n- **Object-Oriented Programming**: Classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Collections**: Arrays, ArrayList, HashMap, Sets, etc.\n- **Exception Handling**: try-catch blocks, custom exceptions\n- **File I/O**: Reading and writing files\n- **Multithreading**: Threads, synchronization\n- **Java 8+ Features**: Lambda expressions, streams, functional interfaces\n- **Best Practices**: Code organization, naming conventions, design patterns\n- **Debugging**: Help finding and fixing errors\n- **Algorithm Implementation**: Sorting, searching, data structures\n\n## How to Get the Best Help:\n\n1. **Share your specific question** or problem\n2. **Include any code** you're working with\n3. **Describe what you've tried** so far\n4. **Mention any error messages** you're encountering\n\nPlease go ahead and ask your Java question, and I'll provide a clear, detailed explanation!",
    "expected": "  @Override\n  public boolean hasNext() {\n    return enumeration.hasMoreElements();\n  }\n\n  @Override\n  public T next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    return enumeration.nextElement();\n  }\n\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException(\"Cannot remove from an Enumeration\");\n  }"
  },
  {
    "id": "fim_hard_003",
    "type": "fim_hard",
    "topic": "mvc",
    "correct": false,
    "score": 0.15922107674684993,
    "edit_distance": 735,
    "prediction": "# Java Teaching Assistant\n\nI'm ready to help you with Java! I can assist with:\n\n- **Core Java Concepts**: syntax, data types, operators, control flow\n- **Object-Oriented Programming**: classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Collections Framework**: Lists, Sets, Maps, and their implementations\n- **Exception Handling**: try-catch, custom exceptions, best practices\n- **Advanced Topics**: streams, lambdas, multithreading, generics\n- **Debugging**: helping identify and fix errors in your code\n- **Best Practices**: code style, design patterns, and clean code principles\n\n## How can I help you today?\n\nPlease feel free to:\n- Ask a specific Java question\n- Share code you'd like me to review or debug\n- Request an explanation of a Java concept\n- Ask for examples or practice problems\n\nJust let me know what you'd like to learn or work on!",
    "expected": "    Objects.requireNonNull(model);\n    append(model.toString() + \"\\n\");\n    append(\"Enter move as row col (1-indexed):\\n\");\n\n    while (!model.isGameOver()) {\n      append(\"Player \" + model.getTurn() + \"'s turn:\\n\");\n      try {\n        int row = scan.nextInt() - 1;\n        int col = scan.nextInt() - 1;\n        model.move(row, col);\n        append(model.toString() + \"\\n\");\n      } catch (InputMismatchException e) {\n        append(\"Invalid input. Enter row and column as integers.\\n\");\n        scan.next(); // consume invalid token\n      } catch (IllegalArgumentException e) {\n        append(\"Invalid move: \" + e.getMessage() + \"\\n\");\n      }\n    }\n\n    if (model.getWinner() != null) {\n      append(\"Game over! Winner: \" + model.getWinner() + \"\\n\");\n    } else {\n      append(\"Game over! It's a tie!\\n\");\n    }"
  },
  {
    "id": "fim_hard_004",
    "type": "fim_hard",
    "topic": "decorator",
    "correct": false,
    "score": 0.20588235294117652,
    "edit_distance": 782,
    "prediction": "# Java Teaching Assistant\n\nHello! I'm here to help you with Java programming. I notice you haven't included a specific question yet.\n\n## I can help you with:\n\n- **Java Basics**: variables, data types, operators, control flow\n- **Object-Oriented Programming**: classes, objects, inheritance, polymorphism, encapsulation\n- **Collections Framework**: Lists, Sets, Maps, and their implementations\n- **Exception Handling**: try-catch blocks, custom exceptions\n- **Java 8+ Features**: lambda expressions, streams, functional interfaces\n- **Multithreading**: threads, synchronization, concurrency\n- **File I/O**: reading and writing files\n- **Best Practices**: coding conventions, design patterns\n- **Debugging**: helping you troubleshoot errors\n\n## Please provide:\n1. Your specific Java question or problem\n2. Any code you're working with (if applicable)\n3. Any error messages you're encountering\n4. What you've already tried (if applicable)\n\nI'm ready to help once you share your question! \ud83d\ude0a",
    "expected": "  @Override\n  public void add(int value) {\n    addCount++;\n    delegate.add(value);\n  }\n\n  @Override\n  public void addAll(Collection<Integer> values) {\n    addCount += values.size();\n    delegate.addAll(values);\n  }\n\n  @Override\n  public void remove(int value) {\n    delegate.remove(value);\n  }\n\n  @Override\n  public boolean member(int value) {\n    return delegate.member(value);\n  }\n\n  @Override\n  public Iterator<Integer> iterator() {\n    return delegate.iterator();\n  }"
  },
  {
    "id": "fim_hard_005",
    "type": "fim_hard",
    "topic": "command",
    "correct": false,
    "score": 0.18816682832201748,
    "edit_distance": 838,
    "prediction": "# Java Teaching Assistant\n\nHello! I'm here to help you with Java programming. However, I notice you haven't included a specific question yet.\n\n## I can help you with:\n\n- **Java Fundamentals**: variables, data types, operators, control structures\n- **Object-Oriented Programming**: classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Java Collections**: ArrayList, HashMap, HashSet, etc.\n- **Exception Handling**: try-catch blocks, custom exceptions\n- **File I/O**: reading and writing files\n- **Multithreading**: threads, synchronization\n- **Java 8+ Features**: lambdas, streams, optional\n- **Best Practices**: code style, design patterns\n- **Debugging Help**: explaining error messages and fixing code issues\n\n## How to ask your question:\n\nPlease provide:\n1. Your specific Java question or problem\n2. Any relevant code you're working with\n3. Error messages (if applicable)\n4. What you've tried so far\n\n**Please feel free to ask your Java question, and I'll provide a clear, detailed answer with examples!**",
    "expected": "  @Override\n  public void execute() {\n    previousPosition = turtle.getPosition();\n    turtle.move(distance);\n  }\n\n  @Override\n  public void undo() {\n    if (previousPosition == null) {\n      throw new IllegalStateException(\"Cannot undo: command not executed\");\n    }\n    turtle.setPosition(previousPosition);\n  }\n\n  @Override\n  public boolean canUndo() {\n    return previousPosition != null;\n  }"
  },
  {
    "id": "fim_hard_006",
    "type": "fim_hard",
    "topic": "strategy",
    "correct": false,
    "score": 0.18219983207388746,
    "edit_distance": 974,
    "prediction": "# Java Teaching Assistant\n\nHello! I'm here to help you with Java programming. I notice you haven't asked a specific question yet. I can help you with topics such as:\n\n## Common Java Topics:\n- **Basics**: variables, data types, operators, control structures\n- **Object-Oriented Programming**: classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Collections**: ArrayList, HashMap, HashSet, etc.\n- **Exception Handling**: try-catch blocks, custom exceptions\n- **File I/O**: reading and writing files\n- **Multithreading**: threads, synchronization\n- **Java 8+ Features**: lambdas, streams, functional interfaces\n- **Data Structures**: arrays, linked lists, stacks, queues, trees\n- **Algorithms**: sorting, searching, recursion\n- **Best Practices**: coding conventions, design patterns\n\n## How I Can Help:\n- \u2705 Explain Java concepts with examples\n- \u2705 Debug code and identify errors\n- \u2705 Provide code examples and solutions\n- \u2705 Review your code and suggest improvements\n- \u2705 Answer theoretical questions about Java\n\n**Please feel free to ask your Java question, and I'll provide a detailed explanation with code examples if needed!**\n\nWhat would you like to learn about today?",
    "expected": "    // Try corners first\n    for (int[] corner : CORNERS) {\n      if (isEmpty(model, corner[0], corner[1])) {\n        return new Coord(corner[0], corner[1]);\n      }\n    }\n\n    // Try center\n    if (isEmpty(model, CENTER[0], CENTER[1])) {\n      return new Coord(CENTER[0], CENTER[1]);\n    }\n\n    // Try edges\n    for (int[] edge : EDGES) {\n      if (isEmpty(model, edge[0], edge[1])) {\n        return new Coord(edge[0], edge[1]);\n      }\n    }\n\n    // No move available\n    return null;"
  },
  {
    "id": "fim_hard_007",
    "type": "fim_hard",
    "topic": "mvc",
    "correct": false,
    "score": 0.14971209213051828,
    "edit_distance": 889,
    "prediction": "# Java Teaching Assistant\n\nHello! I'm here to help you with Java programming. I notice you haven't included a specific question yet. I can assist you with a wide range of Java topics, including:\n\n## Topics I Can Help With:\n\n- **Basics**: Variables, data types, operators, control flow\n- **Object-Oriented Programming**: Classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Data Structures**: Arrays, ArrayLists, LinkedLists, HashMaps, Sets, Stacks, Queues\n- **Exception Handling**: Try-catch blocks, custom exceptions\n- **File I/O**: Reading and writing files\n- **Advanced Topics**: Threads, streams, lambda expressions, generics\n- **Debugging**: Help finding and fixing errors in your code\n- **Best Practices**: Code style, design patterns, optimization\n\n## How to Ask:\n\nPlease feel free to:\n- Post your specific question\n- Share code you're working on\n- Describe an error you're encountering\n- Ask for explanation of Java concepts\n- Request code examples or practice problems\n\n**What would you like help with today?**",
    "expected": "  @Override\n  public void move(int row, int col) {\n    if (gameOver) {\n      throw new IllegalStateException(\"Game is already over\");\n    }\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Position out of bounds\");\n    }\n    if (board[row][col] != null) {\n      throw new IllegalArgumentException(\"Cell already occupied\");\n    }\n\n    board[row][col] = turn;\n\n    if (checkWin(turn)) {\n      winner = turn;\n      gameOver = true;\n    } else if (isBoardFull()) {\n      gameOver = true;\n    } else {\n      turn = (turn == Player.X) ? Player.O : Player.X;\n    }\n  }\n\n  @Override\n  public Player getTurn() {\n    return turn;\n  }\n\n  @Override\n  public Player getWinner() {\n    return winner;\n  }\n\n  @Override\n  public boolean isGameOver() {\n    return gameOver;\n  }\n\n  @Override\n  public Player getPieceAt(int row, int col) {\n    if (row < 0 || row > 2 || col < 0 || col > 2) {\n      throw new IllegalArgumentException(\"Position out of bounds\");\n    }\n    return board[row][col];\n  }"
  },
  {
    "id": "fim_hard_008",
    "type": "fim_hard",
    "topic": "gui",
    "correct": false,
    "score": 0.16981132075471694,
    "edit_distance": 877,
    "prediction": "# Java Teaching Assistant\n\nHello! I'm here to help you with Java programming. I notice you haven't included a specific question yet. I can assist you with a wide range of Java topics, including:\n\n## Topics I Can Help With:\n\n- **Fundamentals**: Variables, data types, operators, control structures\n- **Object-Oriented Programming**: Classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Collections Framework**: Lists, Sets, Maps, and their implementations\n- **Exception Handling**: Try-catch blocks, custom exceptions\n- **Java 8+ Features**: Lambdas, streams, functional interfaces\n- **Multithreading**: Threads, synchronization, concurrency utilities\n- **File I/O**: Reading and writing files\n- **Best Practices**: Code organization, design patterns, debugging strategies\n\n## How to Ask Your Question:\n\nPlease provide:\n1. Your specific question or problem\n2. Any relevant code you're working with\n3. Error messages (if applicable)\n4. What you've already tried\n\n**Please go ahead and ask your Java question, and I'll be happy to help!** \ud83d\ude0a",
    "expected": "    addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        int col = e.getX() / CELL_SIZE;\n        int row = e.getY() / CELL_SIZE;\n        if (row >= 0 && row < 3 && col >= 0 && col < 3) {\n          controller.handleCellClick(row, col);\n          repaint();\n        }\n      }\n    });\n  }\n\n  @Override\n  protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n\n    // Draw grid lines\n    g.setColor(Color.BLACK);\n    for (int i = 1; i < 3; i++) {\n      g.drawLine(i * CELL_SIZE, 0, i * CELL_SIZE, 3 * CELL_SIZE);\n      g.drawLine(0, i * CELL_SIZE, 3 * CELL_SIZE, i * CELL_SIZE);\n    }\n\n    // Draw pieces\n    for (int row = 0; row < 3; row++) {\n      for (int col = 0; col < 3; col++) {\n        Player p = model.getPieceAt(row, col);\n        if (p == Player.X) {\n          drawX(g, row, col);\n        } else if (p == Player.O) {\n          drawO(g, row, col);\n        }\n      }\n    }"
  },
  {
    "id": "fim_hard_009",
    "type": "fim_hard",
    "topic": "observer",
    "correct": false,
    "score": 0.2074652777777778,
    "edit_distance": 919,
    "prediction": "# Java Teaching Assistant\n\nHello! I'm here to help you with Java programming. I notice you haven't included a specific question yet. I can assist you with topics such as:\n\n## Common Java Topics I Can Help With:\n\n- **Basics**: Variables, data types, operators, control structures\n- **Object-Oriented Programming**: Classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Data Structures**: Arrays, ArrayLists, LinkedLists, HashMaps, Sets, etc.\n- **Exception Handling**: try-catch blocks, custom exceptions\n- **File I/O**: Reading and writing files\n- **Multithreading**: Threads, synchronization, concurrency\n- **Java Collections Framework**: Lists, Sets, Maps, Queues\n- **Lambda Expressions & Streams**: Functional programming in Java\n- **Debugging**: Help finding and fixing errors in your code\n\n## How to Ask Your Question:\n\nPlease provide:\n1. **Your specific question** or problem\n2. **Any code** you're working with (if applicable)\n3. **Error messages** you're encountering (if any)\n4. **What you've already tried** (if relevant)\n\nFeel free to ask your Java question, and I'll provide a clear, detailed explanation with examples!",
    "expected": "  public void addObserver(TicTacToeObserver observer) {\n    observers.add(Objects.requireNonNull(observer));\n  }\n\n  public void removeObserver(TicTacToeObserver observer) {\n    observers.remove(observer);\n  }\n\n  private void notifyObservers() {\n    for (TicTacToeObserver obs : observers) {\n      obs.update(this);\n    }\n  }\n\n  @Override\n  public void move(int row, int col) {\n    delegate.move(row, col);\n    notifyObservers();\n  }\n\n  @Override\n  public Player getTurn() {\n    return delegate.getTurn();\n  }\n\n  @Override\n  public Player getWinner() {\n    return delegate.getWinner();\n  }\n\n  @Override\n  public boolean isGameOver() {\n    return delegate.isGameOver();\n  }\n\n  @Override\n  public Player getPieceAt(int row, int col) {\n    return delegate.getPieceAt(row, col);\n  }"
  },
  {
    "id": "fim_hard_010",
    "type": "fim_hard",
    "topic": "command",
    "correct": false,
    "score": 0.20308483290488433,
    "edit_distance": 932,
    "prediction": "# Java Teaching Assistant\n\nI'm here to help you with Java programming! However, I notice you haven't included a specific question yet. I can assist you with topics such as:\n\n## Common Java Topics I Can Help With:\n\n- **Basics**: Variables, data types, operators, control structures\n- **Object-Oriented Programming**: Classes, objects, inheritance, polymorphism, encapsulation, abstraction\n- **Collections**: ArrayList, HashMap, HashSet, LinkedList, etc.\n- **Exception Handling**: try-catch blocks, custom exceptions\n- **File I/O**: Reading/writing files, streams\n- **Multithreading**: Threads, synchronization, concurrency\n- **Java 8+ Features**: Lambda expressions, streams, optional\n- **Data Structures**: Arrays, linked lists, stacks, queues, trees\n- **Algorithms**: Sorting, searching, recursion\n- **Best Practices**: Code organization, naming conventions, design patterns\n\n## How to Ask Your Question:\n\nPlease provide:\n1. Your specific question or problem\n2. Any relevant code you're working with\n3. Error messages (if applicable)\n4. What you've already tried\n\n**Feel free to ask your Java question, and I'll provide a clear, detailed explanation with examples!**",
    "expected": "  public void executeCommand(TurtleCommand command) {\n    command.execute();\n    undoStack.push(command);\n    redoStack.clear(); // Clear redo stack on new command\n  }\n\n  public boolean canUndo() {\n    return !undoStack.isEmpty();\n  }\n\n  public boolean canRedo() {\n    return !redoStack.isEmpty();\n  }\n\n  public void undo() {\n    if (!canUndo()) {\n      throw new IllegalStateException(\"Nothing to undo\");\n    }\n    TurtleCommand command = undoStack.pop();\n    command.undo();\n    redoStack.push(command);\n  }\n\n  public void redo() {\n    if (!canRedo()) {\n      throw new IllegalStateException(\"Nothing to redo\");\n    }\n    TurtleCommand command = redoStack.pop();\n    command.execute();\n    undoStack.push(command);\n  }\n\n  public void clear() {\n    undoStack.clear();\n    redoStack.clear();\n  }"
  },
  {
    "id": "sa_001",
    "type": "short_answer",
    "topic": "adapter",
    "correct": false,
    "score": 0.0,
    "edit_distance": 2247,
    "prediction": "# Why Object Adapter is Necessary for Enumeration to Iterator\n\n## The Problem with Class Adapter\n\nA **class adapter** uses multiple inheritance to adapt one interface to another. In Java, you would need something like:\n\n```java\n// This is IMPOSSIBLE in Java!\npublic class EnumerationIterator \n    extends ExistingEnumerationClass  // inherit implementation\n    implements Iterator {              // adapt to new interface\n    // ...\n}\n```\n\n**This approach fails because:**\n\n1. **Java doesn't support multiple inheritance of classes** - You can only extend one class\n2. **The existing Enumeration class is already defined** - You cannot modify its inheritance hierarchy\n3. **You cannot inherit from both the existing class AND provide Iterator behavior simultaneously**\n\n## Why Object Adapter Works\n\nAn **object adapter** uses composition instead of inheritance:\n\n```java\npublic class EnumerationIterator implements Iterator {\n    private Enumeration enumeration;  // Composition - holds reference\n    \n    public EnumerationIterator(Enumeration enumeration) {\n        this.enumeration = enumeration;\n    }\n    \n    @Override\n    public boolean hasNext() {\n        return enumeration.hasMoreElements();\n    }\n    \n    @Override\n    public Object next() {\n        return enumeration.nextElement();\n    }\n    \n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException();\n    }\n}\n```\n\n## Key Advantages\n\n| Aspect | Object Adapter | Class Adapter |\n|--------|---------------|---------------|\n| **Java Compatibility** | \u2705 Works (uses composition) | \u274c Requires multiple inheritance |\n| **Flexibility** | Can adapt ANY Enumeration instance at runtime | Locked to one specific class |\n| **Existing Objects** | Can wrap already-created objects | Cannot adapt existing instances |\n\n## Practical Example\n\n```java\n// Object adapter can work with any Enumeration implementation\nVector vector = new Vector();\nvector.add(\"A\");\nvector.add(\"B\");\n\n// Adapt the existing Enumeration to Iterator\nEnumeration enumeration = vector.elements();\nIterator iterator = new EnumerationIterator(enumeration);\n\nwhile (iterator.hasNext()) {\n    System.out.println(iterator.next());\n}\n```\n\n## Conclusion\n\nThe object adapter is **necessary** (not just preferred) because Java's single inheritance limitation makes class adapters impossible when you need to both extend an existing class and implement a new interface. Composition provides the flexibility to adapt any Enumeration instance to the Iterator interface at runtime.",
    "expected": "Since the Enumeration-implementing class already exists and cannot be modified, we cannot make it extend an adapter class. An object adapter wraps instances of the existing class through composition, delegating hasNext() to hasMoreElements() and next() to nextElement(), without requiring changes to the adaptee's class hierarchy."
  },
  {
    "id": "sa_002",
    "type": "short_answer",
    "topic": "adapter",
    "correct": false,
    "score": 0.0,
    "edit_distance": 1253,
    "prediction": "# Implementing IntSet1's add() Using IntSet2 Operations\n\nIn a two-way adapter, you need to implement IntSet1's `add(int value)` method using an underlying IntSet2 object. Here's how:\n\n## The Key Difference\n\n- **IntSet1's `add(int value)`**: Returns `void` (no return value)\n- **IntSet2's `add(int value)`**: Returns `boolean` (true if added, false if already present)\n\n## Implementation\n\n```java\npublic class TwoWayAdapter implements IntSet1, IntSet2 {\n    private IntSet2 adaptee;  // The underlying IntSet2 object\n    \n    public TwoWayAdapter(IntSet2 adaptee) {\n        this.adaptee = adaptee;\n    }\n    \n    // Implementing IntSet1's add method\n    @Override\n    public void add(int value) {\n        adaptee.add(value);  // Call IntSet2's add, ignore return value\n    }\n    \n    // Implementing IntSet2's add method (direct delegation)\n    @Override\n    public boolean add(int value) {\n        return adaptee.add(value);\n    }\n}\n```\n\n## Explanation\n\n1. **Simply delegate to IntSet2's add()**: Call the underlying `adaptee.add(value)`\n2. **Ignore the boolean return value**: Since IntSet1's version returns void, we discard the boolean result\n3. **The operation is semantically equivalent**: Both methods add the value to the set (if not already present)\n\n## Why This Works\n\n- Both methods perform the same core operation: adding an element to the set\n- The only difference is the return type\n- IntSet1 doesn't need the success/failure information, so we can safely ignore it",
    "expected": "The add(int value) method can be implemented by calling adaptee.unionWith(IntSet2Impl.singleton(value)). This creates a singleton set containing just the value to add, then unions it with the existing set. The unionWith operation adds all elements from the parameter set to this set."
  },
  {
    "id": "sa_003",
    "type": "short_answer",
    "topic": "adapter",
    "correct": false,
    "score": 0.25,
    "edit_distance": 2319,
    "prediction": "# Implementing `remove()` When Adapting Enumeration to Iterator\n\n## The Appropriate Implementation\n\nWhen adapting `Enumeration` to `Iterator`, the `remove()` method should **throw `UnsupportedOperationException`**:\n\n```java\npublic class EnumerationIterator<E> implements Iterator<E> {\n    private final Enumeration<E> enumeration;\n    \n    public EnumerationIterator(Enumeration<E> enumeration) {\n        this.enumeration = enumeration;\n    }\n    \n    @Override\n    public boolean hasNext() {\n        return enumeration.hasMoreElements();\n    }\n    \n    @Override\n    public E next() {\n        return enumeration.nextElement();\n    }\n    \n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException(\n            \"Remove not supported for Enumeration adapter\");\n    }\n}\n```\n\n## Why This Approach?\n\n### 1. **Enumeration Doesn't Support Removal**\n- `Enumeration` only has two methods: `hasMoreElements()` and `nextElement()`\n- There's no removal capability in the original interface\n- You cannot implement functionality that doesn't exist in the adaptee\n\n### 2. **Maintains the Adapter Pattern Contract**\n```java\n// The adapter can only expose what Enumeration provides\nEnumeration<String> enum = vector.elements();\nIterator<String> iter = new EnumerationIterator<>(enum);\n\n// This properly indicates the limitation:\niter.remove(); // throws UnsupportedOperationException\n```\n\n### 3. **Follows Iterator Contract**\nThe `Iterator` interface explicitly allows `remove()` to throw `UnsupportedOperationException` for optional operations:\n\n```java\n/**\n * Removes from the underlying collection the last element \n * returned by this iterator (optional operation).\n * \n * @throws UnsupportedOperationException if the remove\n *         operation is not supported by this iterator\n */\ndefault void remove() {\n    throw new UnsupportedOperationException(\"remove\");\n}\n```\n\n## Real-World Example\n\n```java\nVector<String> vector = new Vector<>(Arrays.asList(\"A\", \"B\", \"C\"));\nEnumeration<String> enumeration = vector.elements();\nIterator<String> iterator = new EnumerationIterator<>(enumeration);\n\n// Read operations work fine:\nwhile (iterator.hasNext()) {\n    System.out.println(iterator.next());\n}\n\n// But removal is not supported:\ntry {\n    iterator.remove();\n} catch (UnsupportedOperationException e) {\n    System.out.println(\"Remove not supported: \" + e.getMessage());\n}\n```\n\n## Key Principle\n\n**An adapter cannot add functionality that doesn't exist in the adaptee.** It can only translate existing functionality to a different interface. Since `Enumeration` is read-only, the adapted `Iterator` must also be read-only.",
    "expected": "Throw UnsupportedOperationException because Enumeration has no concept of removal - it only supports hasMoreElements() and nextElement(). The Iterator interface documentation specifies that remove() may throw this exception when the underlying structure doesn't support removal. The default implementation in Iterator already throws this exception."
  },
  {
    "id": "sa_004",
    "type": "short_answer",
    "topic": "mvc",
    "correct": true,
    "score": 0.5,
    "edit_distance": 1779,
    "prediction": "# Why Use Readable and Appendable Parameters\n\n## The Problem with Hardcoding System.in and System.out\n\n```java\n// \u274c BAD: Tightly coupled to console I/O\npublic class TicTacToeConsoleController {\n    private Scanner scanner;\n    \n    public TicTacToeConsoleController() {\n        this.scanner = new Scanner(System.in);\n        // Output directly to System.out\n    }\n}\n```\n\n## The Better Approach\n\n```java\n// \u2705 GOOD: Flexible and testable\npublic class TicTacToeConsoleController {\n    private Scanner scanner;\n    private Appendable out;\n    \n    public TicTacToeConsoleController(Readable input, Appendable output) {\n        this.scanner = new Scanner(input);\n        this.out = output;\n    }\n}\n```\n\n## Key Benefits\n\n### 1. **Testability**\nYou can test without actual console interaction:\n\n```java\n@Test\npublic void testGameFlow() {\n    StringReader input = new StringReader(\"1 1\\n2 2\\n3 3\\n\");\n    StringBuilder output = new StringBuilder();\n    \n    TicTacToeConsoleController controller = \n        new TicTacToeConsoleController(input, output);\n    \n    controller.playGame();\n    \n    // Verify output without console\n    assertTrue(output.toString().contains(\"Player X wins!\"));\n}\n```\n\n### 2. **Flexibility**\nSupport different I/O sources:\n- Files\n- Network streams\n- String buffers\n- GUI components\n\n```java\n// Read from file, write to file\nFileReader input = new FileReader(\"moves.txt\");\nFileWriter output = new FileWriter(\"game-log.txt\");\nTicTacToeConsoleController controller = \n    new TicTacToeConsoleController(input, output);\n```\n\n### 3. **Dependency Injection**\nFollows SOLID principles by inverting dependencies\u2014the controller doesn't decide where I/O comes from.\n\n### 4. **Isolation**\nUnit tests run independently without side effects to the console, making them faster and more reliable.\n\n## Summary\n\nUsing `Readable` and `Appendable` parameters creates **loosely coupled, testable, and flexible** code, while hardcoding `System.in/out` creates **rigid, untestable** code that's difficult to work with in automated testing environments.",
    "expected": "Accepting Readable and Appendable enables dependency injection, allowing the controller to be tested without actual console I/O. Tests can pass StringReader with predetermined input and StringBuilder to capture output, enabling automated verification of controller behavior. This decouples the controller from specific I/O implementations."
  },
  {
    "id": "sa_005",
    "type": "short_answer",
    "topic": "mvc",
    "correct": false,
    "score": 0.0,
    "edit_distance": 2775,
    "prediction": "# MVC Responsibilities in a TicTacToe Game\n\nWhen a user clicks a cell in a graphical TicTacToe game, here's how each MVC component should handle the interaction:\n\n## **View** \n**Responsibility: Detect and forward user input**\n\n- Detects the mouse click event on a cell\n- Determines which cell was clicked (e.g., row 2, column 1)\n- Notifies the Controller of the user action\n- Does NOT decide if the move is valid or update game state\n\n```java\n// View example\npublic class TicTacToeView extends JPanel {\n    private TicTacToeController controller;\n    \n    public TicTacToeView(TicTacToeController controller) {\n        this.controller = controller;\n        addMouseListener(new MouseAdapter() {\n            public void mouseClicked(MouseEvent e) {\n                int row = e.getY() / CELL_SIZE;\n                int col = e.getX() / CELL_SIZE;\n                controller.handleCellClick(row, col); // Forward to controller\n            }\n        });\n    }\n}\n```\n\n## **Controller**\n**Responsibility: Coordinate the interaction**\n\n- Receives the click notification from the View\n- Asks the Model to process the move\n- Handles the response (success/failure)\n- Tells the View to update if needed\n\n```java\n// Controller example\npublic class TicTacToeController {\n    private TicTacToeModel model;\n    private TicTacToeView view;\n    \n    public void handleCellClick(int row, int col) {\n        boolean moveSuccessful = model.makeMove(row, col);\n        \n        if (moveSuccessful) {\n            view.refresh(); // Tell view to update display\n            \n            if (model.hasWinner()) {\n                view.displayWinner(model.getWinner());\n            }\n        } else {\n            view.showInvalidMoveMessage();\n        }\n    }\n}\n```\n\n## **Model**\n**Responsibility: Manage game logic and state**\n\n- Validates if the move is legal (cell empty, game not over)\n- Updates the game state (board array, current player)\n- Checks for win conditions or draw\n- Returns success/failure to Controller\n- Does NOT know anything about the View or user interface\n\n```java\n// Model example\npublic class TicTacToeModel {\n    private char[][] board = new char[3][3];\n    private char currentPlayer = 'X';\n    \n    public boolean makeMove(int row, int col) {\n        // Validate move\n        if (row < 0 || row > 2 || col < 0 || col > 2) return false;\n        if (board[row][col] != '\\0') return false;\n        if (hasWinner()) return false;\n        \n        // Update state\n        board[row][col] = currentPlayer;\n        currentPlayer = (currentPlayer == 'X') ? 'O' : 'X';\n        return true;\n    }\n    \n    public boolean hasWinner() { /* check logic */ }\n    public char getWinner() { /* return winner */ }\n}\n```\n\n## **Summary Flow**\n\n1. **View** detects click \u2192 extracts cell coordinates\n2. **Controller** receives coordinates \u2192 asks Model to process\n3. **Model** validates \u2192 updates state \u2192 returns result\n4. **Controller** receives result \u2192 instructs View to update\n5. **View** redraws itself based on current Model state\n\n**Key Principle**: The Model should never depend on the View, and business logic stays completely in the Model.",
    "expected": "Controller: Receives the click event from the View, translates pixel coordinates to board position (row, col), validates the move is legal, and calls the Model's move method. Model: Updates game state (board, current player, win condition), notifies observers of state change. View: Observes Model changes and repaints the board to reflect the new state, without direct Controller involvement in display updates."
  },
  {
    "id": "sa_006",
    "type": "short_answer",
    "topic": "mvc",
    "correct": false,
    "score": 0.0,
    "edit_distance": 1856,
    "prediction": "# Why Controllers Catch IOException and Throw IllegalStateException\n\nThis is a common design pattern in MVC controllers, particularly in frameworks like Java Swing and when working with views. Here's why:\n\n## 1. **Contract Violation Indicates Programming Error**\n\nWhen a controller writes to a view (typically a `StringBuilder`, `StringBuffer`, or GUI component wrapped as `Appendable`), **IOException should never occur** under normal circumstances:\n\n```java\n// These common Appendables don't throw IOException in practice:\nStringBuilder sb = new StringBuilder();  // In-memory, can't fail\nStringWriter sw = new StringWriter();    // In-memory, can't fail\n```\n\nIf an `IOException` *does* occur, it indicates:\n- The view was incorrectly configured\n- An unexpected implementation was used\n- The system is in an invalid state\n\n## 2. **Simplifies Client Code**\n\nControllers expose a cleaner API to users:\n\n```java\n// Without conversion - forces all callers to handle IOException\npublic void renderGame() throws IOException { ... }\n\n// With conversion - cleaner for callers\npublic void renderGame() throws IllegalStateException { ... }\n```\n\nCallers don't need to handle checked exceptions for what is essentially a programming bug.\n\n## 3. **Semantic Accuracy**\n\n- **IOException** = \"Something went wrong with I/O operations\" (expected in file/network operations)\n- **IllegalStateException** = \"The object is in an inappropriate state\" (programming error)\n\n```java\npublic void renderGame() {\n    try {\n        view.append(\"Game: \" + model.getState());\n    } catch (IOException e) {\n        // This shouldn't happen with proper view implementations\n        throw new IllegalStateException(\"Failed to write to view\", e);\n    }\n}\n```\n\n## 4. **Following Framework Conventions**\n\nThis pattern aligns with established Java practices where **runtime exceptions indicate programming errors** that shouldn't be caught, while **checked exceptions indicate recoverable conditions**.\n\n---\n\n**In summary:** It converts an impossible/unexpected checked exception into an unchecked exception that better represents the true nature of the error\u2014a violated precondition or programming mistake.",
    "expected": "IOException is a checked exception that would force all callers to handle I/O failures, which is inappropriate for game logic. An IOException during output represents an unrecoverable state (output stream failed), so wrapping it in IllegalStateException (unchecked) signals that the program cannot continue normally. This keeps the Controller's interface clean while properly signaling catastrophic failure."
  },
  {
    "id": "sa_007",
    "type": "short_answer",
    "topic": "observer",
    "correct": false,
    "score": 0.25,
    "edit_distance": 3716,
    "prediction": "# Observer Pattern: Infinite Recursion Scenario and Prevention\n\n## Scenario Leading to Infinite Recursion\n\nInfinite recursion in the Observer pattern typically occurs when **observers modify the subject they're observing**, creating a circular notification chain.\n\n### Example Scenario\n\n```java\n// A problematic implementation\nclass TemperatureDisplay implements Observer {\n    private WeatherStation station;\n    \n    public TemperatureDisplay(WeatherStation station) {\n        this.station = station;\n        station.attach(this);\n    }\n    \n    @Override\n    public void update(float temperature) {\n        System.out.println(\"Temperature: \" + temperature);\n        \n        // PROBLEM: Observer modifies the subject\n        if (temperature > 100) {\n            station.setTemperature(100); // This triggers another notification!\n        }\n    }\n}\n\nclass WeatherStation {\n    private List<Observer> observers = new ArrayList<>();\n    private float temperature;\n    \n    public void setTemperature(float temp) {\n        this.temperature = temp;\n        notifyObservers(); // Notifies all observers\n    }\n    \n    private void notifyObservers() {\n        for (Observer observer : observers) {\n            observer.update(temperature);\n        }\n    }\n}\n\n// Usage that causes infinite recursion:\nWeatherStation station = new WeatherStation();\nTemperatureDisplay display = new TemperatureDisplay(station);\nstation.setTemperature(105); // Triggers infinite loop!\n```\n\n**What happens:**\n1. `setTemperature(105)` is called\n2. `display.update(105)` is called\n3. Inside update, `setTemperature(100)` is called\n4. This triggers `display.update(100)` again\n5. Loop continues indefinitely \u2192 **StackOverflowError**\n\n## Prevention Strategies\n\n### 1. **State Change Detection (Recommended)**\n\nOnly notify observers if the state actually changes:\n\n```java\nclass WeatherStation {\n    private List<Observer> observers = new ArrayList<>();\n    private float temperature;\n    \n    public void setTemperature(float temp) {\n        // Only notify if value actually changes\n        if (this.temperature != temp) {\n            this.temperature = temp;\n            notifyObservers();\n        }\n    }\n    \n    private void notifyObservers() {\n        for (Observer observer : observers) {\n            observer.update(temperature);\n        }\n    }\n    \n    public void attach(Observer observer) {\n        observers.add(observer);\n    }\n}\n```\n\n### 2. **Notification Lock/Flag**\n\nPrevent recursive notifications using a flag:\n\n```java\nclass WeatherStation {\n    private List<Observer> observers = new ArrayList<>();\n    private float temperature;\n    private boolean isNotifying = false; // Guard flag\n    \n    public void setTemperature(float temp) {\n        if (isNotifying) {\n            return; // Prevent recursive notifications\n        }\n        \n        this.temperature = temp;\n        notifyObservers();\n    }\n    \n    private void notifyObservers() {\n        isNotifying = true;\n        try {\n            for (Observer observer : observers) {\n                observer.update(temperature);\n            }\n        } finally {\n            isNotifying = false; // Always reset\n        }\n    }\n    \n    public void attach(Observer observer) {\n        observers.add(observer);\n    }\n}\n```\n\n### 3. **Deferred Updates with Event Queue**\n\nDecouple notifications from updates:\n\n```java\nclass WeatherStation {\n    private List<Observer> observers = new ArrayList<>();\n    private float temperature;\n    private Queue<Float> pendingUpdates = new LinkedList<>();\n    private boolean isProcessing = false;\n    \n    public void setTemperature(float temp) {\n        pendingUpdates.offer(temp);\n        processUpdates();\n    }\n    \n    private void processUpdates() {\n        if (isProcessing) {\n            return; // Already processing\n        }\n        \n        isProcessing = true;\n        try {\n            while (!pendingUpdates.isEmpty()) {\n                Float temp = pendingUpdates.poll();\n                if (this.temperature != temp) {\n                    this.temperature = temp;",
    "expected": "If an Observer's update() method modifies the Subject it's observing, and that modification triggers notifyObservers() again, infinite recursion occurs. Prevention strategies include: using a flag to track if notification is in progress and skipping re-notification, queuing changes to be processed after current notification completes, or designing observers to not modify subjects during updates."
  },
  {
    "id": "sa_008",
    "type": "short_answer",
    "topic": "decorator",
    "correct": false,
    "score": 0.0,
    "edit_distance": 3425,
    "prediction": "# JScrollPane as a Decorator Pattern Example\n\n## How JScrollPane Demonstrates the Decorator Pattern\n\nJScrollPane is a classic example of the Decorator pattern in Java Swing. Here's how it works:\n\n### Basic Structure\n\n```java\n// Base component (can be any JComponent)\nJTextArea textArea = new JTextArea(10, 30);\n\n// Decorator wrapping the component\nJScrollPane scrollPane = new JScrollPane(textArea);\n\n// Add to frame\nframe.add(scrollPane);\n```\n\n### Key Decorator Characteristics\n\n1. **Same Interface**: Both `JScrollPane` and `JTextArea` extend `JComponent`, allowing them to be treated polymorphically\n\n2. **Wraps Another Component**: JScrollPane contains and delegates to the wrapped component\n\n3. **Adds Functionality**: JScrollPane adds scrolling capability without modifying the original component\n\n```java\n// You can decorate any JComponent\nJScrollPane scrollPane1 = new JScrollPane(new JTextArea());\nJScrollPane scrollPane2 = new JScrollPane(new JTable());\nJScrollPane scrollPane3 = new JScrollPane(new JPanel());\n```\n\n## Why This Design is Beneficial\n\n### 1. **Flexibility**\n```java\n// Use component with or without scrolling\nJTextArea textArea = new JTextArea();\n\n// Without decoration\npanel1.add(textArea);\n\n// With decoration\npanel2.add(new JScrollPane(textArea));\n```\n\n### 2. **Single Responsibility**\n- `JTextArea` focuses on text editing\n- `JScrollPane` focuses on scrolling\n- Each class has one clear purpose\n\n### 3. **Open/Closed Principle**\n```java\n// Add scrolling without modifying JTextArea's code\n// JTextArea remains closed for modification, open for extension\n```\n\n### 4. **Composition Over Inheritance**\n```java\n// Instead of creating:\n// ScrollableTextArea extends JTextArea\n// ScrollableTable extends JTable\n// ScrollablePanel extends JPanel\n// ...\n\n// We have one decorator that works with all components:\nnew JScrollPane(anyJComponent);\n```\n\n### 5. **Stackable Decorators**\n```java\n// Can combine multiple decorators\nJTextArea textArea = new JTextArea();\nJScrollPane scrollPane = new JScrollPane(textArea);\n\n// Add border decoration\nscrollPane.setBorder(BorderFactory.createTitledBorder(\"Editor\"));\n\n// Wrap in another panel if needed\nJPanel decoratedPanel = new JPanel();\ndecoratedPanel.add(scrollPane);\n```\n\n### 6. **Runtime Configuration**\n```java\n// Configure scrolling behavior at runtime\nJScrollPane scrollPane = new JScrollPane(textArea);\n\nscrollPane.setVerticalScrollBarPolicy(\n    JScrollPane.VERTICAL_SCROLLBAR_ALWAYS\n);\nscrollPane.setHorizontalScrollBarPolicy(\n    JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED\n);\n```\n\n## Real-World Example\n\n```java\npublic class TextEditorExample {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"Decorator Pattern Demo\");\n        \n        // Core component - unchanged\n        JTextArea textArea = new JTextArea(20, 40);\n        textArea.setText(\"This text area has scrolling capability\\n\" +\n                        \"added through decoration, not inheritance.\");\n        \n        // Decorate with scrolling\n        JScrollPane scrollPane = new JScrollPane(textArea);\n        \n        // Further customize the decorator\n        scrollPane.setBorder(\n            BorderFactory.createTitledBorder(\"Scrollable Text Editor\")\n        );\n        \n        frame.add(scrollPane);\n        frame.pack();\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setVisible(true);\n    }\n}\n```\n\n## Benefits Summary\n\n| Benefit | Description |\n|---------|-------------|\n| **Reusability** | One JScrollPane class works with any JComponent |\n| **Maintainability** | Changes to scrolling logic stay in JScrollPane |\n| **Testability** | Can test components independently of scrolling |\n| **Flexibility** | Add/remove scrolling without code changes |\n| **Scalability** | Easy to add new decorators",
    "expected": "JScrollPane wraps another component (like JPanel) and adds scrollbar functionality while delegating core behavior to the wrapped component. Benefits include: composition over inheritance (any JComponent can be scrolled), multiple decorators can be combined (JScrollPane around JBorderPane around JPanel), and single responsibility (each decorator adds one feature). The wrapped component doesn't need to know it's being decorated."
  },
  {
    "id": "sa_009",
    "type": "short_answer",
    "topic": "decorator",
    "correct": false,
    "score": 0.0,
    "edit_distance": 3154,
    "prediction": "# Decorator Pattern vs. Inheritance\n\n## Key Distinctions\n\n### **1. Flexibility**\n- **Inheritance**: Static, compile-time binding. You must know all combinations upfront.\n- **Decorator**: Dynamic, runtime composition. Mix and match behaviors on the fly.\n\n### **2. Class Explosion Problem**\n- **Inheritance**: Combinatorial explosion of subclasses\n- **Decorator**: Single decorator classes combined flexibly\n\n## Illustrative Example\n\n```java\n// \u274c INHERITANCE APPROACH - Class Explosion\nclass Coffee { }\nclass CoffeeWithMilk extends Coffee { }\nclass CoffeeWithSugar extends Coffee { }\nclass CoffeeWithMilkAndSugar extends Coffee { }\nclass CoffeeWithMilkAndSugarAndWhip extends Coffee { }\n// Need n! classes for n combinations!\n\n// \u2705 DECORATOR APPROACH - Flexible Composition\ninterface Coffee {\n    double cost();\n    String description();\n}\n\nclass SimpleCoffee implements Coffee {\n    public double cost() { return 2.0; }\n    public String description() { return \"Simple coffee\"; }\n}\n\n// Base decorator\nabstract class CoffeeDecorator implements Coffee {\n    protected Coffee decoratedCoffee;\n    \n    public CoffeeDecorator(Coffee coffee) {\n        this.decoratedCoffee = coffee;\n    }\n}\n\n// Concrete decorators\nclass MilkDecorator extends CoffeeDecorator {\n    public MilkDecorator(Coffee coffee) {\n        super(coffee);\n    }\n    \n    public double cost() {\n        return decoratedCoffee.cost() + 0.5;\n    }\n    \n    public String description() {\n        return decoratedCoffee.description() + \", milk\";\n    }\n}\n\nclass SugarDecorator extends CoffeeDecorator {\n    public SugarDecorator(Coffee coffee) {\n        super(coffee);\n    }\n    \n    public double cost() {\n        return decoratedCoffee.cost() + 0.2;\n    }\n    \n    public String description() {\n        return decoratedCoffee.description() + \", sugar\";\n    }\n}\n\nclass WhipDecorator extends CoffeeDecorator {\n    public WhipDecorator(Coffee coffee) {\n        super(coffee);\n    }\n    \n    public double cost() {\n        return decoratedCoffee.cost() + 0.7;\n    }\n    \n    public String description() {\n        return decoratedCoffee.description() + \", whip\";\n    }\n}\n\n// Usage - Runtime composition\nCoffee coffee = new SimpleCoffee();\ncoffee = new MilkDecorator(coffee);\ncoffee = new SugarDecorator(coffee);\ncoffee = new WhipDecorator(coffee);\n\nSystem.out.println(coffee.description()); // \"Simple coffee, milk, sugar, whip\"\nSystem.out.println(coffee.cost());        // 3.4\n```\n\n## When to Choose Decorator Over Inheritance\n\n### **Choose Decorator When:**\n\n1. **Need runtime flexibility**\n   ```java\n   // Configure based on user input\n   Coffee coffee = new SimpleCoffee();\n   if (userWantsMilk) coffee = new MilkDecorator(coffee);\n   if (userWantsSugar) coffee = new SugarDecorator(coffee);\n   ```\n\n2. **Many optional features/combinations**\n   - Adding responsibilities to individual objects, not entire class\n   - Avoiding subclass explosion\n\n3. **Open/Closed Principle**\n   ```java\n   // Add new decorator without modifying existing code\n   class CaramelDecorator extends CoffeeDecorator {\n       // New behavior added easily\n   }\n   ```\n\n4. **Need to add/remove responsibilities dynamically**\n   ```java\n   Coffee coffee = new SimpleCoffee();\n   coffee = new MilkDecorator(coffee);\n   // Can \"unwrap\" or change decorators at runtime\n   ```\n\n### **Choose Inheritance When:**\n\n1. **IS-A relationship is fundamental**\n   ```java\n   class Dog extends Animal // Dog IS-AN Animal\n   ```\n\n2. **Behavior is fixed and known at compile-time**\n\n3. **Need to override core",
    "expected": "Decorator uses composition: a decorator implements the same interface as the component and holds a reference to a component instance, forwarding calls while adding behavior. Unlike inheritance, decorators can be combined dynamically at runtime, can wrap any implementation of the interface, and avoid class explosion from combinatorial feature combinations. Choose Decorator when features should be composable or when you can't modify the class hierarchy."
  },
  {
    "id": "sa_010",
    "type": "short_answer",
    "topic": "strategy",
    "correct": false,
    "score": 0.0,
    "edit_distance": 3460,
    "prediction": "# TicTacToeStrategy Interface Design\n\n## Core Interface Design\n\n```java\npublic interface TicTacToeStrategy {\n    /**\n     * Selects the best move for the current player.\n     *\n     * @param board Current game board state\n     * @param player The player (X or O) making the move\n     * @return Position object representing the chosen move (row, col)\n     * @throws IllegalStateException if no valid moves are available\n     */\n    Position selectMove(Board board, Player player);\n}\n```\n\n## Supporting Classes\n\n```java\npublic class Position {\n    private final int row;\n    private final int col;\n    \n    public Position(int row, int col) {\n        this.row = row;\n        this.col = col;\n    }\n    \n    public int getRow() { return row; }\n    public int getCol() { return col; }\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Position)) return false;\n        Position position = (Position) o;\n        return row == position.row && col == position.col;\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(row, col);\n    }\n}\n\npublic enum Player {\n    X, O;\n    \n    public Player opponent() {\n        return this == X ? O : X;\n    }\n}\n\npublic interface Board {\n    /**\n     * @return 2D array representing the board state\n     */\n    Player[][] getState();\n    \n    /**\n     * @return List of all valid empty positions\n     */\n    List<Position> getAvailableMoves();\n    \n    /**\n     * @return true if the game has ended\n     */\n    boolean isGameOver();\n    \n    /**\n     * @return the winning player, or null if no winner yet\n     */\n    Player getWinner();\n    \n    /**\n     * Creates a copy of the board with the move applied\n     */\n    Board makeMove(Position position, Player player);\n    \n    /**\n     * @return board dimensions (typically 3 for standard Tic-Tac-Toe)\n     */\n    int getSize();\n}\n```\n\n## Example Strategy Implementations\n\n```java\n/**\n * Random move selection strategy\n */\npublic class RandomStrategy implements TicTacToeStrategy {\n    private final Random random = new Random();\n    \n    @Override\n    public Position selectMove(Board board, Player player) {\n        List<Position> availableMoves = board.getAvailableMoves();\n        \n        if (availableMoves.isEmpty()) {\n            throw new IllegalStateException(\"No available moves\");\n        }\n        \n        return availableMoves.get(random.nextInt(availableMoves.size()));\n    }\n}\n\n/**\n * Minimax algorithm with alpha-beta pruning\n */\npublic class MinimaxStrategy implements TicTacToeStrategy {\n    private static final int MAX_DEPTH = 9;\n    \n    @Override\n    public Position selectMove(Board board, Player player) {\n        List<Position> availableMoves = board.getAvailableMoves();\n        \n        if (availableMoves.isEmpty()) {\n            throw new IllegalStateException(\"No available moves\");\n        }\n        \n        Position bestMove = null;\n        int bestScore = Integer.MIN_VALUE;\n        \n        for (Position move : availableMoves) {\n            Board newBoard = board.makeMove(move, player);\n            int score = minimax(newBoard, 0, false, player, \n                              Integer.MIN_VALUE, Integer.MAX_VALUE);\n            \n            if (score > bestScore) {\n                bestScore = score;\n                bestMove = move;\n            }\n        }\n        \n        return bestMove;\n    }\n    \n    private int minimax(Board board, int depth, boolean isMaximizing, \n                       Player aiPlayer, int alpha, int beta) {\n        if (board.isGameOver() || depth == MAX_DEPTH) {\n            return evaluateBoard(board, aiPlayer, depth);\n        }\n        \n        Player currentPlayer = isMaximizing ? aiPlayer : aiPlayer.opponent();\n        \n        if",
    "expected": "Interface should have: Coord chooseMove(TicTacToeModel model, Piece forWhom). The model parameter provides access to board state (which cells are occupied, whose turn it is, if game is over). The forWhom parameter specifies which player the strategy is choosing for, necessary because the same strategy instance might be used for both players or we need to evaluate from a specific player's perspective."
  },
  {
    "id": "sa_011",
    "type": "short_answer",
    "topic": "strategy",
    "correct": false,
    "score": 0.25,
    "edit_distance": 3404,
    "prediction": "# Strategy Pattern and Function Objects in Java\n\n## The Relationship\n\nThe **Strategy pattern** and **function objects** are closely related concepts:\n\n- **Function objects** (also called functors) are objects whose primary purpose is to encapsulate a single behavior/algorithm\n- The **Strategy pattern** uses function objects to make algorithms interchangeable at runtime\n- Each strategy implementation IS a function object representing a specific algorithm\n\n## Traditional Implementation (Pre-Java 8)\n\n```java\n// Strategy interface\ninterface PaymentStrategy {\n    void pay(double amount);\n}\n\n// Concrete strategies (function objects)\nclass CreditCardStrategy implements PaymentStrategy {\n    private String cardNumber;\n    \n    public CreditCardStrategy(String cardNumber) {\n        this.cardNumber = cardNumber;\n    }\n    \n    @Override\n    public void pay(double amount) {\n        System.out.println(\"Paid $\" + amount + \" with credit card: \" + cardNumber);\n    }\n}\n\nclass PayPalStrategy implements PaymentStrategy {\n    private String email;\n    \n    public PayPalStrategy(String email) {\n        this.email = email;\n    }\n    \n    @Override\n    public void pay(double amount) {\n        System.out.println(\"Paid $\" + amount + \" via PayPal: \" + email);\n    }\n}\n\n// Context\nclass ShoppingCart {\n    private PaymentStrategy paymentStrategy;\n    \n    public void setPaymentStrategy(PaymentStrategy strategy) {\n        this.paymentStrategy = strategy;\n    }\n    \n    public void checkout(double amount) {\n        paymentStrategy.pay(amount);\n    }\n}\n\n// Usage\nShoppingCart cart = new ShoppingCart();\ncart.setPaymentStrategy(new CreditCardStrategy(\"1234-5678\"));\ncart.checkout(100.0);\n```\n\n## Modern Implementation with Lambdas (Java 8+)\n\nLambdas dramatically simplify strategy implementation when strategies have **single abstract methods**:\n\n```java\n// Strategy interface (now a functional interface)\n@FunctionalInterface\ninterface PaymentStrategy {\n    void pay(double amount);\n}\n\n// Context (same as before)\nclass ShoppingCart {\n    private PaymentStrategy paymentStrategy;\n    \n    public void setPaymentStrategy(PaymentStrategy strategy) {\n        this.paymentStrategy = strategy;\n    }\n    \n    public void checkout(double amount) {\n        paymentStrategy.pay(amount);\n    }\n}\n\n// Usage with lambdas - NO separate classes needed!\nShoppingCart cart = new ShoppingCart();\n\n// Strategy as lambda\ncart.setPaymentStrategy(amount -> \n    System.out.println(\"Paid $\" + amount + \" with credit card\"));\ncart.checkout(100.0);\n\n// Another strategy as lambda\ncart.setPaymentStrategy(amount -> \n    System.out.println(\"Paid $\" + amount + \" via PayPal\"));\ncart.checkout(50.0);\n\n// Strategy with captured variables (closure)\nString cardNumber = \"1234-5678\";\ncart.setPaymentStrategy(amount -> \n    System.out.println(\"Paid $\" + amount + \" with card: \" + cardNumber));\ncart.checkout(75.0);\n```\n\n## Comparison: More Complex Example\n\n### Traditional Approach\n```java\ninterface SortStrategy {\n    void sort(int[] array);\n}\n\nclass BubbleSortStrategy implements SortStrategy {\n    @Override\n    public void sort(int[] array) {\n        // Bubble sort implementation\n        for (int i = 0; i < array.length - 1; i++) {\n            for (int j = 0; j < array.length - i - 1; j++) {\n                if (array[j] > array[j + 1]) {\n                    int temp = array[j];\n                    array[j] = array[j + 1];\n                    array[j + 1] = temp;\n                }\n            }\n        }\n    }\n}\n\nclass QuickSortStrategy implements SortStrategy {\n    @Override\n    public void sort(int[] array) {\n        quickSort(array, 0, array.length - 1);\n    }\n    \n    private void quickSort(int[] arr, int low, int high) {\n        // QuickSort implementation...",
    "expected": "Strategy pattern encapsulates an algorithm in an object - the object represents a function/behavior. In Java, a strategy interface with a single method is a functional interface, so strategies can be implemented as lambdas. Instead of creating a CornerStrategy class, you can write: (model, piece) -> findCornerMove(model). This reduces boilerplate while maintaining the pattern's flexibility."
  },
  {
    "id": "sa_012",
    "type": "short_answer",
    "topic": "command",
    "correct": false,
    "score": 0.0,
    "edit_distance": 3313,
    "prediction": "# Command Pattern for Turtle Graphics Undo Feature\n\n## Overview\n\nThe Command pattern encapsulates each turtle action as an object, allowing you to store, execute, and reverse operations. This makes implementing undo functionality straightforward and elegant.\n\n## Implementation\n\n### 1. Command Interface\n\n```java\npublic interface TurtleCommand {\n    void execute();\n    void undo();\n}\n```\n\n### 2. Turtle Class (Receiver)\n\n```java\npublic class Turtle {\n    private int x = 0;\n    private int y = 0;\n    private int direction = 0; // 0=North, 90=East, 180=South, 270=West\n    \n    public void forward(int distance) {\n        double radians = Math.toRadians(direction);\n        x += (int)(distance * Math.sin(radians));\n        y += (int)(distance * Math.cos(radians));\n        System.out.println(\"Moved to (\" + x + \", \" + y + \")\");\n    }\n    \n    public void backward(int distance) {\n        forward(-distance);\n    }\n    \n    public void turnRight(int degrees) {\n        direction = (direction + degrees) % 360;\n        System.out.println(\"Turned to direction: \" + direction);\n    }\n    \n    public void turnLeft(int degrees) {\n        turnRight(-degrees);\n    }\n    \n    public int getX() { return x; }\n    public int getY() { return y; }\n    public int getDirection() { return direction; }\n}\n```\n\n### 3. Concrete Commands\n\n```java\npublic class ForwardCommand implements TurtleCommand {\n    private Turtle turtle;\n    private int distance;\n    \n    public ForwardCommand(Turtle turtle, int distance) {\n        this.turtle = turtle;\n        this.distance = distance;\n    }\n    \n    @Override\n    public void execute() {\n        turtle.forward(distance);\n    }\n    \n    @Override\n    public void undo() {\n        turtle.backward(distance);\n    }\n}\n\npublic class TurnRightCommand implements TurtleCommand {\n    private Turtle turtle;\n    private int degrees;\n    \n    public TurnRightCommand(Turtle turtle, int degrees) {\n        this.turtle = turtle;\n        this.degrees = degrees;\n    }\n    \n    @Override\n    public void execute() {\n        turtle.turnRight(degrees);\n    }\n    \n    @Override\n    public void undo() {\n        turtle.turnLeft(degrees);\n    }\n}\n\npublic class TurnLeftCommand implements TurtleCommand {\n    private Turtle turtle;\n    private int degrees;\n    \n    public TurnLeftCommand(Turtle turtle, int degrees) {\n        this.turtle = turtle;\n        this.degrees = degrees;\n    }\n    \n    @Override\n    public void execute() {\n        turtle.turnLeft(degrees);\n    }\n    \n    @Override\n    public void undo() {\n        turtle.turnRight(degrees);\n    }\n}\n```\n\n### 4. Command Manager (Invoker)\n\n```java\nimport java.util.Stack;\n\npublic class TurtleCommandManager {\n    private Stack<TurtleCommand> history = new Stack<>();\n    private Stack<TurtleCommand> redoStack = new Stack<>();\n    \n    public void executeCommand(TurtleCommand command) {\n        command.execute();\n        history.push(command);\n        redoStack.clear(); // Clear redo history after new command\n    }\n    \n    public void undo() {\n        if (!history.isEmpty()) {\n            TurtleCommand command = history.pop();\n            command.undo();\n            redoStack.push(command);\n            System.out.println(\"Undone last command\");\n        } else {\n            System.out.println(\"Nothing to undo\");\n        }\n    }\n    \n    public void redo() {\n        if (!redoStack.isEmpty()) {\n            TurtleCommand command = redoStack.pop();\n            command.execute();\n            history.push(command);\n            System.out.println(\"Redone command\");\n        } else {\n            System.out.println(\"Nothing to redo\");\n        }\n    }\n    \n    public boolean canUndo()",
    "expected": "Each turtle action (move, turn) becomes a Command object storing the action and parameters. Before execution, the Command stores the turtle's current position/heading. Execute() performs the action, undo() restores the saved state. A command history stack maintains executed commands. Undo pops the last command and calls its undo(), which restores the turtle's previous state. Multiple undos work by continuing to pop and undo."
  },
  {
    "id": "sa_013",
    "type": "short_answer",
    "topic": "command",
    "correct": false,
    "score": 0.0,
    "edit_distance": 1727,
    "prediction": "# Comparing save()/restore() with Command Pattern\n\n## No, they are **not** the same pattern, though they share some similarities.\n\n## SimpleTurtle's save()/restore()\n\nThis implements the **Memento Pattern**:\n\n```java\n// Simplified example\npublic class SimpleTurtle {\n    private Stack<TurtleState> stateStack = new Stack<>();\n    \n    public void save() {\n        // Saves current position and heading\n        stateStack.push(new TurtleState(x, y, heading));\n    }\n    \n    public void restore() {\n        // Restores previous position and heading\n        TurtleState state = stateStack.pop();\n        this.x = state.getX();\n        this.y = state.getY();\n        this.heading = state.getHeading();\n    }\n}\n```\n\n**Key characteristics:**\n- Captures and stores **state snapshots**\n- Allows **reverting to previous states**\n- No concept of \"re-executing\" actions\n- State-focused, not action-focused\n\n## Command Pattern\n\n```java\npublic interface Command {\n    void execute();\n    void undo();\n}\n\npublic class MoveCommand implements Command {\n    private Turtle turtle;\n    private int distance;\n    \n    public void execute() {\n        turtle.forward(distance);\n    }\n    \n    public void undo() {\n        turtle.forward(-distance);  // Move backwards\n    }\n}\n```\n\n**Key characteristics:**\n- Encapsulates **actions/operations** as objects\n- Can **re-execute** or **undo** commands\n- Action-focused, not state-focused\n- Supports more complex undo/redo sequences\n\n## Key Differences\n\n| Aspect | save()/restore() (Memento) | Command Pattern |\n|--------|---------------------------|-----------------|\n| **Focus** | State snapshots | Operations/actions |\n| **Undo mechanism** | State restoration | Reverse operation |\n| **Memory** | Stores complete state | Stores operation details |\n| **Flexibility** | Fixed checkpoint model | Can reorder/replay commands |\n\n## Bottom Line\n\n**save()/restore()** = Memento Pattern (checkpoint system)  \n**Command Pattern** = Operation encapsulation with undo capability\n\nThey solve related but different problems!",
    "expected": "They are different patterns. save()/restore() implements a Memento-like pattern - saving complete state snapshots to a stack and restoring them. Command pattern would encapsulate each move/turn as an object with execute/undo methods. Save/restore saves checkpoints regardless of what operations occurred; Command tracks individual operations. They can complement each other but serve different purposes."
  },
  {
    "id": "sa_014",
    "type": "short_answer",
    "topic": "inheritance",
    "correct": false,
    "score": 0.25,
    "edit_distance": 3167,
    "prediction": "# The Fragile Base Class Problem\n\n## Overview\nThe **fragile base class problem** occurs when a subclass breaks due to changes in its superclass implementation, even though the subclass code itself hasn't changed. This violates encapsulation and makes inheritance risky.\n\n## Example: InstrumentedIntSet\n\n### The Base Class (IntSet)\n```java\npublic class IntSet {\n    private Set<Integer> set = new HashSet<>();\n    \n    public boolean add(Integer element) {\n        return set.add(element);\n    }\n    \n    public boolean addAll(Collection<Integer> elements) {\n        boolean modified = false;\n        for (Integer e : elements) {\n            if (add(e)) {  // Internally calls add()\n                modified = true;\n            }\n        }\n        return modified;\n    }\n}\n```\n\n### The Subclass (InstrumentedIntSet)\n```java\npublic class InstrumentedIntSet extends IntSet {\n    private int addCount = 0;\n    \n    @Override\n    public boolean add(Integer element) {\n        addCount++;\n        return super.add(element);\n    }\n    \n    @Override\n    public boolean addAll(Collection<Integer> elements) {\n        addCount += elements.size();\n        return super.addAll(elements);\n    }\n    \n    public int getAddCount() {\n        return addCount;\n    }\n}\n```\n\n## The Problem\n\n### Usage:\n```java\nInstrumentedIntSet numbers = new InstrumentedIntSet();\nnumbers.addAll(Arrays.asList(1, 2, 3));\nSystem.out.println(numbers.getAddCount());  // Expected: 3, Actual: 6 \u274c\n```\n\n### Why It Breaks:\n1. `addAll()` in subclass adds 3 to `addCount`\n2. Calls `super.addAll()` (base class)\n3. Base class `addAll()` internally calls `add()` for each element\n4. Each `add()` call is **dispatched to the overridden version** in the subclass\n5. Each call increments `addCount` again (3 more times)\n6. **Result: Double counting!**\n\n## The Fragility\n\n### Scenario 1: Base Class Changes Implementation\nIf `IntSet` changes `addAll()` to use a different implementation:\n```java\n// New IntSet implementation\npublic boolean addAll(Collection<Integer> elements) {\n    return set.addAll(elements);  // Direct delegation, no longer calls add()\n}\n```\n\nNow `InstrumentedIntSet.addAll()` works correctly (returns 3), but **only by accident** of the base class change!\n\n### Scenario 2: Base Class Adds New Method\nIf `IntSet` adds a new insertion method:\n```java\npublic void addIfAbsent(Integer element) {\n    if (!set.contains(element)) {\n        add(element);\n    }\n}\n```\n\nThe subclass doesn't override this, so calls to `addIfAbsent()` won't be counted\u2014**silent failure**.\n\n## Solutions\n\n### 1. **Composition over Inheritance** (Preferred)\n```java\npublic class InstrumentedIntSet {\n    private final IntSet intSet = new IntSet();  // Composition\n    private int addCount = 0;\n    \n    public boolean add(Integer element) {\n        addCount++;\n        return intSet.add(element);\n    }\n    \n    public boolean addAll(Collection<Integer> elements) {\n        addCount += elements.size();\n        return intSet.addAll(elements);  // No risk of double-counting\n    }\n    \n    public int getAddCount() {\n        return addCount;\n    }\n}\n```\n\n### 2. **Documentation & Final Methods**\n```java\npublic class IntSet {\n    public final boolean addAll(Collection<Integer> elements) {\n        // Documented: does NOT call add()\n        return set.addAll(elements);\n    }\n}\n```\n\n### 3. **Avoid Overriding Interrelated Methods**\nDon't override methods when you don't fully understand their internal dependencies.\n\n## Key Takeaways\n\n| Problem | Cause |\n|---------|-------|\n| **Fragility** | Subclass depends on super",
    "expected": "If InstrumentedIntSet overrides add() to increment a counter, and also overrides addAll() to add elements.length to the counter then call super.addAll(), problems arise if the base IntSet.addAll() internally calls add() for each element. The counter increments in both addAll() (for the batch) and in each add() call (from super.addAll()), resulting in double-counting. The subclass is fragile because it depends on undocumented base class implementation details."
  },
  {
    "id": "sa_015",
    "type": "short_answer",
    "topic": "inheritance",
    "correct": true,
    "score": 0.5,
    "edit_distance": 3573,
    "prediction": "# Designing a Base Class for Inheritance\n\nTo prevent the fragile base class problem, follow these key principles:\n\n## 1. **Document Self-Use of Overridable Methods**\n\nClearly document when methods call other overridable methods internally:\n\n```java\npublic class BaseList<E> {\n    /**\n     * Adds an element to the list.\n     * \n     * Implementation note: This method calls addAll() internally.\n     * If you override addAll(), this method will use your implementation.\n     */\n    public boolean add(E element) {\n        return addAll(Collections.singleton(element));\n    }\n    \n    /**\n     * Adds all elements from the collection.\n     * Called by add() method.\n     */\n    public boolean addAll(Collection<? extends E> c) {\n        // implementation\n    }\n}\n```\n\n## 2. **Provide Protected Hooks for Extension**\n\n```java\npublic abstract class AbstractProcessor {\n    // Public template method (final)\n    public final void process() {\n        preProcess();\n        doProcess();\n        postProcess();\n    }\n    \n    // Protected hooks for subclasses\n    protected void preProcess() {\n        // Default implementation or empty\n    }\n    \n    protected abstract void doProcess();\n    \n    protected void postProcess() {\n        // Default implementation or empty\n    }\n}\n```\n\n## 3. **Use Final Methods to Prevent Override Issues**\n\n```java\npublic class SecureBase {\n    private int count = 0;\n    \n    // Final to prevent dangerous overriding\n    public final void increment() {\n        count++;\n        onIncrement();\n    }\n    \n    // Hook for customization\n    protected void onIncrement() {\n        // Subclasses can override this safely\n    }\n}\n```\n\n## 4. **Avoid Calling Overridable Methods in Constructors**\n\n```java\n// \u274c BAD: Fragile design\npublic class FragileBase {\n    public FragileBase() {\n        init(); // Dangerous! Subclass not fully initialized\n    }\n    \n    public void init() {\n        // Can be overridden\n    }\n}\n\n// \u2705 GOOD: Safe design\npublic class SafeBase {\n    public SafeBase() {\n        // Only call private/final methods\n        internalInit();\n    }\n    \n    private void internalInit() {\n        // Safe - cannot be overridden\n    }\n    \n    // Provide protected hook called AFTER construction\n    protected void init() {\n        // Subclasses can override safely\n    }\n}\n```\n\n## 5. **Prohibit Inheritance When Not Designed For It**\n\n```java\n// If not designed for inheritance, make it final\npublic final class UtilityClass {\n    // Cannot be extended\n}\n\n// Or use private constructor\npublic class SingletonClass {\n    private SingletonClass() {\n        // Cannot be subclassed\n    }\n}\n```\n\n## 6. **Complete Example: Well-Designed Base Class**\n\n```java\n/**\n * A base class properly designed for inheritance.\n * \n * Inheritance notes:\n * - Override doValidate() to add custom validation\n * - Override formatOutput() to customize output format\n * - Do not override process() - it's the template method\n */\npublic abstract class DataProcessor {\n    \n    // Template method - final to prevent override\n    public final ProcessResult process(Data input) {\n        if (!validate(input)) {\n            return ProcessResult.invalid();\n        }\n        \n        Data processed = doValidate(input);\n        String output = formatOutput(processed);\n        \n        return ProcessResult.success(output);\n    }\n    \n    // Private - internal use only\n    private boolean validate(Data input) {\n        return input != null && input.isValid();\n    }\n    \n    /**\n     * Performs custom validation logic.\n     * \n     * @param input the validated input data\n     * @return processed data\n     */\n    protected abstract Data doProcess(Data input);\n    \n    /**\n     * Formats the output string.\n     * \n     * Default implementation returns toString().\n     * Override to customize output format.\n     * \n     * @param data the processed data\n     * @return formatted string\n     */\n    protecte",
    "expected": "Document all self-use patterns (which methods call which internally). Use private helper methods for shared implementation rather than having public methods call each other. Mark methods as final if they shouldn't be overridden. Factor out common code into private methods that subclasses can't intercept. Alternatively, consider making the class final and preferring composition over inheritance."
  },
  {
    "id": "sa_016",
    "type": "short_answer",
    "topic": "composition",
    "correct": false,
    "score": 0.0,
    "edit_distance": 3139,
    "prediction": "# Rewriting InstrumentedIntSet Using Composition\n\n## Original (Inheritance-Based) Implementation\n\n```java\npublic class InstrumentedIntSet extends HashSet<Integer> {\n    private int addCount = 0;\n    \n    @Override\n    public boolean add(Integer element) {\n        addCount++;\n        return super.add(element);\n    }\n    \n    @Override\n    public boolean addAll(Collection<? extends Integer> c) {\n        addCount += c.size();\n        return super.addAll(c);\n    }\n    \n    public int getAddCount() {\n        return addCount;\n    }\n}\n```\n\n**Problem**: This double-counts when using `addAll()` because `HashSet.addAll()` internally calls `add()`.\n\n## Composition-Based Implementation (Forwarding Class Pattern)\n\n```java\npublic class InstrumentedIntSet implements Set<Integer> {\n    private final Set<Integer> set;  // Composition - HAS-A relationship\n    private int addCount = 0;\n    \n    // Constructor accepts any Set implementation\n    public InstrumentedIntSet(Set<Integer> set) {\n        this.set = set;\n    }\n    \n    @Override\n    public boolean add(Integer element) {\n        addCount++;\n        return set.add(element);\n    }\n    \n    @Override\n    public boolean addAll(Collection<? extends Integer> c) {\n        addCount += c.size();\n        return set.addAll(c);\n    }\n    \n    public int getAddCount() {\n        return addCount;\n    }\n    \n    // Forward all other Set methods to the composed set\n    @Override\n    public int size() {\n        return set.size();\n    }\n    \n    @Override\n    public boolean isEmpty() {\n        return set.isEmpty();\n    }\n    \n    @Override\n    public boolean contains(Object o) {\n        return set.contains(o);\n    }\n    \n    @Override\n    public Iterator<Integer> iterator() {\n        return set.iterator();\n    }\n    \n    @Override\n    public Object[] toArray() {\n        return set.toArray();\n    }\n    \n    @Override\n    public <T> T[] toArray(T[] a) {\n        return set.toArray(a);\n    }\n    \n    @Override\n    public boolean remove(Object o) {\n        return set.remove(o);\n    }\n    \n    @Override\n    public boolean containsAll(Collection<?> c) {\n        return set.containsAll(c);\n    }\n    \n    @Override\n    public boolean removeAll(Collection<?> c) {\n        return set.removeAll(c);\n    }\n    \n    @Override\n    public boolean retainAll(Collection<?> c) {\n        return set.retainAll(c);\n    }\n    \n    @Override\n    public void clear() {\n        set.clear();\n    }\n}\n```\n\n## Better Approach: Reusable Forwarding Class\n\n```java\n// Generic forwarding class (reusable wrapper)\npublic class ForwardingSet<E> implements Set<E> {\n    private final Set<E> set;\n    \n    public ForwardingSet(Set<E> set) {\n        this.set = set;\n    }\n    \n    // Forward all methods\n    public boolean add(E e) { return set.add(e); }\n    public boolean addAll(Collection<? extends E> c) { return set.addAll(c); }\n    public void clear() { set.clear(); }\n    public boolean contains(Object o) { return set.contains(o); }\n    public boolean containsAll(Collection<?> c) { return set.containsAll(c); }\n    public boolean isEmpty() { return set.isEmpty(); }\n    public Iterator<E> iterator() { return set.iterator(); }\n    public boolean remove(Object o) { return set.remove(o); }\n    public boolean removeAll(Collection<?> c) { return set.removeAll(c); }\n    public boolean retainAll(Collection<?> c) { return set.retainAll(c); }\n    public int size() { return set.size(); }\n    public Object[] toArray() { return set.toArray(); }\n    public <T> T",
    "expected": "Declare a private final IntSet delegate field initialized in constructor. Implement IntSet interface by forwarding all methods to delegate (delegate.add(), delegate.remove(), etc.). For instrumentation, add counting logic in add() and addAll() before/after delegating. Key differences: no 'extends', explicit delegation, immune to base class self-use changes, can wrap any IntSet implementation, must implement all interface methods explicitly."
  },
  {
    "id": "sa_017",
    "type": "short_answer",
    "topic": "testing",
    "correct": false,
    "score": 0.0,
    "edit_distance": 1572,
    "prediction": "# Why `assertEquals` Fails with Arrays in JUnit\n\n## The Problem\n\n```java\n@Test\npublic void testArrayEquality() {\n    int[] expected = new int[] {3, 6};\n    int[] actual = new int[] {3, 6};\n    \n    // \u274c This FAILS even though contents are identical!\n    assertEquals(expected, actual);\n}\n```\n\n**Why it fails:** `assertEquals()` uses the `.equals()` method to compare objects. For arrays, `.equals()` only checks **reference equality** (whether they're the same object in memory), not **content equality**.\n\n## The Correct Solutions\n\n### 1. **Use `assertArrayEquals()` (Recommended)**\n\n```java\n@Test\npublic void testArrayEquality() {\n    int[] expected = new int[] {3, 6};\n    int[] actual = new int[] {3, 6};\n    \n    // \u2705 Correct way - compares array contents\n    assertArrayEquals(expected, actual);\n}\n```\n\n### 2. **For Multi-dimensional Arrays**\n\n```java\n@Test\npublic void testMultiDimensionalArray() {\n    int[][] expected = {{1, 2}, {3, 4}};\n    int[][] actual = {{1, 2}, {3, 4}};\n    \n    // \u2705 Use assertArrayEquals for each dimension\n    assertArrayEquals(expected, actual);\n    \n    // Or use Arrays.deepEquals() with assertTrue\n    assertTrue(Arrays.deepEquals(expected, actual));\n}\n```\n\n### 3. **Alternative: Convert to List (for Objects)**\n\n```java\n@Test\npublic void testObjectArray() {\n    String[] expected = {\"hello\", \"world\"};\n    String[] actual = {\"hello\", \"world\"};\n    \n    // \u2705 Convert to lists\n    assertEquals(Arrays.asList(expected), Arrays.asList(actual));\n}\n```\n\n## Summary Table\n\n| Array Type | Recommended Method |\n|------------|-------------------|\n| Primitive arrays (`int[]`, `double[]`, etc.) | `assertArrayEquals()` |\n| Object arrays (`String[]`, `MyClass[]`) | `assertArrayEquals()` |\n| Multi-dimensional arrays | `assertArrayEquals()` or `Arrays.deepEquals()` |\n\n**Key takeaway:** Always use `assertArrayEquals()` for array comparisons in JUnit tests!",
    "expected": "Java arrays use reference equality for equals() - two arrays with identical contents are not 'equal' unless they're the same object. assertEquals calls equals(), which compares references, so two separately created arrays fail even with same contents. Use assertArrayEquals() instead, which compares array contents element by element. For multidimensional arrays, use assertArrayEquals with proper deep comparison."
  },
  {
    "id": "sa_018",
    "type": "short_answer",
    "topic": "testing",
    "correct": false,
    "score": 0.25,
    "edit_distance": 2064,
    "prediction": "# @Before vs @BeforeClass in JUnit\n\n## Key Differences\n\n### @Before\n- **Execution**: Runs **before each test method**\n- **Scope**: Instance method (non-static)\n- **Purpose**: Set up test-specific state that may be modified by individual tests\n\n### @BeforeClass\n- **Execution**: Runs **once before all test methods** in the class\n- **Scope**: Static method\n- **Purpose**: Set up expensive, shared resources\n\n## Code Example\n\n```java\nimport org.junit.*;\n\npublic class DatabaseTest {\n    private static DatabaseConnection connection;\n    private UserRepository userRepo;\n    \n    @BeforeClass\n    public static void setUpClass() {\n        // Runs ONCE before all tests\n        System.out.println(\"Opening database connection...\");\n        connection = new DatabaseConnection();\n        connection.connect();\n    }\n    \n    @Before\n    public void setUp() {\n        // Runs BEFORE EACH test\n        System.out.println(\"Creating fresh UserRepository...\");\n        userRepo = new UserRepository(connection);\n        userRepo.clearCache();\n    }\n    \n    @Test\n    public void testAddUser() {\n        userRepo.add(new User(\"Alice\"));\n        Assert.assertEquals(1, userRepo.count());\n    }\n    \n    @Test\n    public void testDeleteUser() {\n        userRepo.add(new User(\"Bob\"));\n        userRepo.delete(\"Bob\");\n        Assert.assertEquals(0, userRepo.count());\n    }\n    \n    @After\n    public void tearDown() {\n        // Runs AFTER EACH test\n        System.out.println(\"Cleaning up test data...\");\n    }\n    \n    @AfterClass\n    public static void tearDownClass() {\n        // Runs ONCE after all tests\n        System.out.println(\"Closing database connection...\");\n        connection.disconnect();\n    }\n}\n```\n\n## Execution Order\n\n```\n@BeforeClass (once)\n  \u251c\u2500 @Before\n  \u251c\u2500 @Test (testAddUser)\n  \u251c\u2500 @After\n  \u251c\u2500 @Before\n  \u251c\u2500 @Test (testDeleteUser)\n  \u2514\u2500 @After\n@AfterClass (once)\n```\n\n## When to Use Each\n\n| Use @BeforeClass for: | Use @Before for: |\n|----------------------|------------------|\n| Database connections | Resetting object state |\n| File I/O setup | Creating fresh test objects |\n| Server initialization | Clearing collections/caches |\n| Loading large datasets | Test isolation needs |\n\n## JUnit 5 Note\n\nIn **JUnit 5**, these annotations have been renamed:\n- `@BeforeClass` \u2192 `@BeforeAll`\n- `@Before` \u2192 `@BeforeEach`\n- `@AfterClass` \u2192 `@AfterAll`\n- `@After` \u2192 `@AfterEach`",
    "expected": "@Before runs before each test method - use for test fixtures that should be fresh for each test (ensuring test isolation). @BeforeClass runs once before any tests in the class - use for expensive setup shared across tests (like database connections) that doesn't affect test isolation. @BeforeClass methods must be static. Prefer @Before for most cases to maintain test independence."
  },
  {
    "id": "sa_019",
    "type": "short_answer",
    "topic": "testing",
    "correct": false,
    "score": 0.0,
    "edit_distance": 2462,
    "prediction": "# Comparing Exception Testing Approaches in Java\n\n## Two Methods for Testing Exceptions\n\n### 1. **@Test(expected=...) - JUnit 4 Approach**\n\n```java\n@Test(expected = IllegalArgumentException.class)\npublic void testWithExpectedException() {\n    calculator.divide(10, 0);\n}\n```\n\n**Limitations:**\n- Tests the **entire method** - exception can be thrown anywhere\n- Cannot verify the exception **message**\n- Cannot test code **after** the exception\n- Less precise control\n\n### 2. **assertThrows() - JUnit 5 Approach (Preferred)**\n\n```java\n@Test\npublic void testWithAssertThrows() {\n    IllegalArgumentException exception = assertThrows(\n        IllegalArgumentException.class,\n        () -> calculator.divide(10, 0)\n    );\n    \n    // Can verify exception details\n    assertEquals(\"Cannot divide by zero\", exception.getMessage());\n}\n```\n\n## When assertThrows() is Preferred\n\n### \u2705 **1. Verifying Exception Messages**\n```java\n@Test\npublic void testExceptionMessage() {\n    Exception exception = assertThrows(\n        InvalidUserException.class,\n        () -> userService.createUser(\"\")\n    );\n    \n    assertTrue(exception.getMessage().contains(\"Username cannot be empty\"));\n}\n```\n\n### \u2705 **2. Testing Specific Code Blocks**\n```java\n@Test\npublic void testSpecificOperation() {\n    // Setup that shouldn't throw\n    User user = new User(\"John\");\n    \n    // Only this specific call should throw\n    assertThrows(\n        InsufficientFundsException.class,\n        () -> user.withdraw(1000)\n    );\n    \n    // Can continue testing after\n    assertEquals(0, user.getBalance());\n}\n```\n\n### \u2705 **3. Multiple Exception Tests in One Method**\n```java\n@Test\npublic void testMultipleExceptions() {\n    assertThrows(NullPointerException.class, \n        () -> service.process(null));\n    \n    assertThrows(IllegalArgumentException.class, \n        () -> service.process(\"\"));\n    \n    assertThrows(InvalidFormatException.class, \n        () -> service.process(\"invalid\"));\n}\n```\n\n### \u2705 **4. Inspecting Exception Details**\n```java\n@Test\npublic void testExceptionCause() {\n    RuntimeException exception = assertThrows(\n        RuntimeException.class,\n        () -> service.connectToDatabase()\n    );\n    \n    assertNotNull(exception.getCause());\n    assertTrue(exception.getCause() instanceof SQLException);\n}\n```\n\n## Summary\n\n| Feature | @Test(expected=...) | assertThrows() |\n|---------|-------------------|----------------|\n| **Precision** | Entire method | Specific lambda |\n| **Message verification** | \u274c No | \u2705 Yes |\n| **Exception inspection** | \u274c No | \u2705 Yes |\n| **Multiple tests** | \u274c No | \u2705 Yes |\n| **Code after exception** | \u274c No | \u2705 Yes |\n| **JUnit version** | JUnit 4 | JUnit 5+ |\n\n**Recommendation:** Use `assertThrows()` for better precision, readability, and testability. It's the modern standard in JUnit 5.",
    "expected": "assertThrows is preferred when you need to verify exception details beyond just the type. assertThrows returns the exception object, allowing assertions on its message, cause, or other properties. @Test(expected=...) only verifies that some code in the method threw that exception type - it can't test which line threw it or what the message was. assertThrows with a lambda also precisely identifies which code should throw."
  },
  {
    "id": "sa_020",
    "type": "short_answer",
    "topic": "testing",
    "correct": false,
    "score": 0.0,
    "edit_distance": 2400,
    "prediction": "# Mock Objects and Testing Controllers\n\n## What is a Mock Object?\n\nA **mock object** is a simulated object that mimics the behavior of a real object in a controlled way. It's used in unit testing to replace dependencies, allowing you to:\n\n- Test components in isolation\n- Control the behavior of dependencies\n- Verify interactions between objects\n- Avoid expensive operations (database calls, network requests, etc.)\n\n## How Mocks Facilitate Controller Testing\n\nWhen testing a Controller that depends on a Model, mock objects allow you to:\n\n### 1. **Isolate the Controller Logic**\nYou can test the Controller without needing a fully functional Model or database:\n\n```java\npublic class UserController {\n    private UserModel userModel;\n    \n    public UserController(UserModel userModel) {\n        this.userModel = userModel;\n    }\n    \n    public String getUserInfo(int userId) {\n        User user = userModel.findUserById(userId);\n        if (user != null) {\n            return \"User: \" + user.getName();\n        }\n        return \"User not found\";\n    }\n}\n```\n\n### 2. **Test with Predictable Behavior**\n\n```java\nimport org.junit.Test;\nimport static org.mockito.Mockito.*;\nimport static org.junit.Assert.*;\n\npublic class UserControllerTest {\n    \n    @Test\n    public void testGetUserInfo_UserExists() {\n        // Create a mock Model\n        UserModel mockModel = mock(UserModel.class);\n        \n        // Define mock behavior\n        User mockUser = new User(1, \"John Doe\");\n        when(mockModel.findUserById(1)).thenReturn(mockUser);\n        \n        // Test the Controller with the mock\n        UserController controller = new UserController(mockModel);\n        String result = controller.getUserInfo(1);\n        \n        // Verify results\n        assertEquals(\"User: John Doe\", result);\n        \n        // Verify the Model method was called\n        verify(mockModel).findUserById(1);\n    }\n    \n    @Test\n    public void testGetUserInfo_UserNotFound() {\n        UserModel mockModel = mock(UserModel.class);\n        \n        // Mock returns null (user not found)\n        when(mockModel.findUserById(999)).thenReturn(null);\n        \n        UserController controller = new UserController(mockModel);\n        String result = controller.getUserInfo(999);\n        \n        assertEquals(\"User not found\", result);\n    }\n}\n```\n\n## Key Benefits\n\n1. **Speed**: No database or external system calls\n2. **Reliability**: Tests aren't affected by external factors\n3. **Focus**: Test only the Controller's logic\n4. **Flexibility**: Simulate edge cases (errors, null values, exceptions)\n\n## Popular Mocking Frameworks\n\n- **Mockito** (most common)\n- **EasyMock**\n- **JMock**\n\nMock objects are essential for effective unit testing in MVC architectures!",
    "expected": "A mock object simulates a real object with controlled, predictable behavior for testing. For testing a Controller, create a mock Model that returns predetermined values and records method calls. This lets you: test Controller logic in isolation, verify the Controller calls correct Model methods, simulate various Model states/responses without complex setup, and test error handling by having the mock throw exceptions."
  },
  {
    "id": "sa_021",
    "type": "short_answer",
    "topic": "factory",
    "correct": false,
    "score": 0.25,
    "edit_distance": 1530,
    "prediction": "# Advantages of Static Factories over Constructors\n\n## Key Advantages:\n\n### 1. **Descriptive Names**\n- **Constructors**: `new IntSet1Impl()` - unclear what you're getting\n- **Static Factories**: `empty()` or `singleton(5)` - self-documenting code\n\n```java\n// Less clear\nIntSet1Impl set1 = new IntSet1Impl();\n\n// More clear - intention is obvious\nIntSet2Impl set2 = IntSet2Impl.empty();\nIntSet2Impl set3 = IntSet2Impl.singleton(5);\n```\n\n### 2. **Can Return Existing Instances (Caching)**\nStatic factories can return pre-created or cached objects instead of always creating new ones:\n\n```java\npublic static IntSet2Impl empty() {\n    return EMPTY_INSTANCE; // Reuse the same empty set\n}\n```\n\nConstructors **must** create a new object every time.\n\n### 3. **Can Return Subtype/Different Implementation**\nStatic factories can return any subtype, allowing flexibility:\n\n```java\npublic static IntSet create(int size) {\n    if (size < 10) {\n        return new SmallIntSet();  // Optimized for small sets\n    } else {\n        return new LargeIntSet();  // Optimized for large sets\n    }\n}\n```\n\nConstructors can only return their exact class type.\n\n### 4. **Don't Need to Create Objects Every Call**\nCan implement patterns like:\n- **Singleton pattern** - return the same instance\n- **Flyweight pattern** - pool common objects\n- **Lazy initialization** - create only when needed\n\n### 5. **More Flexible API Design**\nYou can have multiple static factories with the same parameter types but different names:\n\n```java\nIntSet2Impl.singleton(5);      // Set containing just 5\nIntSet2Impl.withCapacity(5);   // Empty set with capacity for 5 elements\n```\n\nWith constructors, you can't have two constructors with the same signature.\n\n## Summary:\nStatic factories provide **better readability, performance optimization opportunities, and more flexible design** compared to traditional constructors.",
    "expected": "Static factory advantages: descriptive names (empty() vs new IntSet2Impl() with no indication it's empty), can return cached instances instead of always creating new objects, can return any subtype of the declared return type (implementation hiding), can return different implementations based on parameters, not required to create a new object each call. Disadvantages: can't be subclassed, not immediately obvious they're constructors."
  },
  {
    "id": "sa_022",
    "type": "short_answer",
    "topic": "gui",
    "correct": false,
    "score": 0.0,
    "edit_distance": 1574,
    "prediction": "# Why MouseAdapter is Preferred Over MouseListener\n\n## The Problem with MouseListener\n\nWhen you implement the `MouseListener` interface, you **must implement all 5 methods**, even if you only need one:\n\n```java\npublic class MyPanel extends JPanel implements MouseListener {\n    \n    public MyPanel() {\n        addMouseListener(this);\n    }\n    \n    @Override\n    public void mouseClicked(MouseEvent e) {\n        // This is the only method I actually need\n        System.out.println(\"Mouse clicked at: \" + e.getPoint());\n    }\n    \n    // Forced to implement these empty methods\n    @Override\n    public void mousePressed(MouseEvent e) { }\n    \n    @Override\n    public void mouseReleased(MouseEvent e) { }\n    \n    @Override\n    public void mouseEntered(MouseEvent e) { }\n    \n    @Override\n    public void mouseExited(MouseEvent e) { }\n}\n```\n\n## The Solution with MouseAdapter\n\n`MouseAdapter` is an **abstract class** that provides empty implementations of all MouseListener methods. You only override what you need:\n\n```java\npublic class MyPanel extends JPanel {\n    \n    public MyPanel() {\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mouseClicked(MouseEvent e) {\n                // Only implement what you need!\n                System.out.println(\"Mouse clicked at: \" + e.getPoint());\n            }\n        });\n    }\n}\n```\n\n## Key Benefits\n\n1. **Less boilerplate code** - No need for empty method stubs\n2. **Cleaner and more readable** - Only relevant code is visible\n3. **Easier maintenance** - Fewer methods to navigate through\n4. **Follows best practices** - This is the Adapter design pattern\n\n## When to Use Each\n\n- **Use MouseAdapter**: When you need 1-4 of the 5 methods\n- **Use MouseListener**: When you need all 5 methods (rare)\n\nThis same principle applies to other adapter classes like `KeyAdapter`, `WindowAdapter`, `FocusAdapter`, etc.",
    "expected": "MouseListener has five methods (clicked, pressed, released, entered, exited) - implementing it requires providing all five, even if empty. MouseAdapter is an abstract class with empty default implementations of all MouseListener methods. By extending MouseAdapter, you only override the methods you need (mouseClicked), avoiding clutter from unused empty implementations. This follows the Adapter pattern principles."
  },
  {
    "id": "sa_023",
    "type": "short_answer",
    "topic": "gui",
    "correct": false,
    "score": 0.0,
    "edit_distance": 1486,
    "prediction": "# Why Override `paintComponent()` Instead of `paint()`\n\n## The Key Difference\n\nIn Swing applications, you should override **`paintComponent(Graphics g)`** rather than `paint(Graphics g)` for custom drawing because:\n\n### 1. **The Painting Chain**\n\nThe `paint()` method in Swing components has a specific responsibility chain:\n\n```java\npaint(Graphics g)\n  \u2514\u2500> paintComponent(Graphics g)    // Paints the component itself\n  \u2514\u2500> paintBorder(Graphics g)       // Paints the border\n  \u2514\u2500> paintChildren(Graphics g)     // Paints child components\n```\n\nIf you override `paint()`, you risk breaking this chain and preventing borders and child components from rendering properly.\n\n### 2. **Proper Separation of Concerns**\n\n`paintComponent()` is specifically designed for custom painting of the component's content, making your code cleaner and more maintainable.\n\n## Essential Precaution: Call `super.paintComponent(g)`\n\n**You must call `super.paintComponent(g)` as the first line** in your override:\n\n```java\n@Override\nprotected void paintComponent(Graphics g) {\n    super.paintComponent(g);  // CRITICAL: Always call this first!\n    \n    // Now do your custom painting\n    g.setColor(Color.BLUE);\n    g.fillRect(10, 10, 100, 100);\n}\n```\n\n### Why This Matters\n\nCalling `super.paintComponent(g)`:\n- **Clears the previous painting** (prevents visual artifacts)\n- **Paints the background** according to the component's background color\n- **Handles opaque components** correctly\n- **Maintains proper Swing rendering behavior**\n\n### What Happens If You Forget\n\n```java\n// WRONG - No super call\n@Override\nprotected void paintComponent(Graphics g) {\n    g.fillRect(10, 10, 100, 100);  \n    // Background won't clear, causing \"painting trails\"\n}\n```\n\nThis results in drawing artifacts where old graphics aren't erased, creating a \"smearing\" effect.",
    "expected": "paint() handles all painting including borders, children, and the component itself. Override paintComponent() for custom drawing because it's called specifically for the component's content after borders are drawn and before children. Always call super.paintComponent(g) first to ensure the panel is properly cleared/initialized - without this, previous paint artifacts may remain, especially with transparent backgrounds or when resizing."
  },
  {
    "id": "sa_024",
    "type": "short_answer",
    "topic": "mvc",
    "correct": false,
    "score": 0.0,
    "edit_distance": 2656,
    "prediction": "# Scanner with Readable vs System.in: Testability Comparison\n\n## Key Difference\n\nUsing `Scanner` with a `Readable` interface (or `InputStream`) parameter provides **dependency injection**, making your code testable. Using `Scanner(System.in)` directly creates a **hard dependency** that's difficult to test.\n\n## The Problem with System.in\n\n```java\n// Hard to test - tightly coupled to System.in\npublic class UserInputProcessor {\n    public String getName() {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter name: \");\n        return scanner.nextLine();\n    }\n}\n\n// Testing this requires actual keyboard input or complex System.in mocking\n```\n\n## The Testable Solution\n\n```java\n// Testable - accepts any Readable/InputStream\npublic class UserInputProcessor {\n    private final Scanner scanner;\n    \n    // Dependency injection via constructor\n    public UserInputProcessor(Readable input) {\n        this.scanner = new Scanner(input);\n    }\n    \n    public String getName() {\n        System.out.print(\"Enter name: \");\n        return scanner.nextLine();\n    }\n}\n```\n\n## Testing Examples\n\n### Production Code\n```java\n// In production, use System.in\nUserInputProcessor processor = new UserInputProcessor(\n    new InputStreamReader(System.in)\n);\n```\n\n### Test Code\n```java\n@Test\npublic void testGetName() {\n    // Create test input using StringReader (implements Readable)\n    String testInput = \"John Doe\\n\";\n    Readable mockInput = new StringReader(testInput);\n    \n    UserInputProcessor processor = new UserInputProcessor(mockInput);\n    \n    String result = processor.getName();\n    assertEquals(\"John Doe\", result);\n}\n\n@Test\npublic void testWithInputStream() {\n    // Or use ByteArrayInputStream for InputStream-based injection\n    String testInput = \"Jane Smith\\n\";\n    InputStream mockInput = new ByteArrayInputStream(\n        testInput.getBytes()\n    );\n    \n    UserInputProcessor processor = new UserInputProcessor(\n        new InputStreamReader(mockInput)\n    );\n    \n    String result = processor.getName();\n    assertEquals(\"Jane Smith\", result);\n}\n```\n\n## Benefits Summary\n\n| Aspect | System.in (Hard-coded) | Readable/InputStream Parameter |\n|--------|------------------------|-------------------------------|\n| **Testability** | Requires complex mocking | Easy unit testing |\n| **Flexibility** | Only keyboard input | Any input source |\n| **Test Speed** | Slow/impossible | Fast automated tests |\n| **Isolation** | Depends on external input | Fully isolated tests |\n\n## Best Practice\n\nAlways design methods to accept input sources as parameters rather than hard-coding `System.in`:\n\n```java\n// Good: Flexible and testable\npublic void processInput(InputStream input) {\n    Scanner scanner = new Scanner(input);\n    // ...\n}\n\n// In main method\nprocessInput(System.in);\n\n// In tests\nprocessInput(new ByteArrayInputStream(\"test data\".getBytes()));\n```\n\nThis approach follows the **Dependency Inversion Principle** and makes your code more maintainable and testable.",
    "expected": "System.in is a global InputStream tied to the console - tests using it require actual input or complex stream manipulation. Readable is an interface that can be implemented by StringReader for testing - construct with predetermined input string, no console interaction needed. A controller using Scanner(Readable) can be tested by passing new StringReader(\"1\\n2\\n\") to simulate user input, enabling fully automated tests."
  },
  {
    "id": "sa_025",
    "type": "short_answer",
    "topic": "adapter",
    "correct": false,
    "score": 0.0,
    "edit_distance": 1223,
    "prediction": "# Implementing `isSupersetOf(IntSet2 other)`\n\nWhen implementing `isSupersetOf` in IntSet2 (which uses set-wise operations), you need to check if **all elements in `other` are also in `this` set**.\n\n## Implementation\n\n```java\npublic boolean isSupersetOf(IntSet2 other) {\n    // This set is a superset of other if:\n    // for all elements in other, they must also be in this\n    // Equivalently: other must be a subset of this\n    \n    // Check if every element in 'other' is contained in 'this'\n    for (int i = 0; i < other.elements.length; i++) {\n        if (other.elements[i] && !this.elements[i]) {\n            return false;  // Found element in other but not in this\n        }\n    }\n    return true;\n}\n```\n\n## Key Logic\n\n- **Superset relationship**: Set A is a superset of set B if B \u2286 A (every element of B is in A)\n- We iterate through `other`'s boolean array\n- If `other.elements[i]` is `true` (element i is in other) BUT `this.elements[i]` is `false` (element i is NOT in this), then `this` is **not** a superset\n- If we complete the loop without finding such a case, then `this` **is** a superset\n\n## Alternative Implementation (More Concise)\n\n```java\npublic boolean isSupersetOf(IntSet2 other) {\n    // This is a superset if: this \u222a other = this\n    // Or equivalently: other - this = \u2205\n    \n    IntSet2 union = this.union(other);\n    return this.equals(union);\n}\n```\n\nThis uses the property that A is a superset of B if and only if A \u222a B = A.",
    "expected": "Iterate through all elements in other using other.asList(). For each element, check if this set contains it using member(). If any element is not a member, return false. If all elements are found, return true. Implementation: for (int z : other.asList()) { if (!member(z)) return false; } return true;"
  },
  {
    "id": "sa_026",
    "type": "short_answer",
    "topic": "inheritance",
    "correct": false,
    "score": 0.25,
    "edit_distance": 1970,
    "prediction": "# Why Declare Methods as `final` in IntSet3 for Safe Extension\n\nWhen designing a class like `IntSet3` for safe extension, you might declare methods as `final` for several important reasons:\n\n## 1. **Prevent Breaking Internal Invariants**\n\n```java\npublic class IntSet3 {\n    private int[] elements;\n    private int size;\n    \n    // Final method protects the class invariant\n    public final void add(int x) {\n        if (!contains(x)) {\n            // Critical logic that maintains invariants\n            ensureCapacity();\n            elements[size++] = x;\n        }\n    }\n    \n    // If subclass overrides this carelessly, invariants could break\n    private boolean contains(int x) { /* ... */ }\n}\n```\n\nIf a subclass overrides `add()` incorrectly, it could violate the invariant that all elements are unique.\n\n## 2. **Methods Called in Constructors**\n\n```java\npublic class IntSet3 {\n    public IntSet3(int[] initialElements) {\n        for (int elem : initialElements) {\n            add(elem);  // Dangerous if add() is overridable!\n        }\n    }\n    \n    // Should be final to avoid subclass issues\n    public final void add(int x) { /* ... */ }\n}\n```\n\n**Problem:** If `add()` isn't final, a subclass's overridden version is called during superclass construction, **before the subclass fields are initialized**, leading to bugs.\n\n## 3. **Security and Template Method Pattern**\n\n```java\npublic class IntSet3 {\n    // Final - subclasses cannot bypass security checks\n    public final void addAll(int[] elements) {\n        validatePermissions();  // Security check\n        for (int elem : elements) {\n            addInternal(elem);  // Extensible hook\n        }\n    }\n    \n    // Protected hook method for extension\n    protected void addInternal(int x) { /* ... */ }\n}\n```\n\nThis creates a **template method pattern** where the final method controls the algorithm, but allows safe extension points.\n\n## 4. **Performance Optimization**\n\nFinal methods can be **inlined** by the JVM compiler, improving performance since the compiler knows the method cannot be overridden.\n\n## Key Principle\n\n**Make methods `final` by default** unless you specifically intend them as extension points. This follows the **\"design for inheritance or prohibit it\"** principle (Effective Java, Item 19).",
    "expected": "Final methods cannot be overridden, preventing subclasses from intercepting calls and potentially breaking invariants. If addAll() is final and calls a private helper (not the public add()), subclasses can safely override add() without affecting addAll()'s behavior. This protects the base class's internal logic from subclass interference while still allowing controlled extension points."
  },
  {
    "id": "sa_027",
    "type": "short_answer",
    "topic": "decorator",
    "correct": false,
    "score": 0.0,
    "edit_distance": 2262,
    "prediction": "# Why Decorators Should Implement Interfaces, Not Extend Classes\n\n## The Key Principle\n\nDecorators should implement the same **interface** as the component they decorate, rather than extending the component **class**, to maintain flexibility and follow good object-oriented design principles.\n\n## Reasons\n\n### 1. **Loose Coupling**\n```java\n// Good: Using interface\ninterface Coffee {\n    double getCost();\n    String getDescription();\n}\n\nclass SimpleCoffee implements Coffee {\n    public double getCost() { return 2.0; }\n    public String getDescription() { return \"Simple coffee\"; }\n}\n\n// Decorator implements the interface\nabstract class CoffeeDecorator implements Coffee {\n    protected Coffee decoratedCoffee;\n    \n    public CoffeeDecorator(Coffee coffee) {\n        this.decoratedCoffee = coffee;\n    }\n}\n```\n\n### 2. **Can Decorate Multiple Implementations**\n```java\nclass SimpleCoffee implements Coffee { /* ... */ }\nclass EspressoCoffee implements Coffee { /* ... */ }\nclass ColdBrew implements Coffee { /* ... */ }\n\n// Same decorator works with ALL implementations\nclass MilkDecorator extends CoffeeDecorator {\n    public MilkDecorator(Coffee coffee) { super(coffee); }\n    \n    public double getCost() {\n        return decoratedCoffee.getCost() + 0.5;\n    }\n    \n    public String getDescription() {\n        return decoratedCoffee.getDescription() + \", milk\";\n    }\n}\n\n// Works with any Coffee implementation\nCoffee coffee1 = new MilkDecorator(new SimpleCoffee());\nCoffee coffee2 = new MilkDecorator(new EspressoCoffee());\n```\n\n### 3. **Avoids Inheritance Problems**\n\n```java\n// Bad: Extending concrete class\nclass BadMilkDecorator extends SimpleCoffee {\n    private SimpleCoffee coffee;\n    // Problem: Can ONLY decorate SimpleCoffee\n    // Problem: Inherits unnecessary implementation details\n    // Problem: Tight coupling to concrete class\n}\n```\n\n### 4. **Supports the Decorator Pattern's Goal**\nThe decorator can wrap **any** object that implements the interface, including other decorators:\n\n```java\nCoffee myCoffee = new SimpleCoffee();\nmyCoffee = new MilkDecorator(myCoffee);\nmyCoffee = new SugarDecorator(myCoffee);\nmyCoffee = new WhipDecorator(myCoffee);\n\n// Result: \"Simple coffee, milk, sugar, whip\" - $3.50\n```\n\n## Summary\n\nUsing interfaces ensures:\n- \u2705 **Flexibility** - decorate any implementation\n- \u2705 **Loose coupling** - depend on abstractions\n- \u2705 **Composability** - easily chain decorators\n- \u2705 **Maintainability** - changes to concrete classes don't break decorators\n\nThis follows the **Dependency Inversion Principle**: depend on abstractions, not concretions.",
    "expected": "Interface implementation allows: decorating any implementation of the interface (not tied to one class), using multiple decorators in any order (they're interchangeable), avoiding inheritance hierarchy complications, and maintaining the Liskov Substitution Principle. A decorator wrapping an interface can work with current and future implementations, while extending a class ties you to that specific hierarchy."
  },
  {
    "id": "sa_028",
    "type": "short_answer",
    "topic": "mvc",
    "correct": false,
    "score": 0.0,
    "edit_distance": 3565,
    "prediction": "# Mock View/Log in Testing MVC Controllers\n\n## Role and Purpose\n\nA **mock view** or **log** in MVC testing serves as a **test double** that captures controller output without requiring actual UI components. It allows you to:\n\n1. **Verify controller behavior** - Confirm what data the controller sends to the view\n2. **Test in isolation** - No dependency on actual view implementation\n3. **Assert expectations** - Check that correct methods were called with correct data\n4. **Capture output** - Record all interactions for verification\n\n## Implementation Example\n\n### 1. Simple Mock View with Log\n\n```java\npublic class MockView {\n    private StringBuilder log = new StringBuilder();\n    private Map<String, Object> model = new HashMap<>();\n    \n    // Capture method calls\n    public void displayMessage(String message) {\n        log.append(\"displayMessage: \").append(message).append(\"\\n\");\n    }\n    \n    public void showError(String error) {\n        log.append(\"showError: \").append(error).append(\"\\n\");\n    }\n    \n    public void updateData(String key, Object value) {\n        log.append(\"updateData: \").append(key).append(\" = \").append(value).append(\"\\n\");\n        model.put(key, value);\n    }\n    \n    // Verification methods\n    public String getLog() {\n        return log.toString();\n    }\n    \n    public boolean logContains(String text) {\n        return log.toString().contains(text);\n    }\n    \n    public Object getModelData(String key) {\n        return model.get(key);\n    }\n    \n    public void clearLog() {\n        log.setLength(0);\n        model.clear();\n    }\n}\n```\n\n### 2. Controller Being Tested\n\n```java\npublic class UserController {\n    private UserView view;\n    private UserModel model;\n    \n    public UserController(UserView view, UserModel model) {\n        this.view = view;\n        this.model = model;\n    }\n    \n    public void handleLogin(String username, String password) {\n        if (username == null || username.isEmpty()) {\n            view.showError(\"Username cannot be empty\");\n            return;\n        }\n        \n        User user = model.authenticate(username, password);\n        if (user != null) {\n            view.updateData(\"currentUser\", user);\n            view.displayMessage(\"Welcome, \" + user.getName());\n        } else {\n            view.showError(\"Invalid credentials\");\n        }\n    }\n    \n    public void handleLogout() {\n        view.updateData(\"currentUser\", null);\n        view.displayMessage(\"Logged out successfully\");\n    }\n}\n```\n\n### 3. View Interface for Testing\n\n```java\npublic interface UserView {\n    void displayMessage(String message);\n    void showError(String error);\n    void updateData(String key, Object value);\n}\n```\n\n### 4. Mock Implementation\n\n```java\npublic class MockUserView implements UserView {\n    private List<String> messages = new ArrayList<>();\n    private List<String> errors = new ArrayList<>();\n    private Map<String, Object> data = new HashMap<>();\n    \n    @Override\n    public void displayMessage(String message) {\n        messages.add(message);\n    }\n    \n    @Override\n    public void showError(String error) {\n        errors.add(error);\n    }\n    \n    @Override\n    public void updateData(String key, Object value) {\n        data.put(key, value);\n    }\n    \n    // Test helper methods\n    public List<String> getMessages() {\n        return new ArrayList<>(messages);\n    }\n    \n    public List<String> getErrors() {\n        return new ArrayList<>(errors);\n    }\n    \n    public Object getData(String key) {\n        return data.get(key);\n    }\n    \n    public int getMessageCount() {\n        return messages.size();\n    }\n    \n    public int getErrorCount() {\n        return errors.size();\n    }\n    \n    public void reset() {\n        messages.clear();\n        errors.clear();\n        data.clear();\n    }\n}\n```\n\n### 5. Test Cases Using Mock View\n\n```java\nimport org.junit.jupiter.api.BeforeEach;\nimport",
    "expected": "A mock view records/logs all interactions for later verification. Implement by creating a class implementing the View interface that appends method calls and parameters to a StringBuilder/log. After running the controller, examine the log to verify correct sequence of view updates. This tests that the controller calls view methods correctly without needing actual GUI rendering."
  },
  {
    "id": "sa_029",
    "type": "short_answer",
    "topic": "strategy",
    "correct": false,
    "score": 0.0,
    "edit_distance": 3899,
    "prediction": "# Implementing a Composite Strategy for TicTacToe\n\nA composite strategy follows the **Composite design pattern** combined with the **Chain of Responsibility pattern**. Here's how to implement it:\n\n## Basic Implementation\n\n```java\npublic class CompositeStrategy implements Strategy {\n    private final List<Strategy> strategies;\n    \n    public CompositeStrategy(Strategy... strategies) {\n        this.strategies = Arrays.asList(strategies);\n    }\n    \n    @Override\n    public Move getMove(Board board, Player player) {\n        for (Strategy strategy : strategies) {\n            Move move = strategy.getMove(board, player);\n            if (move != null && board.isValidMove(move)) {\n                return move;\n            }\n        }\n        return null; // No valid move found\n    }\n}\n```\n\n## Usage Example\n\n```java\n// Create a composite strategy that tries multiple approaches\nStrategy compositeStrategy = new CompositeStrategy(\n    new WinningMoveStrategy(),      // Try to win first\n    new BlockingMoveStrategy(),     // Then block opponent\n    new CenterStrategy(),           // Then take center\n    new CornerStrategy(),           // Then take corner\n    new RandomStrategy()            // Finally, random move\n);\n\nPlayer smartPlayer = new Player('X', compositeStrategy);\n```\n\n## Enhanced Version with Logging\n\n```java\npublic class CompositeStrategy implements Strategy {\n    private final List<Strategy> strategies;\n    private boolean debugMode;\n    \n    public CompositeStrategy(boolean debugMode, Strategy... strategies) {\n        this.strategies = Arrays.asList(strategies);\n        this.debugMode = debugMode;\n    }\n    \n    @Override\n    public Move getMove(Board board, Player player) {\n        for (Strategy strategy : strategies) {\n            if (debugMode) {\n                System.out.println(\"Trying: \" + strategy.getClass().getSimpleName());\n            }\n            \n            Move move = strategy.getMove(board, player);\n            \n            if (move != null && board.isValidMove(move)) {\n                if (debugMode) {\n                    System.out.println(\"\u2713 Selected move: \" + move);\n                }\n                return move;\n            }\n        }\n        \n        throw new IllegalStateException(\"No valid move found by any strategy\");\n    }\n}\n```\n\n## Builder Pattern Version (More Flexible)\n\n```java\npublic class CompositeStrategy implements Strategy {\n    private final List<Strategy> strategies;\n    \n    private CompositeStrategy(Builder builder) {\n        this.strategies = new ArrayList<>(builder.strategies);\n    }\n    \n    @Override\n    public Move getMove(Board board, Player player) {\n        for (Strategy strategy : strategies) {\n            Move move = strategy.getMove(board, player);\n            if (move != null && board.isValidMove(move)) {\n                return move;\n            }\n        }\n        return null;\n    }\n    \n    public static class Builder {\n        private final List<Strategy> strategies = new ArrayList<>();\n        \n        public Builder addStrategy(Strategy strategy) {\n            strategies.add(strategy);\n            return this;\n        }\n        \n        public Builder tryToWin() {\n            return addStrategy(new WinningMoveStrategy());\n        }\n        \n        public Builder tryToBlock() {\n            return addStrategy(new BlockingMoveStrategy());\n        }\n        \n        public Builder preferCenter() {\n            return addStrategy(new CenterStrategy());\n        }\n        \n        public Builder preferCorners() {\n            return addStrategy(new CornerStrategy());\n        }\n        \n        public Builder fallbackToRandom() {\n            return addStrategy(new RandomStrategy());\n        }\n        \n        public CompositeStrategy build() {\n            if (strategies.isEmpty()) {\n                throw new IllegalStateException(\"At least one strategy required\");\n            }\n            return new CompositeStrategy(this);\n        }\n    }\n}\n\n// Usage:\nStrategy strategy = new CompositeStrategy.Builder()\n    .tryToWin()\n    .tryToBlock()\n    .preferCenter()\n    .preferCorners()\n    .fallbackToRandom()\n    .build();\n```\n\n## Key Benefits\n\n1. **Flexibility**: Easy to add/remove strategies\n2. **Priority ordering**: Strategies execute in",
    "expected": "Create a CompositeStrategy implementing TicTacToeStrategy that holds a List of strategies. In chooseMove(), iterate through strategies, calling each one's chooseMove(). If a strategy returns a valid Coord (not null, within bounds, unoccupied cell), return it. If a strategy returns null or invalid move, try the next one. Return null or throw if no strategy succeeds. This combines strategies with fallback behavior."
  },
  {
    "id": "sa_030",
    "type": "short_answer",
    "topic": "command",
    "correct": true,
    "score": 0.5,
    "edit_distance": 3485,
    "prediction": "# Designing a Macro Command for Turtle Graphics\n\n## Overview\n\nA macro command is a **composite pattern** implementation that treats a collection of commands as a single command. It's perfect for grouping multiple turtle operations (like drawing a square) into one reusable, undoable unit.\n\n## Design Structure\n\n### 1. Basic Implementation\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MacroCommand implements Command {\n    private List<Command> commands;\n    private String description;\n    \n    public MacroCommand(String description) {\n        this.commands = new ArrayList<>();\n        this.description = description;\n    }\n    \n    // Add commands to the macro\n    public void addCommand(Command command) {\n        commands.add(command);\n    }\n    \n    @Override\n    public void execute() {\n        for (Command command : commands) {\n            command.execute();\n        }\n    }\n    \n    @Override\n    public void undo() {\n        // Undo in reverse order\n        for (int i = commands.size() - 1; i >= 0; i--) {\n            commands.get(i).undo();\n        }\n    }\n    \n    @Override\n    public String getDescription() {\n        return description;\n    }\n}\n```\n\n### 2. Command Interface\n\n```java\npublic interface Command {\n    void execute();\n    void undo();\n    String getDescription();\n}\n```\n\n### 3. Example Turtle Commands\n\n```java\npublic class MoveCommand implements Command {\n    private Turtle turtle;\n    private double distance;\n    \n    public MoveCommand(Turtle turtle, double distance) {\n        this.turtle = turtle;\n        this.distance = distance;\n    }\n    \n    @Override\n    public void execute() {\n        turtle.forward(distance);\n    }\n    \n    @Override\n    public void undo() {\n        turtle.forward(-distance); // Move backward\n    }\n    \n    @Override\n    public String getDescription() {\n        return \"Move \" + distance + \" units\";\n    }\n}\n\npublic class TurnCommand implements Command {\n    private Turtle turtle;\n    private double angle;\n    \n    public TurnCommand(Turtle turtle, double angle) {\n        this.turtle = turtle;\n        this.angle = angle;\n    }\n    \n    @Override\n    public void execute() {\n        turtle.turn(angle);\n    }\n    \n    @Override\n    public void undo() {\n        turtle.turn(-angle);\n    }\n    \n    @Override\n    public String getDescription() {\n        return \"Turn \" + angle + \" degrees\";\n    }\n}\n```\n\n## Usage Example\n\n### Drawing a Square\n\n```java\npublic class TurtleApplication {\n    public static void main(String[] args) {\n        Turtle turtle = new Turtle();\n        CommandHistory history = new CommandHistory();\n        \n        // Create a macro for drawing a square\n        MacroCommand drawSquare = createSquareMacro(turtle, 100);\n        \n        // Execute the macro\n        drawSquare.execute();\n        history.push(drawSquare);\n        \n        // Can undo the entire square with one command\n        history.undo();\n        \n        // Can redo it\n        history.redo();\n    }\n    \n    private static MacroCommand createSquareMacro(Turtle turtle, double sideLength) {\n        MacroCommand square = new MacroCommand(\"Draw Square\");\n        \n        for (int i = 0; i < 4; i++) {\n            square.addCommand(new MoveCommand(turtle, sideLength));\n            square.addCommand(new TurnCommand(turtle, 90));\n        }\n        \n        return square;\n    }\n}\n```\n\n## Advanced Features\n\n### 1. Command History Manager\n\n```java\nimport java.util.Stack;\n\npublic class CommandHistory {\n    private Stack<Command> undoStack;\n    private Stack<Command> redoStack;\n    \n    public CommandHistory() {\n        undoStack = new Stack<>();\n        redoStack = new Stack<>();\n    }\n    \n    public void push(Command command) {\n        undoStack.push(command);\n        redoStack.clear(); // Clear redo stack on new command\n    }",
    "expected": "Create MacroCommand implementing Command that holds a List<Command> of sub-commands. execute() iterates through the list calling execute() on each in order. undo() iterates in reverse order calling undo() on each. This ensures the macro is atomic - all sub-commands execute or none do (if needed, wrap in try-catch), and undo properly reverses the sequence. Store/restore aggregate state if needed for efficiency."
  },
  {
    "id": "tf_001",
    "type": "true_false",
    "topic": "adapter",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1651,
    "prediction": "# Answer: **FALSE**\n\n## Explanation:\n\nThis statement is **incorrect** because **Java does NOT support multiple inheritance for classes**. A Java class can only extend one parent class at a time.\n\n## Key Points:\n\n### Why This is False:\n1. **Single Inheritance Only**: Java only allows a class to extend ONE class using the `extends` keyword\n2. **The Diamond Problem**: Java avoids the \"diamond problem\" by not supporting multiple class inheritance\n3. **Class Adapter Limitation**: A class adapter can only adapt ONE adaptee class through inheritance\n\n### Class Adapter Pattern Constraint:\n\n```java\n// \u274c INVALID - Cannot extend multiple classes\npublic class ClassAdapter extends AdapteeOne, AdapteeTwo \n    implements Target {\n    // This will NOT compile!\n}\n\n// \u2705 VALID - Can only extend ONE class\npublic class ClassAdapter extends Adaptee implements Target {\n    @Override\n    public void request() {\n        specificRequest(); // Inherited from Adaptee\n    }\n}\n```\n\n### Solution for Multiple Adaptees:\n\nIf you need to adapt multiple classes, use an **Object Adapter** instead:\n\n```java\n// \u2705 Object Adapter - Can adapt multiple classes\npublic class ObjectAdapter implements Target {\n    private AdapteeOne adapteeOne;\n    private AdapteeTwo adapteeTwo;\n    \n    public ObjectAdapter(AdapteeOne a1, AdapteeTwo a2) {\n        this.adapteeOne = a1;\n        this.adapteeTwo = a2;\n    }\n    \n    @Override\n    public void request() {\n        adapteeOne.specificRequestOne();\n        adapteeTwo.specificRequestTwo();\n    }\n}\n```\n\n**Note**: Java DOES support multiple inheritance for **interfaces** (a class can implement multiple interfaces), but not for classes.",
    "expected": false
  },
  {
    "id": "tf_002",
    "type": "true_false",
    "topic": "adapter",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1486,
    "prediction": "**False**\n\nThis statement is **incorrect**. A two-way adapter does **not** need to maintain two separate internal data structures.\n\n## Explanation:\n\nA two-way adapter implements multiple interfaces but typically uses **one underlying data structure** that supports all the required operations from both interfaces.\n\n### Example:\n\n```java\ninterface IntSet1 {\n    void add(int value);\n    boolean contains(int value);\n}\n\ninterface IntSet2 {\n    void insert(int value);\n    boolean has(int value);\n}\n\n// Two-way adapter with SINGLE data structure\nclass TwoWaySetAdapter implements IntSet1, IntSet2 {\n    private Set<Integer> data = new HashSet<>();  // ONE data structure\n    \n    // IntSet1 methods\n    @Override\n    public void add(int value) {\n        data.add(value);\n    }\n    \n    @Override\n    public boolean contains(int value) {\n        return data.contains(value);\n    }\n    \n    // IntSet2 methods\n    @Override\n    public void insert(int value) {\n        data.add(value);  // Uses same underlying data\n    }\n    \n    @Override\n    public boolean has(int value) {\n        return data.contains(value);  // Uses same underlying data\n    }\n}\n```\n\n## Key Points:\n\n- The adapter **translates method calls** from different interfaces to operations on the **same underlying data**\n- Maintaining two separate data structures would be redundant and create synchronization problems\n- The purpose of an adapter is to provide different \"views\" or interfaces to the same data, not to duplicate it",
    "expected": false
  },
  {
    "id": "tf_003",
    "type": "true_false",
    "topic": "adapter",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1713,
    "prediction": "# Answer: **True**\n\nThis statement is correct. Here's why:\n\n## Explanation\n\n### The Fundamental Problem\n\n`Enumeration` and `Iterator` are not perfectly compatible interfaces:\n\n```java\n// Enumeration interface (legacy)\npublic interface Enumeration<E> {\n    boolean hasMoreElements();\n    E nextElement();\n    // NO remove method!\n}\n\n// Iterator interface (modern)\npublic interface Iterator<E> {\n    boolean hasNext();\n    E next();\n    void remove();  // This method must be implemented\n}\n```\n\n### Why `remove()` Cannot Be Implemented\n\nWhen creating an adapter from `Enumeration` to `Iterator`:\n\n```java\npublic class EnumerationIterator<E> implements Iterator<E> {\n    private final Enumeration<E> enumeration;\n    \n    public EnumerationIterator(Enumeration<E> enumeration) {\n        this.enumeration = enumeration;\n    }\n    \n    @Override\n    public boolean hasNext() {\n        return enumeration.hasMoreElements();\n    }\n    \n    @Override\n    public E next() {\n        return enumeration.nextElement();\n    }\n    \n    @Override\n    public void remove() {\n        // Cannot delegate to enumeration - it has no remove method!\n        throw new UnsupportedOperationException(\"Remove not supported\");\n    }\n}\n```\n\n### Why This Is Appropriate\n\n1. **Interface contract**: The `Iterator` interface explicitly allows `remove()` to throw `UnsupportedOperationException` for read-only iterators\n2. **No alternative**: Since `Enumeration` provides no removal mechanism, there's no way to implement it meaningfully\n3. **Standard practice**: This is the same approach used by Java's Collections Framework for unmodifiable collections\n\nThis is a classic example of the **Adapter Pattern** with limited functionality adaptation.",
    "expected": true
  },
  {
    "id": "tf_004",
    "type": "true_false",
    "topic": "mvc",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1429,
    "prediction": "# Answer: **False**\n\n## Explanation:\n\nIn the MVC (Model-View-Controller) pattern, the Controller should **NOT** directly modify the View's display elements. This violates the core principles of MVC architecture.\n\n### The Correct MVC Flow:\n\n1. **Controller's Role**: \n   - Receives user input\n   - Updates the **Model** based on that input\n   - Does NOT directly manipulate View components\n\n2. **Model's Role**:\n   - Holds the application data and business logic\n   - Notifies observers (typically the View) when data changes\n\n3. **View's Role**:\n   - Observes the Model for changes\n   - Updates its own display elements when notified\n   - Sends user actions to the Controller\n\n### Why This Matters:\n\n```java\n// \u274c WRONG - Controller directly modifying View\npublic class Controller {\n    private View view;\n    \n    public void updateData(String newData) {\n        view.setLabel(newData);  // BAD: Direct manipulation\n    }\n}\n\n// \u2705 CORRECT - Controller updates Model, View observes Model\npublic class Controller {\n    private Model model;\n    \n    public void updateData(String newData) {\n        model.setData(newData);  // Model notifies View automatically\n    }\n}\n```\n\n### Benefits of Proper Separation:\n- **Loose coupling** between components\n- **Reusability** - same Model can work with different Views\n- **Testability** - components can be tested independently\n- **Maintainability** - changes to View don't affect Controller logic",
    "expected": false
  },
  {
    "id": "tf_005",
    "type": "true_false",
    "topic": "mvc",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1739,
    "prediction": "# Answer: **True**\n\n## Explanation:\n\nThis statement is **correct** and demonstrates a fundamental principle of good software design and testability.\n\n### Why This is Dependency Injection:\n\n```java\npublic class TicTacToeConsoleController {\n    private Readable input;\n    private Appendable output;\n    \n    // Dependency Injection via constructor\n    public TicTacToeConsoleController(Readable input, Appendable output) {\n        this.input = input;\n        this.output = output;\n    }\n}\n```\n\n### Benefits for Testing:\n\n**1. Without Dependency Injection (Hard to Test):**\n```java\npublic class TicTacToeConsoleController {\n    public TicTacToeConsoleController() {\n        // Hardcoded dependencies - difficult to test!\n        Scanner scanner = new Scanner(System.in);\n        // Always writes to System.out\n    }\n}\n```\n\n**2. With Dependency Injection (Easy to Test):**\n```java\n@Test\npublic void testGamePlay() {\n    // Use StringReader instead of System.in\n    Readable testInput = new StringReader(\"1 1\\n2 2\\n3 3\\n\");\n    \n    // Use StringBuilder instead of System.out\n    Appendable testOutput = new StringBuilder();\n    \n    TicTacToeConsoleController controller = \n        new TicTacToeConsoleController(testInput, testOutput);\n    \n    controller.playGame();\n    \n    // Easy to verify output!\n    String output = testOutput.toString();\n    assertTrue(output.contains(\"Player X wins\"));\n}\n```\n\n### Key Advantages:\n\n- \u2705 **Testable**: No need for actual console I/O during tests\n- \u2705 **Flexible**: Can use `StringReader`, `FileReader`, or `System.in`\n- \u2705 **Verifiable**: Can capture and assert on output\n- \u2705 **Isolated**: Tests don't depend on external systems\n\nThis is a textbook example of **Dependency Injection** improving testability.",
    "expected": true
  },
  {
    "id": "tf_006",
    "type": "true_false",
    "topic": "mvc",
    "correct": false,
    "score": 0.0,
    "edit_distance": 1610,
    "prediction": "# Answer: **TRUE**\n\n## Explanation:\n\nWhen a Controller's `playGame()` method catches an `IOException` from an `Appendable`, it **should propagate the IOException to the caller** rather than wrapping it in an unchecked exception.\n\n## Reasoning:\n\n### 1. **IOExceptions are Checked Exceptions for a Reason**\n`IOException` is a checked exception that signals a recoverable I/O error. Callers of `playGame()` should be aware that I/O operations might fail and should have the opportunity to handle these failures appropriately.\n\n### 2. **Preserves Exception Semantics**\nWrapping an `IOException` in an unchecked exception (like `RuntimeException`) hides the true nature of the error and removes the compile-time guarantee that the caller will handle it.\n\n### 3. **Better Design Practice**\n```java\n// GOOD: Propagate the IOException\npublic void playGame() throws IOException {\n    try {\n        appendable.append(\"Game started\\n\");\n        // ... game logic ...\n    } catch (IOException e) {\n        throw e; // Propagate to caller\n    }\n}\n\n// BAD: Wrapping in unchecked exception\npublic void playGame() {\n    try {\n        appendable.append(\"Game started\\n\");\n    } catch (IOException e) {\n        throw new IllegalStateException(\"I/O error\", e); // Don't do this\n    }\n}\n```\n\n### 4. **Caller Control**\nBy propagating the checked exception, you allow the caller to decide how to handle I/O failures\u2014whether to retry, log, display an error message, or fail gracefully.\n\n**Conclusion:** Propagating the `IOException` maintains proper exception handling semantics and gives callers appropriate control over error handling.",
    "expected": false
  },
  {
    "id": "tf_007",
    "type": "true_false",
    "topic": "observer",
    "correct": false,
    "score": 0.0,
    "edit_distance": 2003,
    "prediction": "# Answer: **TRUE**\n\nThis statement is **correct**. Modifying the Subject during an Observer's `update()` callback can indeed cause infinite recursion if not handled carefully.\n\n## Why This Happens\n\nWhen an Observer modifies the Subject during `update()`:\n\n1. Subject notifies all Observers (including Observer A)\n2. Observer A's `update()` is called\n3. Observer A modifies the Subject\n4. Subject triggers notifications again\n5. Observer A's `update()` is called again\n6. **Cycle repeats infinitely** \u2192 StackOverflowError\n\n## Example of the Problem\n\n```java\nclass Subject {\n    private List<Observer> observers = new ArrayList<>();\n    private int state;\n    \n    public void setState(int state) {\n        this.state = state;\n        notifyObservers(); // Triggers notifications\n    }\n    \n    private void notifyObservers() {\n        for (Observer obs : observers) {\n            obs.update(this);\n        }\n    }\n}\n\nclass ProblematicObserver implements Observer {\n    @Override\n    public void update(Subject subject) {\n        // Modifying subject during update!\n        subject.setState(subject.getState() + 1); // \u274c Infinite recursion!\n    }\n}\n```\n\n## Common Solutions\n\n### 1. **Notification Flag**\n```java\nclass Subject {\n    private boolean isNotifying = false;\n    \n    private void notifyObservers() {\n        if (isNotifying) return; // Prevent re-entry\n        \n        isNotifying = true;\n        try {\n            for (Observer obs : observers) {\n                obs.update(this);\n            }\n        } finally {\n            isNotifying = false;\n        }\n    }\n}\n```\n\n### 2. **Deferred Notifications**\n```java\nclass Subject {\n    private Queue<Runnable> pendingNotifications = new LinkedList<>();\n    \n    public void setState(int state) {\n        this.state = state;\n        scheduleNotifications();\n    }\n}\n```\n\n### 3. **Design Guideline**\n**Best practice**: Observers should generally **NOT** modify the Subject during `update()`. Instead, they should only read state and update themselves.",
    "expected": true
  },
  {
    "id": "tf_008",
    "type": "true_false",
    "topic": "decorator",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1797,
    "prediction": "# Answer: **False**\n\n## Explanation:\n\nThe statement is **incorrect**. The Decorator pattern does **NOT** require the decorator to extend the concrete class being decorated. Instead, both the decorator and the concrete class should **implement the same interface** (or extend the same abstract class).\n\n## Key Principles of the Decorator Pattern:\n\n1. **Decorator and component implement the same interface** - This allows decorators to wrap components transparently\n2. **Decorator HAS-A (contains) component** - Through composition, not inheritance from concrete class\n3. **Decorator IS-A component** - Through the shared interface/abstract class\n\n## Correct Structure:\n\n```java\n// Component interface\ninterface Coffee {\n    String getDescription();\n    double getCost();\n}\n\n// Concrete component\nclass SimpleCoffee implements Coffee {\n    public String getDescription() {\n        return \"Simple coffee\";\n    }\n    \n    public double getCost() {\n        return 2.0;\n    }\n}\n\n// Decorator (implements same interface, NOT extends SimpleCoffee)\nabstract class CoffeeDecorator implements Coffee {\n    protected Coffee decoratedCoffee;\n    \n    public CoffeeDecorator(Coffee coffee) {\n        this.decoratedCoffee = coffee;\n    }\n}\n\n// Concrete decorator\nclass MilkDecorator extends CoffeeDecorator {\n    public MilkDecorator(Coffee coffee) {\n        super(coffee);\n    }\n    \n    public String getDescription() {\n        return decoratedCoffee.getDescription() + \", with milk\";\n    }\n    \n    public double getCost() {\n        return decoratedCoffee.getCost() + 0.5;\n    }\n}\n```\n\n## Why This Matters:\n\n- \u2705 Allows decorating any implementation of the interface\n- \u2705 Supports multiple layers of decoration\n- \u2705 Follows \"program to an interface\" principle\n- \u274c Extending concrete class would create tight coupling",
    "expected": false
  },
  {
    "id": "tf_009",
    "type": "true_false",
    "topic": "decorator",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1591,
    "prediction": "# Answer: **TRUE**\n\nThis statement is correct. The JScrollPane/JPanel relationship is a classic example of the **Decorator pattern** in Java Swing.\n\n## Why This Demonstrates the Decorator Pattern:\n\n### 1. **Wraps the Original Component**\n```java\nJPanel panel = new JPanel();\nJScrollPane scrollPane = new JScrollPane(panel);\n// JScrollPane wraps the JPanel\n```\n\n### 2. **Adds New Functionality**\n- The `JScrollPane` adds scrolling capabilities (horizontal/vertical scrollbars)\n- The original `JPanel` doesn't need to know about scrolling\n\n### 3. **Delegates Core Behavior**\n- The `JScrollPane` delegates painting and component management to the wrapped `JPanel`\n- The panel maintains its original functionality\n\n### 4. **Transparent to Client Code**\n```java\n// Both implement Component/Container interfaces\nframe.add(scrollPane);  // Can be added just like the panel\n```\n\n## Decorator Pattern Key Characteristics Present:\n\n\u2705 **Same interface type** - Both are `Component` subclasses  \n\u2705 **Wraps an object** - JScrollPane contains a JPanel  \n\u2705 **Adds responsibility** - Adds scrolling without modifying JPanel  \n\u2705 **Forwards requests** - Delegates display/behavior to wrapped component  \n\n## Visual Example:\n```java\nJPanel panel = new JPanel();\npanel.setPreferredSize(new Dimension(1000, 1000));\n\n// Decorator adds scrolling capability\nJScrollPane decorator = new JScrollPane(panel);\ndecorator.setPreferredSize(new Dimension(400, 400));\n\nframe.add(decorator); // Now scrollable!\n```\n\nThe JScrollPane \"decorates\" the JPanel with scrolling behavior while preserving all original panel functionality.",
    "expected": true
  },
  {
    "id": "tf_010",
    "type": "true_false",
    "topic": "strategy",
    "correct": false,
    "score": 0.0,
    "edit_distance": 1569,
    "prediction": "# Correct! \u2713\n\nThis is indeed an example of the **Strategy Pattern**.\n\n## Why This Represents the Strategy Pattern\n\nThe Strategy Pattern is characterized by:\n\n1. **Encapsulation of algorithms** - Different move selection algorithms can implement this interface\n2. **Interchangeable behavior** - Strategies can be swapped at runtime\n3. **Common interface** - All strategies share the same `chooseMove()` method signature\n4. **Decoupling** - The client (game) doesn't need to know implementation details\n\n## Example Implementation\n\n```java\n// Strategy interface\npublic interface TicTacToeStrategy {\n    Coord chooseMove(TicTacToeModel model, Piece forWhom);\n}\n\n// Concrete Strategy 1: Random moves\npublic class RandomStrategy implements TicTacToeStrategy {\n    @Override\n    public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n        // Pick a random valid move\n    }\n}\n\n// Concrete Strategy 2: Minimax AI\npublic class MinimaxStrategy implements TicTacToeStrategy {\n    @Override\n    public Coord chooseMove(TicTacToeModel model, Piece forWhom) {\n        // Use minimax algorithm\n    }\n}\n\n// Context: Player using a strategy\npublic class AIPlayer {\n    private TicTacToeStrategy strategy;\n    \n    public void setStrategy(TicTacToeStrategy strategy) {\n        this.strategy = strategy;  // Runtime swap!\n    }\n    \n    public Coord makeMove(TicTacToeModel model, Piece piece) {\n        return strategy.chooseMove(model, piece);\n    }\n}\n```\n\nThis allows you to easily switch between beginner AI, expert AI, or human input strategies without changing the game logic.",
    "expected": true
  },
  {
    "id": "tf_011",
    "type": "true_false",
    "topic": "strategy",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1694,
    "prediction": "# Answer: **FALSE**\n\nThis statement is **incorrect**. The Strategy pattern **CAN** have multiple strategies active simultaneously for the same context object.\n\n## Explanation\n\n### Multiple Strategies ARE Possible\n\nA context object can maintain references to multiple strategy objects and use them for different purposes:\n\n```java\n// Context with multiple strategies\npublic class PaymentProcessor {\n    private ValidationStrategy validationStrategy;\n    private EncryptionStrategy encryptionStrategy;\n    private LoggingStrategy loggingStrategy;\n    \n    public void processPayment(Payment payment) {\n        // Using multiple strategies simultaneously\n        validationStrategy.validate(payment);\n        String encrypted = encryptionStrategy.encrypt(payment.getData());\n        loggingStrategy.log(\"Payment processed\");\n    }\n    \n    // Setters for each strategy\n    public void setValidationStrategy(ValidationStrategy strategy) {\n        this.validationStrategy = strategy;\n    }\n    \n    public void setEncryptionStrategy(EncryptionStrategy strategy) {\n        this.encryptionStrategy = strategy;\n    }\n    \n    public void setLoggingStrategy(LoggingStrategy strategy) {\n        this.loggingStrategy = strategy;\n    }\n}\n```\n\n### Key Differences from Decorator\n\n- **Strategy**: Typically uses composition to hold strategy references; multiple strategies can handle *different concerns*\n- **Decorator**: Chains decorators together in layers; multiple decorators can enhance the *same concern*\n\nBoth patterns support multiple active instances, just organized differently. The main distinction is that Strategy uses **delegation to alternatives** while Decorator uses **wrapping for enhancement**.",
    "expected": false
  },
  {
    "id": "tf_012",
    "type": "true_false",
    "topic": "command",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1956,
    "prediction": "# Answer: **TRUE**\n\n## Explanation:\n\nThe Command pattern is **ideally suited** for implementing undo functionality. Here's why:\n\n### Key Principles:\n\n1. **Encapsulation of Action**: Each command object encapsulates a request as an object, containing all information needed to execute the action.\n\n2. **State Preservation**: Commands can store the state before execution, which is necessary to reverse the operation.\n\n3. **Reversible Operations**: Commands can implement an `undo()` method alongside the `execute()` method.\n\n### Example:\n\n```java\npublic interface Command {\n    void execute();\n    void undo();\n}\n\npublic class LightOnCommand implements Command {\n    private Light light;\n    \n    public LightOnCommand(Light light) {\n        this.light = light;\n    }\n    \n    @Override\n    public void execute() {\n        light.on();\n    }\n    \n    @Override\n    public void undo() {\n        light.off();  // Reverses the action\n    }\n}\n\npublic class TextInsertCommand implements Command {\n    private TextEditor editor;\n    private String text;\n    private int position;\n    \n    public TextInsertCommand(TextEditor editor, String text, int position) {\n        this.editor = editor;\n        this.text = text;\n        this.position = position;\n    }\n    \n    @Override\n    public void execute() {\n        editor.insert(text, position);\n    }\n    \n    @Override\n    public void undo() {\n        editor.delete(position, text.length());  // Reverses insertion\n    }\n}\n```\n\n### Undo Manager Example:\n\n```java\npublic class CommandManager {\n    private Stack<Command> history = new Stack<>();\n    \n    public void executeCommand(Command command) {\n        command.execute();\n        history.push(command);\n    }\n    \n    public void undo() {\n        if (!history.isEmpty()) {\n            Command command = history.pop();\n            command.undo();\n        }\n    }\n}\n```\n\nThis pattern is commonly used in text editors, graphics applications, and transaction systems.",
    "expected": true
  },
  {
    "id": "tf_013",
    "type": "true_false",
    "topic": "command",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1500,
    "prediction": "# Answer: **False**\n\n## Explanation:\n\nThe `save()` and `restore()` methods in SimpleTurtle are **NOT** implementations of the Command pattern. Here's why:\n\n### What These Methods Actually Do:\n- **`save()`**: Pushes the current turtle state (position, heading) onto a stack\n- **`restore()`**: Pops state from the stack and restores the turtle to that state\n\nThese are simple **stack-based state management** operations, not command objects.\n\n### Why This Isn't the Command Pattern:\n\n**The Command Pattern requires:**\n1. Encapsulating requests as objects\n2. A common Command interface with an `execute()` method\n3. Typically includes `undo()` functionality\n4. Commands can be queued, logged, or passed around\n\n**What save()/restore() actually are:**\n- Direct method calls on the turtle object\n- Use a simple stack data structure (LIFO)\n- No command objects encapsulating the operations\n- No `execute()` or `undo()` methods\n- Not polymorphic command objects\n\n### Example Contrast:\n\n```java\n// Command Pattern (what turtle drawing commands would look like):\nCommand forward = new ForwardCommand(turtle, 100);\nforward.execute();\nforward.undo();\n\n// save()/restore() (NOT Command pattern):\nturtle.save();        // Just pushes state to stack\nturtle.forward(100);\nturtle.restore();     // Just pops state from stack\n```\n\nThe confusion may arise because save/restore provide undo-like functionality, but they use a different design pattern altogether (Memento pattern is closer, though still not a perfect match).",
    "expected": false
  },
  {
    "id": "tf_014",
    "type": "true_false",
    "topic": "inheritance",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1351,
    "prediction": "# Answer: **TRUE**\n\n## Explanation:\n\nThis is a classic **self-use problem** in inheritance. Let me walk through what happens:\n\n### The Scenario:\n```java\nclass IntSet2 {\n    public void add(int x) {\n        // adds element\n    }\n    \n    public void addAll(Collection<Integer> c) {\n        for (int x : c) {\n            add(x);  // internally calls add()\n        }\n    }\n}\n\nclass InstrumentedIntSet2 extends IntSet2 {\n    private int count = 0;\n    \n    @Override\n    public void add(int x) {\n        count++;\n        super.add(x);\n    }\n    \n    @Override\n    public void addAll(Collection<Integer> c) {\n        count += c.size();\n        super.addAll(c);\n    }\n}\n```\n\n### What Happens When You Call `addAll([1, 2, 3])`:\n\n1. **`InstrumentedIntSet2.addAll()`** executes:\n   - Increments `count` by 3 \u2713\n   \n2. **Calls `super.addAll()`** (IntSet2's version):\n   - Loops through each element\n   - Calls `add()` for each element\n   \n3. **But which `add()`?** Due to polymorphism, it calls **`InstrumentedIntSet2.add()`** (the overridden version):\n   - Increments `count` by 1 for element 1 \u2713\n   - Increments `count` by 1 for element 2 \u2713\n   - Increments `count` by 1 for element 3 \u2713\n\n### Result:\n- **Total count = 6** (should be 3)\n- Elements are **double-counted**!\n\n### The Solution:\nOnly override `add()`, not `addAll()`, and let inheritance handle the rest.",
    "expected": true
  },
  {
    "id": "tf_015",
    "type": "true_false",
    "topic": "inheritance",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1750,
    "prediction": "# Answer: **TRUE**\n\nMaking a method `final` in a base class **is indeed a defensive programming technique** that prevents subclasses from overriding that method, thereby protecting the base class's internal behavior.\n\n## Explanation\n\n### Why This Is True\n\n1. **Prevents Override Interference**\n   - A `final` method cannot be overridden by subclasses\n   - Guarantees the method's behavior remains unchanged in the inheritance hierarchy\n\n2. **Protects Internal Contracts**\n   - If base class methods depend on each other, `final` ensures those dependencies aren't broken\n   - Prevents subclasses from inadvertently breaking the base class's logic\n\n### Example\n\n```java\npublic class BankAccount {\n    private double balance;\n    \n    // Final method - subclasses cannot override\n    public final void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n            logTransaction(\"Deposit\", amount);\n        }\n    }\n    \n    // Protected method that deposit() relies on\n    protected void logTransaction(String type, double amount) {\n        System.out.println(type + \": $\" + amount);\n    }\n}\n\npublic class SavingsAccount extends BankAccount {\n    // Compilation ERROR - cannot override final method\n    // public void deposit(double amount) { ... }\n    \n    // Can still override non-final methods\n    @Override\n    protected void logTransaction(String type, double amount) {\n        System.out.println(\"SAVINGS - \" + type + \": $\" + amount);\n    }\n}\n```\n\n### When to Use `final` Methods\n\n- **Security-critical operations**\n- **Methods that maintain class invariants**\n- **Template method pattern implementations**\n- **Methods called from constructors**\n\nThis is a key defensive programming practice in object-oriented design.",
    "expected": true
  },
  {
    "id": "tf_016",
    "type": "true_false",
    "topic": "composition",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1634,
    "prediction": "# Answer: **TRUE**\n\n## Explanation:\n\nThis statement is **correct**. The design pattern described is called **composition with forwarding** (also known as the **wrapper pattern** or **decorator pattern**), and it does indeed avoid the fragile base class problem.\n\n### Why This Is True:\n\n**1. Composition Over Inheritance:**\n```java\npublic class InstrumentedIntSet implements IntSet {\n    private IntSet delegate;  // Composition - HAS-A relationship\n    private int addCount = 0;\n    \n    public InstrumentedIntSet(IntSet delegate) {\n        this.delegate = delegate;\n    }\n    \n    @Override\n    public void add(int x) {\n        addCount++;\n        delegate.add(x);  // Forwarding\n    }\n    \n    @Override\n    public void addAll(int[] elements) {\n        addCount += elements.length;\n        delegate.addAll(elements);  // Forwarding\n    }\n    \n    public int getAddCount() {\n        return addCount;\n    }\n}\n```\n\n**2. Avoids Fragile Base Class Problem:**\n- **With inheritance**: If the base class implementation changes (e.g., `addAll()` internally calls `add()`), your subclass can break or double-count\n- **With composition**: You're insulated from internal implementation changes in the delegate class\n- The wrapper only depends on the **interface contract**, not the implementation details\n\n**3. Key Benefits:**\n- \u2705 No dependency on base class implementation details\n- \u2705 Works with any `IntSet` implementation\n- \u2705 More flexible and maintainable\n- \u2705 Prevents unexpected behavior from base class modifications\n\nThis is a recommended design principle from Joshua Bloch's *Effective Java* (Item 18: \"Favor composition over inheritance\").",
    "expected": true
  },
  {
    "id": "tf_017",
    "type": "true_false",
    "topic": "testing",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1150,
    "prediction": "# Answer: False\n\nThis statement is **incorrect**. Using `assertEquals(new int[] {3, 6}, new int[] {3, 6})` in JUnit will **FAIL**, not pass.\n\n## Explanation\n\nThe reason is that `assertEquals()` uses the `.equals()` method to compare objects, and arrays in Java use **reference equality** by default, not content equality.\n\n```java\n@Test\npublic void testArrayEquality() {\n    // This will FAIL\n    assertEquals(new int[] {3, 6}, new int[] {3, 6});\n    // Even though they have the same elements, they are different objects\n}\n```\n\n## Correct Way to Assert Array Equality\n\nTo properly test array equality in JUnit, use:\n\n### **JUnit 4:**\n```java\nimport static org.junit.Assert.assertArrayEquals;\n\n@Test\npublic void testArrayEquality() {\n    assertArrayEquals(new int[] {3, 6}, new int[] {3, 6}); // PASSES\n}\n```\n\n### **JUnit 5:**\n```java\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\n@Test\npublic void testArrayEquality() {\n    assertArrayEquals(new int[] {3, 6}, new int[] {3, 6}); // PASSES\n}\n```\n\n## Key Takeaway\n\n- `assertEquals()` \u2192 compares **object references** for arrays \u274c\n- `assertArrayEquals()` \u2192 compares **array contents** \u2705",
    "expected": false
  },
  {
    "id": "tf_018",
    "type": "true_false",
    "topic": "testing",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1271,
    "prediction": "# Answer: False\n\nThe statement is **incorrect**.\n\n## Correct Behavior\n\nA `@Before` annotated method in JUnit runs **before each individual test method**, not once before all tests.\n\n## Key Distinctions\n\n| Annotation | Execution Timing |\n|------------|------------------|\n| `@Before` | Before **each** test method |\n| `@BeforeClass` | Once before **all** tests in the class |\n\n## Example\n\n```java\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\n\npublic class ExampleTest {\n    \n    @BeforeClass\n    public static void setUpOnce() {\n        // Runs ONCE before all tests\n        System.out.println(\"BeforeClass: runs once\");\n    }\n    \n    @Before\n    public void setUpBeforeEach() {\n        // Runs before EACH test\n        System.out.println(\"Before: runs before each test\");\n    }\n    \n    @Test\n    public void test1() {\n        System.out.println(\"Test 1\");\n    }\n    \n    @Test\n    public void test2() {\n        System.out.println(\"Test 2\");\n    }\n}\n```\n\n**Output:**\n```\nBeforeClass: runs once\nBefore: runs before each test\nTest 1\nBefore: runs before each test\nTest 2\n```\n\n## Note for JUnit 5\nIn JUnit 5, the annotations have changed:\n- `@BeforeEach` (equivalent to JUnit 4's `@Before`)\n- `@BeforeAll` (equivalent to JUnit 4's `@BeforeClass`)",
    "expected": false
  },
  {
    "id": "tf_019",
    "type": "true_false",
    "topic": "testing",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1276,
    "prediction": "# Answer: **True**\n\n## Explanation:\n\nThe annotation `@Test(expected = IllegalArgumentException.class)` in JUnit 4 will cause a test to pass **if and only if** the annotated test method throws an `IllegalArgumentException` (or a subclass of it).\n\n### How it works:\n\n- \u2705 **Test PASSES** if: An `IllegalArgumentException` is thrown during the test execution\n- \u274c **Test FAILS** if: \n  - No exception is thrown\n  - A different exception type is thrown\n\n### Example:\n\n```java\n@Test(expected = IllegalArgumentException.class)\npublic void testInvalidInput() {\n    // This test will PASS because it throws IllegalArgumentException\n    throw new IllegalArgumentException(\"Invalid input\");\n}\n\n@Test(expected = IllegalArgumentException.class)\npublic void testWillFail() {\n    // This test will FAIL because no exception is thrown\n    int result = 2 + 2;\n}\n\n@Test(expected = IllegalArgumentException.class)\npublic void testWillAlsoFail() {\n    // This test will FAIL because it throws a different exception\n    throw new NullPointerException();\n}\n```\n\n### Note:\nIn JUnit 5, this syntax has changed to `@Test` with `assertThrows()`:\n```java\n@Test\npublic void testInvalidInput() {\n    assertThrows(IllegalArgumentException.class, () -> {\n        // code that should throw exception\n    });\n}\n```",
    "expected": true
  },
  {
    "id": "tf_020",
    "type": "true_false",
    "topic": "mvc",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1553,
    "prediction": "# Answer: **False**\n\n## Explanation:\n\nMock objects **do not** serve the same purpose as actual objects, nor should they implement identical behavior in all cases. Here are the key distinctions:\n\n### Purpose Differences:\n\n1. **Actual Objects**: Perform real business logic, interact with databases, external APIs, file systems, etc.\n\n2. **Mock Objects**: Provide **controlled, predictable responses** for testing purposes without executing real logic.\n\n### Why Mocks Behave Differently:\n\n```java\n// Actual object - performs real database operation\npublic class UserRepository {\n    public User findById(int id) {\n        // Actually queries database\n        return database.query(\"SELECT * FROM users WHERE id = ?\", id);\n    }\n}\n\n// Mock object - returns predetermined test data\n@Test\npublic void testUserService() {\n    UserRepository mockRepo = mock(UserRepository.class);\n    \n    // Mock returns controlled data, NO database call\n    when(mockRepo.findById(1))\n        .thenReturn(new User(1, \"Test User\"));\n    \n    // This is DIFFERENT from actual behavior - that's the point!\n}\n```\n\n### Key Characteristics of Mocks:\n\n- **Simplified behavior**: Return only what's needed for the test\n- **No side effects**: Don't write to databases, send emails, etc.\n- **Fast execution**: No I/O operations\n- **Predictable**: Always return the same test data\n- **Isolated**: Test one component without dependencies\n\n### The Real Purpose:\nMocks **isolate the code under test** by replacing dependencies with controllable substitutes, not by replicating actual behavior.",
    "expected": false
  },
  {
    "id": "tf_021",
    "type": "true_false",
    "topic": "factory",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1495,
    "prediction": "# Answer: **False**\n\nThis statement is **false**. A static factory method like `IntSet2Impl.singleton(int member)` does **not** violate encapsulation in any meaningful way.\n\n## Explanation:\n\n### Why the statement is false:\n\n1. **Encapsulation is about hiding implementation details**, not hiding class names. The key question is: what does the method *return*?\n\n2. **Proper usage returns an interface type:**\n```java\npublic class IntSet2Impl implements IntSet2 {\n    public static IntSet2 singleton(int member) {\n        // implementation\n        return new IntSet2Impl(...);\n    }\n}\n```\n\nThe return type is `IntSet2` (the interface), not `IntSet2Impl`. Clients interact with the interface:\n\n```java\nIntSet2 set = IntSet2Impl.singleton(5); // Client only sees IntSet2\n```\n\n3. **The client only knows the concrete class name for the factory call**, but afterward works entirely through the interface. This is a common and accepted pattern.\n\n### Benefits of this approach:\n\n- \u2705 Implementation details remain hidden\n- \u2705 The concrete class can be swapped without changing client code\n- \u2705 Clients depend on the interface, not the implementation\n- \u2705 This is a standard Java pattern (see `Collections.emptyList()`, `List.of()`, etc.)\n\n### Comparison to constructor:\n\nBoth require knowing a concrete class name at instantiation:\n- `new IntSet2Impl()` \u2190 requires concrete class\n- `IntSet2Impl.singleton()` \u2190 requires concrete class\n\nNeither violates encapsulation if used properly with interface return types.",
    "expected": false
  },
  {
    "id": "tf_022",
    "type": "true_false",
    "topic": "adapter",
    "correct": true,
    "score": 1.0,
    "edit_distance": 2230,
    "prediction": "# Answer: **True**\n\nThis statement is correct. Let me explain why:\n\n## Why Object Adapter is Preferred in These Cases:\n\n### 1. **When the Adaptee Class is Final**\n\n```java\n// Adaptee class marked as final\npublic final class LegacyPrinter {\n    public void printOldWay(String text) {\n        System.out.println(\"Legacy: \" + text);\n    }\n}\n\n// \u274c CLASS ADAPTER - Won't work with final class\n// This will cause a compilation error!\npublic class PrinterAdapter extends LegacyPrinter implements ModernPrinter {\n    // Cannot extend final class!\n}\n\n// \u2705 OBJECT ADAPTER - Works perfectly\npublic class PrinterAdapter implements ModernPrinter {\n    private final LegacyPrinter adaptee; // Composition instead of inheritance\n    \n    public PrinterAdapter(LegacyPrinter adaptee) {\n        this.adaptee = adaptee;\n    }\n    \n    @Override\n    public void print(String text) {\n        adaptee.printOldWay(text);\n    }\n}\n```\n\n### 2. **When Adapting Multiple Adaptees**\n\n```java\n// Multiple adaptee classes\npublic class EmailService {\n    public void sendEmail(String msg) { /* ... */ }\n}\n\npublic class SmsService {\n    public void sendSms(String msg) { /* ... */ }\n}\n\n// \u274c CLASS ADAPTER - Can only extend one class\npublic class NotificationAdapter extends EmailService implements Notifier {\n    // Can't also extend SmsService - Java doesn't support multiple inheritance\n}\n\n// \u2705 OBJECT ADAPTER - Can adapt multiple services\npublic class NotificationAdapter implements Notifier {\n    private EmailService emailService;\n    private SmsService smsService;\n    \n    public NotificationAdapter(EmailService email, SmsService sms) {\n        this.emailService = email;\n        this.smsService = sms;\n    }\n    \n    @Override\n    public void notify(String message, String type) {\n        if (type.equals(\"email\")) {\n            emailService.sendEmail(message);\n        } else if (type.equals(\"sms\")) {\n            smsService.sendSms(message);\n        }\n    }\n}\n```\n\n## Key Advantages of Object Adapter:\n\n- **Composition over inheritance** - More flexible\n- **Works with final classes** - No inheritance needed\n- **Can adapt multiple objects** - Holds multiple references\n- **Runtime flexibility** - Can swap adaptees dynamically\n\nThe statement is **True**.",
    "expected": true
  },
  {
    "id": "tf_023",
    "type": "true_false",
    "topic": "decorator",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1672,
    "prediction": "# Answer: **True**\n\n## Explanation:\n\nIn the Decorator pattern, a concrete decorator **must call the corresponding method on its wrapped component** to maintain the chain of responsibility. This is essential for the pattern to work correctly.\n\n## How It Works:\n\n```java\n// Component interface\ninterface Coffee {\n    double getCost();\n    String getDescription();\n}\n\n// Concrete Component\nclass SimpleCoffee implements Coffee {\n    public double getCost() {\n        return 2.0;\n    }\n    \n    public String getDescription() {\n        return \"Simple coffee\";\n    }\n}\n\n// Decorator base class\nabstract class CoffeeDecorator implements Coffee {\n    protected Coffee wrappedCoffee;\n    \n    public CoffeeDecorator(Coffee coffee) {\n        this.wrappedCoffee = coffee;\n    }\n}\n\n// Concrete Decorator\nclass MilkDecorator extends CoffeeDecorator {\n    public MilkDecorator(Coffee coffee) {\n        super(coffee);\n    }\n    \n    public double getCost() {\n        // MUST call wrapped component's method\n        return wrappedCoffee.getCost() + 0.5;  // Add own behavior\n    }\n    \n    public String getDescription() {\n        // MUST call wrapped component's method\n        return wrappedCoffee.getDescription() + \", milk\";  // Add own behavior\n    }\n}\n```\n\n## Key Points:\n\n1. **The call can happen before OR after** adding the decorator's behavior\n2. **Without this call**, the chain breaks and wrapped components are ignored\n3. This maintains the **delegation chain** through all decorators\n4. It's what allows **multiple decorators to stack** properly\n\n```java\nCoffee coffee = new MilkDecorator(new SugarDecorator(new SimpleCoffee()));\n// All decorators in the chain get executed\n```",
    "expected": true
  },
  {
    "id": "tf_024",
    "type": "true_false",
    "topic": "gui",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1487,
    "prediction": "# Answer: **True**\n\n## Explanation:\n\nWhen working with mouse events in Java Swing, you have two options:\n\n### 1. **Implementing MouseListener directly**\n```java\npublic class MyPanel extends JPanel implements MouseListener {\n    public MyPanel() {\n        addMouseListener(this);\n    }\n    \n    // Must implement ALL 5 methods, even if you don't need them\n    public void mouseClicked(MouseEvent e) { /* your code */ }\n    public void mousePressed(MouseEvent e) { }\n    public void mouseReleased(MouseEvent e) { }\n    public void mouseEntered(MouseEvent e) { }\n    public void mouseExited(MouseEvent e) { }\n}\n```\n\n### 2. **Extending MouseAdapter** \u2713\n```java\npublic class MyPanel extends JPanel {\n    public MyPanel() {\n        addMouseListener(new MouseAdapter() {\n            // Only override the method(s) you need!\n            @Override\n            public void mouseClicked(MouseEvent e) {\n                // your code here\n            }\n        });\n    }\n}\n```\n\n## Key Advantages of MouseAdapter:\n\n- **Less boilerplate code** - No need to implement empty methods\n- **Cleaner code** - Only write what you actually use\n- **Adapter pattern** - Provides empty implementations of all interface methods\n- **Works for both MouseListener and MouseMotionListener**\n\n## Why This Works:\n\n`MouseAdapter` is an abstract class that implements both `MouseListener` and `MouseMotionListener` interfaces with empty method bodies. You can selectively override only the methods relevant to your application.",
    "expected": true
  },
  {
    "id": "tf_025",
    "type": "true_false",
    "topic": "gui",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1426,
    "prediction": "# Answer: **False**\n\n## Explanation:\n\nCalling `repaint()` on a Swing `JPanel` does **not** trigger an immediate synchronous call to `paintComponent()`. Instead, it works asynchronously.\n\n## How `repaint()` Actually Works:\n\n1. **`repaint()` is asynchronous** - It schedules a paint request rather than painting immediately\n2. **Event queue mechanism** - The repaint request is placed on the Event Dispatch Thread (EDT) queue\n3. **Coalescing** - Multiple `repaint()` calls may be merged into a single paint operation for efficiency\n4. **Eventual execution** - `paintComponent()` is called later when the EDT processes the request\n\n## Example Demonstrating Asynchronous Behavior:\n\n```java\npublic class RepaintDemo extends JPanel {\n    public RepaintDemo() {\n        setPreferredSize(new Dimension(300, 200));\n    }\n    \n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        System.out.println(\"paintComponent called\");\n    }\n    \n    public void demonstrateAsync() {\n        System.out.println(\"Before repaint()\");\n        repaint();\n        System.out.println(\"After repaint()\");\n        // Output shows \"After repaint()\" BEFORE \"paintComponent called\"\n    }\n}\n```\n\n## For Immediate Synchronous Painting:\n\nIf you need immediate painting, use:\n```java\npaintImmediately(0, 0, getWidth(), getHeight());\n```\n\nThis is rarely recommended as it bypasses Swing's optimized painting mechanism.",
    "expected": false
  },
  {
    "id": "tf_026",
    "type": "true_false",
    "topic": "mvc",
    "correct": false,
    "score": 0.0,
    "edit_distance": 1457,
    "prediction": "# Answer: **Partially Correct** \u2757\n\nLet me clarify the concepts here:\n\n## What's Correct \u2713\n- `Readable` does operate on **characters** (text)\n- `InputStream` operates on **bytes** (binary data)\n- `Readable` is indeed suitable for text-based input\n\n## What Needs Clarification \u26a0\ufe0f\n\n### \"More general\" is misleading\n\n`Readable` is not necessarily \"more general\" than `InputStream` - they serve **different purposes**:\n\n- **`InputStream`**: For binary/byte-oriented data (images, audio, any file type)\n- **`Readable`**: For character/text-oriented data (reading text input)\n\nThey are parallel abstractions in different type hierarchies, not one being more general than the other.\n\n## Key Differences\n\n```java\n// InputStream - byte-oriented\nInputStream in = new FileInputStream(\"data.bin\");\nint byteData = in.read(); // reads bytes (0-255)\n\n// Readable - character-oriented  \nReadable readable = new FileReader(\"text.txt\");\nCharBuffer buffer = CharBuffer.allocate(100);\nreadable.read(buffer); // reads characters\n```\n\n## Better Statement\n\n> \"The **Readable** interface in Java operates on **characters** rather than bytes (like InputStream), making it **more appropriate** for text-based input, such as reading from a Scanner or text files with character encoding support.\"\n\n### Summary\n- \u2713 Character vs. byte distinction is correct\n- \u2717 \"More general\" is inaccurate - they're different abstractions for different use cases\n- \u2713 Suitable for text-based input is correct",
    "expected": true
  },
  {
    "id": "tf_027",
    "type": "true_false",
    "topic": "inheritance",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1539,
    "prediction": "# Answer: **True**\n\nThis statement is **correct**. When a class is \"designed for inheritance,\" proper documentation should include implementation details about internal method calls, also known as \"self-use\" patterns.\n\n## Why This Matters\n\nWhen you override a method in a subclass, you need to know:\n- Which other methods in the superclass call the method you're overriding\n- What internal dependencies exist between methods\n- How your override will affect the overall behavior\n\n## Example\n\n```java\n/**\n * This class is designed for inheritance.\n * \n * IMPLEMENTATION NOTE FOR SUBCLASSES:\n * - The add() method calls addAll() internally\n * - If you override addAll(), it will affect add()'s behavior\n * - Override only one of these methods to avoid unexpected results\n */\npublic class MyCollection {\n    private int count = 0;\n    \n    /**\n     * Adds a single element.\n     * Implementation: delegates to addAll()\n     */\n    public void add(Object element) {\n        addAll(Collections.singleton(element));\n    }\n    \n    /**\n     * Adds multiple elements.\n     * Called by: add()\n     */\n    public void addAll(Collection<?> elements) {\n        count += elements.size();\n        // ... actual addition logic\n    }\n}\n```\n\n## Key Principle from Effective Java\n\nJoshua Bloch's *Effective Java* (Item 19) emphasizes: **\"Design and document for inheritance or else prohibit it.\"** This includes documenting self-use patterns so subclass authors can make informed decisions about which methods to override without breaking the class's invariants.",
    "expected": true
  },
  {
    "id": "tf_028",
    "type": "true_false",
    "topic": "strategy",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1713,
    "prediction": "# Answer: **False**\n\nThis statement is **false**. A strategy that always throws `UnsupportedOperationException` can be useful and does not necessarily represent a design flaw.\n\n## Valid Use Cases:\n\n### 1. **Indicating Unimplemented Optional Operations**\n```java\npublic interface Collection<E> {\n    boolean add(E e);\n    boolean remove(Object o);\n}\n\npublic class ImmutableCollection<E> implements Collection<E> {\n    @Override\n    public boolean add(E e) {\n        throw new UnsupportedOperationException(\"Cannot modify immutable collection\");\n    }\n    \n    @Override\n    public boolean remove(Object o) {\n        throw new UnsupportedOperationException(\"Cannot modify immutable collection\");\n    }\n}\n```\n\n### 2. **Read-Only Implementations**\n```java\npublic class ReadOnlyStrategy implements DataStrategy {\n    @Override\n    public void write(String data) {\n        throw new UnsupportedOperationException(\"Read-only strategy\");\n    }\n    \n    @Override\n    public String read() {\n        // Actual implementation\n        return data;\n    }\n}\n```\n\n### 3. **Placeholder for Future Implementation**\n```java\npublic class BetaFeatureStrategy implements PaymentStrategy {\n    @Override\n    public void processPayment(double amount) {\n        throw new UnsupportedOperationException(\"Feature not yet implemented\");\n    }\n}\n```\n\n## Real-World Examples:\n- `Collections.unmodifiableList()` returns lists where mutating operations throw `UnsupportedOperationException`\n- Java's `Arrays.asList()` throws this exception on `add()` and `remove()`\n\n## Key Point:\nThe exception **explicitly communicates** that certain operations are intentionally not supported, which is better than silently failing or returning misleading values.",
    "expected": false
  },
  {
    "id": "tf_029",
    "type": "true_false",
    "topic": "testing",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1775,
    "prediction": "# Answer: **True**\n\nThis statement is correct. Using `assertThrows` with a lambda expression is indeed preferred over `@Test(expected=...)` for several important reasons:\n\n## Key Advantages of `assertThrows`\n\n### 1. **Exception Message and State Testing**\n```java\n// Using assertThrows (JUnit 5) - BETTER\n@Test\nvoid testInvalidInput() {\n    IllegalArgumentException exception = assertThrows(\n        IllegalArgumentException.class,\n        () -> myMethod(-1)\n    );\n    \n    // Can verify exception details\n    assertEquals(\"Value must be positive\", exception.getMessage());\n    assertNotNull(exception.getCause());\n}\n\n// Using @Test(expected=...) (JUnit 4) - LIMITED\n@Test(expected = IllegalArgumentException.class)\nvoid testInvalidInput() {\n    myMethod(-1);\n    // Cannot inspect the exception at all!\n}\n```\n\n### 2. **Precise Exception Location**\n```java\n@Test\nvoid testWithAssertThrows() {\n    setup();  // If this throws, test fails correctly\n    \n    // Exception MUST occur in this specific lambda\n    assertThrows(IllegalArgumentException.class, \n        () -> myMethod(-1));\n    \n    cleanup();  // If this throws, test fails correctly\n}\n\n@Test(expected = IllegalArgumentException.class)\nvoid testWithExpected() {\n    setup();  // If this throws, test passes incorrectly!\n    myMethod(-1);\n    cleanup();  // Never reached\n}\n```\n\n### 3. **Better Test Readability**\n`assertThrows` makes it explicit *which line* should throw the exception, improving test clarity.\n\n## Summary\n`assertThrows` provides:\n- \u2705 Access to exception object for detailed assertions\n- \u2705 Precise control over where exception should occur\n- \u2705 Better test accuracy and maintainability\n- \u2705 Modern JUnit 5 best practice\n\nThe `@Test(expected=...)` annotation is now considered outdated for these reasons.",
    "expected": true
  },
  {
    "id": "tf_030",
    "type": "true_false",
    "topic": "composition",
    "correct": true,
    "score": 1.0,
    "edit_distance": 1523,
    "prediction": "# Answer: **True**\n\n## Explanation\n\nThis statement is **true**. Composition with delegation does require more boilerplate code compared to inheritance because you must explicitly forward each method call to the delegate object.\n\n## Comparison Example\n\n### Using Inheritance (Less Boilerplate)\n```java\nclass Stack<T> extends ArrayList<T> {\n    public void push(T item) {\n        add(item);\n    }\n    \n    public T pop() {\n        return remove(size() - 1);\n    }\n}\n// Automatically inherits all ArrayList methods (add, remove, size, etc.)\n```\n\n### Using Composition with Delegation (More Boilerplate)\n```java\nclass Stack<T> {\n    private List<T> list = new ArrayList<>();\n    \n    public void push(T item) {\n        list.add(item);\n    }\n    \n    public T pop() {\n        return list.remove(list.size() - 1);\n    }\n    \n    // Must explicitly forward EVERY method you want to expose\n    public int size() {\n        return list.size();\n    }\n    \n    public boolean isEmpty() {\n        return list.isEmpty();\n    }\n    \n    public void clear() {\n        list.clear();\n    }\n    \n    // ... and so on for each method\n}\n```\n\n## Why Accept the Extra Boilerplate?\n\nDespite the extra code, composition is often preferred because:\n- **Better encapsulation** - only expose methods you want\n- **Flexibility** - easier to change implementation\n- **Avoids fragile base class problem**\n- **Follows \"favor composition over inheritance\" principle**\n\n**Note:** Some languages (like Kotlin) provide delegation syntax to reduce this boilerplate.",
    "expected": true
  },
  {
    "id": "essay_001",
    "type": "essay",
    "topic": "inheritance_vs_composition",
    "correct": false,
    "score": 0.0,
    "edit_distance": 3477,
    "prediction": "# The Fragile Base Class Problem: A Comprehensive Explanation\n\n## (a) How the Problem Manifests\n\nThe fragile base class problem occurs when a subclass breaks due to changes in its parent class, even when the subclass code itself hasn't changed. Let me demonstrate with the InstrumentedIntSet example:\n\n```java\n// Base class\npublic class IntSet {\n    private Set<Integer> set = new HashSet<>();\n    \n    public boolean add(int element) {\n        return set.add(element);\n    }\n    \n    public boolean addAll(Collection<Integer> elements) {\n        boolean modified = false;\n        for (int element : elements) {\n            modified |= add(element);  // Internally calls add()\n        }\n        return modified;\n    }\n    \n    public int size() {\n        return set.size();\n    }\n}\n\n// Subclass attempting to count additions\npublic class InstrumentedIntSet extends IntSet {\n    private int addCount = 0;\n    \n    @Override\n    public boolean add(int element) {\n        addCount++;\n        return super.add(element);\n    }\n    \n    @Override\n    public boolean addAll(Collection<Integer> elements) {\n        addCount += elements.size();\n        return super.addAll(elements);\n    }\n    \n    public int getAddCount() {\n        return addCount;\n    }\n}\n```\n\n**The Bug in Action:**\n\n```java\nInstrumentedIntSet set = new InstrumentedIntSet();\nset.addAll(Arrays.asList(1, 2, 3));\n\nSystem.out.println(\"Expected count: 3\");\nSystem.out.println(\"Actual count: \" + set.getAddCount());  // Prints 6!\nSystem.out.println(\"Actual size: \" + set.size());          // Prints 3\n```\n\n**Why the count is wrong:** The count is **doubled** because:\n1. `addAll()` increments `addCount` by 3\n2. `super.addAll()` calls `add()` three times\n3. Each `add()` call increments `addCount` by 1\n4. Total: 3 + 3 = 6\n\n## (b) Why the Problem Occurs\n\nThe problem stems from **implementation inheritance** combined with **self-use** (when a base class method calls another overridable method):\n\n```java\n// What happens during addAll(Arrays.asList(1, 2, 3)):\n\nInstrumentedIntSet.addAll() {\n    addCount += 3;              // addCount = 3\n    super.addAll() {            // Call to IntSet.addAll()\n        for (1, 2, 3) {\n            add(element);       // \u26a0\ufe0f Polymorphic call!\n                                // Calls InstrumentedIntSet.add(), not IntSet.add()\n        }\n    }\n}\n\n// Each add() call:\nInstrumentedIntSet.add() {\n    addCount++;                 // addCount = 4, 5, 6\n    super.add();\n}\n```\n\n**Key Issues:**\n\n1. **Hidden Dependencies:** The subclass doesn't know that `addAll()` uses `add()` internally\n2. **Polymorphic Method Dispatch:** When `IntSet.addAll()` calls `add()`, it calls the **overridden version** in `InstrumentedIntSet`\n3. **Violates Encapsulation:** The subclass must understand the base class's internal implementation\n4. **Fragility:** If the base class implementation changes, the subclass breaks\n\n**Alternative Attempts That Also Fail:**\n\n```java\n// Attempt 1: Don't override addAll()\npublic class InstrumentedIntSet extends IntSet {\n    private int addCount = 0;\n    \n    @Override\n    public boolean add(int element) {\n        addCount++;\n        return super.add(element);\n    }\n    // No addAll() override\n}\n// Problem: This works NOW, but if IntSet later changes addAll() \n// to not use add(), your counting breaks!\n\n// Attempt 2: Reimplement addAll() without calling super\n@Override\npublic boolean addAll(Collection<Integer> elements) {\n    addCount += elements.size();\n    //",
    "expected": ""
  },
  {
    "id": "essay_002",
    "type": "essay",
    "topic": "adapter_pattern",
    "correct": false,
    "score": 0.0,
    "edit_distance": 3815,
    "prediction": "# Object Adapters vs. Class Adapters: A Comprehensive Comparison\n\n## (a) Structural Differences\n\n### Class Adapter (Inheritance-Based)\n```java\n// Target interface\ninterface MediaPlayer {\n    void play(String filename);\n}\n\n// Adaptee (existing incompatible class)\nclass LegacyAudioPlayer {\n    public void playAudio(String filename) {\n        System.out.println(\"Playing audio: \" + filename);\n    }\n}\n\n// Class Adapter - uses inheritance\nclass ClassAdapter extends LegacyAudioPlayer implements MediaPlayer {\n    @Override\n    public void play(String filename) {\n        // Directly call inherited method\n        playAudio(filename);\n    }\n}\n```\n\n**Key Characteristics:**\n- Uses **multiple inheritance** (extends adaptee, implements target)\n- Direct access to adaptee's protected members\n- Static binding at compile-time\n- Single adaptee instance\n\n### Object Adapter (Composition-Based)\n```java\n// Object Adapter - uses composition\nclass ObjectAdapter implements MediaPlayer {\n    private LegacyAudioPlayer adaptee;\n    \n    public ObjectAdapter(LegacyAudioPlayer adaptee) {\n        this.adaptee = adaptee;\n    }\n    \n    @Override\n    public void play(String filename) {\n        // Delegate to composed object\n        adaptee.playAudio(filename);\n    }\n}\n```\n\n**Key Characteristics:**\n- Uses **composition** (has-a relationship)\n- Works with adaptee and its subclasses\n- Dynamic binding at runtime\n- Can adapt multiple related classes\n\n## (b) When to Choose Each Approach\n\n### Choose Class Adapter When:\n\n**Scenario 1: Simple, Single-Class Adaptation**\n```java\nclass TemperatureSensor {\n    protected double readCelsius() {\n        return 25.0;\n    }\n}\n\ninterface FahrenheitReader {\n    double readTemperature();\n}\n\n// Simple class adapter - no flexibility needed\nclass TempAdapter extends TemperatureSensor implements FahrenheitReader {\n    @Override\n    public double readTemperature() {\n        return readCelsius() * 9/5 + 32;\n    }\n}\n```\n\n**Scenario 2: Need Access to Protected Members**\n```java\nclass DatabaseConnection {\n    protected void internalConnect(String url) {\n        // Implementation\n    }\n    \n    protected boolean isConnectionValid() {\n        return true;\n    }\n}\n\ninterface Connection {\n    void connect(String url);\n}\n\nclass DBAdapter extends DatabaseConnection implements Connection {\n    @Override\n    public void connect(String url) {\n        // Can access protected methods\n        if (!isConnectionValid()) {\n            internalConnect(url);\n        }\n    }\n}\n```\n\n### Choose Object Adapter When:\n\n**Scenario 1: Adapting Multiple Related Classes**\n```java\nabstract class PaymentProcessor {\n    abstract void processPayment(double amount);\n}\n\nclass PayPalProcessor extends PaymentProcessor {\n    void processPayment(double amount) {\n        System.out.println(\"PayPal: $\" + amount);\n    }\n}\n\nclass StripeProcessor extends PaymentProcessor {\n    void processPayment(double amount) {\n        System.out.println(\"Stripe: $\" + amount);\n    }\n}\n\ninterface UnifiedPayment {\n    void pay(double amount);\n}\n\n// Object adapter works with entire hierarchy\nclass PaymentAdapter implements UnifiedPayment {\n    private PaymentProcessor processor;\n    \n    public PaymentAdapter(PaymentProcessor processor) {\n        this.processor = processor; // Can be ANY subclass\n    }\n    \n    @Override\n    public void pay(double amount) {\n        processor.processPayment(amount);\n    }\n}\n\n// Usage\nUnifiedPayment paypal = new PaymentAdapter(new PayPalProcessor());\nUnifiedPayment stripe = new PaymentAdapter(new StripeProcessor());\n```\n\n**Scenario 2: Runtime Flexibility**\n```java\nclass LoggingAdapter implements MediaPlayer {\n    private LegacyAudioPlayer adaptee;\n    private boolean loggingEnabled;\n    \n    public LoggingAdapter(LegacyAudioPlayer adaptee, boolean logging) {\n        this.adaptee = adapt",
    "expected": ""
  },
  {
    "id": "essay_003",
    "type": "essay",
    "topic": "mvc_architecture",
    "correct": false,
    "score": 0.0,
    "edit_distance": 3372,
    "prediction": "# Model-View-Controller (MVC) in TicTacToe Application\n\n## (a) Specific Responsibilities of Each Component\n\n### Model - Game Logic & State\nThe Model manages the **core game state and business logic**, independent of any UI concerns:\n\n```java\npublic class TicTacToeModel {\n    private char[][] board;\n    private char currentPlayer;\n    private GameState gameState;\n    private List<ModelObserver> observers;\n    \n    public TicTacToeModel() {\n        board = new char[3][3];\n        currentPlayer = 'X';\n        gameState = GameState.IN_PROGRESS;\n        observers = new ArrayList<>();\n        initializeBoard();\n    }\n    \n    // Business logic - validates and executes moves\n    public boolean makeMove(int row, int col) {\n        if (!isValidMove(row, col)) {\n            return false;\n        }\n        \n        board[row][col] = currentPlayer;\n        notifyObservers();\n        \n        if (checkWin()) {\n            gameState = GameState.WIN;\n        } else if (isBoardFull()) {\n            gameState = GameState.DRAW;\n        } else {\n            switchPlayer();\n        }\n        \n        return true;\n    }\n    \n    // Game logic methods\n    private boolean isValidMove(int row, int col) {\n        return row >= 0 && row < 3 && col >= 0 && col < 3 \n               && board[row][col] == ' ' \n               && gameState == GameState.IN_PROGRESS;\n    }\n    \n    private boolean checkWin() {\n        // Check rows, columns, and diagonals\n        for (int i = 0; i < 3; i++) {\n            if (checkLine(board[i][0], board[i][1], board[i][2])) return true;\n            if (checkLine(board[0][i], board[1][i], board[2][i])) return true;\n        }\n        return checkLine(board[0][0], board[1][1], board[2][2]) ||\n               checkLine(board[0][2], board[1][1], board[2][0]);\n    }\n    \n    private boolean checkLine(char c1, char c2, char c3) {\n        return c1 != ' ' && c1 == c2 && c2 == c3;\n    }\n    \n    // Getters for read-only access to state\n    public char[][] getBoardCopy() {\n        char[][] copy = new char[3][3];\n        for (int i = 0; i < 3; i++) {\n            System.arraycopy(board[i], 0, copy[i], 0, 3);\n        }\n        return copy;\n    }\n    \n    public char getCurrentPlayer() { return currentPlayer; }\n    public GameState getGameState() { return gameState; }\n}\n\nenum GameState {\n    IN_PROGRESS, WIN, DRAW\n}\n```\n\n### View - User Interface\nThe View is responsible for **displaying information and capturing user input**:\n\n```java\npublic interface TicTacToeView {\n    void displayBoard(char[][] board);\n    void displayCurrentPlayer(char player);\n    void displayWinner(char winner);\n    void displayDraw();\n    void displayInvalidMove();\n    void setController(TicTacToeController controller);\n}\n\n// Console implementation\npublic class ConsoleView implements TicTacToeView, ModelObserver {\n    private TicTacToeController controller;\n    private TicTacToeModel model;\n    private Scanner scanner;\n    \n    public ConsoleView(TicTacToeModel model) {\n        this.model = model;\n        this.scanner = new Scanner(System.in);\n        model.addObserver(this); // Register as observer\n    }\n    \n    @Override\n    public void displayBoard(char[][] board) {\n        System.out.println(\"\\n  0   1   2\");\n        for (int i = 0; i < 3; i++) {\n            System.out.print(i + \" \");\n            for (int j = 0; j < 3; j++) {\n                System",
    "expected": ""
  },
  {
    "id": "essay_004",
    "type": "essay",
    "topic": "decorator_pattern",
    "correct": false,
    "score": 0.0,
    "edit_distance": 3765,
    "prediction": "# The Decorator Pattern in Java\n\n## (a) Core Structure and Difference from Inheritance\n\n### Core Structure\n\nThe Decorator pattern allows adding responsibilities to objects dynamically without modifying their structure.\n\n```java\n// Component interface - defines the contract\ninterface Coffee {\n    String getDescription();\n    double getCost();\n}\n\n// Concrete Component - the base object\nclass SimpleCoffee implements Coffee {\n    @Override\n    public String getDescription() {\n        return \"Simple Coffee\";\n    }\n    \n    @Override\n    public double getCost() {\n        return 2.00;\n    }\n}\n\n// Decorator abstract class - wraps a component\nabstract class CoffeeDecorator implements Coffee {\n    protected Coffee decoratedCoffee;\n    \n    public CoffeeDecorator(Coffee coffee) {\n        this.decoratedCoffee = coffee;\n    }\n    \n    @Override\n    public String getDescription() {\n        return decoratedCoffee.getDescription();\n    }\n    \n    @Override\n    public double getCost() {\n        return decoratedCoffee.getCost();\n    }\n}\n\n// Concrete Decorators - add specific responsibilities\nclass MilkDecorator extends CoffeeDecorator {\n    public MilkDecorator(Coffee coffee) {\n        super(coffee);\n    }\n    \n    @Override\n    public String getDescription() {\n        return decoratedCoffee.getDescription() + \", Milk\";\n    }\n    \n    @Override\n    public double getCost() {\n        return decoratedCoffee.getCost() + 0.50;\n    }\n}\n\nclass CaramelDecorator extends CoffeeDecorator {\n    public CaramelDecorator(Coffee coffee) {\n        super(coffee);\n    }\n    \n    @Override\n    public String getDescription() {\n        return decoratedCoffee.getDescription() + \", Caramel\";\n    }\n    \n    @Override\n    public double getCost() {\n        return decoratedCoffee.getCost() + 0.75;\n    }\n}\n\n// Usage\npublic class DecoratorDemo {\n    public static void main(String[] args) {\n        Coffee coffee = new SimpleCoffee();\n        System.out.println(coffee.getDescription() + \" $\" + coffee.getCost());\n        \n        // Dynamically add decorations\n        coffee = new MilkDecorator(coffee);\n        System.out.println(coffee.getDescription() + \" $\" + coffee.getCost());\n        \n        coffee = new CaramelDecorator(coffee);\n        System.out.println(coffee.getDescription() + \" $\" + coffee.getCost());\n        \n        // Output:\n        // Simple Coffee $2.0\n        // Simple Coffee, Milk $2.5\n        // Simple Coffee, Milk, Caramel $3.25\n    }\n}\n```\n\n### Key Differences from Inheritance\n\n```java\n// INHERITANCE APPROACH - Static, inflexible\nclass CoffeeWithMilk extends SimpleCoffee { }\nclass CoffeeWithMilkAndCaramel extends CoffeeWithMilk { }\nclass CoffeeWithCaramel extends SimpleCoffee { }\n// Problem: Combinatorial explosion!\n// Need classes for every combination\n\n// DECORATOR APPROACH - Dynamic, flexible\nCoffee coffee = new CaramelDecorator(\n                    new MilkDecorator(\n                        new SimpleCoffee()));\n// Can combine at runtime in any order\n```\n\n**Key Differences:**\n1. **Runtime vs Compile-time**: Decorators add behavior at runtime; inheritance at compile-time\n2. **Composition vs Extension**: Decorators use composition; inheritance uses extension\n3. **Flexibility**: Can mix and match decorators; inheritance creates rigid hierarchies\n4. **Explosion Prevention**: Avoids class explosion from all possible combinations\n\n## (b) Decorator Pattern in Swing\n\n### Java I/O Library Example\n\n```java\n// Classic example from java.io\ntry {\n    // Each layer wraps and adds functionality\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n    BufferedInputStream bis = new BufferedInputStream(fis);\n    DataInputStream dis = new DataInputStream(bis);\n    \n    // Decorated behavior - efficient reading with data type support",
    "expected": ""
  },
  {
    "id": "essay_005",
    "type": "essay",
    "topic": "strategy_pattern",
    "correct": false,
    "score": 0.0,
    "edit_distance": 3452,
    "prediction": "# Strategy Pattern for TicTacToe AI System\n\n## Complete Implementation with Detailed Explanation\n\n## (a) Interface Design for the Strategy\n\n```java\n/**\n * Strategy interface for TicTacToe move selection algorithms.\n * This defines the contract that all AI strategies must follow.\n */\n@FunctionalInterface\npublic interface TicTacToeStrategy {\n    /**\n     * Selects the best move for the current board state.\n     * \n     * @param board Current game board state\n     * @param player The player symbol ('X' or 'O')\n     * @return Position object representing the chosen move\n     * @throws IllegalStateException if no valid move is available\n     */\n    Position selectMove(Board board, char player);\n    \n    /**\n     * Optional method to get strategy name for logging/debugging\n     */\n    default String getStrategyName() {\n        return this.getClass().getSimpleName();\n    }\n}\n\n/**\n * Represents a position on the TicTacToe board\n */\npublic class Position {\n    private final int row;\n    private final int col;\n    \n    public Position(int row, int col) {\n        this.row = row;\n        this.col = col;\n    }\n    \n    public int getRow() { return row; }\n    public int getCol() { return col; }\n    \n    @Override\n    public String toString() {\n        return String.format(\"(%d, %d)\", row, col);\n    }\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Position)) return false;\n        Position position = (Position) o;\n        return row == position.row && col == position.col;\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(row, col);\n    }\n}\n\n/**\n * Represents the TicTacToe board state\n */\npublic class Board {\n    private final char[][] grid;\n    private static final int SIZE = 3;\n    public static final char EMPTY = '-';\n    \n    public Board() {\n        grid = new char[SIZE][SIZE];\n        for (int i = 0; i < SIZE; i++) {\n            Arrays.fill(grid[i], EMPTY);\n        }\n    }\n    \n    public Board(char[][] existingGrid) {\n        this.grid = new char[SIZE][SIZE];\n        for (int i = 0; i < SIZE; i++) {\n            System.arraycopy(existingGrid[i], 0, this.grid[i], 0, SIZE);\n        }\n    }\n    \n    public boolean isEmpty(int row, int col) {\n        return grid[row][col] == EMPTY;\n    }\n    \n    public void setMove(int row, int col, char player) {\n        if (isEmpty(row, col)) {\n            grid[row][col] = player;\n        } else {\n            throw new IllegalArgumentException(\"Position already occupied\");\n        }\n    }\n    \n    public char getCell(int row, int col) {\n        return grid[row][col];\n    }\n    \n    public List<Position> getAvailableMoves() {\n        List<Position> moves = new ArrayList<>();\n        for (int i = 0; i < SIZE; i++) {\n            for (int j = 0; j < SIZE; j++) {\n                if (isEmpty(i, j)) {\n                    moves.add(new Position(i, j));\n                }\n            }\n        }\n        return moves;\n    }\n    \n    public boolean isFull() {\n        return getAvailableMoves().isEmpty();\n    }\n    \n    public char checkWinner() {\n        // Check rows and columns\n        for (int i = 0; i < SIZE; i++) {\n            if (grid[i][0] != EMPTY && \n                grid[i][0] == grid[i][1] && grid[i][1] == grid[i][2]) {\n                return grid[i][0];\n            }\n            if (grid[0][i] != EMPTY && \n                grid[0][i] == grid[1][i] && grid[1][i] == gri",
    "expected": ""
  },
  {
    "id": "essay_006",
    "type": "essay",
    "topic": "command_pattern",
    "correct": false,
    "score": 0.0,
    "edit_distance": 3513,
    "prediction": "# Command Pattern for Undo/Redo in Turtle Graphics\n\n## (a) Command Interface and Concrete Command Classes\n\nThe Command pattern encapsulates requests as objects, allowing parameterization and queuing of operations.\n\n```java\n// Command Interface\npublic interface Command {\n    void execute();\n    void undo();\n    String getDescription();\n}\n\n// Receiver - The Turtle that performs actual operations\npublic class Turtle {\n    private double x;\n    private double y;\n    private double angle;\n    private boolean penDown;\n    private List<Line> drawnLines;\n    \n    public Turtle() {\n        this.x = 0;\n        this.y = 0;\n        this.angle = 0;\n        this.penDown = true;\n        this.drawnLines = new ArrayList<>();\n    }\n    \n    public void move(double distance) {\n        double newX = x + distance * Math.cos(Math.toRadians(angle));\n        double newY = y + distance * Math.sin(Math.toRadians(angle));\n        \n        if (penDown) {\n            drawnLines.add(new Line(x, y, newX, newY));\n        }\n        \n        x = newX;\n        y = newY;\n    }\n    \n    public void rotate(double degrees) {\n        angle = (angle + degrees) % 360;\n    }\n    \n    public void setPenDown(boolean down) {\n        this.penDown = down;\n    }\n    \n    public void removeLine(Line line) {\n        drawnLines.remove(line);\n    }\n    \n    public void addLine(Line line) {\n        drawnLines.add(line);\n    }\n    \n    // Getters and setters\n    public double getX() { return x; }\n    public double getY() { return y; }\n    public double getAngle() { return angle; }\n    public boolean isPenDown() { return penDown; }\n    \n    public void setX(double x) { this.x = x; }\n    public void setY(double y) { this.y = y; }\n    public void setAngle(double angle) { this.angle = angle; }\n}\n\n// Supporting class for drawn lines\npublic class Line {\n    private final double x1, y1, x2, y2;\n    \n    public Line(double x1, double y1, double x2, double y2) {\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n    \n    // Getters omitted for brevity\n}\n```\n\n## (b) Commands Storing State for Undo\n\nEach concrete command stores the state necessary to reverse its operation.\n\n```java\n// Concrete Command - Move Forward\npublic class MoveCommand implements Command {\n    private final Turtle turtle;\n    private final double distance;\n    \n    // State for undo\n    private double previousX;\n    private double previousY;\n    private Line drawnLine;\n    private boolean hadPenDown;\n    \n    public MoveCommand(Turtle turtle, double distance) {\n        this.turtle = turtle;\n        this.distance = distance;\n    }\n    \n    @Override\n    public void execute() {\n        // Capture state before execution\n        previousX = turtle.getX();\n        previousY = turtle.getY();\n        hadPenDown = turtle.isPenDown();\n        \n        // Execute the command\n        turtle.move(distance);\n        \n        // If a line was drawn, capture it\n        if (hadPenDown) {\n            drawnLine = new Line(previousX, previousY, \n                               turtle.getX(), turtle.getY());\n        }\n    }\n    \n    @Override\n    public void undo() {\n        // Remove the drawn line if it exists\n        if (drawnLine != null) {\n            turtle.removeLine(drawnLine);\n        }\n        \n        // Restore previous position\n        turtle.setX(previousX);\n        turtle.setY(previousY);\n    }\n    \n    @Override\n    public String getDescription() {\n        return \"Move \" + distance + \" units\";\n    }\n}\n\n//",
    "expected": ""
  },
  {
    "id": "essay_007",
    "type": "essay",
    "topic": "testing_design",
    "correct": false,
    "score": 0.0,
    "edit_distance": 3901,
    "prediction": "# Dependency Injection and Testing in Java\n\n## (a) What is Dependency Injection?\n\n**Dependency injection** is a design pattern where an object receives its dependencies from external sources rather than creating them itself. Instead of the object instantiating its own dependencies, they are \"injected\" from the outside.\n\n### Example Demonstration:\n\n```java\n// WITHOUT Dependency Injection (tightly coupled)\npublic class TicTacToeConsoleController {\n    private Scanner scanner;\n    private PrintStream output;\n    \n    public TicTacToeConsoleController() {\n        this.scanner = new Scanner(System.in);  // Hard-coded dependency\n        this.output = System.out;                // Hard-coded dependency\n    }\n}\n\n// WITH Dependency Injection (loosely coupled)\npublic class TicTacToeConsoleController {\n    private Readable input;\n    private Appendable output;\n    \n    // Dependencies are injected via constructor\n    public TicTacToeConsoleController(Readable input, Appendable output) {\n        this.input = input;\n        this.output = output;\n    }\n}\n```\n\n**How this demonstrates DI:**\n- The controller doesn't create its own I/O objects\n- It accepts `Readable` and `Appendable` interfaces as parameters\n- The caller decides what concrete implementations to provide\n- This inverts the control of dependency creation\n\n## (b) Enabling Automated Testing Without Console I/O\n\nThis design enables testing by allowing us to substitute the real console with testable alternatives:\n\n```java\npublic class TicTacToeConsoleController {\n    private final Readable input;\n    private final Appendable output;\n    private TicTacToeModel model;\n    \n    public TicTacToeConsoleController(Readable input, Appendable output, \n                                      TicTacToeModel model) {\n        this.input = input;\n        this.output = output;\n        this.model = model;\n    }\n    \n    public void playGame() throws IOException {\n        Scanner scan = new Scanner(this.input);\n        \n        while (!model.isGameOver()) {\n            output.append(\"Current board:\\n\");\n            output.append(model.toString());\n            output.append(\"\\nEnter move (row col): \");\n            \n            int row = scan.nextInt();\n            int col = scan.nextInt();\n            \n            model.move(row, col);\n        }\n        \n        output.append(\"Game over! Winner: \" + model.getWinner());\n    }\n}\n```\n\n**Testing without actual console:**\n\n```java\n@Test\npublic void testValidGameSequence() throws IOException {\n    // Use StringReader instead of System.in\n    Readable input = new StringReader(\"0 0\\n1 1\\n0 1\\n1 0\\n0 2\\n\");\n    \n    // Use StringBuilder instead of System.out\n    StringBuilder output = new StringBuilder();\n    \n    TicTacToeModel model = new TicTacToeModel();\n    TicTacToeConsoleController controller = \n        new TicTacToeConsoleController(input, output, model);\n    \n    controller.playGame();\n    \n    // Verify output without seeing anything on console\n    assertTrue(output.toString().contains(\"Game over\"));\n}\n```\n\n**Benefits:**\n- Tests run silently (no console clutter)\n- Tests are fast (no waiting for user input)\n- Tests are repeatable (same input every time)\n- Tests can be automated in CI/CD pipelines\n\n## (c) Mock Objects and Their Use\n\n**Mock objects** are simulated objects that mimic the behavior of real objects in controlled ways. They allow you to:\n- Verify that certain methods were called\n- Control what values are returned\n- Test edge cases and error conditions\n\n### Using Mocks with the Controller:\n\n```java\nimport static org.mockito.Mockito.*;\n\npublic class TicTacToeControllerTest {\n    \n    @Test\n    public void testControllerCallsModelMove() throws IOException {\n        // Create mock objects\n        Readable input = new StringReader(\"2 1\\n\");\n        Appendable output = mock(Appendable.class);\n        TicTacToeModel mockModel = mock(TicTacToeModel.class",
    "expected": ""
  },
  {
    "id": "essay_008",
    "type": "essay",
    "topic": "observer_pattern",
    "correct": false,
    "score": 0.0,
    "edit_distance": 4205,
    "prediction": "# The Observer Pattern: A Comprehensive Guide\n\n## (a) Structure of the Observer Pattern\n\nThe Observer pattern defines a one-to-many dependency between objects where changes in one object (Subject) automatically notify all dependent objects (Observers).\n\n### Core Components:\n\n```java\n// Subject interface - maintains list of observers\npublic interface Subject {\n    void attach(Observer observer);\n    void detach(Observer observer);\n    void notifyObservers();\n}\n\n// Observer interface - receives updates\npublic interface Observer {\n    void update(Subject subject);\n}\n\n// Concrete Subject\npublic class WeatherStation implements Subject {\n    private List<Observer> observers = new ArrayList<>();\n    private double temperature;\n    private double humidity;\n    private double pressure;\n    \n    @Override\n    public void attach(Observer observer) {\n        observers.add(observer);\n    }\n    \n    @Override\n    public void detach(Observer observer) {\n        observers.remove(observer);\n    }\n    \n    @Override\n    public void notifyObservers() {\n        for (Observer observer : observers) {\n            observer.update(this);\n        }\n    }\n    \n    // Business logic that triggers notifications\n    public void setMeasurements(double temp, double humidity, double pressure) {\n        this.temperature = temp;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        notifyObservers(); // Automatically notify all observers\n    }\n    \n    // Getters for observers to pull data\n    public double getTemperature() { return temperature; }\n    public double getHumidity() { return humidity; }\n    public double getPressure() { return pressure; }\n}\n\n// Concrete Observer\npublic class CurrentConditionsDisplay implements Observer {\n    private double temperature;\n    private double humidity;\n    \n    @Override\n    public void update(Subject subject) {\n        if (subject instanceof WeatherStation) {\n            WeatherStation station = (WeatherStation) subject;\n            this.temperature = station.getTemperature();\n            this.humidity = station.getHumidity();\n            display();\n        }\n    }\n    \n    public void display() {\n        System.out.println(\"Current conditions: \" + temperature \n            + \"\u00b0F and \" + humidity + \"% humidity\");\n    }\n}\n```\n\n## (b) Loose Coupling Benefits\n\nThe Observer pattern creates loose coupling in several ways:\n\n```java\n// 1. Subject only knows Observer interface, not concrete classes\npublic class NewsAgency implements Subject {\n    private List<Observer> subscribers = new ArrayList<>();\n    private String news;\n    \n    public void attach(Observer observer) {\n        subscribers.add(observer);  // Works with ANY Observer implementation\n    }\n    \n    public void setNews(String news) {\n        this.news = news;\n        notifyObservers();\n    }\n    \n    public String getNews() { return news; }\n    \n    public void notifyObservers() {\n        for (Observer observer : subscribers) {\n            observer.update(this);  // Polymorphic call\n        }\n    }\n}\n\n// Different observer implementations - Subject doesn't need to change\npublic class EmailSubscriber implements Observer {\n    private String email;\n    \n    public EmailSubscriber(String email) {\n        this.email = email;\n    }\n    \n    @Override\n    public void update(Subject subject) {\n        if (subject instanceof NewsAgency) {\n            String news = ((NewsAgency) subject).getNews();\n            System.out.println(\"Email to \" + email + \": \" + news);\n        }\n    }\n}\n\npublic class SMSSubscriber implements Observer {\n    private String phoneNumber;\n    \n    public SMSSubscriber(String phone) {\n        this.phoneNumber = phone;\n    }\n    \n    @Override\n    public void update(Subject subject) {\n        if (subject instanceof NewsAgency) {\n            String news = ((NewsAgency) subject).getNews();\n            System.out.println(\"SMS to \" + phoneNumber + \": \" + news);\n        }\n    }\n}\n\n// Usage - Add/remove observers dynamically without changing Subject\npublic class Demo {\n    public static void main(String[] args) {\n        NewsAgency agency = new NewsAgency();\n        \n        Observer emailSub = new EmailSubscriber(\"user@example.com\");",
    "expected": ""
  },
  {
    "id": "essay_009",
    "type": "essay",
    "topic": "design_for_inheritance",
    "correct": false,
    "score": 0.0,
    "edit_distance": 3749,
    "prediction": "# Design and Document for Inheritance or Else Prohibit It\n\n## (a) What It Means to Design a Class for Inheritance\n\nDesigning for inheritance requires deliberate architectural decisions:\n\n```java\npublic class PropertyChangeSupport {\n    private final List<PropertyChangeListener> listeners = new ArrayList<>();\n    \n    /**\n     * Adds a listener. This method is called by firePropertyChange.\n     * Subclasses may override to add custom behavior but must call super.\n     */\n    public void addPropertyChangeListener(PropertyChangeListener listener) {\n        listeners.add(listener);\n    }\n    \n    /**\n     * Fires property change event. Implementation note: This method\n     * calls addPropertyChangeListener internally. Subclasses overriding\n     * addPropertyChangeListener should be aware of this call pattern.\n     */\n    protected void firePropertyChange(String property, Object oldValue, Object newValue) {\n        // Implementation detail: shows self-use pattern\n        for (PropertyChangeListener listener : listeners) {\n            listener.propertyChange(new PropertyChangeEvent(this, property, oldValue, newValue));\n        }\n    }\n}\n```\n\n**Key Design Considerations:**\n\n1. **Self-use patterns must be documented** - which overridable methods call which others\n2. **Hook methods** - provide protected methods for customization points\n3. **State management** - ensure subclasses can maintain invariants\n4. **Constructor restrictions** - never call overridable methods in constructors\n\n```java\n// DANGEROUS - Not designed for inheritance\npublic class BadParent {\n    public BadParent() {\n        init(); // BAD: Calls overridable method in constructor\n    }\n    \n    public void init() {\n        // Subclass may not be fully initialized!\n    }\n}\n\nclass BadChild extends BadParent {\n    private final Date timestamp = new Date();\n    \n    @Override\n    public void init() {\n        System.out.println(timestamp.getTime()); // NullPointerException!\n        // timestamp not yet initialized when parent constructor runs\n    }\n}\n```\n\n## (b) Documentation Necessary for Safe Subclassing\n\n```java\n/**\n * Abstract class for processing items in batches.\n * \n * <p><b>Implementation Requirements for Subclasses:</b>\n * \n * <p>Subclasses must implement {@link #processItem(Object)} to define\n * item processing logic.\n * \n * <p><b>Self-Use Patterns:</b>\n * <ul>\n *   <li>{@code processBatch()} calls {@code processItem()} for each item\n *   <li>{@code processBatch()} calls {@code onBatchComplete()} after processing\n * </ul>\n * \n * <p><b>Overriding Guidelines:</b>\n * <ul>\n *   <li>{@code processItem()}: MUST be overridden, called once per item\n *   <li>{@code onBatchComplete()}: MAY override, must call super if overridden\n *   <li>{@code validateItem()}: MAY override, called before processItem()\n * </ul>\n * \n * <p><b>Thread Safety:</b> This class is not thread-safe. Subclasses\n * requiring thread safety must provide their own synchronization.\n * \n * @param <T> the type of items to process\n */\npublic abstract class BatchProcessor<T> {\n    \n    /**\n     * Processes a batch of items.\n     * \n     * <p><b>Implementation Note:</b> This method iterates through items,\n     * calling {@link #validateItem(Object)} then {@link #processItem(Object)}\n     * for each. Finally calls {@link #onBatchComplete()}.\n     * \n     * @param items items to process\n     * @throws IllegalArgumentException if any item fails validation\n     */\n    public final void processBatch(List<T> items) {\n        for (T item : items) {\n            if (validateItem(item)) {\n                processItem(item);\n            }\n        }\n        onBatchComplete();\n    }\n    \n    /**\n     * Processes a single item. Subclasses must implement this method.\n     * \n     *",
    "expected": ""
  },
  {
    "id": "essay_010",
    "type": "essay",
    "topic": "integration",
    "correct": false,
    "score": 0.0,
    "edit_distance": 3883,
    "prediction": "# Design Patterns for a Graphical Drawing Application\n\nI'll explain how multiple design patterns work together to create a robust, maintainable drawing application.\n\n## Complete Architecture Overview\n\n```java\n// ==================== CORE SHAPE HIERARCHY ====================\n\n/**\n * Base Shape interface - Component in Decorator pattern\n */\ninterface Shape {\n    void draw(RenderContext context);\n    Rectangle getBounds();\n    Shape clone();\n    String getDescription();\n}\n\n/**\n * Concrete shapes\n */\nclass Circle implements Shape {\n    private Point center;\n    private double radius;\n    private Color fillColor;\n    \n    public Circle(Point center, double radius, Color fillColor) {\n        this.center = center;\n        this.radius = radius;\n        this.fillColor = fillColor;\n    }\n    \n    @Override\n    public void draw(RenderContext context) {\n        context.drawCircle(center, radius, fillColor);\n    }\n    \n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(\n            center.x - radius, \n            center.y - radius,\n            2 * radius, \n            2 * radius\n        );\n    }\n    \n    @Override\n    public Shape clone() {\n        return new Circle(center, radius, fillColor);\n    }\n    \n    @Override\n    public String getDescription() {\n        return \"Circle at \" + center + \" with radius \" + radius;\n    }\n    \n    // Getters and setters...\n    public Point getCenter() { return center; }\n    public double getRadius() { return radius; }\n}\n\nclass Rectangle implements Shape {\n    private Point topLeft;\n    private double width;\n    private double height;\n    private Color fillColor;\n    \n    public Rectangle(Point topLeft, double width, double height, Color fillColor) {\n        this.topLeft = topLeft;\n        this.width = width;\n        this.height = height;\n        this.fillColor = fillColor;\n    }\n    \n    @Override\n    public void draw(RenderContext context) {\n        context.drawRectangle(topLeft, width, height, fillColor);\n    }\n    \n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(topLeft, width, height, null);\n    }\n    \n    @Override\n    public Shape clone() {\n        return new Rectangle(topLeft, width, height, fillColor);\n    }\n    \n    @Override\n    public String getDescription() {\n        return \"Rectangle at \" + topLeft + \" [\" + width + \"x\" + height + \"]\";\n    }\n}\n```\n\n## (a) Strategy Pattern for Rendering Backends\n\nThe Strategy pattern allows switching between different rendering implementations at runtime.\n\n```java\n// ==================== STRATEGY PATTERN FOR RENDERING ====================\n\n/**\n * Strategy interface - defines rendering operations\n */\ninterface RenderContext {\n    void drawCircle(Point center, double radius, Color color);\n    void drawRectangle(Point topLeft, double width, double height, Color color);\n    void drawLine(Point start, Point end, Color color, int thickness);\n    void drawText(String text, Point position, Font font, Color color);\n    void beginPath();\n    void endPath();\n    void setTransform(AffineTransform transform);\n}\n\n/**\n * Concrete Strategy for screen rendering\n */\nclass ScreenRenderContext implements RenderContext {\n    private Graphics2D graphics;\n    \n    public ScreenRenderContext(Graphics2D graphics) {\n        this.graphics = graphics;\n    }\n    \n    @Override\n    public void drawCircle(Point center, double radius, Color color) {\n        graphics.setColor(color);\n        int x = (int)(center.x - radius);\n        int y = (int)(center.y - radius);\n        int diameter = (int)(2 * radius);\n        graphics.fillOval(x, y, diameter, diameter);\n    }\n    \n    @Override\n    public void drawRectangle(Point topLeft, double width, double height, Color color) {\n        graphics.setColor(color);\n        graphics.fillRect((int)topLeft.x, (int)topLeft.y, (int)width, (int)height);\n    }\n    \n    @Override\n    public",
    "expected": ""
  }
]